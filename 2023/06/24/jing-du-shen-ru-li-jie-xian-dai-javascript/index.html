<!DOCTYPE HTML>
<html lang="zh-CN">
    
    

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="精读《深入理解现代JavaScript》, QT-7274">
    <meta name="description" content="想要了解在过去几年中被添加到 JavaScript 的最新特性，以及未来如何在语言不断发展的过程中掌握最新动态，那么本书非常适合你！">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>精读《深入理解现代JavaScript》 | QT-7274</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"></head>

    
<body>


    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    <div>
                    
                    <img src="/medias/images/loading.gif" data-original="/medias/logo.gif" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">QT-7274</span>
                </div>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">
    <div class="mobile-head bg-color">
      <div>
        
        <img no-lazy src="/medias/logo.gif" class="logo-img circle responsive-img">
        
        <div class="logo-name">QT-7274</div>
        <div class="logo-desc">
          
              Never really desperate, only the lost of the soul.
              
            </div>
      </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/QT-7274/QT-7274.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #003a8c;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/QT-7274/QT-7274.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">精读《深入理解现代JavaScript》</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                <span class="chip bg-color">前端</span>
                            </a>
                        
                            <a href="/tags/%E4%B9%A6%E7%B1%8D/">
                                <span class="chip bg-color">书籍</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" class="post-category">
                                前端开发
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-06-24
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-06-26
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    33 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="第二章：块级作用域声明：-let-和-const"><a href="#第二章：块级作用域声明：-let-和-const" class="headerlink" title="第二章：块级作用域声明： let 和 const"></a>第二章：块级作用域声明： let 和 const</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>对于现在的 <code>JavaScript</code> 来说，声明变量的方式一共有三种：</p>
<blockquote>
<ul>
<li><code>var</code>：变量，会跳出块级作用域</li>
<li><code>let</code>：变量，不会跳出块级作用域</li>
<li><code>const</code>：常量，不会跳出块级作用域</li>
</ul>
</blockquote>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>什么是块级作用域？</p>
<blockquote>
<p>所谓块级作用域指的是 <strong>两个大括号中间的内容</strong>，比如 <code>for 循环、if、函数</code> 只要存在 <code>&#123;&#125;</code> 那么都会生成块级作用域。</p>
</blockquote>
<p>除了块级作用域之外，<code>var</code> 和 <code>let、const</code> 在特性上也有一些区别。这个区别主要体现在两个方面 <strong>变量提升、暂时性死区（<code>TDZ</code>）</strong></p>
<h3 id="变量提升与暂时性死区"><a href="#变量提升与暂时性死区" class="headerlink" title="变量提升与暂时性死区"></a>变量提升与暂时性死区</h3><p>咱们先来看变量提升。对于 <code>var</code> 声明的变量而言，会存在变量提升的概念，也就是可以 <strong>先使用、后定义</strong>，咱么来看这段代码：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(msg) &#x2F;&#x2F; undefined （并不会报错）
var msg &#x3D; &#39;hello world&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在这段代码中，<code>msg</code> 变量先被使用，后声明。虽然打印了 <code>undefined</code>，但是它并不会报错。</p>
<p>原因是因为，以上代码会被编译为以下形式：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var msg
console.log(msg) &#x2F;&#x2F; undefined
msg &#x3D; &#39;hello world&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>即 <strong>msg 变量的定义会被提升到最前面</strong>。而这种形式就叫做 <strong>变量提升</strong>。</p>
<p>但是如果我们使用 <code>let 或 const</code> 来代替 <code>var</code> 的话，因为 <code>let、const</code> 不具备变量提升，所以就会抛出对应的错误：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(msg2); &#x2F;&#x2F; Uncaught ReferenceError: Cannot access &#39;msg2&#39; before initialization
let msg2 &#x3D; &#39;hello word&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>而这样的错误，就被叫做 <strong>暂时性死区（ temporal dead zone，简称TDZ ）。</strong></p>
<h3 id="旧习换新"><a href="#旧习换新" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>这里的旧习换新主要包含两点：</p>
<ul>
<li>第一点是 **不要使用 <code>var</code>，改用 <code>let</code> 和 <code>const</code>**：因为无论是 <strong>跳出块级作用域也好，还是变量提升也好</strong>，在标准图灵完备的编程语言中，都不是一个应该具备的特性。</li>
<li>第二点是 <strong>缩小变量的作用域，从而提升可维护性</strong>：想要理解这句话，可能需要具备一定的编程经验。如果大家不是很理解的话，那么可以想象一下 <strong>一万行代码的文件和一百行代码的文件</strong> 哪个更好维护？我们始终需要谨记 <strong>代码越少，越容易维护</strong>。所以 <strong>缩小你的作用域空间，减少逻辑的复杂度。</strong></li>
</ul>
<h2 id="第三章：函数的新特性"><a href="#第三章：函数的新特性" class="headerlink" title="第三章：函数的新特性"></a>第三章：函数的新特性</h2><p>函数作为 <code>JavaScript 世界</code> 的 <strong>一等公民</strong>，是我们在实际项目开发中，无时无刻不在使用的东西。</p>
<p>在这一章中，咱们主要从 <strong>参数、this 指向、构造函数</strong> 这三个方面来去说明函数的新特性。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>函数的参数分为两种 <strong>形参、实参</strong>。所谓形参指的是 <strong>定义函数时指定的形式参数</strong>。所谓实参指的是 <strong>调用函数时，传递的实际参数。</strong></p>
<p>而在定义形参时，我们可以通过 <strong>赋值符 &#x3D;</strong> 的形式，为形参指定 <strong>默认值</strong>。这表示 <strong>如果没有传递对应的实参，则该形参默认为该值</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function fn(name &#x3D; &#39;张三&#39;) &#123;
  console.log(name); &#x2F;&#x2F; 张三
&#125;
fn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个默认值可以为 <strong>任意的单一表达式</strong>，比如我们可以指定一个 <strong>立即执行的箭头函数</strong>，那么此时默认值会为该函数的值：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 箭头函数：() &#x3D;&gt; &#39;李四&#39;
&#x2F;&#x2F; (() &#x3D;&gt; &#39;李四&#39;)() 表示立即执行的箭头函数
function fn(name &#x3D; (() &#x3D;&gt; &#39;李四&#39;)()) &#123;
  console.log(name);
&#125;
fn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 <code>JavaScript</code> 中，函数的实参和形参并不要求是一一对应的。也就是说 <strong>实参的数量可以超过形参的数量</strong>。那么在这种情况下，如果我们想要获取到 <strong>多余的实参</strong>，一共有两种方式：</p>
<ul>
<li><p>第一种是传统的 <code>arguments </code>，但是它并不是通用的，<strong>在箭头函数中无法使用</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function fn(name) &#123;
  console.log(arguments); &#x2F;&#x2F; [&#39;张三&#39;, 30, &#39;男&#39;, callee: ƒ, Symbol(Symbol.iterator): ƒ]
&#125;

const fn &#x3D; (name) &#x3D;&gt; &#123;
  console.log(arguments); &#x2F;&#x2F; Uncaught ReferenceError: arguments is not defined
&#125;

fn(&#39;张三&#39;, 30, &#39;男&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>第二种是 <code>ES6 之后</code> 新增的 <strong>“rest” 参数</strong>，它是通用的，表示 <strong>接收所有的剩余参数</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function fn(name, ...args) &#123;
  console.log(args); &#x2F;&#x2F; [30, &#39;男&#39;]
&#125;

const fn &#x3D; (name, ...args) &#x3D;&gt; &#123;
  console.log(args); &#x2F;&#x2F; [30, &#39;男&#39;]
&#125;

fn(&#39;张三&#39;, 30, &#39;男&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>针对 <code>this</code> 指向，指的是 <strong>普通函数和箭头函数</strong> 下的 <code>this</code> 指向问题。</p>
<p>这应该是一个 <strong>面试</strong> 时的高频问点。当大家遇到这样的问题时，大多数时候只需要从三个方面进行回答即可：</p>
<ul>
<li><p>首先第一个方面是 <strong>普通函数的 this 指向</strong>：针对于普通函数而言，<code>this</code> 指向<span style="color: red">调用方</span></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function fn() &#123;
  console.log(this); &#x2F;&#x2F; window
&#125;
fn() &#x2F;&#x2F; window.fn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>然后是箭头函数：针对于箭头函数而言，不会修改 <code>this</code> 指向，即 <strong>this 指向上层作用域中的 this</strong> </p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;
  name: &#39;张三&#39;,
  fn() &#123;
    console.log(this); &#x2F;&#x2F; person

    const subFn &#x3D; () &#x3D;&gt; &#123;
      console.log(this); &#x2F;&#x2F; 指向上层作用域（fn）中的 this
    &#125;
    subFn()
  &#125;
&#125;
person.fn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>最后是 <code>call、apply、bind</code> 这三个 <code>API</code>：它们都可以在 <strong>普通函数</strong> 中修改 <code>this</code> 指向，<code>this</code> 指向它们的第一个参数</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;
  name: &#39;张三&#39;
&#125;

const fn &#x3D; () &#x3D;&gt; &#123;
  console.log(this); &#x2F;&#x2F; window  箭头函数永远不会修改 this 指向
&#125;

function fn2() &#123;
  console.log(this); &#x2F;&#x2F; person
&#125;

fn.apply(person)
fn2.call(person)
fn.bind(person)()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数通常指 <strong>首字母大写的普通函数</strong> 。也就是说：<span style="color: red"><strong>箭头函数永远不可以作为构造函数使用</strong></span></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Person(name) &#123;
  &#x2F;&#x2F; this 指向实例对象
  this.name &#x3D; name
&#125;
const p &#x3D; new Person(&#39;张三&#39;)
console.log(p); &#x2F;&#x2F; Person &#123;name: &#39;张三&#39;&#125;


const Person2 &#x3D; (name) &#x3D;&gt; &#123;
  &#x2F;&#x2F; this 指向 window
  this.name &#x3D; name
&#125;
const p2 &#x3D; new Person2(&#39;张三&#39;)
console.log(p2); &#x2F;&#x2F; Uncaught TypeError: Person2 is not a constructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="旧习换新-1"><a href="#旧习换新-1" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>这一章的旧习换新主要包含四点内容，也是对本章重点内容的总结：</p>
<ul>
<li>首选是关于箭头函数和普通函数的使用场景： <strong>不想修改 this 指向时，使用箭头函数。需要改变 this 的指向时，使用普通函数</strong></li>
<li>其次是关于参数默认值：<strong>使用参数默认值，而不要使用代码为参数赋初始值</strong></li>
<li>第三是关于剩余参数： <strong>使用 rest 参数替代 arguments 关键字</strong> 来获取剩余参数</li>
</ul>
<h2 id="第四章：类"><a href="#第四章：类" class="headerlink" title="第四章：类"></a>第四章：类</h2><p>针对于第四章而言，从名字到内容都非常的纯粹，一个字 <strong>类</strong>。</p>
<p>那么对于这一章的内容，让我们从一个问题开始：我们常说 <strong>JavaScript 实际上没有类，只是用原型来模拟了类？是这样的吗？</strong></p>
<p>答案是 <strong>当然不是</strong>。其实从 <code>ES2015</code> 之后，<code>ECMAScript</code> 标准为 <code>JavaScript</code> 提供了 <strong>类</strong> 的概念。它并不是原型的模拟，只是 <strong>可以用原型来模拟类而已</strong>。</p>
<p>那么下面咱们就来看看 <code>ES2015</code> 之后的 <strong>类语法</strong></p>
<h3 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h3><p>类语法分为 <strong>创建</strong> 和 <strong>使用</strong> 两部分。</p>
<p>咱们先来看类的创建：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const fnName &#x3D; &#39;fn&#39; + Math.floor(Math.random() * 1000)
class Color &#123;
  &#x2F;&#x2F; 一个《构造函数》
  constructor(r &#x3D; 0, g &#x3D; 0, b &#x3D; 0) &#123;
    &#x2F;&#x2F; 三个《数据属性》
    this.r &#x3D; r
    this.g &#x3D; g
    this.b &#x3D; b
  &#125;

  &#x2F;&#x2F; 一个《访问器属性》
  get rgb() &#123;
    &#x2F;&#x2F; 可通过 实例.rgb 访问
    return &#96;rgb($&#123;this.r&#125;, $&#123;this.g&#125;, $&#123;this.b&#125;)&#96;
  &#125;

  set rgb(val) &#123;
    &#x2F;&#x2F; 为 r、g、b 赋值
    &#x2F;&#x2F; 可通过 实例.rgb &#x3D; xx 访问
  &#125;

  &#x2F;&#x2F; 一个《原型方法》
  toString() &#123;
    return &#96;重写的原型方法：$&#123;this.rgb&#125;&#96;
  &#125;

  &#x2F;&#x2F; 一个静态方法
  static fromCss(r, g, b) &#123;
    &#x2F;&#x2F; 利用 new this 可以直接得到 Color 实例
    return new this(r, g, b)
  &#125;

  &#x2F;&#x2F; 动态方法名
  [fnName]() &#123;
    return &#96;动态方法名为：$&#123;fnName&#125;&#96;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这段代码中，我们通过类语法 <code>class</code> 创建了一个类 <code>Color</code>，这里大家注意，根据规范 <strong>类名首字母应该大写</strong>。这里的代码我已经写好了注释，大家可以在这里暂停来查看下对应的代码内容。</p>
<p>而如果想要使用类的话，那么必须要通过 <code>new</code> 关键字来进行使用：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const c &#x3D; new Color(30, 144, 255)
console.log(c[fnName]()); &#x2F;&#x2F; 动态方法名为：fn275
console.log(c.toString()); &#x2F;&#x2F; 重写的原型方法：rgb(30, 144, 255)
console.log(c.rgb); &#x2F;&#x2F; rgb(30, 144, 255)
console.log(Color.fromCss(255, 255, 255)); &#x2F;&#x2F; Color &#123;r: 255, g: 255, b: 255&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><p>继承在编程语言中是一个非常常见的概念，在 <code>ES6</code> 之前想要完成继承，那么多数情况下需要使用 <strong>原型继承</strong> 的方式。而原型继承有很多种，比如：<strong>组合式继承、原型式继承、寄生式继承、寄生式组合继承 ……</strong> 很多种方式。</p>
<p>但是在实际开发中，如果我们直接使用类语法的话，那么想要实现继承就非常容易了。只需要使用到一个关键字 <code>extends</code></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class SubColor extends Color &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>而除了 <code>extends</code> 之外，类继承的时候还有另外一个关键字 <code>super</code>。 <code>super</code> 关键字可以用来 <strong>处理与父类相关的事情</strong>。</p>
<p>它的使用场景主要有两个：</p>
<h4 id="作为函数使用"><a href="#作为函数使用" class="headerlink" title="作为函数使用"></a>作为函数使用</h4><p><code>super</code> 关键字可以直接作为函数进行使用。比如：在构造函数中使用时，<code>super</code> 可以直接调用父类的构造函数，在通常情况下 <span style='color: red'><strong>这是一个必须的操作</strong></span></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class SubColor extends Color &#123;
  constructor(r &#x3D; 0, g &#x3D; 0, b &#x3D; 0, a &#x3D; 1) &#123;
    &#x2F;&#x2F; 触发父类的构造函数
    super(r, g, b)
    this.a &#x3D; a
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="作为属性查询使用"><a href="#作为属性查询使用" class="headerlink" title="作为属性查询使用"></a>作为属性查询使用</h4><p><code>super</code> 关键字可以用来 <strong>访问一个对象字面或类的 [[Prototype]] 的方法和属性</strong>。比如：我们可以在静态方法中利用 <code>super</code> 访问父类的静态方法</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class SubColor extends Color &#123;
  static fromCss(r, g, b, a &#x3D; 1) &#123;
    &#x2F;&#x2F; 通过 super 调用父类的静态方法
    const result &#x3D; super.fromCss(r, g, b)
    &#x2F;&#x2F;  code....
    return new this(r, g, b, a)
  &#125;
&#125;
&#x2F;&#x2F; 子类重写的 formCss。result &#x3D; &#123;color: red&#125; + &#123;fontSize: 20px&#125;
console.log(Color.fromCss(255, 255, 255));
console.log(SubColor.fromCss(255, 255, 255, 1)); &#x2F;&#x2F; SubColor &#123;r: 255, g: 255, b: 255, a: 1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>对于类而言，最后一个需要大家关注的概念就是 <code>new.target</code>。</p>
<p><strong><code>new.target</code></strong> 属性允许你 <strong>检测函数或构造方法是否是通过 new 运算符被调用的，并且可以返回一个指向构造方法或函数的引用</strong>。</p>
<p>我们可以利用它来判断 <strong>当前触发构造函数时是通过哪个类来触发的</strong> ，这在 <strong>多层继承判断来源时会非常有用</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class Color &#123;
  constructor() &#123;
    console.log(&#96;new.target.name: $&#123;new.target.name&#125;&#96;);
  &#125;
&#125;

class SubColor extends Color &#123;
  constructor() &#123;
    super()
  &#125;
&#125;

new Color() &#x2F;&#x2F; new.target: 指向 Color

new SubColor() &#x2F;&#x2F; new.target: 指向 SubColor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="旧习换新-2"><a href="#旧习换新-2" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>这里的旧习换新环节，就比较简单了，只有一点： <strong>实际开发中，通过 <code>class</code> 来完成类的构建和继承。</strong></p>
<h2 id="第五章：对象的新特性"><a href="#第五章：对象的新特性" class="headerlink" title="第五章：对象的新特性"></a>第五章：对象的新特性</h2><p>接下来我们来看对象在 <code>ES6</code> 之后的新特性。</p>
<p>对象在我们日常开发中使用的场景是非常多的，所以这一章中的很多新特性大家或多或少的应该都有一些了解。我挑选了几个日常开发中最常用的语法，来给大家进行下分享。</p>
<p>首先是  <strong>可计算的属性名</strong>。</p>
<p>有些时候，我们可能希望 <strong>对象的 <code>key</code> 是一个不确定的唯一值。</strong> 比如：世界上每一个人都是唯一的，所以 <code>person</code> 对象应该具备一个唯一的 <code>“特性”</code> ，那么我们就可以通过这种方式来进行表示</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const key &#x3D; Symbol(&#39;key&#39;)
const person &#x3D; &#123;
  name: &#39;张三&#39;,
  &#x2F;&#x2F; 可计算的属性名
  [key]: key
&#125;
console.log(person); &#x2F;&#x2F; &#123;name: &#39;张三&#39;, Symbol(key): Symbol(key)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这段代码中，我们利用 <code>Symbol</code> 构建了一个 <code>key</code>，然后利用 <code>[key]</code> 作为 <code>person</code> 的<code>唯一 key 名</code>。</p>
<p>同时，为了方便对象字面量的编写，<code>ES6</code> 之后提供了 <strong>属性简写</strong> 的语法： <strong>当 key 和 value 拥有同样的变量名时，那么可以进行简写</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const name &#x3D; &#39;张三&#39;
const person &#x3D; &#123;
  &#x2F;&#x2F; name: name
  name
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>属性简写</strong> 是我们在日常开发中非常常用的一种方式。</p>
<p>除了属性简写之后，还有另外一个新特性也是我们在日常开发中非常常见的，那就是 <strong>展开运算符</strong>。</p>
<p>展开运算符以 <code>...</code> 的形式进行表示，可以用在对象的展开和合并的多个场景中：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const names &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]

&#x2F;&#x2F; 展开
console.log(...names); &#x2F;&#x2F; 张三 李四 王五

&#x2F;&#x2F; 合并
console.log([&#39;赵六&#39;, ...names]); &#x2F;&#x2F;[&#39;赵六&#39;, &#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="旧习换新-3"><a href="#旧习换新-3" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>最后是对象的旧习换新环节，这个环节的内容比较多，主要有 5 个：</p>
<ol>
<li>当你需要一个动态的 <code>key</code> 时，可以通过可计算的属性名直接创建该对象</li>
<li>多使用属性的简写，以此来简化对象构建的过程</li>
<li>是 <code>Object.assign</code> 方法，这是一个 <code>ES6</code> 新增的方法。可以 <strong>将一个对象的可枚举属性复制到另一个对象上</strong> 。但是要注意，这是一个浅拷贝的</li>
<li><code>Symbol</code> 可以构建一个唯一值。 使用 <code>Symbol</code> 作为 <code>key</code> 名，可以避免属性名冲突</li>
<li>最后是关于实例的原型，之前访问实例的原型时多通过 <code>__proto__</code> 访问。现在可以通过 <code>Object.setPrototypeOf、Object.getPrototypeOf</code> 来直接访问原型</li>
</ol>
<h2 id="第六章：可迭代对象、迭代器、生成器"><a href="#第六章：可迭代对象、迭代器、生成器" class="headerlink" title="第六章：可迭代对象、迭代器、生成器"></a>第六章：可迭代对象、迭代器、生成器</h2><p>从这一章的名字就可以看出来，这一章中主要讲了三个东西 <code>可迭代对象、迭代器、生成器</code>。本章的内容在我们日常的业务项目开发中其实用的不是特别多，并且很多时候有更习惯的替代方案。但是在面试中，确有可能经常被问到，所以不妨一听。</p>
<h3 id="可迭代对象、迭代器"><a href="#可迭代对象、迭代器" class="headerlink" title="可迭代对象、迭代器"></a>可迭代对象、迭代器</h3><p>首先咱们先来看可迭代对象、迭代器。想要了解这两个东西，咱们需要先搞清楚他们的概念：</p>
<blockquote>
<p>迭代器：所谓迭代器指的是 <strong>一个具有 next 方法的对象</strong>。也就是说，从 <strong>理论上</strong>，只要一个对象具备 <code>next</code> 方法，那么它就是迭代器。这里大家注意：<strong>迭代器可以应用在数组中，却 不可以 应用在普通对象中</strong></p>
<p>可迭代对象：而可迭代对象指的是 <strong>可以通过标准方法获取迭代器，以遍历其内容的对象</strong>。</p>
<p>所以说 <strong>可迭代对象、迭代器</strong> 通常是配合来进行说明的。</p>
</blockquote>
<p>而对于迭代器而言，分为 <strong>隐式迭代器 和 显示迭代器</strong> 两种。</p>
<p>咱们先来看隐式迭代器 <code>for of</code>，它拥有 <strong>隐式</strong> 的 <code>next</code> 方法：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const names &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]
for (const iterator of names) &#123;
  console.log(iterator); &#x2F;&#x2F; 张三、李四、王五
&#125;

const person &#x3D; &#123;
  name: &#39;张三&#39;,
  age: 30
&#125;
&#x2F;&#x2F; Uncaught TypeError: person is not iterable
&#x2F;&#x2F; 普通对象默认不可迭代
for (const iterator of person) &#123;
  console.log(iterator);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而显示迭代器被叫做 <code>Symbol.iterator</code>，每个数组都包含一个 <code>Symbol.iterator</code> 的属性，可以利用该属性获取显示迭代器，它拥有 <strong>显示</strong> 的 <code>next</code> 方法：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const names &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]
const it &#x3D; names[Symbol.iterator]()
console.log(it); &#x2F;&#x2F; Array Iterator &#123;&#125;
console.log(it.next()); &#x2F;&#x2F; &#123;value: &#39;张三&#39;, done: false&#125;
console.log(it.next()); &#x2F;&#x2F; &#123;value: &#39;李四&#39;, done: false&#125;
console.log(it.next()); &#x2F;&#x2F; &#123;value: &#39;王五&#39;, done: false&#125;
console.log(it.next()); &#x2F;&#x2F; &#123;value: undefined, done: true&#125;

&#x2F;&#x2F; const person &#x3D; &#123;
&#x2F;&#x2F;   name: &#39;张三&#39;,
&#x2F;&#x2F;   age: 30
&#x2F;&#x2F; &#125;
&#x2F;&#x2F; &#x2F;&#x2F; Uncaught TypeError: person is not iterable
&#x2F;&#x2F; &#x2F;&#x2F; 普通对象默认不可迭代
&#x2F;&#x2F; for (const iterator of person) &#123;
&#x2F;&#x2F;   console.log(iterator);
&#x2F;&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而针对于对象而言，咱们也说过 <strong>普通对象默认不可迭代</strong>。不可迭代的原因其实是因为 <strong>缺少 Symbol.iterator 属性</strong>。所以如果我们希望让普通对象可迭代的话，那么可以通过以下两步来完成：</p>
<ul>
<li>为对象添加 <code>Symbol.iterator</code> 属性，返回 <code>iterator</code> 迭代器对象</li>
<li><code>iterator</code> 迭代器对象中包含 <code>next</code> 方法</li>
</ul>
<p>因为在实际开发中使用场景不多，所以其中具体的代码咱们就不在这里说了。</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>虽然迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。生成器函数提供了一个强大的选择：<strong>它允许你定义一个包含自有迭代算法的函数，同时它可以自动维护自己的状态</strong>。所以我们可以 <strong>利用生成器得到一个迭代器对象（<code>Generator</code> 符合 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE">可迭代协议</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">迭代器协议</a>），同时该迭代器对象同样会拥有 <code>next</code> 方法</strong>。</p>
<p>那么咱们搞明白 <strong>生成器与迭代器</strong> 的关系之后，下面咱们来看下 <strong>生成器</strong> 的语法。</p>
<p>想要创建并使用生成器的话，一共分为三步：</p>
<ol>
<li><p>生成器被称为 <strong>生成器函数</strong>，所以想要构建一个生成器，那么必须要构建一个函数：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 通过在 function 后面增加一个 * 来标记当前函数为生成器函数
function* simple() &#123;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>生成器内部包含 <strong>暂停迭代</strong> 的功能，这个暂停是配合 <code>next</code> 方法进行使用的</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function* simple() &#123;
  for (let i &#x3D; 0; i &lt; 3; i++) &#123;
    &#x2F;&#x2F; 使用 yield 控制暂停迭代
    yield console.log(i);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>调用生成器函数，可以得到一个迭代器对象，通过 <code>next</code> 方法控制 <strong>迭代过程</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const s &#x3D; simple()
s.next() &#x2F;&#x2F; 0
s.next() &#x2F;&#x2F; 1
s.next() &#x2F;&#x2F; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>同时对于生成器而言，它还可以 <strong>传递参数（消费值）</strong>，咱们来看这个例子：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function* add() &#123;
  console.log(&#39;开始&#39;);
  &#x2F;&#x2F; yield 后面的内容被叫做 value，并且 yield 包含返回值
  const value1 &#x3D; yield &quot;请输入第一次的值&quot;
  console.log(&#96;第一次的值为：$&#123;value1&#125;&#96;);

  const value2 &#x3D; yield &quot;请输入第二次的值&quot;
  console.log(&#96;第二次的值为：$&#123;value2&#125;&#96;);

  return value1 + value2
&#125;

let result
const gen &#x3D; add()
&#x2F;&#x2F; 开始
result &#x3D; gen.next()
console.log(result);
&#x2F;&#x2F; 第一次输入值
result &#x3D; gen.next(35)
console.log(result);
&#x2F;&#x2F; 第二次输入值
result &#x3D; gen.next(7)
console.log(result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="/medias/images/loading.gif" data-original="image-20230625185609320.png" alt="image-20230625185609320" style="zoom:50%;" />

<h3 id="旧习换新-4"><a href="#旧习换新-4" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>就像我们开始所说的一样，在实际企业开发中生成器与自定义迭代器其实使用率并不高，所以这里的旧习换新只有一个：</p>
<ul>
<li><strong>利用 DOM 的可迭代特性，通过 for….of… 进行循环</strong>。比如在通过 <code>querySelectAll</code> 获取 <code>DOM</code> 的伪数组之后，伪数组虽然没有办法直接 <code>forEach</code>，但是可以利用隐式迭代器 <code>for of</code> 完成循环操作</li>
</ul>
<h2 id="第七章：解构"><a href="#第七章：解构" class="headerlink" title="第七章：解构"></a>第七章：解构</h2><p>关于对象相关的最后一部分就是 <strong>解构</strong> 了。解构应该是日常开发中非常常用的语法。其目的是为了 <strong>从数据结构中快速提取对应的内容</strong></p>
<p>解构分为两部分：对象解构 和 数组解构。</p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>当对对象进行解构时，需要 <strong>配合 大括号 完成，大括号中放入需要提取的字段名，同时该字段名会作为新的变量名被创建</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;
  name: &#39;张三&#39;,
  age: 30
&#125;

&#x2F;&#x2F; 以大括号的形式来结构对象
&#x2F;&#x2F; 以 key 的形式，获取指定属性
const &#123; name &#125; &#x3D; person &#x2F;&#x2F; const name &#x3D; person.name
console.log(name); &#x2F;&#x2F; 张三<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而当 <strong>对象呈嵌套形式时</strong>，同样可以利用 <strong>嵌套解构</strong> 的形式进行结构：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;
  name: &#39;曹操&#39;,
  age: 58,
  children: [
    &#123;
      name: &#39;曹丕&#39;,
      age: 35
    &#125;,
    &#123;
      name: &#39;曹植&#39;,
      age: 28
    &#125;
  ]
&#125;

&#x2F;&#x2F; &#123; children &#125; 表示获取 person 的 children
&#x2F;&#x2F; &#123; children: [caoPi] &#125; 表示从 children 中获取第一个元素，命名为 caoPi
const &#123; children: [caoPi] &#125; &#x3D; person
console.log(caoPi); &#x2F;&#x2F; &#123;name: &#39;曹丕&#39;, age: 35&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>而对于数组的解构，需要 <strong>配合 中括号 完成，</strong>中括号中 <strong>按照下标的顺序，依次写入新的变量名</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

&#x2F;&#x2F; 以中括号的形式来结构对象
&#x2F;&#x2F; 中括号定义变量名
const [v1, v2, v3] &#x3D; arr &#x2F;&#x2F; const v1 &#x3D; arr[0], v2 &#x3D; arr[1], v3 &#x3D; arr[2]
console.log(v1, v2, v3); &#x2F;&#x2F; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同时，对于数组解构而言，也可以通过 <code>“rest” 语法</code> 直接获取 <strong>剩余元素，剩余元素会被赋值给新的数组</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

&#x2F;&#x2F; 以中括号的形式来结构对象
&#x2F;&#x2F; 中括号定义变量名
&#x2F;&#x2F; “rest” 语法... 表示剩余所有组成新数组
const [v1, ...v2] &#x3D; arr &#x2F;&#x2F; const v1 &#x3D; arr[0], v2 &#x3D; [arr[1], arr[2]]
console.log(v1, v2); &#x2F;&#x2F; &#39;a&#39;,  [&#39;b&#39;, &#39;c&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="旧习换新-5"><a href="#旧习换新-5" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>解构是日常开发中常用的语法，但是本身比较简单。只要大家在以后的开发中多使用解构语法，就会发现它本质上是一个非常简单的东西。</p>
<h2 id="第八章：Promise"><a href="#第八章：Promise" class="headerlink" title="第八章：Promise"></a>第八章：Promise</h2><p>接下来咱们来看第八章、第九章关于异步处理的部分。</p>
<p>说道异步，肯定有很多小伙伴直接想到的就是 <code>Promise</code>。 没有 <code>Promise</code> 是 <code>ES6</code> 之后专门用来处理异步的解决方案。但是要注意：</p>
<blockquote>
<p> <code>Promise</code> <strong>本身并不执行任何操作，它只是一种观察异步操作结果的方案</strong>。</p>
</blockquote>
<p>在 <code>Promise</code> 内部对整个异步的操作分为 <strong>三种状态</strong>，对应 <strong>三种结果</strong>。而语法分为 <strong>定义</strong> 和 <strong>使用</strong> 两部分。其中三种状态发生在定义阶段，三种结果发生在使用阶段。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function reload(b) &#123;
  &#x2F;&#x2F; 创建 promise 实例
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    console.log(&#39;代码进入 pending 状态&#39;);
    setTimeout(() &#x3D;&gt; &#123;
      if (b) &#123;
        resolve(&#39;代码进入 已成功 状态&#39;)
      &#125; else &#123;
        reject(&#39;代码进入 已拒绝 状态&#39;)
      &#125;
    &#125;, 500);
  &#125;)
&#125;

const p1 &#x3D; reload(true)
p1.then((data) &#x3D;&gt; &#123;
  console.log(data); &#x2F;&#x2F; 代码进入 已成功 状态
&#125;).finally(() &#x3D;&gt; &#123;
  console.log(&#39;p1 已敲定&#39;);
&#125;)

const p2 &#x3D; reload(false)
p2.then((data) &#x3D;&gt; &#123;
  console.log(data); &#x2F;&#x2F; 代码进入 已拒绝 状态
&#125;).finally(() &#x3D;&gt; &#123;
  console.log(&#39;p2已敲定&#39;);
&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同时，对于 <code>Promise</code> 而言，它支持链式调用的方式。只要在 <code>.then</code> 中 <code>return</code> 了内容，那么 <code>return</code> 的内容就会被封装为 <code>Promise.resolve</code> ，从而可以继续 <code>.then</code>:</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const p1 &#x3D; reload(true)
p1.then((data) &#x3D;&gt; &#123;
  console.log(data); &#x2F;&#x2F; 代码进入 已成功 状态
  return &#39;进入第二次 Promise&#39;
&#125;).then(data &#x3D;&gt; &#123;
  console.log(data);
  return &#39;进入第三次 Promise&#39;
&#125;).then(data &#x3D;&gt; &#123;
  console.log(data);
  console.log(&#39;三次结束&#39;);
&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="旧习换新-6"><a href="#旧习换新-6" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>对于 <code>Promise</code> 来说，现在在开发中的使用已经非常普遍了。所以当大家以后遇到异步问题时，应该首先考虑 <code>Promise</code></p>
<h2 id="第九章：异步函数、迭代器、生成器"><a href="#第九章：异步函数、迭代器、生成器" class="headerlink" title="第九章：异步函数、迭代器、生成器"></a>第九章：异步函数、迭代器、生成器</h2><p><code>Promise</code> 可以帮助我们处理异步操作，但是从上面的代码我们可以看出，在 <code>Promise</code> 的 <strong>使用</strong> 阶段，代码的复杂度其实并不低。</p>
<p>所以在 <code>ES7</code> 之后，<code>TC39</code> 推出了 <strong>异步函数</strong> 的概念，以解决 <code>Promise</code> 使用的复杂度问题。</p>
<p>想要定义异步函数，那么需要通过 <code>async</code> 关键字来进行定义，在异步函数中，可以通过 <code>await</code> 关键字来 <strong>让异步操作，变为同步的写法</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function reload1() &#123;
  &#x2F;&#x2F; 创建 promise 实例
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      resolve(&#39;reload1 进入 已成功 状态&#39;)
    &#125;, 500);
  &#125;)
&#125;

function reload2() &#123;
  &#x2F;&#x2F; 创建 promise 实例
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      resolve(&#39;reload2 进入 已成功 状态&#39;)
    &#125;, 500);
  &#125;)
&#125;

function reload3() &#123;
  &#x2F;&#x2F; 创建 promise 实例
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      resolve(&#39;reload3 进入 已成功 状态&#39;)
    &#125;, 500);
  &#125;)
&#125;


&#x2F;&#x2F; async 和 await 必须同时出现
&#x2F;&#x2F; async 标记指定方法为《异步方法》,该方法会返回一个 Promise
&#x2F;&#x2F; await 只能在《异步方法》中使用
async function start() &#123;
  &#x2F;&#x2F; 该操作同样为异步操作，只不过拥有了同步的写法
  const result1 &#x3D; await reload1()
  console.log(result1);
  const result2 &#x3D; await reload2()
  console.log(result2);
  const result3 &#x3D; await reload3()
  console.log(result3);

  return &#39;start 返回值&#39;
&#125;

const p &#x3D; start()
console.log(p); &#x2F;&#x2F; promise<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在使用 <code>async/await</code> 时，默认情况下返回值是 <code>.then</code> 的内容，如果想要捕获异常，那么需要通过 <code>try...catch...</code> 来完成。</p>
<p>同时对于异步函数来说，也可以配合生成器进行使用，得到 <strong>异步生成器函数</strong>。这种异步生成器，在需要 <strong>手动控制多个异步请求的顺序以及结果的时候，会有些用处</strong>，如果大家没有这方面的需求，只需要有个印象就可以了。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; async 函数必然返回 promise
async function* fetchInSeries([...urls]) &#123;
  for (const url of urls) &#123;
    const res &#x3D; await fetch(url)
    &#x2F;&#x2F; g.next().value 得到 res.json()
    yield res.json()
  &#125;
&#125;

async function getData() &#123;
  const g &#x3D; fetchInSeries([&#39;1.json&#39;, &#39;2.json&#39;, &#39;3.json&#39;])
  &#x2F;*
    let result &#x3D; await g.next()
    while (!result.done) &#123;
      console.log(result.value);
      result &#x3D; await g.next()
    &#125;
  *&#x2F;
  let result
  while (!(result &#x3D; await g.next()).done) &#123;
    console.log(result.value);
  &#125;
&#125;

getData()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在以上代码的 <code>getData()</code> 方法中，我们通过 <code>fetchInSeries</code> 方法得到了一个迭代器 <code>g</code> ，然后利用 <code>while</code> 循环的方式进行了迭代。</p>
<p>而整个迭代的过程可以进一步的简写，利用 <code>for await of</code> 语法，会更加轻松</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">async function getData() &#123;
  &#x2F;&#x2F; for await of：利用迭代器的特性配合 await 解析生成器
  for await (const value of fetchInSeries([&#39;1.json&#39;, &#39;2.json&#39;, &#39;3.json&#39;])) &#123;
    console.log(value);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="旧习换新-7"><a href="#旧习换新-7" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>使用 <code>async、await</code> 配合 <code>promise</code> 处理异步请求，是在当前阶段开发中非常常见的一种场景。当大家遇到异步请求时，那么首先应该想到的就是 <code>Promise + async\await</code>。</p>
<h2 id="第十章：模板字面量、标签函数和新的字符串特性"><a href="#第十章：模板字面量、标签函数和新的字符串特性" class="headerlink" title="第十章：模板字面量、标签函数和新的字符串特性"></a>第十章：模板字面量、标签函数和新的字符串特性</h2><p>从第十章开始，到第十四章为止，这五个章节主要是对传统技术的升级。</p>
<p>以第十章为例，传统技术下，想要拼接字符串与变量，那么一般需要通过 <strong>+ 运算符</strong> 进行隐式转换。而 <code>ES6</code> 之后，提供了 <strong>模板字符串</strong> 的概念：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const msg &#x3D; &#39;world&#39;
console.log(&#96;hello $&#123;msg&#125;&#96;); &#x2F;&#x2F; hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>处理之外，还提供了一些新的字符串方法。</p>
<p>以及通过 <code>for of</code> 隐式迭代器对字符串进行迭代操作。</p>
<h3 id="旧习换新-8"><a href="#旧习换新-8" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>这一章的内容中，对我们日常开发和面试有用的内容其实比较少，里面还包含一些对我们没有什么用处的东西，比如 <code>Unicode 的改进</code>，这些我就略过了，如果大家对 <code>Unicode</code> 感兴趣的话，可以去看一下书中的内容。</p>
<h2 id="第十一章：新数组特性、类型化数组"><a href="#第十一章：新数组特性、类型化数组" class="headerlink" title="第十一章：新数组特性、类型化数组"></a>第十一章：新数组特性、类型化数组</h2><p>对于第十一章来说，和第十章其实非常的类似。第十一章主要讲解的是 <code>Array 数组的改进</code>。内容主要就是两部分。</p>
<p>第一部分是对于 <code>Array</code> 数组的新增方法。</p>
<p>第二部分是 <strong>类型化数组</strong>。</p>
<p>对于很多小伙伴来说，类型化数组的概念大家可能是第一次听到。但是大家应该知道 <strong>JavaScript 中传统的 “数组” 并不是真正的数组，而是一个对象。</strong> 所以在 <code>ES6</code> 之后，<code>TC39</code> 提出了一个新的概念就是 <strong>类型化数组</strong>，不同的类型化数组可以存储不同的值，但是在日常的使用中，我们可能很少会主动使用这个东西。</p>
<h3 id="旧习换新-9"><a href="#旧习换新-9" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>数组的新增方法，在日常开发中是非常有用的。所以以上我们所列举出来的方法大家一定去 <code>MDN</code> 上看一下，至少做到有个印象。</p>
<h2 id="第十二章：Map-和-Set"><a href="#第十二章：Map-和-Set" class="headerlink" title="第十二章：Map 和 Set"></a>第十二章：Map 和 Set</h2><p>上面两章的内容相对都比较简单。但是接下来的 <code>Map</code> 和 <code>Set</code> 可能对于很多小伙伴来说是 <strong>“盲区”</strong>。</p>
<p>这一章一共讲到了 <code>4个</code> 新的接口：<code>Map、Set、WeakMap、WeakSet</code>。</p>
<p>咱么先来看 <code>Map</code>。<code>Map</code> 是 <strong>以 键\值对 的形式存储数据的对象，其中键值对可以是任何值</strong>。乍一看可能和 <strong>普通对象</strong> 没有什么区别，但是大家需要注意的是 <strong>普通对象的 key 只能是 字符串</strong>。 而 <strong>Map 对象的 key 可以是任意值</strong>。</p>
<p>也就是说虽然存储方式相同，但是可存储的内容确实大大不同的。</p>
<p>除此之外，在 <code>API</code> 上，<code>Map</code> 和 <code>&#123;&#125;</code> 也有较大的区别。我们可以来看下关于 <code>Map</code> 对象的基本语法：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 创建
const m &#x3D; new Map()
&#x2F;&#x2F; 增
m.set(&#39;name&#39;, &#39;张三&#39;)
m.set(&#39;age&#39;, &#39;30&#39;)
&#x2F;&#x2F; 改
m.set(&#39;name&#39;, &#39;李四&#39;)
&#x2F;&#x2F; 查
m.get(&#39;name&#39;)
&#x2F;&#x2F; 删
m.delete(&#39;name&#39;)
&#x2F;&#x2F; 获取长度
console.log(m.size);
&#x2F;&#x2F; 迭代
for (const [key, value] of m) &#123;
  console.log(key, value);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而对于 <code>Set</code> 而言，它与数组有些类似，但是不同的地方在于 <strong><code>Set</code> 存储唯一值，也就是元素不可以重复。</strong></p>
<p>同样它的语法和传统的 <code>Array</code> 也有较大的区别：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 创建
const s &#x3D; new Set()
&#x2F;&#x2F; 增
s.add(&#39;张三&#39;).add(&#39;李四&#39;)
&#x2F;&#x2F; 是否包含
s.has(&#39;张三&#39;)
&#x2F;&#x2F; 删
s.delete(&#39;张三&#39;)
&#x2F;&#x2F; 清空
s.clear()
&#x2F;&#x2F; 获取长度
console.log(s.size);
&#x2F;&#x2F; 迭代
for (const value of s) &#123;
  console.log(value);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而对于 <code>Map</code> 和 <code>Set</code> 来说，都提供了一个 <code>Weak</code> 版，叫做 <code>WeakMap</code> 和 <code>WeakSet</code>。</p>
<p> <code>WeakMap</code> 和 <code>WeakSet</code>与 <code>Map</code> 和 <code>Set</code> 的区别主要体现在三个地方：</p>
<ul>
<li>首先第一个地方是 <strong>值为弱引用</strong> ，这意味着它并不会影响垃圾回收。</li>
<li>同时因为是弱引用，所以 <strong>值不会保存在内存中</strong>，这个就比较好理解了。</li>
<li>最后就是 <strong>不可迭代</strong>。</li>
</ul>
<h3 id="旧习换新-10"><a href="#旧习换新-10" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>最后就是旧习换新。</p>
<ul>
<li>首先：如果你要以键值对的形式保存数据，同时 <code>Key</code> 非字符串，那么此时可以考虑使用 <code>Map</code></li>
<li>其次：<code>Set</code> 对象可以存储唯一值，这在数组去重的场景下会非常有用</li>
<li>最后：如果你希望 <code>key</code> 跟随变量的销毁而被回收时，那么可以使用 <code>WeakMap</code> 或 <code>WeakSet</code></li>
</ul>
<h2 id="第十三章：模块"><a href="#第十三章：模块" class="headerlink" title="第十三章：模块"></a>第十三章：模块</h2><p>第十三章主要讲解的就是模块化的概念。任何的模块化都会被分成两部分 <strong>导入</strong> 和 <strong>导出</strong>。</p>
<p>而目前在前端领域，主要的模块化方式有两个 <code>ESM</code> 和 <code>CJS</code> 。</p>
<p>所以说咱们在这一章中要学习的就是：</p>
<ul>
<li><code>ESM</code> 的导入、导出</li>
<li><code>CJS</code> 的导入、导出</li>
</ul>
<p>一个四个环节。</p>
<p>那么首先我们先来看 <code>ESM</code>。所谓 <code>ESM</code> 指的是 <strong>ES2015 之后新增的标准模块化方案 <code>ES Module</code><strong>。它相对复杂一点，分为 <strong>直接导出</strong>、</strong>按需导出</strong>、<strong>直接导入</strong>、<strong>按需导入</strong> 一共四部分。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">直达链接</a>。</p>
<p>除了这标准的四部分之后，有时候在 <code>EMS</code> 中可能还会涉及到 <strong>导入同时导出</strong> 的场景，如果想要导入并导出，那么可以通过 <code>export &#123;xx&#125; from &#39;./xx&#39;</code> 的方式进行。</p>
<p>第二个是 <code>CJS</code>。<code>CJS</code> 的逻辑与 <code>ESM</code> 相同，甚至更加简单。只是语法上会稍有不同。<code>CJS</code> 不存在按需的概念，所以只有导入和导出两部分。<a target="_blank" rel="noopener" href="https://nodejs.org/docs/latest/api/modules.html">文档直达链接</a></p>
<p>除了 <code>CJS</code> 和 <code>EMS</code> 之外，还有一些其他的模块化方案，比如 <code>UMD</code>，<code>AMD</code>、<code>CMD</code> 等等。这些模块化方案在应用层开发中很少见，所以咱们不做讨论。</p>
<h3 id="旧习换新-11"><a href="#旧习换新-11" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>最后就是旧习换新环节。</p>
<p>其实对于模块化的问题，在现在的企业开发中已经是非常常见的了。无论是 <code>EMS</code> 还是 <code>CJS</code> 都已经得到了广泛的应用。所以这一章的内容，对于大多数小伙伴来说，应该都没有太大的难度才对。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">QT-7274</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://qt-7274.github.io/2023/06/24/jing-du-shen-ru-li-jie-xian-dai-javascript/">https://qt-7274.github.io/2023/06/24/jing-du-shen-ru-li-jie-xian-dai-javascript/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">QT-7274</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                    <span class="chip bg-color">前端</span>
                                </a>
                            
                                <a href="/tags/%E4%B9%A6%E7%B1%8D/">
                                    <span class="chip bg-color">书籍</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/images/loading.gif" data-original="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/images/loading.gif" data-original="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.gif") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid;">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'tzmyy70PpnbbxclXN4jYmjPA-gzGzoHsz',
        appKey: 'TCY55mH7vS6x5sVr1bCLm5Gg',
        serverURLs: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        requiredFields: ['nick','mail'],
        enableQQ: 'true',
        lang: 'zh-cn',
        placeholder: '😉畅所欲言！\n📲请文明评论，禁止恶意评论🚫 \n⚠️公开网络空间，请不要发表任何包含个人或其他人的隐私信息🔐',
        master: ["f18e9f29c8274571d5a0752aca9310ef"],
        friends:["0aa4f09d8249581a4380a6fc541062e7","6a66a1ba019c52f168d99313efbef39a"]
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/06/26/css-zhong-de-he-zi-mo-xing/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/images/loading.gif" data-original="/medias/featureimages/14.jpg" class="responsive-img" alt="CSS中的盒子模型">
                        
                        <span class="card-title">CSS中的盒子模型</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            CSS会把所有的HTML元素都看成一个盒子，所有的样式也是基于这个神奇的盒子。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" class="post-category">
                                    前端开发
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/CSS/">
                        <span class="chip bg-color">CSS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/06/24/css-xuan-ze-qi-quan-chong-ji-suan/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/images/loading.gif" data-original="/medias/featureimages/3.jpg" class="responsive-img" alt="CSS选择器权重计算">
                        
                        <span class="card-title">CSS选择器权重计算</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本文通过图解提供一种计算CSS选择器权重的简单方法
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-06-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" class="post-category">
                                    前端开发
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/CSS/">
                        <span class="chip bg-color">CSS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">QT-7274</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/QT-7274" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2531376773@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2531376773" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2531376773" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>


    <a  class="tooltipped" target="_blank" data-tooltip="微信联系我: Q5268368" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 3,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>

</html>
