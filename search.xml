<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS进阶--文本效果</title>
      <link href="/2023/04/06/css-jin-jie-wen-ben-xiao-guo/"/>
      <url>/2023/04/06/css-jin-jie-wen-ben-xiao-guo/</url>
      
        <content type="html"><![CDATA[<h1 id="文本效果"><a href="#文本效果" class="headerlink" title="文本效果"></a>文本效果</h1><h2 id="深入text-indent"><a href="#深入text-indent" class="headerlink" title="深入text-indent"></a>深入text-indent</h2><ol><li>实现首行缩进2字符：<code>text-indent:2em</code></li><li>在引擎优化中，h1是非常重要的标签，一般情况下，我们都是把网站的LOGO图片放在h1标签中。但是搜索引擎只能识别文字，不能识别图片。为了更好地进行搜索引擎优化，一个很好的解决方案是：<ul><li>指定h1元素的长宽和LOGO图片的长宽一样</li><li>定义h1的背景图片为LOGO图片</li><li>使用<code>text-indent:-9999px</code>来隐藏h1的文字内容</li></ul></li></ol><h2 id="深入text-align"><a href="#深入text-align" class="headerlink" title="深入text-align"></a>深入text-align</h2><p>text-align属性用来定义文本或图片的对齐方式，常用取值为left、right、center。</p><p>text-align属性对文本、inline元素以及inline-block元素都会起作用，但对block元素不起作用。</p><h3 id="关于页面居中"><a href="#关于页面居中" class="headerlink" title="关于页面居中"></a>关于页面居中</h3><p>在实现页面居中的方式中，<code>text-align:center</code>和<code>margin:0 auto</code>是最常见的两种居中方式，不过这两者也有着本质的区别。</p><ul><li><code>text-align:center</code> 实现的是文本、inline元素以及inline-block元素的水平居中。</li><li><code>margin:0 auto</code>实现的是block元素的水平居中。</li><li><code>text-align:center</code> 在<strong>父元素</strong>中定义，<code>margin:0 auto</code>在<strong>当前元素</strong>中定义。</li></ul><h2 id="深入line-height"><a href="#深入line-height" class="headerlink" title="深入line-height"></a>深入line-height</h2><p>line-height的准确定义：两行文字<strong>基线</strong>之间的距离。关于顶线、中线、基线、底线的内容本文不再赘述。</p><h3 id="height和line-height"><a href="#height和line-height" class="headerlink" title="height和line-height"></a>height和line-height</h3><p>line-height是有默认值的，当没有定义line-height属性时，浏览器就会采用默认的line-height值。</p><p>一行文字的高度是由line-height决定，而不是由height决定。例如在p标签中，一个p标签的文字可以有很多行，其中line-height定义的是一行文字的高度，而height定义的才是整个段落的高度（即p标签的高度）。</p><p>我们可以定义height和line-height这<strong>两个属性值相等</strong>，从而实现<strong>单行文字的垂直居中</strong>。</p><h3 id="line-height的取值"><a href="#line-height的取值" class="headerlink" title="line-height的取值"></a>line-height的取值</h3><p>当line-height的取值为百分比或者em值时，元素的行高是相对于“当前元素”的font-size值来计算的。计算公式如下：</p><p><code>line-height = （当前元素font-size）×（百分比）</code> </p><p><code>line-height =（当前元素font-size）×（em值）</code></p><h2 id="深入vertical-align"><a href="#深入vertical-align" class="headerlink" title="深入vertical-align"></a>深入vertical-align</h2><p>W3C官方对vertical-align属性的定义有以下4个方面的解释。</p><ul><li>vertical-align属性用于定义<strong>周围的文字、inline元素以及inline-block元素相对于该元素基线的垂直对齐方式</strong>。</li><li>在表格单元格中，vertical-align属性可以定义单元格td元素中内容的对齐方式。td元素是table-cell元素，也就是说vertical-align属性对table-cell类型元素有效（<strong>针对自身而言</strong>）。</li><li>vertical-align属性对inline元素、inline-block元素和table-cell元素有效，对block元素无效。</li><li>vertical-align属性允许制定负长度值（如-2px）和百分比值（如50%）。</li></ul><p>vertical-align属性中最常见的属性值有4个：top、middle、baseline、bottom</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器中的重绘和重排</title>
      <link href="/2023/03/30/liu-lan-qi-zhong-de-chong-hui-he-chong-pai/"/>
      <url>/2023/03/30/liu-lan-qi-zhong-de-chong-hui-he-chong-pai/</url>
      
        <content type="html"><![CDATA[<h1 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h1><p>阅读基础：掌握<a href="https://qt7274.co/2023/03/29/liu-lan-qi-yun-zuo-yuan-li/">浏览器运作原理 | QT-7274 (qt7274.co)</a></p><ul><li><p>当DOM结构中的元素发生改变，或者浏览器窗口大小改变，或者元素位置、大小、内容发生改变时，会重新进行样式计算（Style）、布局（Layout）、绘制（Paint）以及后面的所有流程，也就是整个页面都会重新渲染。这种行为我们称为<strong>重排</strong>。</p></li><li><p>当元素的样式（如颜色、背景、边框等）发生改变时，浏览器会重新绘制元素的外观，这个过程叫做重绘。重绘不会重新触发布局（Layout），但会触发样式计算（Style）和绘制（Paint），这种行为称为<strong>重绘</strong>。</p></li><li><p>区别：重排和重绘都会影响页面的渲染性能，但是<strong>重排的开销更大</strong>，因为它会重新计算元素的位置和大小，重新布局整个页面。而重绘只是重新绘制元素的外观，对于页面渲染性能的影响相对较小。因此，为了提高页面性能，尽量减少重排的次数，优化CSS样式，避免频繁操作DOM。</p></li></ul><h2 id="为什么要避免大量的重绘和重排？"><a href="#为什么要避免大量的重绘和重排？" class="headerlink" title="为什么要避免大量的重绘和重排？"></a>为什么要避免大量的重绘和重排？</h2><p>重排和重绘都会占用主线程，同时JavaScript也会占用主线程，即他们会出现抢占执行时间的问题。</p><p>如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。如果在运行动画时还有大量的JavaScript代码，当在一帧的时间内布局和绘制结束后，还有剩余时间，JS就会拿到主线程的使用权。如果JS执行时间过长，就会导致在<strong>下一帧开始时JS没有及时归还主线程</strong>，导致下一帧动画没有按时渲染，就会出现页面动画<strong>卡顿</strong>。</p><h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><ol><li>通过<code>requestAnimationFrame()</code>这个API帮助我们解决这个问题，这个方法会在每一帧被调用，通过API的回调，我们可以把JS运行任务分成一些更小的任务块，在每一帧时间用完前暂停JS执行，归还主线程。这样在下一帧开始时，主线程可以按时执行布局和绘制。React的渲染引擎React Fiber就是用到了这个api来做了很多优化。</li><li>栅格化的整个流程是不占用主线程的，意味着它无需和JS抢夺主线程。而CSS中有个动画属性为<code>transform</code>，通过该属性实现的动画不会经过布局和绘制，而是<strong>直接运行在合成器线程和栅格化线程中</strong>，所以不会受到主线程中JS执行的影响。且通过<code>transform</code>实现的动画由于不需要经过布局绘制、样式计算等操作，节省了很多运算时间。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器运作原理</title>
      <link href="/2023/03/29/liu-lan-qi-yun-zuo-yuan-li/"/>
      <url>/2023/03/29/liu-lan-qi-yun-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h1><p>浏览器的结构可以简单地划分为以下模块：</p><ul><li>用户界面</li><li>浏览器引擎：其中包括数据持久层</li><li>渲染引擎：其中包括网络、JS解析器等</li></ul><p>其中渲染引擎可以说是一个浏览器的<strong>核心</strong>和<strong>灵魂</strong>，也就是我们常说的浏览器<strong>内核</strong>。</p><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><ul><li>IE浏览器：Trident内核</li><li>Firefox浏览器：Gecko内核</li><li>Safari浏览器：Webkit内核（已开源）</li><li>Chrome&#x2F;Opera&#x2F;Edge浏览器：Blink内核</li></ul><p>本文以Chrome内核为基础进行解释。</p><h2 id="从单进程进化到多进程结构"><a href="#从单进程进化到多进程结构" class="headerlink" title="从单进程进化到多进程结构"></a>从单进程进化到多进程结构</h2><p>以前的浏览器是单进程浏览器，一个进程中大概有页面线程负责页面，JS线程负责执行JS代码，还有其他各种线程。单进程的浏览器引发了很多问题：</p><ol><li>其中一个线程的卡死可能会导致整个进程出问题。</li><li>安全性堪忧，多个线程间共享数据。</li><li>流畅度差，一个进程需要负责太多事情，导致浏览器运行效率低。</li></ol><p>目前的浏览器采用多进程结构，分类如下：</p><ul><li><p><strong>浏览器进程</strong></p><ol><li>负责控制除标签页外的用户界面，包括地址栏、书签、后退和前进按钮。</li><li>负责与浏览器的其他进程协调工作。</li></ol></li><li><p><strong>渲染进程</strong></p><ol><li>负责控制显示tab标签内的所有内容，将其转换为用户可视化的内容。</li><li>负责与浏览器进程通信，处理用户输入和鼠标操作等。</li></ol><p>浏览器默认情况下会为每个标签页创建一个进程。浏览器默认情况下会为每个标签页创建一个进程。这种进程模型会占用更多内存，但是更加安全，各个标签页相互独立，当其中一个标签页渲染器进程卡死，并不会影响其他标签。</p><blockquote><p>注意：Chrome一共有4种进程模型，默认为每个实例创建一个渲染器进程，详见官方文档。</p></blockquote></li><li><p><strong>缓存进程</strong></p><ol><li>负责管理浏览器的缓存数据，包括将访问过的网页和资源文件存储在本地缓存中，下次访问同一网页时可以更快地加载页面。缓存进程还可以根据用户的使用习惯，预加载可能需要访问的网页和资源文件，以提升用户的体验。</li><li>负责在后台执行一些优化操作，如缓存常用的资源文件，以提高浏览器的性能和响应速度。</li></ol></li><li><p><strong>网络进程</strong></p><p>负责处理网络请求，包括DNS解析、建立TCP连接、SSL认证等。每个标签页都有一个独立的网络进程，这样可以避免一个标签页的网络请求影响到其他标签页的性能。</p></li><li><p><strong>GPU进程</strong></p><p>负责处理GPU相关的任务，如图形渲染、图像处理等。这个进程在Windows和Linux上是独立的进程，而在macOS上则与浏览器进程合并，称为“GPU进程”。</p></li><li><p><strong>插件进程</strong></p><p>负责运行浏览器插件，如Flash、PDF阅读器等。插件进程是一个独立的进程，与浏览器进程和渲染进程分别通信。</p></li></ul><h1 id="浏览器内部工作原理"><a href="#浏览器内部工作原理" class="headerlink" title="浏览器内部工作原理"></a>浏览器内部工作原理</h1><p>当你在浏览器地址栏输入地址时，浏览器进程的UI线程会捕捉你的输入内容：</p><ul><li>如果输入内容是网址，则UI线程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器获取数据。</li><li>如果输入内容不是网址而是一串关键词，浏览器知道你是要搜索，于是会使用默认搜索引擎来进行搜索。</li></ul><p>当网络线程获取数据之后：</p><ol><li><p>当网络线程获取数据之后，会通过SafeBrowsing来检查网站是否是恶意站点。</p></li><li><p>当网络数据接收完毕，安全检验通过后，网络线程会通知UI线程。</p></li><li><p>UI线程创建渲染器进程来渲染页面。浏览器进程通过<strong>IPC管道</strong>将数据传递给渲染器进程。</p></li><li><p><strong>（Dom）</strong>渲染器进程的主线程对HTML内容进行解析，构造DOM数据结构（DOM是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API）：</p><ol><li><p>HTML首先通过Tokeniser通过词法分析将输入的html内容解析成多个标记。根据识别后的标记进行DOM树构造。</p></li><li><p>在DOM树构造过程中会创建document对象，然后以document的为根节点的DOM树不断进行修改，向其中添加各种元素。</p></li><li><p>HTML代码中往往会引入一些额外的资源，例如图片、CSS、JS脚本等。图片和CSS资源需要通过网络下载或者从缓存中直接加载。这些资源不会阻塞html的解析，因为它们不会影响DOM的生成。<strong>但当html解析中遇到script标签，就会停止html解析流程，转而去加载解析并且执行JS。</strong></p><blockquote><p>为什么不跳过JS解析，等html解析完成了再去加载运行JS呢？</p></blockquote><p>这是因为浏览器并不知道JS执行是否会改变当前页面的HTML结构，如果JS代码里调用了document.write方法来修改html，那么之前的html解析就没有任何意义了。</p><p><u>这也是为什么script标签的位置，使用async或defer属性来异步加载JS的重要性。</u></p></li></ol></li><li><p><strong>（Style）</strong>在script标签加载完成后，我们会获得一个DOM树，但我们仍然不知道每个树节点上的样式。主线程需要解析CSS，并确定每个DOM节点的计算样式。</p></li><li><p><strong>（Layout）</strong>接下来需要知道每个节点放在页面上哪个位置，即节点坐标以及该节点需要占用多大的区域。</p></li><li><p>主线程通过遍历DOM和计算好的样式来生成Layout树。LAYOUT树上的每个节点都记录了x，y坐标和边框尺寸。</p><p>注意：DOM树和Layout树并不是一一对应的。</p><ul><li>设置了display:none的节点不会出现在Layout树上。</li><li>在before伪类中添加了content值的元素，content里的内容会出现在Layout树上，而不会出现在DOM树中。这是因为DOM是通过HTML解析获得，并不关心样式。</li></ul></li><li><p><strong>（Paint）</strong>我们还需知道以何种顺序来绘制节点。例如z-index属性会影响节点绘制的层级关系，如果按照DOM的层级结构来绘制页面则会导致错误的渲染。所以主线程遍历Layout树创建一个绘制记录表，代表了绘制的顺序，这个阶段称为绘制。</p></li><li><p><strong>（Rastering）</strong>在知道文档的绘制顺序后，终于到了该把这些信息转化为像素点的时候了。这种行为被称为栅格化。</p><p>Chrome最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分。这种方式带来的缺点显而易见，会导致显示延迟。</p><p>随着不断的优化升级，现在的Chrome使用了一种更复杂的栅格化流程，叫做<strong>合成（Composting）</strong>。合成是一种将页面的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程中单独进行合成页面的技术。</p></li><li><p><strong>（Layer）</strong>主线程遍历Layout树生成Layer树，当Layer树生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程。合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块，然后将每个图块发送给栅格化线程（Raster Thread）。</p></li><li><p>栅格化线程栅格化每个图块，并将它们存储在GPU内存中，当图块栅格化完成后，合成器线程将收集称为“draw quads”的图块信息。这些信息里记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息，根据这些信息合成器线程生成了一个合成器帧。</p></li><li><p>合成器帧通过IPC传送给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。</p></li></ol><h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><p>①浏览器进程中的网络线程请求获取到html数据——②通过IPC将数据传给渲染器进程的主线程——③主线程将html解析构造DOM树——④样式计算——⑤根据DOM树和生成好的样式生成Layout树——⑥通过遍历Layout树生成绘制顺序表——⑦通过遍历Layout树生成Layer树——⑧主线程将Layer树和绘制顺序表一起传给合成器线程——⑨合成器线程根据规则划分图层——⑩将图层分为更小的图块（tiles）传给栅格化线程进行栅格化——⑪栅格化完成后合成器线程会获得栅格化线程传过来的“draw quads”图块信息——⑫根据图块信息合成器线程上合成了一个合成器帧——⑬该合成器帧通过IPC传回给浏览器进程——⑭浏览器进程再传给GPU进行渲染——⑮将图像展示在屏幕上</p><p><img src="C:/Users/qsq/AppData/Roaming/Typora/typora-user-images/image-20230330235132605.png" alt="image-20230330235132605"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶--display简介</title>
      <link href="/2023/03/22/css-jin-jie-display-jian-jie/"/>
      <url>/2023/03/22/css-jin-jie-display-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h1><h2 id="块元素、行内元素、行内块元素"><a href="#块元素、行内元素、行内块元素" class="headerlink" title="块元素、行内元素、行内块元素"></a>块元素、行内元素、行内块元素</h2><p>块元素（block）特点：</p><ul><li><strong>块元素独占一行，排斥其他元素（包括块元素和行内元素）与其位于同一行。</strong></li><li><strong>块元素内部可以容纳其他块元素和行内元素。</strong></li><li><strong>可以定义width，也可以定义height。</strong></li><li><strong>可以定义4个方向的margin。</strong></li></ul><p>行内元素（inline）特点：</p><ul><li><strong>行内元素可以与其他行内元素位于同一行。</strong></li><li><strong>行内元素内部可以容纳其他行内元素，但不可以容纳块元素。</strong></li><li><strong>无法定义height，也无法定义width。</strong></li><li><strong>可以定义margin-left和margin-right，无法定义margin-top和margin-bottom。</strong></li></ul><p>行内块元素（inline-block）特点：</p><p><strong>同时具备了block元素和inline元素的特点。</strong></p><p>在HTML5中，最典型的inline-block元素有两个：<strong>img</strong>和<strong>input</strong>。</p><h2 id="display-none"><a href="#display-none" class="headerlink" title="display:none"></a>display:none</h2><p>对于display:none，我们需要注意以下两点：</p><ul><li>display:none元素一般用来配合JavaScript动态隐藏元素，被隐藏的元素不占据原来的位置。</li><li>display:none不推荐用来隐藏一些对SEO关键的部分，因为对于搜索引擎而言，它不会将display:none隐藏的内容加入权重考虑。</li></ul><h3 id="display-none和visibility-none的区别"><a href="#display-none和visibility-none的区别" class="headerlink" title="display:none和visibility:none的区别"></a>display:none和visibility:none的区别</h3><p>虽然两种方式都可以隐藏元素，但二者之间有本质的区别：</p><ul><li>display:none：元素被隐藏后，<strong>不占据原来的位置</strong>。</li><li>visibility:none：元素被隐藏后，<strong>依然占据原来的位置</strong>。</li></ul><h2 id="display-table-cell"><a href="#display-table-cell" class="headerlink" title="display:table-cell"></a>display:table-cell</h2><p>display:table-cell可以让元素以表格单元格的形式呈现。换句话说，就是table-cell类型元素具有td元素的特点。</p><p>常见用途有以下三种：</p><ul><li>图片垂直居中于元素</li><li>等高布局</li><li>自动平均划分元素</li></ul><h3 id="图片垂直居中于元素"><a href="#图片垂直居中于元素" class="headerlink" title="图片垂直居中于元素"></a>图片垂直居中于元素</h3><p>我们可以配合使用display:table-cell和vertical-align: middle来实现<strong>大小不固定的图片的垂直居中</strong>效果。</p><p>（图片的水平居中可以使用text-align:center来实现)</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 父元素 */</span>      <span class="token punctuation">&#123;</span>          <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>          <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token comment">/* 子元素 */</span>      <span class="token punctuation">&#123;</span>          <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="等高布局"><a href="#等高布局" class="headerlink" title="等高布局"></a>等高布局</h3><p>我们知道，同一行的单元格td元素高度是相等的，因此，table-cell元素也具备这个特点。根据这个特点，我们可以实现<strong>等高布局</strong>效果。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html>&lt;html lang=<span class="token string">"en"</span>>&lt;head>    &lt;meta charset=<span class="token string">"UTF-8"</span> />    &lt;meta http-equiv=<span class="token string">"X-UA-Compatible"</span> content=<span class="token string">"IE=edge"</span> />    &lt;meta name=<span class="token string">"viewport"</span> content=<span class="token string">"width=device-width, initial-scale=1.0"</span> />    &lt;title>&lt;/title>    &lt;style type=<span class="token string">"text/css"</span>>        <span class="token comment">/* 定义父元素具备的特点 */</span>        <span class="token selector">#wrapper</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-row<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#img-box</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token comment">/* 垂直居中 */</span>            <span class="token property">vertical-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token comment">/* 水平居中  */</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#text-box</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    &lt;/style>    &lt;script>    &lt;/script>&lt;/head>&lt;body>    &lt;div id=<span class="token string">"wrapper"</span>>        &lt;div id=<span class="token string">"img-box"</span>>            &lt;img src=<span class="token string">"http://www.cxy521.com/static/img/index/image/baidu_favicon.ico"</span> alt=<span class="token string">""</span> class=<span class="token string">"img"</span> />        &lt;/div>        &lt;div id=<span class="token string">"text-box"</span>>            &lt;span>baidu&lt;/span>        &lt;/div>    &lt;/div>&lt;/body>&lt;/html><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自动平均划分元素"><a href="#自动平均划分元素" class="headerlink" title="自动平均划分元素"></a>自动平均划分元素</h3><p>可以为每一个li元素定义display:table-cell，它会<strong>自动平均划分元素，并且使得它们在同一行显示</strong>。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 父元素 */</span>       <span class="token punctuation">&#123;</span>           <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span> <span class="token comment">/* 子元素 */</span>       <span class="token punctuation">&#123;</span>          <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后为父元素定义一定的宽度，那么此时子元素的宽度就会根据子元素的个数自动平均划分。</p><h2 id="inline-block元素间距"><a href="#inline-block元素间距" class="headerlink" title="inline-block元素间距"></a>inline-block元素间距</h2><p>inline-block元素之间有一定的间距。在实际开发中，这种间距有时会对我们的布局产生影响。大多数时候我们需要去除inline-block元素的间距。</p><p>在CSS中，我们可以为<strong>父元素</strong>定义一个”<strong>font-size:0;</strong>“来去除inline-block元素的间距。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 父元素 */</span>       <span class="token punctuation">&#123;</span>          <span class="token property">font-size</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：<u>因为父元素使用了font-size:0，所以子元素如果有文字需要定义自身的font-size，不然会因为继承而看不到文字。</u></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶--负margin技术</title>
      <link href="/2023/03/19/css-jin-jie-fu-margin-ji-zhu/"/>
      <url>/2023/03/19/css-jin-jie-fu-margin-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h1 id="负margin技术"><a href="#负margin技术" class="headerlink" title="负margin技术"></a>负margin技术</h1><p>当margin取值为负数时，margin对普通文档流元素和对浮动元素的影响是不一样的。其中，margin对普通文档流元素的影响，可以分为以下两种情况：</p><ul><li>当元素的margin-top或者margin-left为负数时，“<strong>当前元素</strong>”会被拉向指定方向。</li><li>当元素的margin-bottom或者margin-right为负数时，“<strong>后续元素</strong>”会被拉向指定方向。</li></ul><p>对于浮动元素，我们只需要比普通文档流元素多考虑一点，那就是浮动元素的“流动方向”。</p><h2 id="负margin技巧"><a href="#负margin技巧" class="headerlink" title="负margin技巧"></a>负margin技巧</h2><h3 id="图片与文本对齐"><a href="#图片与文本对齐" class="headerlink" title="图片与文本对齐"></a>图片与文本对齐</h3><p>当图片与文本放到一起的时候，它们在底部水平方向上往往都是不对齐的。这是因为在默认情况下，图片与周围的文本是基线对齐，也就是vertical-align:baseline。如果想让它们在底部水平方向上对齐，有两种方法：一种是使用vertical-align:text-bottom；另一种是使用负margin技术。</p><p><img src="C:/Users/qsq/AppData/Roaming/Typora/typora-user-images/image-20230319234230998.png" alt="image-20230319234230998"></p><p>默认情况下，图片与文字在底部水平方向上是不对齐的。我们在CSS中添加：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">img</span><span class="token punctuation">&#123;</span><span class="token property">margin</span><span class="token punctuation">:</span>0 3px -3px 0<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得到效果如下：</p><p><img src="C:/Users/qsq/AppData/Roaming/Typora/typora-user-images/image-20230319234504244.png" alt="image-20230319234504244"></p><h3 id="自适应两列布局"><a href="#自适应两列布局" class="headerlink" title="自适应两列布局"></a>自适应两列布局</h3><p>自适应两列布局，指的是在两列布局中，其中一列的宽度是固定的，而另外一列宽度自适应。如果使用浮动来做的话，只能实现固定的左右两列布局，并不能实现其中一列为自适应的布局。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">#main,#sidebar</span>        <span class="token punctuation">&#123;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#main</span>        <span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">margin-right</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#sidebar</span>        <span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span>        <span class="token comment">/* 防止浏览器可视区域宽度不足时发生文本重叠 */</span>        <span class="token selector">#main p</span> <span class="token punctuation">&#123;</span><span class="token property">margin-right</span><span class="token punctuation">:</span> 210px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">           </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是主体部分，自适应宽度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sidebar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是侧边栏部分，固定宽度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:/Users/qsq/AppData/Roaming/Typora/typora-user-images/image-20230319235048025.png" alt="image-20230319235048025"></p><h3 id="元素垂直居中"><a href="#元素垂直居中" class="headerlink" title="元素垂直居中"></a>元素垂直居中</h3><p>想要实现块元素的垂直居中，一般来说比较麻烦，不过有一个经典的方法就是使用position结合负margin来实现：首先，给父元素写上position:relative，这样做是为了给子元素添加position:absolute的时候不会定位到外太空去；然后给子元素添加如下属性：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">父元素</span><span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token selector">子元素</span><span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>        <span class="token property">margin-top</span><span class="token punctuation">:</span> “height值一半的负值”<span class="token punctuation">;</span>        <span class="token property">margin-left</span><span class="token punctuation">:</span> “width值一般的负值”<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tab选项卡"><a href="#tab选项卡" class="headerlink" title="tab选项卡"></a>tab选项卡</h3><p>具体技巧就是使用margin-top:-1px消除tab选项卡的下边框。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶--外边距叠加</title>
      <link href="/2023/03/19/css-jin-jie-wai-bian-ju-die-jia/"/>
      <url>/2023/03/19/css-jin-jie-wai-bian-ju-die-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h1><p>外边距叠加，又称“margin叠加”，指的是当两个垂直外边距相遇时，这两个外边距将会合并成一个外边距。</p><p>其中，**叠加之后的外边距高度，等于发生叠加之前的两个外边距中的<u>最大值</u>**。</p><p>外边距叠加有三种情况：同级元素、父级元素、空元素</p><h2 id="同级元素"><a href="#同级元素" class="headerlink" title="同级元素"></a>同级元素</h2><p>当一个元素出现在另一个元素上面的时候，第1个元素的下边距（margin-bottom）将会与第2个元素的上边距（margin-top）发生合并。</p><h2 id="父子元素"><a href="#父子元素" class="headerlink" title="父子元素"></a>父子元素</h2><p>当一个元素包含在另外一个元素中时（呈父子关系），假如没有padding或border把外边距分隔开，父元素和子元素的相邻上下外边距也会发生合并。</p><h2 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h2><p>空元素，指的是没有子元素或者没有文字内容的元素，当一个空元素有上下外边距时，如果没有border或padding，则元素的上外边距与下外边距就会合并。如果空元素的外边距碰到另外一个元素的外边距，它们也会发生合并。</p><p>注意：</p><ol><li><strong>水平外边距，永远不会有叠加，水平外边距指的是margin-left和margin-right。</strong></li><li><strong>垂直外边距只有在以上三种情况下会叠加。</strong></li><li><strong>外边距叠加之后的外边距高度，等于发生叠加之前的两个外边距中的最大值。</strong></li><li><strong>外边距叠加针对的是block以及inline-block元素，不包括inline元素。因为inline元素的margin-top和margin-bottom设置无效。</strong></li></ol><p>建议：</p><p><u>最好统一使用margin-top或margin-bottom，不要混合使用，从而降低出现问题的风险。</u></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶——CSS单位</title>
      <link href="/2023/03/19/css-jin-jie-css-dan-wei/"/>
      <url>/2023/03/19/css-jin-jie-css-dan-wei/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h2><p>总体来说，CSS单位可以分为绝对单位和相对单位两大类。</p><h3 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h3><p>绝对单位多用于传统页面印刷中，极少用于前端开发。</p><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p>在CSS中，相对单位定义的大小是不固定的，一般是相对于其他长度而言。在CSS中，常用的相对单位如下表所示：</p><table><thead><tr><th>相对单位</th><th>说明</th></tr></thead><tbody><tr><td>px</td><td>像素</td></tr><tr><td>%</td><td>百分比</td></tr><tr><td>em</td><td>1em等于“<strong>当前元素</strong>”字体大小</td></tr><tr><td>rem</td><td>1rem等于“<strong>根元素</strong>”字体大小</td></tr></tbody></table><h4 id="像素（px）"><a href="#像素（px）" class="headerlink" title="像素（px）"></a>像素（px）</h4><p>px，全称pixel（像素），指一张图片中最小的点，或者是计算机屏幕中最小的点。严格来讲，px属于相对单位，因为屏幕分辨率不同，1px大小也是不同的。但是<u>如果不考虑屏幕分辨率，我们也可以把px当作绝对单位来看待</u>，这也是为什么很多地方说px是绝对单位的原因。</p><h4 id="百分比（-）"><a href="#百分比（-）" class="headerlink" title="百分比（%）"></a>百分比（%）</h4><p>在CSS中，支持百分比作为单位的属性很多，大致可以分为3类。</p><ul><li>width，height，font-size的百分比是相对于<strong>父元素“相同属性”的值</strong>来计算的、</li><li>line-height的百分比是相对于<strong>当前元素</strong>的font-size值来计算的。</li><li>vertical-align的百分比是相对于<strong>当前元素</strong>的line-height值决定的。</li></ul><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>在CSS中，em是相对于“<strong>当前元素</strong>”的字体大小而言的。其中，1em就等于“当前元素”字体大小。这里的字体大小指的是以px为单位的font-size值。</p><blockquote><p>注意：如果当前元素的font-size没有定义，则当前元素会继承父元素的font-size。如果当前元素的所有祖先元素都没有定义font-size，则当前元素会继承浏览器默认的font-size。其中，所有浏览器默认的font-size的值都是16px。</p><p>为了简化font-size的计算，我们在CSS中提前声明body{font-size:62.5%;}。通过这个声明，我们可以使默认字体大小变为16px×62.5%&#x3D;10px，此时1em&#x3D;10px。</p></blockquote><p>在CSS中，使用em作为单位有以下3个小技巧：</p><ol><li>首行缩进使用text-indent:2em来实现。</li><li>使用em作为统一单位：在实际开发中，对于em我们一般需要计算两次——第一次，当前元素font-size属性的px值；第二次，当前元素其他属性（如width、height等）的px值，因为如果当前元素其他属性要以em为单位，就得以当前元素的font-size值再计算一次。</li><li>使用em作为字体大小单位：如果想控制一个页面的字体大小，最佳选择是使用em作为单位，当需要改变页面整体的文字大小时，我们只需要改变根元素字体大小即可。这个特点在跨平台网站开发中有着明显的优势。</li></ol><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem，是指相对于<strong>根元素</strong>（即html元素）的字体大小。rem是CSS3新引入的单位，目前的主流浏览器，除了IE8外，大部分是支持rem的。rem布局是移动端最常见的布局方式之一。</p><p>rem和em很相似，不过也有明显区别：<u>em是相对“当前元素”的字体大小，而rem是相对“根元素”的字体大小。</u></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶——CSS特性与优先级</title>
      <link href="/2023/03/14/css-jin-jie-css-te-xing-yu-you-xian-ji/"/>
      <url>/2023/03/14/css-jin-jie-css-te-xing-yu-you-xian-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS特性"><a href="#CSS特性" class="headerlink" title="CSS特性"></a>CSS特性</h2><p>CSS具有两大特性：继承性和层叠性。</p><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>CSS的继承性，是指子元素继承了父元素的某些样式特性。但不是所有属性都具有继承性。</p><p>在CSS中，具有继承性的属性有3类：</p><ul><li><strong>文本相关属性</strong>：font-family、font-size、font-style、font-weight、font、line-height、text-align、text-indent、word-spacing。</li><li><strong>列表相关属性</strong>：list-style-image、list-style-position、list-style-type、list-style。</li><li><strong>颜色相关属性</strong>：color</li></ul><blockquote><p>注意：<strong>a元素本身有默认的颜色样式，优先级要比继承的颜色高。</strong>如果要想改变a元素的颜色，必须选中a元素进行操作才行。当然，如果想要a元素也能继承父元素颜色的话，可以在a元素中使用“color:inherit;”来实现。</p></blockquote><p>CSS的继承性，可以让我们少写很多代码，只要在父元素中定义了属性，就不需要在子元素中重复定义了，这样让CSS代码显得更加精简优雅，提高可读性和可维护性。</p><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>如果在网页中，对于同一个元素，我们重复定义了多个相同的属性时，CSS应该如何处理？</p><p>CSS的层叠性，指的就是样式的覆盖。对于同一个元素来说，如果我们重复定义多个相同的属性，并且这些样式具有相同的权重，CSS会以最后定义的属性值为准，也就是遵循“<strong>后来者居上</strong>”原则。</p><p>“后来者居上”原则必须符合以下3个条件才生效：</p><ol><li><strong>元素相同</strong></li><li><strong>属性相同</strong></li><li><strong>权重相同</strong></li></ol><h2 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h2><p>CSS全称层叠样式表。很多人只知道CSS是用来控制样式的，并没有深入理解“层叠”这两个字的含义。</p><p>“层叠”，其实指的是样式的覆盖。当样式的覆盖发生冲突时，以优先级高的为准。当“同一个元素”的“同一个样式属性”被运用上多个属性值时，我们就需要遵循一定的优先级规则来选择一个属性值了。</p><p>对于样式覆盖发生的冲突，常见的共有以下5种情况：</p><ol><li>引用方式冲突</li><li>继承方式冲突</li><li>指定样式冲突</li><li>继承样式和指定样式冲突</li><li>!important</li></ol><h3 id="引用方式冲突"><a href="#引用方式冲突" class="headerlink" title="引用方式冲突"></a>引用方式冲突</h3><p>CSS有3种常用的引用方式：外部样式、内部样式和行内样式。</p><p>这3种引入方式的优先级如下：</p><p><strong>行内样式＞（内部样式&#x3D;外部样式）</strong></p><p>行内样式的优先级最高，内部样式与外部样式优先级相同。如果内部样式与外部样式同时存在，则以最后引用的样式为准（“后来者居上”原则。）</p><h3 id="继承方式冲突"><a href="#继承方式冲突" class="headerlink" title="继承方式冲突"></a>继承方式冲突</h3><p>如果是由于继承方式引起的冲突，则“<strong>最近的祖先元素</strong>”获胜。祖先元素，指的是当前元素的父元素等。</p><h3 id="指定样式冲突"><a href="#指定样式冲突" class="headerlink" title="指定样式冲突"></a>指定样式冲突</h3><p>所谓的指定样式，指的是指定“<strong>当前元素</strong>”的样式。当直接指定的样式发生冲突，样式<strong>权重高者</strong>获胜。</p><p>在CSS中，各种选择器的权重如下表所示：</p><table><thead><tr><th>选择器</th><th>权重</th></tr></thead><tbody><tr><td>通配符</td><td>0</td></tr><tr><td>伪元素</td><td>1</td></tr><tr><td>元素选择器</td><td>1</td></tr><tr><td>class选择器</td><td>10</td></tr><tr><td>伪类</td><td>10</td></tr><tr><td>属性选择器</td><td>10</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>行内样式</td><td>1000</td></tr></tbody></table><p>常见的伪元素只有4个：::before、::after、::first-letter、::first-line。伪类我们经常见到，如hover、:first-child等。常见的选择器优先级如下。</p><p><strong>行内样式＞id选择器＞class选择器＞元素选择器</strong></p><blockquote><p>注意：在CSS中，选择器的权重计算只针对指定样式（<strong>当前元素</strong>），<strong>并不能用于继承样式</strong>。</p></blockquote><h3 id="继承样式和指定样式冲突"><a href="#继承样式和指定样式冲突" class="headerlink" title="继承样式和指定样式冲突"></a>继承样式和指定样式冲突</h3><p><u>当继承样式和指定样式发生冲突时，指定样式获胜。</u></p><h3 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h3><p>在CSS中，我们可以使用!important规则来改变样式的优先级。如果一个样式使用“!important”来声明，则这个样式会覆盖CSS中<strong>其他的任何样式</strong>声明。</p><p><strong>如果你想要覆盖其他所有样式，可以使用!important来实现。</strong></p><h4 id="important的用法"><a href="#important的用法" class="headerlink" title="!important的用法"></a>!important的用法</h4><p>在CSS中，!important有以下两种常见的使用情况。</p><ol><li><pre><code class="css">#someId p&#123;color:red;&#125;p&#123;color:green;&#125;</code></pre><p>这种情况下，如果不使用!important，则第一条样式永远比第二条样式优先级更高。</p></li><li><p>如果写了一些很差的行内样式，但是又想在内部样式表或外部样式表修改这个样式，这种情况下，就需要在内部样式表或外部样式表中使用!important来覆盖那些行内样式。</p></li></ol><h4 id="如何覆盖-important"><a href="#如何覆盖-important" class="headerlink" title="如何覆盖!important"></a>如何覆盖!important</h4><p>想要覆盖!important声明的样式很简单，共有两种解决方法。</p><ol><li><p>使用相同的选择器，再添加一条!important的CSS语句。</p><p>不过这个CSS语句得放在后面，因为在优先级相同的情况下，后面定义的属性会覆盖前面定义的属性。</p></li><li><p>使用更高优先级的选择器，再添加一条!important的CSS语句。</p></li></ol><p>总而言之，对于CSS优先级的内容，主要掌握以下两条黄金定律即可：</p><blockquote><ol><li><strong>优先级高的样式覆盖优先级低的样式。</strong></li><li><strong>同一优先级的样式，后定义的覆盖先定义的，即“后来则居上”原则。</strong></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动多尺度峰值查找算法</title>
      <link href="/2023/03/07/zi-dong-duo-chi-du-feng-zhi-cha-zhao-suan-fa/"/>
      <url>/2023/03/07/zi-dong-duo-chi-du-feng-zhi-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Automatic-multiscale-based-peak-detection-AMPD"><a href="#Automatic-multiscale-based-peak-detection-AMPD" class="headerlink" title="Automatic multiscale-based peak detection (AMPD)"></a>Automatic multiscale-based peak detection (AMPD)</h1><p>本文算法的原始论文出处：<a href="https://link.zhihu.com/?target=https://www.mdpi.com/1999-4893/5/4/588/htm">Algorithms | Free Full-Text | An Efficient Algorithm for Automatic Peak Detection in Noisy Periodic and Quasi-Periodic Signals | HTML (mdpi.com)</a></p><p>本文代码的原始出处：<a href="https://zhuanlan.zhihu.com/p/549588865">推荐一个非常实用的峰值查找算法（peak detection） - 知乎 (zhihu.com)</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment"># 自动峰检测算法，参考：https://zhuanlan.zhihu.com/p/549588865</span><span class="token keyword">def</span> <span class="token function">AMPD</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    实现AMPD算法    在AMPD算法中，将输入数据平均分成多个长度相等的窗口，并逐个对窗口进行峰值检测。首先选择一个窗口长度k（从1开始逐渐增大）。    然后算法会从第k个数据点开始遍历，对于每个数据点i，都会检查其左侧和右侧距离为k的数据点，如果i点的数值比这两个点都要大，那么就认为i点是一个峰值。如果在一个窗口内有多个峰值，则窗口内的峰值指数之和会越小，因为要同时满足窗口内所有峰值的条件。    这样就可以通过比较不同窗口长度的峰值指数之和，找到一个最合适的窗口大小，并用它来检测所有的波峰。    :param data: 1-D numpy.ndarray    :return: 波峰所在索引值的列表    """</span>        p_data <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>data<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span> <span class="token comment"># 创建一个和data具有相同形状的新数组，初始化全为0，数据类型为int32。这个数组用于在算法中记录每个数据点的峰值指数，即这个数据点处于多少个窗口的峰值位置。</span>    count <span class="token operator">=</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># 获取数据数组的长度。</span>    arr_rowsum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment"># 用于存储每个窗口的峰值指数之和。因为算法会遍历不同长度的窗口，并计算每个窗口内的峰值的数量，最终累加到对应的arr_rowsum列表位置上，通过比较其中所有元素的大小，选择最小那个值对应的窗口长度作为最终判断波峰的阈值。</span>    <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 指定窗口长度的循环范围，从1到数据长度的1/2，使用循环变量k依次代表窗口长度。</span>        row_sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># 当前窗口的峰值指数之和</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> count <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 遍历当前窗口内的所有数据点，判断当前是否为峰值，如果当前点为峰值，则row_sum减去1，表示当前窗口内多了一个峰值。</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span> <span class="token keyword">and</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">:</span>                row_sum <span class="token operator">-=</span> <span class="token number">1</span>        arr_rowsum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>row_sum<span class="token punctuation">)</span> <span class="token comment"># 将当前窗口的峰值指数之和添加到列表arr_rowsum中，以便后续比较窗口质量。</span>    min_index <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>arr_rowsum<span class="token punctuation">)</span> <span class="token comment"># 使用NumPy库的argmin函数找到arr_rowsum中最小值对应的索引，也就是最小的峰值指数之和所对应的窗口长度，赋值给max_window_length</span>    max_window_length <span class="token operator">=</span> min_index    <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> max_window_length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> count <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 再次判断当前点是否为峰值，并将p_data数组中当前点的值加1，表示当前点出现在一个峰值之中，标记了这个峰值的位置。</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span> <span class="token keyword">and</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">:</span>                p_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>p_data <span class="token operator">==</span> max_window_length<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># 返回波峰所在索引值的列表</span>    <span class="token comment"># 注意：第一次对点进行判断，是为了计算当前窗口的峰值个数，用来衡量当前窗口的质量，也就是计算峰值指数之和。第二次对点进行判断，是为了标记每个峰值的位置。</span><span class="token triple-quoted-string string">"""用于模拟生成由3个信号叠加而成，其中包含了频率为100HZ和300HZ的信号以及随机噪声的长度为1000的数组y，来模拟真实环境下信号的特性"""</span><span class="token keyword">def</span> <span class="token function">sim_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    N <span class="token operator">=</span> <span class="token number">1000</span>    x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>    y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi <span class="token operator">*</span> <span class="token number">300</span> <span class="token operator">*</span> x<span class="token punctuation">)</span> \         <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">*</span> x<span class="token punctuation">)</span> \        <span class="token operator">+</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>N<span class="token punctuation">)</span>    <span class="token keyword">return</span> y<span class="token keyword">def</span> <span class="token function">wav_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 数据来源：https://github.com/LXP-Never/blog_data/tree/master/machine_learning_date</span>    <span class="token keyword">import</span> scipy<span class="token punctuation">.</span>io<span class="token punctuation">.</span>wavfile <span class="token keyword">as</span> wf    sample_rate<span class="token punctuation">,</span> noised_sigs <span class="token operator">=</span> wf<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token string">'../实验数据/music.wav'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sample_rate<span class="token punctuation">)</span>  <span class="token comment"># sample_rate：采样率44100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>noised_sigs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># noised_sigs:存储音频中每个采样点的采样位移(220500,)</span>    times <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>noised_sigs<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">/</span> sample_rate <span class="token comment"># 该数组中每个元素表示对应采样点的时刻（单位为秒）。</span>    <span class="token keyword">return</span> noised_sigs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3000</span><span class="token punctuation">]</span> <span class="token comment"># 只返回前3000个采样点的采样位移值，即只返回音频信号的前3000个采样点数据。</span><span class="token keyword">def</span> <span class="token function">vis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    y <span class="token operator">=</span> sim_data<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># y = wav_data()</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>    px <span class="token operator">=</span> AMPD<span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment"># 获取信号中的峰值位置px。</span>    plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>px<span class="token punctuation">,</span> y<span class="token punctuation">[</span>px<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"red"</span><span class="token punctuation">)</span> <span class="token comment"># 在原始信号图像上标注出峰值位置，峰值处的点具有红色。</span>    a <span class="token operator">=</span> plt<span class="token punctuation">.</span>axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">.4</span><span class="token punctuation">,</span> <span class="token number">.2</span><span class="token punctuation">,</span> <span class="token number">.4</span><span class="token punctuation">,</span> <span class="token number">.4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 创建一个新的子图，显示信号的局部细节，并将峰值可视化。</span>    a<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>px<span class="token punctuation">,</span> y<span class="token punctuation">[</span>px<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"red"</span><span class="token punctuation">)</span>    a<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">u"原信号"</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'green'</span><span class="token punctuation">)</span>    a<span class="token punctuation">.</span>set_xlim<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token comment"># 设置x轴的显示范围</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>vis<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以对该代码进一步优化，特别是在窗口长度的循环部分。一种可能的优化方法是使用numpy中的矩阵运算来替代循环操作，以提高计算效率。具体来说，可以使用np.maximum函数来找到每个窗口内的最大值，并将其与当前点的值进行比较，得到一个布尔型矩阵，其中True表示当前点处于峰值位置。然后使用np.sum函数对这个矩阵进行求和，即可得到当前窗口内的峰值数量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_peaks</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>     p_data <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>data<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>     count <span class="token operator">=</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>     arr_rowsum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 使用numpy矩阵运算替代循环操作 </span>        max_data <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         is_peak <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token operator">></span> max_data<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         row_sum <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>is_peak<span class="token punctuation">)</span>         arr_rowsum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>row_sum<span class="token punctuation">)</span>     min_index <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>arr_rowsum<span class="token punctuation">)</span>     max_window_length <span class="token operator">=</span> min_index     <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> max_window_length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 同样使用numpy矩阵运算替代循环操作 </span>        max_data <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         is_peak <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token operator">></span> max_data<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         p_data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>is_peak<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">return</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>p_data <span class="token operator">==</span> max_window_length<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5新增元素</title>
      <link href="/2023/02/27/html5-xin-zeng-yuan-su/"/>
      <url>/2023/02/27/html5-xin-zeng-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h1><h2 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h2><p>HTML5新增的主要结构元素有6个：header、nav、article、aside、section、footer</p><h3 id="header元素"><a href="#header元素" class="headerlink" title="header元素"></a>header元素</h3><p>在HTML5中，header元素一般用于3个地方：页面头部、文章头部和区块元素。</p><ul><li>当header元素用于页面头部时，header元素一般用于包含网站名称、页面LOGO、顶部导航、介绍信息等。</li><li>当header元素用于文章头部时，header元素一般用于包含文章标题、meta信息。meta信息一般指作者、点赞数、评论数等。</li><li>当header元素用于区块头部时，header元素一般用于只包含区块的标题内容。</li></ul><h3 id="nav元素"><a href="#nav元素" class="headerlink" title="nav元素"></a>nav元素</h3><p>在HTML5中，nav元素一般用于3个地方：<strong>顶部导航</strong>、<strong>侧栏导航</strong>和<strong>分页导航</strong>。</p><p>当用于顶部导航时，nav元素可以放到header元素内部，也可以放到header元素外部。具体放在里面还是外面，取决于实际开发需求。</p><h3 id="article元素"><a href="#article元素" class="headerlink" title="article元素"></a>article元素</h3><p>在HTML5中，article元素一般只会用于一个地方：<strong>文章内容部分</strong>。</p><p>可以把article看成一个独立的部分，它内部可以包含标题以及其他部分。</p><blockquote><p>注意：在严格意义上，每一个article元素内部都应该有一个header元素。</p></blockquote><h3 id="aside元素"><a href="#aside元素" class="headerlink" title="aside元素"></a>aside元素</h3><p>在HTML5中，aside元素一般用于表示跟周围区域相关的内容。</p><h3 id="section元素"><a href="#section元素" class="headerlink" title="section元素"></a>section元素</h3><p>在HTML5中，section元素一般用于<strong>某一个需要标题内容的区块</strong>。</p><p>如果页面某个区块不需要标题，直接使用div元素即可，否则建议使用section元素。</p><p>在HTML5中，article、aside元素是比section元素更具语义化的元素，可以看成是特殊的seciton元素。</p><h3 id="footer元素"><a href="#footer元素" class="headerlink" title="footer元素"></a>footer元素</h3><p>在HTML5中，footer元素一般用于两个地方：一个是“<strong>页面底部</strong>”，另一个是“<strong>文章底部</strong>”。</p><p>当用于页面底部时，footer元素一般包含友情链接、版权声明、备案信息等。</p><p>当用于文章底部时，也就是放在article元素内部时，footer元素一般包含“上一篇&#x2F;下一篇导航”“文章分类”“发布信息”等。</p><h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><p>HTML5在HTML4.01的基础上，对表单进行了以下两个方向的扩展。</p><ul><li>新增input元素类型</li><li>新增其他表单元素</li></ul><h3 id="新增input元素类型"><a href="#新增input元素类型" class="headerlink" title="新增input元素类型"></a>新增input元素类型</h3><p>在HTML5中，大量地增加了input元素的种类——input元素的type属性新增了大量属性值：</p><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">email</td><td align="center">邮件类型</td></tr><tr><td align="center">tel</td><td align="center">电话号码</td></tr><tr><td align="center">url</td><td align="center">URL类型</td></tr></tbody></table><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">range</td><td align="center">取数字（滑块方式）</td></tr><tr><td align="center">number</td><td align="center">取数字（微调方式）</td></tr><tr><td align="center">color</td><td align="center">取颜色</td></tr></tbody></table><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">取日期（如2018-11-11）</td></tr><tr><td align="center">time</td><td align="center">取时间（如08:04)</td></tr><tr><td align="center">month</td><td align="center">取月份</td></tr><tr><td align="center">week</td><td align="center">取周数</td></tr></tbody></table><h4 id="验证型"><a href="#验证型" class="headerlink" title="验证型"></a>验证型</h4><h5 id="email"><a href="#email" class="headerlink" title="email"></a>email</h5><blockquote><p>注意：<strong>必须是submit按钮才会进行email验证，使用其他按钮（如button按钮）则不会。</strong>这是因为email类型的文本框采用了浏览器内置的验证机制，而浏览器内置的验证机制必须使用submit按钮才会触发。</p></blockquote><h5 id="tel"><a href="#tel" class="headerlink" title="tel"></a>tel</h5><blockquote><p>注意：tel类型文本框并不具备完整的验证功能，如果想要验证效果，则需要结合pattern属性来实现。</p></blockquote><h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><blockquote><p>注意：url类型文本框并不具备完整的验证功能，如果想要验证效果，则需要结合pattern属性来实现。</p></blockquote><h4 id="取值型"><a href="#取值型" class="headerlink" title="取值型"></a>取值型</h4><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><p>设置不同的value值，滑块也会出现在对应数值的位置。</p><h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>number类型和range类型功能非常相似，都是获取一个范围内的数字。不过两者的外观不同，其中number类型使用的是“微调按钮”，而range类型使用的是“滑块”。</p><h5 id="color"><a href="#color" class="headerlink" title="color"></a>color</h5><p>可通过直接使用浏览器自带的取色工具来获取颜色值。color类型元素不仅可以选择颜色，还可以将常用的颜色值添加到自定义颜色栏中，以便再次使用，非常方便。</p><h5 id="date"><a href="#date" class="headerlink" title="date"></a>date</h5><p>当我们点击date类型元素时，浏览器会弹出自带的日历工具，以方便直接选取日期。value属性用于设置日期初始值，格式必须如“2018-05-20”。</p><h5 id="time"><a href="#time" class="headerlink" title="time"></a>time</h5><p>可通过直接使用浏览器自带的工具来获取时间（时、分）。</p><h5 id="month"><a href="#month" class="headerlink" title="month"></a>month</h5><p>可通过直接使用浏览器自带的工具来获取“月数”。value属性用于设置月份初始值，格式必须如“2018-08”。</p><h5 id="week"><a href="#week" class="headerlink" title="week"></a>week</h5><p>可通过直接使用浏览器自带的工具来获取“周数”。value属性用于设置初始值，格式必须如“2018-W08”。其中W是week的缩写。</p><h3 id="新增其他表单元素"><a href="#新增其他表单元素" class="headerlink" title="新增其他表单元素"></a>新增其他表单元素</h3><p>HTML5还新增了3个表单元素：output、datalist、keygen。</p><h4 id="output元素"><a href="#output元素" class="headerlink" title="output元素"></a>output元素</h4><p>在HTML5中，可以使用output元素来定义表单元素的输出结果或计算结果。</p><p>output是一个<strong>行内元素</strong>，只不过它比span更具有语义化。<u>output元素一般放在form元素内部，并且配合其他表单元素来使用。</u></p><h4 id="datalist元素"><a href="#datalist元素" class="headerlink" title="datalist元素"></a>datalist元素</h4><p>在HTML5中，可以使用datalist元素来为文本框提供一个可选的列表。</p><p><u>如果想要把datalist绑定某个文本框，需要设置该文本框的list属性值等于datalist的id值。</u></p><h4 id="keygen元素"><a href="#keygen元素" class="headerlink" title="keygen元素"></a>keygen元素</h4><p>在HTML5中，可以使用keygen元素来生成页面的密钥。它在各大浏览器中的兼容性很差，仅作了解。</p><h2 id="其他新增元素"><a href="#其他新增元素" class="headerlink" title="其他新增元素"></a>其他新增元素</h2><p>HTML5还增加了大量语义化元素，其中最重要的有以下6个：</p><ul><li>address</li><li>time</li><li>progress</li><li>meter</li><li>figure和figcaption</li><li>fieldset和legend</li></ul><h3 id="address元素"><a href="#address元素" class="headerlink" title="address元素"></a>address元素</h3><p>在HTML5中，可以使用更具语义化的address元素来为“整个页面”或者“某一个article元素”添加地址信息（电子邮件或真实地址）。</p><h3 id="time元素"><a href="#time元素" class="headerlink" title="time元素"></a>time元素</h3><p>在HTML5中，可以使用更具语义化的time元素来显示页面中的日期时间信息。</p><p>其中datetime属性取值是一个时间，可以省略不写。datetime属性中的时间是提供给搜索引擎看的，而time标签内的时间是提供给用户看的，两者内容可以一样也可以不一样。time元素与datetime属性的关系，有点类似于img元素与alt元素的关系。</p><h3 id="progress元素"><a href="#progress元素" class="headerlink" title="progress元素"></a>progress元素</h3><p>在HTML5中，可以使用progress元素以进度条的形式来显示某一个任务的完成度。</p><p>对于progress元素来说，<strong>它只有max值而没有min值</strong>：任何进度条的最小值都是0，因此progress元素默认最小值也是0。此外，max和value必须是0或正数，并且max值必须大于等于value值。</p><h3 id="meter元素"><a href="#meter元素" class="headerlink" title="meter元素"></a>meter元素</h3><p>在HTML5中，可以使用进度条的形式来显示数据所占的比例。</p><p>meter元素和progress元素非常相似，都是以进度条形式来显示数据比例。不过，两者在语义上有很大的区别：</p><ul><li>meter元素一般用于显示<strong>静态数据</strong>比例。所谓的静态数据，指的是很少改变的数据。</li><li>progress元素一般用于显示<strong>动态数据</strong>比例。所谓的动态数据，指的是会不断改变的数据。</li></ul><h3 id="figure和figcaption元素"><a href="#figure和figcaption元素" class="headerlink" title="figure和figcaption元素"></a>figure和figcaption元素</h3><p><u>figure元素用于包含图片和图注，figcaption元素用于表示图注文字。</u>在实际开发中，对于“图片+图注”效果，我们都建议使用figure和figcation这两个元素来实现，从而使得页面的语义更加良好。</p><h3 id="fieldset和legend元素"><a href="#fieldset和legend元素" class="headerlink" title="fieldset和legend元素"></a>fieldset和legend元素</h3><p>在HTML5中，可以使用fieldset元素来给表单元素进行分组。其中，legend元素用于定义某一组表单的标题。</p><p>他们的作用一是可以增强表单的语义，二是可以定义field元素的disabled属性来禁用整个组中的表单元素。</p><h2 id="改良后的元素"><a href="#改良后的元素" class="headerlink" title="改良后的元素"></a>改良后的元素</h2><h3 id="a元素"><a href="#a元素" class="headerlink" title="a元素"></a>a元素</h3><p>HTML5为a元素新增了3个属性：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>download</td><td>定义可被下载的目标（如文件、图片等）</td></tr><tr><td>media</td><td>定义被链接文档为何种媒介&#x2F;设备优化的</td></tr><tr><td>type</td><td>定义被链接文档的MIME类型</td></tr></tbody></table><p>其中download属性用于为文件取一个新的文件名。如果download属性值省略，则表示使用旧的文件名。</p><h3 id="ol元素"><a href="#ol元素" class="headerlink" title="ol元素"></a>ol元素</h3><p>HTML5为ol元素新增了一个reversed属性，用于设置列表顺序为降序显示。</p><h3 id="small元素"><a href="#small元素" class="headerlink" title="small元素"></a>small元素</h3><p>在HTML5中，我们可以使用更具语义化的small元素来表示“小字印刷体”的文字。small元素一般用于网站底部的免责声明、版权声明等。</p><h3 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h3><p>HTML5为script元素新增了两个属性：defer和async。这两个属性的作用都是加快页面的加载速度，两者区别如下：</p><ul><li>defer属性用于异步加载外部JavaScript文件，当异步加载完成后，<strong>该外部JavaScript文件不会立即执行，而是等到整个HTML文档加载完成才会执行。</strong></li><li>async属性用于异步加载外部JavaScript文件，当异步加载完成后，<strong>该外部JavaScript文件会立即执行，即使整个HTML文档还没有加载完成。</strong></li></ul><p>defer和async都是异步加载的，两者区别在于，异步加载外部JavaScript文件完成后何时执行。从上面也可以看出，defer属性更符合大多数开发场景对脚本加载执行的要求。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式总结</title>
      <link href="/2023/01/09/zheng-ze-biao-da-shi-zong-jie/"/>
      <url>/2023/01/09/zheng-ze-biao-da-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式总结"><a href="#正则表达式总结" class="headerlink" title="正则表达式总结"></a>正则表达式总结</h1><h2 id="正则表达式入门"><a href="#正则表达式入门" class="headerlink" title="正则表达式入门"></a>正则表达式入门</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li>搜索文件中包含的字符</li><li>在Web网页中生成一些合法的HTML代码</li><li>检查电子邮件是否符合正确的语法格式</li><li>替换代码中的字符</li><li>定向检索包含某字符的文件</li><li>将数据批量导入应用程序</li><li>搜索文件中特定文本的位置</li></ol><p>根本上来说，正则表达式的两种基本用途：<strong>搜索</strong>和<strong>替换</strong></p><h3 id="正则表达式概念"><a href="#正则表达式概念" class="headerlink" title="正则表达式概念"></a>正则表达式概念</h3><p>正则表达式是一些用来匹配和处理文本的字符串，这种语言的用途就是为了解决我们前面所描述的种种问题。</p><h3 id="JavaScript中的正则表达式"><a href="#JavaScript中的正则表达式" class="headerlink" title="JavaScript中的正则表达式"></a>JavaScript中的正则表达式</h3><p>JavaScript 1.x版本在String和RegEx对象的以下几个方法里实现了正则表达式处理。</p><ul><li>exec：一个用来搜索一个匹配的RegEx方法</li><li>match：一个用来匹配一个字符串的String方法</li><li>replace：一个用来完成替换操作的String方法</li><li>search：一个用来测试在某给定字符串里是否存在着一个匹配String方法</li><li>split：一个用来把一个字符串拆分为多个子串的String方法</li><li>test：一个用来测试在某给定字符串里是否存在着一个匹配的RegEx方法</li></ul><p>注意：</p><ul><li>JavaScript使用命令行选项来管理全局的区分大小写搜索：g选项激活全局搜索功能，i选项让匹配操作不区分字母的大小写，这两个选项可以组合为gi。</li><li>其他命令行选项包括：m，支持多行字符串；s，支持单行字符串；x，忽略正则表达式模式里的空白字符。</li><li>在使用回溯引用的时候，$’将返回被匹配字符串前面的所有东西，$&#96;将返回被匹配字符串后面的所有东西，$+将返回最后一个被匹配的子表达式，$&amp;将返回被匹配到的所有东西。</li><li>JavaScript提供了一个名为RegExp的全局对象，在执行完一个正则表达式之后，你们可以通过这个对象获得与这次执行有关的信息。</li><li>JavaScript不支持POSIX字符类。</li><li>JavaScript不支持\A和\Z。</li></ul><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><h3 id="匹配纯文本"><a href="#匹配纯文本" class="headerlink" title="匹配纯文本"></a>匹配纯文本</h3><p>正则表达式可以包含<strong>纯文本</strong>（甚至可以只包含纯文本），所以看起来可能不像是一个正则表达式。当然，像这样使用正则表达式是一种浪费。</p><h3 id="多个匹配结果"><a href="#多个匹配结果" class="headerlink" title="多个匹配结果"></a>多个匹配结果</h3><p>绝大多数正则表达式引擎的<strong>默认行为是只返回第1个匹配结果</strong>。</p><blockquote><p>在JavaScript中，可选的为g（global，全局）标志将返回一个包含着所有匹配的结果数组。</p></blockquote><h3 id="字母的大小写问题"><a href="#字母的大小写问题" class="headerlink" title="字母的大小写问题"></a>字母的大小写问题</h3><p>正则表达式是<strong>区分字母大小写</strong>的。</p><blockquote><p>在JavaScript中，可以用i标志来强制执行一次不区分字母大小写的搜索。</p></blockquote><h3 id="匹配任意字符"><a href="#匹配任意字符" class="headerlink" title="匹配任意字符"></a>匹配任意字符</h3><p><code>.</code>字符可以匹配任何一个单个的字符（<strong>但在大多数的正则表达式中，<code>.</code>不能匹配换行符</strong>）。在SQL中相当于_字符。</p><h3 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h3><p>如果需要匹配<code>.</code>字符本身而不是它在正则表达式里的特殊含义，必须在<code>.</code>的前面加上一个<code>\</code>（反斜杠）字符来对它进行转义。</p><h2 id="匹配一组字符"><a href="#匹配一组字符" class="headerlink" title="匹配一组字符"></a>匹配一组字符</h2><h3 id="匹配多个字符中的某一个"><a href="#匹配多个字符中的某一个" class="headerlink" title="匹配多个字符中的某一个"></a>匹配多个字符中的某一个</h3><p>可以使用元字符<code>[</code>和<code>]</code>来定义一个字符集合。在字符集合中，这两个元字符之间的所有字符都是该集合的组成部分，字符集合的匹配结果是能够与该集合里的任意一个成员相匹配的文本。</p><p>注意：</p><ol><li><strong>字符集合中的字符涉及位置匹配问题。</strong></li><li>字符集合在<strong>不需要区分字母大小写的搜索操作中较为常见</strong>。最适合用在从全局看需要区分字母大小写，但在某个局部不需要区分字母大小写的搜索操作里。</li></ol><h3 id="利用字符集合区间"><a href="#利用字符集合区间" class="headerlink" title="利用字符集合区间"></a>利用字符集合区间</h3><p>使用正则表达式的时候，会频繁地用到一些字符区间。为了简化字符区间的定义，正则表达式提供了一个特殊的元字符，字符区间可以用<code>-</code>（连字符）来定义：</p><ul><li>A-Z：匹配从A到Z的所有大写字母。</li><li>a-z：匹配从a到Z的所有小写字母。</li><li>A-z：匹配从ASCII字符A到ASCII字符z的所有字母。这个模式一般不常用，因为它还包含着[和^等在ASCII字符表里排列在Z和a之间的字符。</li><li>0-9：数字区间。</li></ul><p>注意：</p><ol><li>在定义一个字符区间的时候，<strong>一定要避免让这个区间的尾字符小于它的首字符。</strong></li><li><code>-</code>是一个特殊的元字符，作为元字符它只能用在<code>[</code>和<code>]</code>之间。在字符集合以外的地方，<code>-</code>只是一个普通字符，只能与-本身相匹配，因此在正则表达式里，<code>-</code>字符不需要被转义。</li><li>在同一个字符集合里可以给出多个字符区间。</li></ol><h3 id="取非匹配"><a href="#取非匹配" class="headerlink" title="取非匹配"></a>取非匹配</h3><p>在某些场合，我们需要反过来做，给出一组不需要得到的字符。换句话说，除了那个字符集合中的字符，其他字符都可以匹配。</p><p>用元字符<code>^</code>来表明你想对一个字符集合进行<strong>取非匹配</strong>，和逻辑非运算很相似。</p><p>注意：</p><blockquote><p><strong><code>^</code>的效果将作用于给定字符集合里的所有字符或字符区间，而不是仅限于紧跟在<code>^</code>字符后面的那一个字符或字符区间。</strong></p></blockquote><h2 id="使用元字符"><a href="#使用元字符" class="headerlink" title="使用元字符"></a>使用元字符</h2><h3 id="对特殊字符进行转义"><a href="#对特殊字符进行转义" class="headerlink" title="对特殊字符进行转义"></a>对特殊字符进行转义</h3><p>任何一个元字符都可以通过给它加上一个反斜杠字符<code>\</code>作为前缀的办法来<strong>转义</strong>。</p><h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>空白元字符：</p><ul><li>[\b]：回退（并删除）一个字符</li><li>\f：换页符</li><li>\n：换行符</li><li>\r：回车符</li><li>\t：制表符</li><li>\v：垂直制表符</li></ul><h2 id="匹配特定的字符类别"><a href="#匹配特定的字符类别" class="headerlink" title="匹配特定的字符类别"></a>匹配特定的字符类别</h2><h3 id="匹配数字（与非数字）"><a href="#匹配数字（与非数字）" class="headerlink" title="匹配数字（与非数字）"></a>匹配数字（与非数字）</h3><ul><li>\d：任何一个数字字符</li><li>\D：任何一个非数字字符</li></ul><h3 id="匹配字母和数字（与非字母和数字）"><a href="#匹配字母和数字（与非字母和数字）" class="headerlink" title="匹配字母和数字（与非字母和数字）"></a>匹配字母和数字（与非字母和数字）</h3><ul><li>\w：任何一个字母数字字符（大小写均可）或下划线字符</li><li>\W：任何一个非字母数字或非下划线字符</li></ul><h3 id="匹配空白字符（与非空白字符）"><a href="#匹配空白字符（与非空白字符）" class="headerlink" title="匹配空白字符（与非空白字符）"></a>匹配空白字符（与非空白字符）</h3><ul><li>\s：任何一个空白字符（除了\b字符）</li><li>\S：任何一个非空白字符（除了\b字符）</li></ul><h3 id="匹配十六进制或八进制数值"><a href="#匹配十六进制或八进制数值" class="headerlink" title="匹配十六进制或八进制数值"></a>匹配十六进制或八进制数值</h3><p>使用十六进制：前缀\x来给出</p><p>使用八进制：前缀\0来给出</p><h2 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h2><h3 id="匹配一个或多个字符"><a href="#匹配一个或多个字符" class="headerlink" title="匹配一个或多个字符"></a>匹配一个或多个字符</h3><p>要想匹配<strong>同一个字符（或字符集合）的多次重复</strong>，只要简单地给这个字符（或字符集合）加上一个<code>+</code>元字符作为后缀即可。</p><blockquote><p>注意：要给一个字符集合加上<code>+</code>后缀时，<strong>必须把<code>+</code>放在这个字符集合的外面</strong>。</p></blockquote><h3 id="匹配零个或多个字符"><a href="#匹配零个或多个字符" class="headerlink" title="匹配零个或多个字符"></a>匹配零个或多个字符</h3><p>想要匹配一个可有可无的字符，需要使用<code>*</code>元字符来完成，用法和<code>+</code>完全一样，<strong>但可以匹配该字符（或字符集合）连续出现零次或多次的情况。</strong></p><h3 id="匹配零个或一个字符"><a href="#匹配零个或一个字符" class="headerlink" title="匹配零个或一个字符"></a>匹配零个或一个字符</h3><p><code>?</code>只能匹配一个字符（或字符集合）的<strong>零次或一次出现，最多不超过一次</strong>。</p><h3 id="匹配的重复次数"><a href="#匹配的重复次数" class="headerlink" title="匹配的重复次数"></a>匹配的重复次数</h3><p>正则表达式里的<code>+</code>、<code>*</code>和<code>?</code>解决了许多问题，但有些问题光靠它们还不够：</p><ul><li><code>+</code>和<code>*</code>匹配的字符个数<strong>没有上限</strong>。我们无法为它们将匹配的字符个数设定一个最大值。</li><li><code>+</code>、<code>*</code>和<code>?</code>至少匹配零个或一个字符。我们无法为它们将匹配的字符个数另行设定一个最小值。</li><li>如果只使用<code>+</code>和<code>*</code>，我们无法把它们将匹配的字符个数设定为一个精确的数字。</li></ul><p>正则表达式提供了一个用来设定重复次数的语法。重复次数要用<code>&#123;</code>和<code>&#125;</code>字符来给出，<strong>把数值写在它们之间</strong>。</p><h3 id="为重复匹配次数设定一个区间"><a href="#为重复匹配次数设定一个区间" class="headerlink" title="为重复匹配次数设定一个区间"></a>为重复匹配次数设定一个区间</h3><p> <code>&#123;</code> <code>&#125;</code>语法还可以用来为重复匹配次数设定一个区间，也就是为重复匹配次数设定一个最小值和一个最大值。例如区间{2,4}的含义是最少重复2次，最多重复4次。</p><h3 id="匹配“至少重复多少次”"><a href="#匹配“至少重复多少次”" class="headerlink" title="匹配“至少重复多少次”"></a>匹配“至少重复多少次”</h3><p> <code>&#123;</code> <code>&#125;</code>语法的最后一种用法是给出一个最小的重复次数（但不必给出一个最大值）。<code>&#123;</code> <code>&#125;</code>的这种用法与我们用来为重复匹配次数设定一个区间的 <code>&#123;</code> <code>&#125;</code>语法很相似，只是省略了最大值部分而已。</p><h3 id="防止过度匹配"><a href="#防止过度匹配" class="headerlink" title="防止过度匹配"></a>防止过度匹配</h3><p><code>*</code>和<code>+</code>元字符在重复匹配次数方面都没有上限值，而这样做<strong>有时会导致过度匹配</strong>的现象。</p><p>因为<code>*</code>和<code>+</code>都是所谓的“贪婪型”元字符，它们在进行匹配时的行为模式是多多益善而不是适可而止的，<strong>它们会尽可能地从一段文本的开头一直匹配到这段文本的末尾，而不是从这段文本的开头匹配到碰到第一个匹配时为止。</strong></p><p>使用“懒惰型”版本可以避免这个问题，写法很简单，只要给贪婪型元字符加上一个<code>?</code>后缀即可。</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><p>在某些场合，只需要对某段文本的<strong>特定位置</strong>进行匹配，这就引出了位置匹配的概念。</p><h3 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h3><p>使用边界限定符，也就是在正则表达式里用一些特殊的元字符来表明我们想让匹配操作在什么位置（或边界）发生。</p><p>第一种边界：由限定符<code>\b</code>指定的单词边界，<code>\b</code>用来匹配一个单词的开始或结尾。</p><p>注意：</p><ul><li>如果你想匹配一个<strong>完整的单独的单词</strong>，就必须在你想要匹配的文本的<strong>前后</strong>都加上<code>\b</code>限定符。</li><li>\b匹配且只匹配一个位置，不匹配任何字符。</li></ul><p>如果你想表明不匹配一个单词边界，请使用<code>\B</code>（例如查找前后都有多余空格的连字符）。</p><h3 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h3><p>用来定义字符串边界的元字符有两个：<strong>一个是用来定义字符串开头的<code>^</code>，另一个是用来定义字符串结尾的<code>$</code>。</strong></p><p>注意：^是几个有着多种用途的元字符之一。</p><ul><li>只有当它<strong>出现在一个字符集合里并紧跟在左方括号[的后面时，它才能发挥求非的作用</strong>。</li><li>如果是在<strong>一个字符集合的外面并位于一个模式的开头，<code>^</code>将匹配字符串的开头</strong>。</li></ul><h3 id="分行匹配模式"><a href="#分行匹配模式" class="headerlink" title="分行匹配模式"></a>分行匹配模式</h3><p>用来启用分行匹配模式的<code>(?m)</code>记号就是一个能够改变其他元字符行为的元字符序列（<strong>必须出现在整个模式的最前面</strong>）。</p><p>分行匹配模式将使得正则表达式引擎把<strong>行分隔符当作一个字符串分隔符来对待</strong>，在分行匹配模式下，^不仅匹配正常的字符串开头，还将匹配行分隔符（换行符）后面的开始位置（这个位置是不可见的）；类似地，$不仅匹配正常的字符串结尾，还讲匹配行分隔符（换行符）后面的结束位置。</p><p>警告：有许多正则表达式实现不支持<code>(?m)</code>。</p><h2 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h2><p>子表达式是一个更大的表达式的一部分：把一个表达式划分为一系列子表达式的<strong>目的是为了把那些子表达式当作一个独立元素来使用。</strong></p><p>子表达式必须用<code>(</code>和<code>)</code>括起来。</p><h3 id="子表达式的嵌套"><a href="#子表达式的嵌套" class="headerlink" title="子表达式的嵌套"></a>子表达式的嵌套</h3><p>子表达式允许多重嵌套，这种嵌套的层次在理论上没有限制，但在实际工作中还是应该遵循适可而止的原则。</p><h2 id="回溯引用：前后一致匹配"><a href="#回溯引用：前后一致匹配" class="headerlink" title="回溯引用：前后一致匹配"></a>回溯引用：前后一致匹配</h2><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p><strong>某个模式的第二部分对这个模式的第一部分毫无所知</strong>，即使匹配到也有可能是不合法的编程语言写法，所以需要借助回溯引用。</p><h3 id="回溯引用匹配"><a href="#回溯引用匹配" class="headerlink" title="回溯引用匹配"></a>回溯引用匹配</h3><p>回溯引用指的是<strong>模式的后半部分引用在前半部分中定义的子表达式</strong>。——可以将回溯引用想象成<strong>变量</strong>。</p><p>注意：</p><ol><li>回溯引用只能用来引用模式里的<strong>子表达式</strong>。</li><li>回溯引用匹配通常从1开始计数（\1、\2等）。在许多现实里，第0个匹配（\0）可以用来代表整个正则表达式。</li><li>子表达式是通过它们的相对位置来引用的。虽然收到普遍的支持，但这种语法存在着一个严重的不足：如果子表达式的想对位置发生了变化，整个模式也许就不能再完成原来的工作，删除或添加子表达式的后果可能更为严重。<ul><li>为了弥补这一不足，一些比较新的正则表达式实现还支持“命名捕获”：给某个子表达式起一个唯一的名字，然后用这个名字（而不是相对位置）来引用这个子表达式，但还没有得到广泛支持，而且已支持的实现具体的语法也极不统一。</li></ul></li></ol><h3 id="回溯引用在替换操作中的应用"><a href="#回溯引用在替换操作中的应用" class="headerlink" title="回溯引用在替换操作中的应用"></a>回溯引用在替换操作中的应用</h3><p>同一个子表达式可以被引用任意多次，只要在需要用到它的地方写出它的回溯引用就行了。</p><p>在JavaScript中使用<code>$</code>符号引用。</p><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p>有些正则表达式实现允许我们使用元字符对字母进行大小写转换。</p><ul><li>\E：结束\L或\U转换</li><li>\l：把下一个字符转换为小写</li><li>\L：把\L到\E之间的字符全部转换为小写</li><li>\u：把下一个字符转换为大写</li><li>\U：把\U到\E之间的字符全部转换为大写</li></ul><h2 id="前后查找"><a href="#前后查找" class="headerlink" title="前后查找"></a>前后查找</h2><p>前文中正则表达式都是用来匹配文本的，但有时我们还需要使用正则表达式标记我们想要匹配的文本的位置（不仅仅是文本本身）。这就引出了前后查找（对某一位置的前、后内容进行查找）的概念。</p><p> 注意：JavaScript仅支持向前查找。</p><h3 id="向前查找"><a href="#向前查找" class="headerlink" title="向前查找"></a>向前查找</h3><p>向前查找指定了一个<strong>必须匹配但不在结果中返回的模式</strong>。（<strong>它必须用在一个子表达式里</strong>）</p><p>从语法上来看，一个向前查找模式其实就是一个以<code>?=</code>开头的子表达式，需要匹配的文本跟在<code>=</code>的后面。</p><p><strong>在向前查找里，被匹配的文本不包含在最终返回的匹配结果里，这被称为“不消费”。</strong></p><blockquote><p>注意：向前查找模式<code>?=</code>其实和子表达式<code>(</code> <code>)</code>匹配的东西是一样的，<strong>区别在于匹配到的字符是否出现在最终的匹配结果里。</strong></p></blockquote><h3 id="向后查找"><a href="#向后查找" class="headerlink" title="向后查找"></a>向后查找</h3><p>向后查找就是<strong>查找出现在被匹配文本之前的字符（但不消费它）</strong>，向后查找操作符是<code>?&lt;=</code>。</p><p>警告：</p><ul><li><strong>向前查找模式的长度是可变的</strong>，它们可以包含<code>.</code>和<code>+</code>之类的元字符，所以非常灵活。</li><li><strong>向后查找模式只能是固定长度</strong>。</li></ul><h3 id="对前后查找取非"><a href="#对前后查找取非" class="headerlink" title="对前后查找取非"></a>对前后查找取非</h3><p>前后查找还有一种不太常见的用法叫做负前后查找。负向前查找将<strong>向前查找不与给定模式相匹配的文本</strong>，负向后查找<strong>将向后查找不与给定模式相匹配的文本</strong>。</p><p>负前后查找使用<code>!</code>来取非（它将替换掉<code>=</code>）。</p><h2 id="嵌入条件"><a href="#嵌入条件" class="headerlink" title="嵌入条件"></a>嵌入条件</h2><h3 id="正则表达式中的条件"><a href="#正则表达式中的条件" class="headerlink" title="正则表达式中的条件"></a>正则表达式中的条件</h3><p>正则表达式里的条件要用<code>?</code>来定义。嵌入条件分为以下两种情况：</p><ol><li>根据一个回溯引用来进行条件处理。</li><li>根据一个前后查找来进行条件处理。</li></ol><h3 id="回溯引用条件"><a href="#回溯引用条件" class="headerlink" title="回溯引用条件"></a>回溯引用条件</h3><p>回溯引用条件只在一个<strong>前面的子表达式搜索取得成功的情况下才允许使用一个表达式</strong>。</p><p>用来定义这种条件的语法是<code>(?(backreference)true-regex)</code>，其中<code>?</code>表明这是一个条件，括号里的backreference是一个回溯引用，true-regex是一个只在backreference存在时才会被执行的子表达式。</p><p>条件还可以有否则表达式，否则表达式只在给定的回溯引用不存在（也就是条件没有得到满足）时才会被执行。用来定义这种条件的语法是<code>(?(backreference)true-regex | false-regex)</code>，这个语法接受一个条件和两个将分别在这个条件得到满足和没有得到满足时执行的子表达式。</p><h3 id="前后查找条件"><a href="#前后查找条件" class="headerlink" title="前后查找条件"></a>前后查找条件</h3><p>前后查找条件只在一个向前查找或向后查找操作取得成功的情况下才允许一个表达式被使用。定义一个前后查找条件的语法与定义一个回溯引用条件的语法大同小异，只需把回溯引用（括号里的回溯引用编号）替换为一个完整的前后查找表达式就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6标准总结</title>
      <link href="/2023/01/08/es6-biao-zhun-zong-jie/"/>
      <url>/2023/01/08/es6-biao-zhun-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6标准总结"><a href="#ES6标准总结" class="headerlink" title="ES6标准总结"></a>ES6标准总结</h1><h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><ol><li>声明的变量只在let命令所在的代码块内有效。</li><li>声明的变量一定要在声明后使用，否则报错。</li><li>只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部影响（封闭作用域）。</li><li>不允许在相同作用域内重复声明同一个变量。</li><li>为JavaScript新增了块级作用域，防止了内层变量覆盖外层变量或泄露为全局变量。</li><li>在块级作用域之前加上do，使得块级作用域可以变为表达式，得到返回值（本质上块级作用域是一个语句，没有返回值）。</li></ol><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ol><li>声明一个只读的常量。一旦声明，常量的值就不能改变。</li><li>一旦声明常量，就必须立即初始化，不能留到以后赋值。</li><li>只在声明所在的块级作用域内有效。</li><li>声明的变量一定要在声明后使用，否则报错。</li><li>const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。<ul><li>对于简单类型的数据（数值、字符串、布尔值〉而言，值就保存在变量指向的内存地址中，因此等同于常量。</li><li>但对于复合类型的数据（主要是 对象和数组）而言，变量指向的内存地址保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。</li></ul></li></ol><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>在ES5中，顶层变量（在浏览器环境中指的是window对象，在Node环境中指的是global对象）&#x3D;全局变量，有以下缺点：</p><ol><li>无法在编译时就提示变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。</li><li>很容易不知不觉地就创建全局变量。</li><li>顶层对象的属性是到处都可以读写的，这非常不利于模块化编程。</li><li>window对象有实体含义，指的是浏览器的窗口对象，这样也是不合适的。</li></ol><p>从ES6开始，全局变量逐步与顶层对象的属性隔离：</p><ol><li>var命令和function命令声明的全局变量 &#x3D; 顶层对象的属性。</li><li>let命令、const命令、class命令声明的全局变量 ≠ 顶层对象的属性。</li></ol><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>ES6允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构。</p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><ol><li><p>模式匹配——只要等号两边的模式（对应位置）相同，左边的变量就会被赋予对应的值。</p></li><li><p>解构不成功，变量的值等于undefined。</p></li><li><p>不完全解构，即等号左边的模式只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p></li><li><p>如果等号的右边不是数组（严格来说不是可遍历的结构），那么将会报错。</p><p>因为等号右边的值或是转为对象以后不具备Iterator接口，或是本身就不具备Iterator接口。</p></li><li><p>解构赋值允许指定默认值。默认值生效的条件是，数组成员的属性值严格等于undefined。</p><ul><li>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到时才会求值。</li><li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</li></ul></li></ol><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><ol><li>对象的属性没有次序，变量必须与属性同名才能取到正确的值。</li><li>解构赋值允许指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。</li><li>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</li><li>应该将整个解构赋值语句放在一个圆括号里面，否则JavaScript引擎会将句首{}理解成一个代码块，从而发生语法错误。</li><li>解构赋值允许等号左边的模式之中不放置任何变量名。</li><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</li></ol><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><ol><li>字符串被转换了一个类似数组的对象，所以也可以解构赋值。</li><li>类似数组的对象都有一个length属性，因此还可以对这个属性进行解构赋值。</li></ol><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><ol><li>如果等号右边是数值和布尔值，则会先转为对象。</li><li>只要等号右边的值不是对象或数组，就先将其转为对象。</li></ol><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><ol><li>只要有可能导致解构的歧义，就不得使用圆括号。<ul><li>变量声明语句，模式不能使用圆括号。</li><li>函数参数属于变量声明，不能使用圆括号。</li><li>赋值语句的模式不能使用圆括号。</li></ul></li><li>可以使用圆括号的情况只有一种：赋值语句的非模式部分可以使用圆括号。</li></ol><h3 id="解构用途"><a href="#解构用途" class="headerlink" title="解构用途"></a>解构用途</h3><ol><li>交换变量的值</li><li>从函数返回多个值</li><li>设置函数参数</li><li>提取JSON数据</li><li>设置函数参数的默认值</li><li>遍历Map结构</li><li>输入模块的指定方法</li></ol><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h3><ol><li>JavaScript允许采用 \uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。但是，这种表示法只限于码点在 \u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用2个双字节的形式表达。</li><li>ES6允许将码点放入大括号，就能正确解读该字符。</li></ol><h3 id="CodePointAt"><a href="#CodePointAt" class="headerlink" title="CodePointAt()"></a>CodePointAt()</h3><ol><li>JavaScript内部，字符以UTF-16的格式存储，每个字符固定为2个字节。对于那些需要4个字节存储的字符，JavaScript会认为它们是两个字符。</li><li>ES6提供了codePointAt()方法，能够正确处理4个字节存储的字符，返回一个字符的码点（十进制值）。</li><li>该方法定义在字符串的实例对象上。</li></ol><h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><ol><li>可以识别大于 0xFFFF 的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</li><li>该方法定义在String对象上。</li></ol><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><ol><li>ES6为字符串添加了遍历器接口，使得字符串可以由for…of循环遍历。除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</li></ol><h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><ol><li>字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。</li></ol><h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><ol><li>ES6为字符串实例提供了normalize方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</li></ol><h3 id="其余方法"><a href="#其余方法" class="headerlink" title="其余方法"></a>其余方法</h3><ol><li>includes()：返回布尔值，表示是否找到了参数字符串。（使用第二个参数n，针对从第n个位置到字符串结束位置之间的字符）</li><li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。（使用第二个参数n，针对从第n个位置到字符串结束位置之间的字符）</li><li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。（使用第二个参数n，针对前n个字符）</li></ol><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>返回一个新字符串，表示将原字符串重复n次。</p><ol><li>参数如果是小数，会被取整。</li><li>参数如果是负数或者Infinity，会报错。</li><li>参数如果是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。</li><li>参数如果是NaN等同于0。</li><li>参数如果是字符串，则会先转换成数字。</li></ol><h3 id="padStart-、padEnd"><a href="#padStart-、padEnd" class="headerlink" title="padStart()、padEnd()"></a>padStart()、padEnd()</h3><p>如果某个字符串不够指定长度，会在头部或者尾部补全。</p><p>padStart()用于头部补全，padEnd()用于尾部补全。</p><ol><li>第一个参数：指定字符串的最小长度</li><li>第二个参数：用来补全的字符串</li><li>如果原字符串的长度等于或大于指定的最小长度，则返回原字符串。</li><li>如果用来补全的宇符串与原字符串的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</li><li>如果省略第二个参数，则会用空格来补全。</li><li>可用来提示字符串格式。</li></ol><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>增强版的字符串，用反引号（&#96;）标识。</p><ol><li>可以当作普通字符串使用</li><li>可以用来定义多行字符串</li><li>字符串中嵌入变量</li><li>如果在模板字符串中需要使用反引号，则在其前面要用反斜杠转义。</li><li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出中。</li><li>大括号内可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</li><li>如果大括号中的值不是字符串，将按照一般的规则转换为字符串（例如对象）。</li><li>模板字符串中还能调用函数。</li><li>如果模板字符串中的变量没有声明，将报错。</li></ol><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</p><h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h3><p>该方法往往用来充当模板字符串的处理函数，返回一个反斜线都被转义（即反斜线前面再加一个反斜线）的字符串，对应于替换变量后的模板字符串。</p><ol><li>如果原字符串中的反斜线已经被转义，那么String.raw不会做任何处理。</li><li>该方法也可以作为正常的函数使用，其第一个参数应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</li></ol><h3 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h3><p>标签模板中可以内嵌其他语言，但是模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p><ol><li>有一个解决方法是放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，且从raw属性上可以得到原始字符串（只在标签模板解析字符串时生效，非标签模板场合依然会报错。）。</li></ol><h2 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h2><h3 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h3><p>在ES5中，RegExp构造函数的参数有两种情况：</p><ol><li>第一种情况：参数是字符串，这时第二个参数表示正则表达式的修饰符。</li><li>第二种情况：参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝。但是，此时ES5不允许使用第二个参数添加修饰符，否则会报错。</li></ol><p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有正则表达式的修饰符，只使用新指定的修饰符。</p><h3 id="U修饰符"><a href="#U修饰符" class="headerlink" title="U修饰符"></a>U修饰符</h3><p>ES6对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，可以正确处理4个字节的UTF-16编码。</p><h4 id="点字符"><a href="#点字符" class="headerlink" title="点字符"></a>点字符</h4><p><code>.</code>字符在正则表达式中的含义是除换行符以外的任意单个字符，对于码点大于0xFFFF的Unicode字符，<code>.</code>字符不能识别，必须加上u修饰符。</p><p>后面的以后再写，懒得写了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6标准入门</title>
      <link href="/2022/11/08/es6-biao-zhun-ru-men/"/>
      <url>/2022/11/08/es6-biao-zhun-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>为什么选择ES6的Promise？——Promise能比较好地解决<strong>异步嵌套</strong>问题，ES6代表前端的未来，涉及很多现代编程语言概念中很流行的部分，让前端程序员的代码更加优美并且能够向前兼容。</p></blockquote><h3 id="ES6和JS的关系"><a href="#ES6和JS的关系" class="headerlink" title="ES6和JS的关系"></a>ES6和JS的关系</h3><blockquote><p>ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的 一 种实现。</p></blockquote><h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6中的let命令用法类似于var，但是<strong>所声明的变量只在let命令所在的代码块内生效</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a <span class="token comment">// ReferenceError: a is not defined.</span>b <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>for循环的计数器就很适合使用let命令：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 如果此处使用var变量，则a[6]为10</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因如下：</p><ul><li><p>如果变量 i 是用var声明的，则该变量在全局范围内都有效，全局只有一个变量 i，每一次循环i的值都会发生变化。也就是说，所有数组 a 的成员中的 i 指向的都是同 一个 i ，导致运行时输出的是最后一轮的 i 值，也就是 10 。</p></li><li><p>如果变量 i 是用let声明的，则当前i只在本轮循环中有效，所以每一次循环 i 都是一个新的变量，所以最终输出6</p><blockquote><p>如果每一轮循环的变量 i 都是重新声明的，那么它怎么知道上一轮的循环的值从而计算出本轮循环的值呢？</p><p>JavaScript引擎内部会<strong>记住</strong>上一次循环的值，初始化本轮的 i 值时，就在上一轮的循环中计算。</p></blockquote></li></ul><p>此外，for循环还有一个特别之处：<strong>设置循环变量的那一部分是一个父作用域，循环内部是一个单独的子作用域</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token string">'abc'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// abc</span><span class="token comment">// abc</span><span class="token comment">// abc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><ul><li>var命令会出现变量提升现象，即变量可以在声明前使用，值为undefined。</li><li><strong>let所声明的变量一定要在声明后使用</strong></li></ul><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><blockquote><p>只要块级作用域存在let命令，它所声明的变量就“<strong>绑定</strong>”这个区域，不受外部影响：</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tmp <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span><span class="token keyword">let</span> tmp<span class="token punctuation">;</span> <span class="token comment">// let的声明导致tmp变量绑定这个作用域</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上称为“<strong>暂时性死区</strong>”（temporal deadzone，简称TDZ）。</p><p>“暂时性死区”也意味着 typeof 不再是一个百分之百的安全操作。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">typeof</span> x<span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span><span class="token keyword">let</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的代码中，变量x使用let命令声明，所以在声明之前都属于x的“死区”，只要用到该变量就会报错。</p><p>几种较为隐蔽的“死区”：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//1.</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">x <span class="token operator">=</span> y<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 之所以调用bar函数报错，是因为参数x的默认值等于另一个参数y，而此时y还没有声明。如果y的默认值是x，就不会报错。</span><span class="token punctuation">&#125;</span><span class="token comment">//2.</span><span class="token comment">// 不报错</span><span class="token keyword">var</span> x <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">// 报错</span><span class="token keyword">let</span> x <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">// ReferenceError:x is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p><strong>let不允许在相同作用域内重复声明同一个变量。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 报错</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 报错</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> arg <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h4><ol><li><strong>外层作用域无法读取内层作用域的变量</strong></li><li><strong>内层作用域可以定义外层作用域的同名变量</strong></li></ol><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数匿名函数（IIFE）不再必要了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// IIFE写法</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 块级作用域写法</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> tmp <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>ES6引入了块级作用域，明确<strong>允许在块级作用域之中声明函数</strong>。</p><p>ES6规定，在块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><blockquote><p>注意：在ES6浏览器中，块级作用域内声明函数的行为类似于var声明变量！</p></blockquote><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成<strong>函数表达式的形式</strong>，而不是函数声明语句：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：ES6的块级作用域允许声明函数的规则<strong>只在使用大括号的情况下成立</strong>，如果没用使用大括号则会报错！</p></blockquote><h4 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h4><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没用返回值。即在外部无法获取块级作用域内部变量的值。</p><p>现在有一个提案，使得块级作用域可以变为表达式，即可以返回值，方法就是在<strong>块级作用域之前加上do语句</strong>，使它变为do表达式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">do</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t <span class="token operator">*</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 变量x会得到整个块级作用域的返回值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><blockquote><p>const声明一个只读的常量，一旦声明，常量的值就不能改变。</p><p>————这意味着，const一旦声明常量，就<strong>必须立即进行初始化</strong>，不能留到以后赋值。</p></blockquote><ul><li>const作用域与let命令相同，只在声明所在的块级作用域内有效。</li><li>const命令声明的常量也不会提升，同样存在暂存性死区，只能在声明后使用。</li><li>const声明常量和let一样，不可重复声明</li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>const实际上保证的并不是变量的值不得改动，而是变量指向的<strong>那个内存地址</strong>不得改动。</p><p>对于简单类型的数据（数值、字符串、布尔值）而言，值就保存在变量指向的内存地址中，因此等同于常量。</p><p>但对于复合类型的数据（主要是对象和数组）而言，变量指向的内存地址保存的<strong>只是一个指针</strong>，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。——因此声明一个对象为常量时必须非常小心。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 为foo添加一个属性，可以成功</span>foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span>prop <span class="token comment">// 123</span><span class="token comment">// 将foo指向另一个对象，就会报错</span>foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: "foo" is read-only</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：不可变的只是这个对象的地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p></blockquote><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code> 方法。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> foo <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 常规模式时，下面一行不起作用，因为该对象被冻结</span><span class="token comment">// 严格模式时，改行会报错</span>foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">constantize</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">constantize</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ES6声明变量的六种方法"><a href="#ES6声明变量的六种方法" class="headerlink" title="ES6声明变量的六种方法"></a>ES6声明变量的六种方法</h4><ul><li>var命令</li><li>function命令</li><li>let命令</li><li>const命令</li><li>import命令</li><li>class命令</li></ul><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>顶层对象在浏览器环境中指的是window对象，在Node环境中指的是global对象。在ES5中，顶层对象的属性与全局变量是等价的。</p><p>顶层对象的属性与全局变量相关，被认为是JavaScript语言中最大的设计败笔之一 ：</p><ol><li>无法在编译时就提示变量未声明的错误，只有在运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。</li><li>程序员很容易不知不觉地创建全局变量。</li><li>顶层对象的属性是到处都可以读写的，这非常不利于模块化编程。</li><li>window对象有实体含义，指的是浏览器的窗口对象，这样也是不合适的。</li></ol><p>ES6为了改变这一点，规定：</p><blockquote><ul><li><strong>为了保持兼容性，var命令和function命令声明的全局变量依旧是顶层对象的属性</strong></li><li><strong>另一方面规定，let命令、const命令、class命令声明的全局变量不属于顶层对象的属性</strong></li></ul></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 如果在Node的REPL环境，可以写成gloabal.a</span><span class="token comment">// 或者采用通用方法，写成this.a</span>window<span class="token punctuation">.</span>a <span class="token comment">// 1</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span>b <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>ES5的顶层对象本身也是一个问题，因为它在各种实现中是不统一的。</p><ul><li><strong>在浏览器中，顶层对象是window，但 Node 和 Web Worker 没有 window。</strong></li><li>在浏览器和Web Worker中，self也指向顶层对象，但是Node没有self。</li><li><strong>在Node中，顶层对象是global，但其他环境都不支持。</strong></li></ul><p>同一段代码为了能够在各种环境中取到顶层对象，目前一般是使用<code>this</code>变量，但是也有局限性。</p><ul><li>在全局环境中，this 会返回顶层对象。<strong>但是，在 Node 模块和 ES6模块中，this返回的是当前模块。</strong></li><li>对于函数中的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，this会返回 undefined。</li><li>不管是严格模式，还是普通模式，<code>new Function (&#39;return this&#39;) ()</code>总会返回全局对象。但是，如果浏览器用了 CSP（内容安全政策），那么eval、new Function 这些方法都可能无法使用。</li></ul><p>现有一个提案，在语言标准的局面引入 <code>global</code> 作为顶层对象。也就是说，<code>global</code> 都是存在的，都可以拿到顶层对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// CommonJS的写法</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'system.global/shim'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ES6模块的写法</span><span class="token keyword">import</span> shim <span class="token keyword">from</span> <span class="token string">'system.global/shim'</span><span class="token punctuation">;</span> <span class="token function">shim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码可以保证，在各种环境中global对象都是存在的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// CommonJS的写法</span><span class="token keyword">var</span> global <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'system.global'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ES6模块的写法</span><span class="token keyword">import</span> getGlobal <span class="token keyword">from</span> <span class="token string">'system.global'</span><span class="token punctuation">;</span><span class="token keyword">const</span> global <span class="token operator">=</span> <span class="token function">getGlobal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码将顶层对象放入变量global中。</p><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h3><h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li>ES6语法可以从数组中提取值，按照对应位置对变量赋值：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>bar<span class="token punctuation">]</span><span class="token punctuation">,</span> baz<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> third<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token string">'baz'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>head<span class="token punctuation">,</span> <span class="token operator">...</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>head <span class="token comment">// 1</span>tail <span class="token comment">// [2, 3, 4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本质上这种写法属于<strong>模式匹配</strong>，只要等号两边的模式相同，左边的变量就会赋予对应的值。</p><ul><li>如果解构不成功，变量的值就等于undefined。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>bar<span class="token punctuation">,</span> foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>另一种情况是不完全解构，即等号左边的模式<strong>只匹配一部分的等号右边的数组</strong>，这种情况下，解构依然可以成功。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>x <span class="token comment">// 1</span>y <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果等号的右边不是数组（或者严格说不是可遍历的结构）那么将会报错：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 报错</span><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NAN</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的语句都会报错，因为等号右边的值或是转为对象以后不具备Iterator接口，或是本身就不具备Iterator接口。</p><p>对于Set结构，也可以使用数组的解构赋值——<strong>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</strong></p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul><li>解构赋值允许指定默认值：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>foo <span class="token comment">// true</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x = 'a', y = 'b'</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x = 'a', y = 'b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：ES6内部使用严格相等运算符（&#x3D;&#x3D;&#x3D;）判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p></blockquote><p>例如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">undefined</span><span class="token punctuation">]</span><span class="token punctuation">;</span>x <span class="token comment">// 1</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">]</span><span class="token punctuation">;</span>x <span class="token comment">// null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined</p><ul><li>如果默认值是一个表达式，那么这个表达式是<strong>惰性求值</strong>的，<strong>即只有在用到时才会求值</strong>。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'aaa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>上面的代码中，因为x能取到值，所以函数f根本不会执行。上面的代码等价如下：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>默认值可以引用解构赋值的其他变量，<strong>但该变量必须已经声明</strong>。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x=1; y=1</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x=2; y=2</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x=1; y=2</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> y<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// ReferenceError</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p><blockquote><p>对象的解构和数组有一个重要的不同——</p><p>数组的元素是按次序排列的，变量的取值是由它的位置决定的；</p><p>而对象的属性没有次序，<strong>变量必须与属性同名才能取到正确的值。</strong></p></blockquote><p>如果变量名和属性名不一致，必须写成下面这样：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> baz <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">'bbb'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>baz <span class="token comment">// 'aaa'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，对象的赋值解解构是下面形式的简写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> foo<span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> bar <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">'bbb'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>也就是说，对象的解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量。<strong>真正被赋值的是后者，而不是前者。</strong></p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> baz <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">'bbb'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>baz <span class="token comment">// "aaa"</span>foo <span class="token comment">// error: foo is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><ul><li>与数组一样，解构也可以用于嵌套结构的对象。</li><li>对象的解构也可以指定默认值——默认值生效的条件是，对象的属性值严格等于undefined。</li><li><strong>如果解构失败，变量的值等于<code>undefined</code>。</strong></li><li><strong>如果解构模式是嵌套的对象，且子对象所在的父属性不存在，那么将会报错。</strong></li></ul><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// SyntaxError: syntax error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为JavaScript引擎会将 {x} 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>关于圆括号与赋值结构的关系，参见下文：</p><p>解构赋值允许等号左边的模式之中不放置任何变量名：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的表达式虽然毫无意义，但可以执行。</p><p>对象的解构赋值可以很方便地将现有对象的方法赋值到某个变量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">&#123;</span> log<span class="token punctuation">,</span> sin<span class="token punctuation">,</span> cos <span class="token punctuation">&#125;</span> <span class="token operator">=</span> Math<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的代码将Math对象的对数、正弦、余弦三个方法赋值到对应的变量上，使用起来就方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><ul><li>字符串可以解构赋值，因为此时<strong>字符串被转换成了一个类似数组的对象</strong>。</li><li>类似数组的对象都有一个length对象，因此还可以对这个属性进行解构赋值。</li></ul><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是<strong>数值</strong>和<strong>布尔值</strong>，则会先转为对象。</p><blockquote><p>赋值解构的规则是：<strong>只要等号右边的值不是对象或数组，就先将其转为对象。</strong></p><p>由于undefined和null无法转换为对象，所以对它们进行解构赋值时会报错。</p></blockquote><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y，对于函数内部的代码来说，它们能感受到的参数就是x和y。</p><p>另一个例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [3, 7]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。<br>由此带来的问题是，如果模式中出现圆括号该怎么处理？</p><blockquote><p>ES6的规则是，只要有可能导致解构的歧义，就<strong>不得使用圆括号</strong>。</p></blockquote><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><ol><li>变量声明语句</li><li>函数参数</li><li>赋值语句的模式，即将整个模式放在圆括号中（而非将整个赋值语句放在圆括号中）</li></ol><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><blockquote><p>可以使用圆括号的情况只有 一 种 ： 赋值语句的<strong>非模式部分</strong>可以使用圆括号。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">p</span><span class="token operator">:</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">.</span>prop<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门-动态规划</title>
      <link href="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/"/>
      <url>/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解为若干子问题，自顶向下求解各子问题，合并子问题的解，从而得到原问题的解。动态规划也是把原问题分解为若干子问题，然后自底向上，先求解最小的子问题，把结果存储在表格中，再求解大的子问题时，直接从表格中查询小的子问题的解，避免重复计算，从而提高算法效率。</p><blockquote><p>与分治法的区别：在分治法中，各个子问题是互不相交的，即相互独立。如果各个子问题有重叠，不是相互独立的，动态规划闪亮登场！</p></blockquote><h3 id="算法要素："><a href="#算法要素：" class="headerlink" title="算法要素："></a>算法要素：</h3><p>什么问题可以使用动态规划呢？我们首先要分析问题是否具有以下两个性质：</p><ol><li><p>最优子结构</p><p><strong>最优子结构性质是指问题的最优解包含其子问题的最优解。</strong>最优子结构是使用动态规划的最基本条件，如果不具有最优子结构性质，就不可以使用动态规划解决。</p></li><li><p>子问题重叠</p><p>子问题重叠是指在求解子问题的过程中，<strong>有大量的子问题是重复的，那么只需要求解一次，然后把结果存储在表中</strong>，以后使用时可以直接查询，不需要再次求解。</p><p>子问题重叠不是使用动态规划的必要条件，但问题存在子问题重叠更能够充分彰显动态规划的优势。</p></li></ol><h3 id="解题秘籍："><a href="#解题秘籍：" class="headerlink" title="解题秘籍："></a>解题秘籍：</h3><p>遇到一个实际问题，如何采用动态规划来解决呢？</p><ol><li><strong>分析最优解的结构特征。</strong></li><li><strong>建立最优值的递归式。</strong></li><li><strong>自底向上计算最优值，并记录。</strong></li><li><strong>构造最优解。</strong></li></ol><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><p>给定两个序列 X&#x3D;{x1，x2，x3，…，x m}和 Y&#x3D;{y1，y2，y3，…，yn}，找出 X 和 Y 的一个最长的公共子序列。</p><p>例如：X&#x3D;（A，B，C，B，A，D，B），Y&#x3D;（B，C，B，A，A，C），那么最长公共子序列是 B，C，B，A。</p><p>如何找到最长公共子序列呢？</p><p>如果使用暴力搜索方法，需要穷举 X 的所有子序列，检查每个子序列是否也是 Y 的子序列，记录找到的最长公共子序列。X 的子序列有 2m 个，因此暴力求解的方法时间复杂度为指数阶，这是我们避之不及的爆炸性时间复杂度。</p><p>那么能不能用动态规划算法呢？<br>下面分析该问题是否具有最优子结构性质。</p><ol><li><p>分析最优解的结构特征</p><p>假设已经知道 Zk&#x3D;{z1，z2，z3，…，zk}是 X m&#x3D;{x1，x2，x3，…，x m}和 Yn&#x3D;{y1，y2，y3，…，y n}的最长公共子序列。</p><p><strong>这个假设很重要，我们都是这样假设已经知道了最优解。</strong></p><p>那么可以分 3 种情况讨论。</p><ul><li><p>xm&#x3D; yn&#x3D; zk：那么 Zk−1&#x3D;{z1，z2，z3，…，zk−1}是 Xm−1 和 Yn−1 的最长公共子序列：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027222127785.png" alt="image-20221027222127785"></p><p>反证法证明：如果 Zk−1 &#x3D;{z1，z2，z3，…，zk−1 }不是 X m−1 和 Yn−1 的最长公共子序列，那么它们一定存在一个最长公共子序列。设 M 为 X m−1 和 Yn−1 的最长公共子序列，M 的长度大于Zk−1 的长度，即|M|&gt;|Zk−1|。如果在 X m−1 和 Yn−1 的后面添加一个相同的字符 xm&#x3D; y n，则 zk&#x3D;xm&#x3D;y n，|M+{zk}|&gt;|Zk−1+{zk}|&#x3D;|Zk|，那么 Zk 不是 X m 和 Yn 的最长公共子序列，这与假设 Zk 是 X m 和 Yn 的最长公共子序列矛盾，问题得证。</p></li><li><p>xm≠yn，xm≠zk：我们可以把 xm 去掉，那么 Zk 是 Xm−1 和 Yn 的最长公共子序列：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027222217619.png" alt="image-20221027222217619"></p><p>反证法证明：如果 Zk 不是 X m−1 和 Y n 的最长公共子序列，那么它们一定存在一个最长公共子序列。设 M 为 X m−1 和 Y n 的最长公共子序列，M 的长度大于 Zk 的长度，即|M|&gt;|Zk|。如果我们在 X m−1 的后面添加一个字符 x m，那么 M 也是 X m 和 Yn 的最长公共子序列，因为|M|&gt;|Zk|，那么 Zk 不是 X m 和 Y n 的最长公共子序列，这与假设 Zk 是 X m 和 Y n 的最长公共子序列矛盾，问题得证。</p></li><li><p>xm≠yn，yn≠zk：我们可以把 y n 去掉，那么 Zk 是 X m 和 Yn−1 的最长公共子序列：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027222826143.png" alt="image-20221027222826143"></p><p>反证法证明：如果 Zk 不是 X m 和 Y n−1 的最长公共子序列，那么它们一定存在一个最长公共子序列。设 M 为 X m 和 Y n−1 的最长公共子序列，M 的长度大于 Zk 的长度，即|M|&gt;|Zk|。如果我们在 Yn−1 的后面添加一个字符 yn，那么 M 也是 Xm 和 Yn 的最长公共子序列，因为|M|&gt;|Zk|，那么 Zk不是 Xm 和 Yn 的最长公共子序列，这与假设 Zk 是 Xm 和 Yn 的最长公共子序列矛盾，问题得证。</p></li></ul></li><li><p>建立最优值的递归式</p><p>设 c[i][j]表示 X i 和 Y j 的最长公共子序列长度。</p><ul><li><p>xm &#x3D; yn &#x3D; zk：那么 c[i][j] &#x3D; c[i−1][j−1]+1；</p></li><li><p>xm ≠ yn：那么我们只需要求解 X i 和 Y j−1 的最长公共子序列和 X i−1 和 Y j 的最长公共子序列，比较它们的长度哪一个更大，就取哪一个值。即 c[i][j]&#x3D; max{c[i][j−1],c[i−1][j]}。</p></li><li><p>最长公共子序列长度递归式：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027223715163.png" alt="image-20221027223715163"></p></li></ul></li><li><p>底向上计算最优值，并记录最优值和最优策略</p><p>i&#x3D;1 时：{x1 }和{y1，y2，y3，…，y n}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p><p>i&#x3D;2 时：{x2 }和{y1，y2，y3，…，y n}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p><p>……</p><p>i&#x3D;m 时：{x m}和{y1，y2，y3，…，yn}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p></li><li><p>构造最优解</p><p>上面的求解过程只是得到了最长公共子序列长度，并不知道最长公共子序列是什么，那怎么办呢？</p><p>例如，现在已经求出 c[m][n]&#x3D;5，表示 X m 和 Y n 的最长公共子序列长度是 5，那么这个 5是怎么得到的呢？我们可以反向追踪 5 是从哪里来的。根据递推式，有如下情况。</p><p>x i &#x3D; y j 时：c[i][j]&#x3D; c[i−1][j−1]+1；</p><p>x i ≠ y j 时：c[i][j]&#x3D; max{c[i][j−1], c[i−1][j]}；</p><p>那么 c[i][j]的来源一共有 3 个：c[i][j]&#x3D; c[i−1][j−1]+1，c[i][j]&#x3D; c[i][j−1]，c[i][j]&#x3D; c[i−1][j]。在第 3 步自底向上计算最优值时，用一个辅助数组 b [i][j]记录这 3 个来源：</p><p>c[i][j]&#x3D; c[i−1][j−1]+1，b[i][j]&#x3D;1；</p><p>c[i][j]&#x3D; c[i][j−1]，b[i][j]&#x3D;2；</p><p>c[i][j]&#x3D; c[i−1][j]，b[i][j]&#x3D;3。</p><p>这样就可以根据 b[m][n]反向追踪最长公共子序列，当 b[i][j]&#x3D;1 时，输出 x i；当 b [i][j]&#x3D;2时，追踪 c[i][j−1]；当 b[i][j]&#x3D;3 时，追踪 c[i−1][j]，直到 i&#x3D;0 或 j&#x3D;0 停止。</p></li></ol><h3 id="图解分析："><a href="#图解分析：" class="headerlink" title="图解分析："></a>图解分析：</h3><p>以字符串 s1 &#x3D;“ABCADAB”，s2&#x3D;“BACDBA”为例。</p><ol><li><p>初始化</p><p>len1&#x3D;7，len2&#x3D;6，初始化 c[][]第一行、第一列元素为 0：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027225817829.png" alt="image-20221027225817829"></p></li><li><p>i&#x3D;1：s1[0]与 s2[j−1]比较，j&#x3D;1，2，3，…，len2。即“A”与“BACDBA”分别比较一次。</p><p><strong>如果字符相等，c[i][j]取<u>左上角</u>数值加 1，记录最优值来源 b[i][j]&#x3D;1。</strong></p><p><strong>如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果 c[i][j]的值来源于左侧 b[i][j]&#x3D;2，来源于上面 b[i][j]&#x3D;3。</strong></p><ul><li><p>j&#x3D;1：A≠B，左侧&#x3D;上面，取左侧数值，c[1][1]&#x3D; 0，最优策略来源 b[1][1]&#x3D;2：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027230443409.png" alt="image-20221027230443409"></p></li><li><p>j&#x3D;2：A&#x3D;A，则取左上角数值加 1，c[1][2]&#x3D; c[0][1]+1&#x3D;2，最优策略来源 b[1][2] &#x3D;1：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027230615500.png" alt="image-20221027230615500"></p></li><li><p>j&#x3D;3：A≠C，左侧≥上面，取左侧数值，c[1][3]&#x3D; 1，最优策略来源 b[1][3] &#x3D;2：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027230649108.png" alt="image-20221027230649108"></p></li><li><p>j&#x3D;6：A&#x3D;A，则取左上角数值加 1，c[1][6]&#x3D;1，最优策略来源 b[1][6]&#x3D;1：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027230840156.png" alt="image-20221027230840156"></p></li></ul></li><li><p>i&#x3D;2：s1[1]与 s2 [j−1]比较，j&#x3D;1，2，3，…，len2。即“B”与“BACDBA”分别比较一次。</p><p>如果字符相等，c[i][j]取左上角数值加 1，记录最优值来源 b[i][j]&#x3D;1。</p><p>如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果 c[i][j]的值来源于左侧 b[i][j]&#x3D;2，来源于上面 b[i][j]&#x3D;3：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027231109658.png" alt="image-20221027231109658"></p></li><li><p>继续处理 i&#x3D;2，3，…，len1：s1[i−1]与 s2 [j−1]比较，j&#x3D;1，2，3，…，len2。处理结果如下：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027231613378.png" alt="image-20221027231613378"></p><blockquote><p>c[][]右下角的值即为最长公共子序列的长度。</p></blockquote><p>c[7][6]&#x3D;4，即字符串 s1 &#x3D;“ABCADAB”，s2 &#x3D;“BACDBA”的最长公共子序列的长度为 4。</p><p>那么最长公共子序列包含哪些字符呢？</p></li><li><p>构造最优解</p><p>首先读取 b[7][6]&#x3D;2，说明来源为 2，向左找 b[7][5]；</p><p>b[7][5]&#x3D;1，向左上角找 b[6][4]，返回时输出 s[6]&#x3D;“B”；<br>b[6][4]&#x3D;3，向上找 b[5][4]；<br>b[5][4]&#x3D;1，向左上角找 b[4][3]，返回时输出 s[4]&#x3D;“D”；<br>b[4][3]&#x3D;2，向左找 b[4][2]；<br>b[4][2]&#x3D;1，向左上角找 b[3][1]，返回时输出 s[3]&#x3D;“C”；<br>b[3][1]&#x3D;3，向上找 b[2][1]；<br>b[2][1]&#x3D;1，向左上角找，返回时输出 s[1]&#x3D;“B”；</p><p>b[1][0]中列为 0，算法停止，返回，输出最长公共子序列为 BCDB：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027232645959.png" alt="image-20221027232645959"></p><blockquote><p>即输出追踪到的左上角元素</p></blockquote></li></ol><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li><p>最长公共子序列求解函数</p><p>首先计算两个字符串的长度，然后从 i&#x3D;1 开始，s1 [0]与 s2 中的每一个字符比较。<br>如果当前字符相同，则公共子序列的长度为 c[i−1][j−1]+1，并记录最优策略来源 b[i][j] &#x3D; 1。<br>如果当前字符不相同，则公共子序列的长度为 c[i][j−1]和 c[i−1][j]中的最大值，如果c[i][j−1]≥c[i−1][j]，则最优策略来源 b[i][j]&#x3D;2；如果 c[i][j−1]&lt;c[i−1][j]，则最优策略来源b[i][j]&#x3D;3。直到 i&gt; len1 时，算法结束，这时 c[len1][len2]就是我们要的最长公共序列长度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">LCSL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//控制s1序列不同的子问题</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//控制s2序列不同的子问题</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>s2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//如果当前字符相同，则公共子序列的长度为该字符前的最长公共序列+1</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最优解输出函数</p><p>输出最优解仍然使用倒推法。因为我们在求最长公共子序列长度 c[i][j]的过程中，用 b[i][j]记录了 c[i][j]的来源，那么就可以根据 b[i][j]数组倒推最优解。</p><p>如果 b[i][j]&#x3D;1，说明 s1[i−1]&#x3D;s2[j−1]，那么我们就可以递归输出 print(i−1，j−1)；然后输出 s1[i−1]。</p><p>如果 b[i][j]&#x3D;2，说明 s1[i−1]≠s2[j−1]且最优解来源于 c[i][j]&#x3D;c[i][j−1]，递归输出 print(i，j−1)。</p><p>如果 b[i][j]&#x3D;3，说明 s1[i−1]≠s2[j−1]且最优解来源于 c[i][j]&#x3D;c[i−1][j]，递归输出 print(i−1，j)。<br>当 i&#x3D;&#x3D;0||j&#x3D;&#x3D;0 时，递归结束。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token comment">//根据记录下来的信息构造最长公共子序列（从b[i][j]开始递推）</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>            <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 4-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1002</span><span class="token punctuation">;</span><span class="token keyword">int</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> s1<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>s2<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> len1<span class="token punctuation">,</span>len2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LCSL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//控制s1序列不同的子问题</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//控制s2序列不同的子问题</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>s2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//如果当前字符相同，则公共子序列的长度为该字符前的最长公共序列+1</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token comment">//根据记录下来的信息构造最长公共子序列（从b[i][j]开始递推）</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>            <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入字符串s1:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s1<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入字符串s2:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s2<span class="token punctuation">;</span>    len1 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算两个字符串的长度</span>    len2 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化第一列为0</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化第一行为0</span>    <span class="token punctuation">&#125;</span>    <span class="token function">LCSL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s1和s2的最长公共子序列长度是:"</span><span class="token operator">&lt;&lt;</span>c<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s1和s2的最长公共子序列是:"</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span>len2<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment">// /*用于测试</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"c[i][j]数组："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          cout <span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token operator">&lt;&lt;</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"b[i][j]数组："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          cout <span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token operator">&lt;&lt;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// */用于测试</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度："><a href="#算法复杂度：" class="headerlink" title="算法复杂度："></a>算法复杂度：</h3><ol><li><p>时间复杂度：</p><p>由于每个数组单元的计算耗费 Ο(1)时间，如果两个字符串的长度分别是 m、n，那么算法时间复杂度为 Ο(m*n)。</p></li><li><p>空间复杂度：</p><p>空间复杂度主要为两个二维数组 c[][]，b[][]，占用的空间为 O(m*n)。</p></li></ol><h3 id="优化拓展："><a href="#优化拓展：" class="headerlink" title="优化拓展："></a>优化拓展：</h3><p>因为 c[i][j]有 3 种来源：c[i−1][j−1]+1、c[i][j−1]、c[i−1][j]。我们可以利用 c 数组本身来判断来源于哪个值，从而不用 b[][]，这样可以节省 O(m<em>n)个空间。但因为 c 数组还是 O(m</em>n)个空间，所有空间复杂度数量级仍然是 O(m*n)，只是从常数因子上的改进。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028175628346.png" alt="image-20221028175628346"></p><h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><h3 id="问题分析：-1"><a href="#问题分析：-1" class="headerlink" title="问题分析："></a>问题分析：</h3><p>矩阵连乘问题就是对于给定 n 个连乘的矩阵，找出一种加括号的方法，使得矩阵连乘的计算量（乘法次数）最小。</p><ol><li><p>什么是矩阵可乘？</p><blockquote><p>如果两个矩阵，<strong>第 1 个矩阵的列等于第 2 个矩阵的行时，那么这两个矩阵是可乘的。</strong></p></blockquote><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028180740102.png" alt="image-20221028180740102"></p></li><li><p>矩阵相乘后的结果是什么？</p><p><strong>多个矩阵相乘的结果矩阵，其行、列分别等于第 1 个矩阵的行、最后 1 个矩阵的列。</strong>而且无论矩阵的计算次序如何都不影响它们的结果矩阵。</p></li><li><p>两个矩阵相乘需要多少次乘法？</p><blockquote><p><strong>Am×n、An×k 相乘执行乘法运算的次数为 m×n×k。</strong></p></blockquote></li></ol><p>如果穷举所有的加括号方法，那么加括号的所有方案是一个卡特兰数序列，其算法时间复杂度为 2<sup>n</sup>，是指数阶。因此穷举的办法是很糟的，那么能不能用动态规划呢？</p><p>下面分析矩阵连乘问题 AiAi+1…Aj 是否具有最优子结构性质。</p><ol><li><p>分析最优解的结构特征</p><ul><li><p>假设我们已经知道了在第 k 个位置加括号会得到最优解，那么原问题就变成了两个子问题：（AiAi+1…Ak），（Ak+1Ak+2…Aj）:</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028181917124.png" alt="image-20221028181917124"></p><p>原问题的最优解是否包含子问题的最优解呢？</p></li><li><p>假设 AiAi+1…Aj 的乘法次数是 c，（AiAi+1…Ak）的乘法次数是 a，（Ak+1Ak+2…Aj）的乘法次数是 b，（AiAi+1…Ak）和（Ak+1Ak+2…Aj）的结果矩阵相乘的乘法次数是 d，那么c&#x3D;a+b+d，无论两个子问题（AiAi+1…Ak）、（Ak+1Ak+2…Aj）的计算次序如何，都不影响它们结果矩阵，两个结果矩阵相乘的乘法次数 d 不变。</p><p>因此我们只需要证明如果 c 是最优的，则 a 和 b 一定是最优的（即原问题的最优解包含子问题的最优解）。</p></li></ul></li><li><p>建立最优值递归式</p><ul><li><p>用 m[i][j]表示 AiAi+1 …Aj 矩阵连乘的最优值，那么两个子问题（AiAi+1 …Ak ）、（Ak+1Ak+2…Aj）对应的最优值分别是 m[i][k]、m[k+1][j]。剩下的只需要考查（AiAi+1…Ak）和（Ak+1Ak+2…Aj）的结果矩阵相乘的乘法次数了。</p></li><li><p>设矩阵 Am 的行数为 p m，列数为 q m，m&#x3D;i，i+1, …，j，且矩阵是可乘的，即相邻矩阵前一个矩阵的列等于下一个矩阵的行（q m&#x3D; p m+1）。（AiAi+1…Ak）的结果是一个 p i×q k矩阵，（Ak+1Ak+2…Aj）的结果是一个 p k+1×qj 矩阵，q k&#x3D; p k+1，两个结果矩阵相乘的乘法次数是 p i*p k+1 *q j。</p></li><li><p>当 i&#x3D;j 时，只有一个矩阵，m[i][j]&#x3D;0；</p><p>当 i&gt;j 时，m[i][j]&#x3D;min{m[i][k]+m[k+1][j]+pi×pk+1×qj}</p><p>如果用一维数组 p[]来记录矩阵的行和列，第 i 个矩阵的行数存储在数组的第 i−1 位置，列数存储在数组的第 i 位置，那么 pi<em>p k+1</em>qj 对应的数组元素相乘为 p[i−1]<em>p[k]</em> p[j]，原递归式变为：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028183443792.png" alt="image-20221028183443792"></p></li></ul></li><li><p>自底向上计算并记录最优值</p><p>先求两个矩阵相乘的最优值，再求 3 个矩阵相乘的最优值，直到 n 个矩阵连乘的最优值。</p></li><li><p>构造最优解</p><p>上面得到的最优值只是矩阵连乘的最小的乘法次数，并不知道加括号的次序，需要从记录表中还原加括号次序，构造出最优解，例如 A1（A2A3）。</p></li></ol><h3 id="图解分析：-1"><a href="#图解分析：-1" class="headerlink" title="图解分析："></a>图解分析：</h3><p>假设有5个矩阵：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028184059795.png" alt="image-20221028184059795"></p><ol><li><p>初始化</p><p>采用一维数组 p[]记录矩阵的行和列，实际上只需要记录每个矩阵的行，再加上最后一个矩阵的列即可。m[i][i]&#x3D;0，s[i][i]&#x3D;0，其中 i&#x3D; 1，2，3，4，5。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028184442920.png" alt="image-20221028184442920"></p><p>最优值数组 m[i][i]&#x3D;0，最优决策数组 s[i][i]&#x3D;0，其中 i&#x3D; 1，2，3，4，5。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028184457563.png" alt="image-20221028184457563"></p></li><li><p>计算两个矩阵相乘的最优值</p><p>规模 r&#x3D;2。根据递归式：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028185814891.png" alt="image-20221028185814891"></p><ul><li><p>A1 *A2：k&#x3D;1，m[1][2]&#x3D;min{ m[1][1]+ m[2][2]+p0p1p2 }&#x3D;150；s[1][2]&#x3D;1。</p></li><li><p>A2 *A3：k&#x3D;2，m[2][3]&#x3D;min{ m[2][2]+ m[3][3]+p1p2p3 }&#x3D;400；s[2][3]&#x3D;2。</p></li><li><p>A3 *A4：k&#x3D;3，m[3][4]&#x3D;min{ m[3][3]+ m[4][4]+p2p3p4 }&#x3D;160；s[3][4]&#x3D;3。</p></li><li><p>A4 *A5：k&#x3D;4，m[4][5]&#x3D;min{ m[4][4]+ m[5][5]+p3p4p5 }&#x3D;64； s[4][5]&#x3D;4。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028185848792.png" alt="image-20221028185848792"></p></li></ul></li><li><p>计算 3 个矩阵相乘的最优值</p><p>规模 r&#x3D;3。根据递归式：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028185814891.png" alt="image-20221028185814891"></p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190045501.png" alt="image-20221028190045501"></p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190053112.png" alt="image-20221028190053112"></p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190209778.png" alt="image-20221028190209778"></p></li><li><p>计算 4 个矩阵相乘的最优值</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190253904.png" alt="image-20221028190253904"></p></li><li><p>计算 5 个矩阵相乘的最优值</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190650549.png" alt="image-20221028190650549"></p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190705171.png" alt="image-20221028190705171"></p></li><li><p>根据最优解</p><p>根据最优决策数组 s[][]中的数据来构造最优解，即加括号的位置。</p><p>首先读取 s[1][5]&#x3D;4，表示在 k&#x3D;4 的位置把矩阵分为两个子问题：（A1A2A3A4）、A5。</p><p>再看第一个子问题（A1A2A3A4），读取 s[1][4]&#x3D;1，表示在 k&#x3D;1 的位置把矩阵分为两个子问题：A1、（A2A3A4）。</p><p>子问题 A1 不用再分解，输出；子问题（A2A3A4），读取 s[2][4]&#x3D;2，表示在 k&#x3D;2 的位置把矩阵分为两个子问题：A2、（A3A4）。</p><p>子问题 A2 不用再分解，输出；子问题(A3A4 )，读取 s[3][4]&#x3D;3，表示在 k&#x3D;3 的位置把矩阵分为两个子问题：A3、A4。这两个子问题都不用再分解，输出</p><p>子问题 A5 不用再分解，输出。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190934126.png" alt="image-20221028190934126"></p><p>最优解为：（（A1（A2（A3A4）））A5）。<br>最优值为：314。</p></li></ol><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><p>按照算法思想和设计，以下程序将矩阵的行和列存储在一维数组 p[]，m[][]数组用于存储分成的各个子问题的最优值，s[][]数组用于存储各个子问题的决策点，然后在一个 for 循环里，将问题分为规模为 r 的子问题，求每个规模子问题的最优解，那么得到的 m[1][n]就是最小的计算量。</p><ol><li><p>矩阵连乘求解函数</p><p>首先将数组 m[][]，s[][]初始化为 0，然后自底向上处理不同规模的子问题，r 为问题的规模，r&#x3D; 2；r &lt;&#x3D; n；r++，当 r&#x3D; 2 时，表示矩阵连乘的规模为 2，即两个矩阵连乘。求解两个矩阵连乘的最优值和最优策略，根据递归式对每一个 k 值，找到最小值用 m[i][j]记录，并用 s[i][j]记录取得最小值的 k 值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">matrixchain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>r<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> r <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token comment">//不同规模的子问题</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">-</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>           j <span class="token operator">=</span> i <span class="token operator">+</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>           m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//决策为k=i的乘法次数</span>           s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                     <span class="token comment">//子问题的最优策略是i;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//对从i到j的所有决策，求最优值，记录最优策略</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> t <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最优解输出函数</p><p>根据存储表格 s[][]中的数据来构造最优解，即加括号的位置。首先打印一个左括号，然后递归求解子问题 print（i，s[i][j]），print（s[i][j]+1，j），再打印右括号，当 i&#x3D;j 即只剩下一个矩阵时输出该矩阵即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> j <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout <span class="token operator">&lt;&lt;</span><span class="token string">"A["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 4-4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> msize <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> m<span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> s<span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">matrixchain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>r<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> r <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token comment">//不同规模的子问题</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">-</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>           j <span class="token operator">=</span> i <span class="token operator">+</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>           m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//决策为k=i的乘法次数</span>           s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                     <span class="token comment">//子问题的最优策略是i;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//对从i到j的所有决策，求最优值，记录最优策略</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> t <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> j <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout <span class="token operator">&lt;&lt;</span><span class="token string">"A["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入矩阵的个数 n:"</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token punctuation">,</span>j<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请依次输入每个矩阵的行数和最后一个矩阵的列数:"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>        cin <span class="token operator">>></span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">matrixchain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">/*用于测试    for (i = 1; i &lt;= n; i++ )        &#123;          for (j = i; j &lt;= n; j++ )            cout &lt;&lt; m[i][j]&lt;&lt;"  " ;          cout &lt;&lt; endl;        &#125;     for (i = 1; i &lt;= n; i++ )        &#123;          for (j = i; j &lt;= n; j++ )            cout &lt;&lt; s[i][j]&lt;&lt;"  " ;          cout &lt;&lt; endl;        &#125;    cout &lt;&lt; endl;    */</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小计算量的值为 "</span> <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度：-1"><a href="#算法复杂度：-1" class="headerlink" title="算法复杂度："></a>算法复杂度：</h3><ol><li><p>时间复杂度</p><p>由程序可以得出：语句 t&#x3D; m[i][k] + m[k+1][j] +p[i−1]*p[k]*p[j]，它是算法的基本语句，在 3 层 for 循环中嵌套。最坏情况下，该语句的执行次数为 O(n<sup>3</sup>)，print()函数算法的时间主要取决于递归，时间复杂度为 O(n)。故该程序的时间复杂度为 O(n<sup>3</sup>)。</p></li><li><p>空间复杂度</p><p>该程序的输入数据的数组为 p[]，辅助变量为 i、j、r、t、k、m[][]、s[][]，空间复杂度取决于辅助空间，因此空间复杂度为 O(n<sup>2</sup>)。</p></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门-分治法</title>
      <link href="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/"/>
      <url>/2022/10/23/suan-fa-ru-men-fen-zhi-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="分治法本质"><a href="#分治法本质" class="headerlink" title="分治法本质"></a>分治法本质</h2><blockquote><p>分治算法，其本质就是将一个大规模的问题分解为若干个规模较小的相同子问题，分而治之。</p></blockquote><p>那么在现实生活中，什么样的问题才能使用分治法解决呢？简单来说，需要满足以下 3 个条件：</p><ol><li>原问题可分解为若干个规模较小的相同子问题。</li><li>子问题相互独立。</li><li>子问题的解可以合并为原问题的解。</li></ol><h2 id="分治法解题步骤"><a href="#分治法解题步骤" class="headerlink" title="分治法解题步骤"></a>分治法解题步骤</h2><ul><li>分解：将要解决的问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。</li><li>治理：求解各个子问题。由于各个子问题与原问题形式相同，只是规模较小而已，而当子问题划分得足够小时，就可以用较简单的方法解决。</li><li>合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。</li></ul><blockquote><p><strong>递归</strong>是彰显分治法优势的利器。</p></blockquote><h2 id="二分搜索技术"><a href="#二分搜索技术" class="headerlink" title="二分搜索技术"></a>二分搜索技术</h2><h3 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h3><p>问题描述：给定 n 个元素，这些元素是<strong>有序</strong>的（假定为升序），从中查找特定元素 x。</p><p>算法思想：将有序序列分成规模大致相等的两部分，然后取中间元素与特定查找元素 x 进行比较，如果 x 等于中间元素，则查找成功，算法终止；如果 x 小于中间元素，则在序列的前半部分继续查找，即在序列的前半部分重复分解和治理操作；否则，在序列的后半部分继续查找，即在序列的后半部分重复分解和治理操作。</p><p>算法设计：用一维数组 S[]存储该有序序列，设变量 low 和 high 表示查找范围的下界和上界，middle 表示查找范围的中间位置，x 为特定的查找元素。</p><ul><li>初始化。令 low&#x3D;0，即指向有序数组 S[]的第一个元素；high&#x3D;n−1，即指向有序数组S[]的最后一个元素。</li><li>middle&#x3D;（low+high）&#x2F;2，即指示查找范围的中间元素。</li><li>判定 low≤high 是否成立，如果成立，转第 4 步，否则，算法结束。</li><li>判断 x 与 S[middle]的关系。如果 x&#x3D;S[middle]，则搜索成功，算法结束；如果x&gt;S[middle]，则令 low&#x3D;middle+1；否则令 high&#x3D;middle−1，转为第 2 步。</li></ul><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 3-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdlib></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> M<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span>n<span class="token punctuation">,</span>i<span class="token punctuation">;</span><span class="token keyword">int</span> s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> low<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>high<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//low指向有序数组的第一个元素，high指向有序数组的最后一个元素</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> middle<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//middle为查找范围的中间值</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>s<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">//x等于查找范围的中间值，算法结束</span>          <span class="token keyword">return</span> middle<span class="token punctuation">;</span>       <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">></span>s<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//x大于查找范围的中间元素，则从左半部分查找</span>              low<span class="token operator">=</span>middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>   <span class="token comment">//x小于查找范围的中间元素，则从右半部分查找</span>              high<span class="token operator">=</span>middle<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"该数列中的元素个数n为："</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入数列中的元素："</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>           cin<span class="token operator">>></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>s<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"排序后的数组为："</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>           cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入要查找的元素："</span><span class="token punctuation">;</span>        cin<span class="token operator">>></span>x<span class="token punctuation">;</span>        i<span class="token operator">=</span><span class="token function">BinarySearch</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>s<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"该数列中没有要查找的元素"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"要查找的元素在第"</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">"位"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析："><a href="#算法复杂度分析：" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p><strong>时间复杂度：</strong></p><ol><li><p>首先需要进行排序，调用 sort 函数，进行排序复杂度为 O(nlogn)，如果数列本身有序，那么这部分不用考虑。</p></li><li><p>如果我们用 T(n)来表示 n 个有序元素的二分查找算法时间复杂度，那么：</p><ul><li><p>当 n&#x3D;1 时，需要一次比较，T(n)&#x3D;O(1)</p></li><li><p>当 n&gt;1 时，特定元素和中间位置元素比较，需要 O(1)时间，如果比较不成功，那么需要在前半部分或后半部分搜索，问题的规模缩小了一半，时间复杂度变为 T(n&#x2F;2)。</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023113347212.png" alt="image-20221023113347212"></p></li><li><p>当 n&gt;1 时，可以递推求解如下。</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023113358680.png" alt="image-20221023113358680"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup>，则x &#x3D; logn。</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023113505382.png" alt="image-20221023113505382"></p><p>二分查找算法的时间复杂度为 O(logn)。</p></li></ul></li></ol><p><strong>空间复杂度：</strong>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为 O(1)。</p><h3 id="优化拓展："><a href="#优化拓展：" class="headerlink" title="优化拓展："></a>优化拓展：</h3><p>在上面程序中，我们采用 BinarySearch（int n，int s[]，int x）函数来实现二分搜索，那么能不能用递归来实现呢？因为递归有自调用问题，那么就需要增加两个参数 low 和 high 来标记搜索范围的开始和结束。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">recursionBS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">></span>high<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>middle<span class="token punctuation">)</span>      <span class="token keyword">return</span> middle   <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span>middle<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token function">recursionBS</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> low<span class="token punctuation">,</span> middle<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">else</span>         <span class="token keyword">return</span> <span class="token function">recursionBS</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间复杂度：</strong></p><p>在递归算法中，每一次递归调用都需要一个栈空间存储，那么我们只需要看看有多少次调用。</p><p>假设原问题的规模为 n，那么第一次递归就分为两个规模为 n&#x2F;2 的子问题，这两个子问题并不是每个都执行，只会执行其中之一。</p><p>因为我们和中间值比较后，要么去前半部分查找，要么去后半部分查找；然后再把规模为 n&#x2F;2的子问题继续划分为两个规模为 n&#x2F;4 的子问题，选择其一；继续分治下去，最坏的情况会分治到只剩下一个数值，那么我们执行的节点数就是从树根到叶子所经过的节点，每一层执行一个，直到最后一层：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023120324903.png" alt="image-20221023120324903"></p><p>递归调用最终的规模为 1，即 n&#x2F;2x&#x3D;1，则x&#x3D;logn。假设阴影部分是搜索经过的路径，一共经过了 logn 个节点，也就是说递归调用了 logn 次。</p><p>因此，二分搜索递归算法的空间复杂度为 O(logn)。</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><h3 id="算法设计：-1"><a href="#算法设计：-1" class="headerlink" title="算法设计："></a>算法设计：</h3><p>合并排序是采用分治策略实现对 n 个元素进行排序的算法，是分治法的一个典型应用和完美体现。它是一种平衡、简单的二分分治策略，过程大致分为：</p><ul><li>分解—将待排序元素分成大小大致相同的两个子序列。</li><li>治理—对两个子序列进行合并排序。</li><li>合并—将排好序的有序子序列进行合并，得到最终的有序序列。</li></ul><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023123323025.png" alt="image-20221023123323025"></p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li><p>合并操作：</p><p>设置 3 个工作指针 i、j、k（整型数）和一个辅助数组 B[]。其中，i 和 j 分别指向两个待排序子序列中当前待比较的元素，k 指向辅助数组 B[]中待放置元素的位置。比较 A[i]和A[j]，将较小的赋值给 B[k]，同时相应指针向后移动。如此反复，直到所有元素处理完毕。最后把辅助数组 B 中排好序的元素复制到 A 数组中：</p><p>第 1 次比较 A[i]&#x3D;4 和 A[j]&#x3D;2，将较小元素 2 放入 B 数组中，j++，k++：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023124616377.png" alt="image-20221023124616377"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//按从小到大存放到辅助数组B[]中</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>           B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">else</span>           B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当j&gt;high 了，while 循环结束，但 A 数组还剩有元素（i≤mid）怎么办呢？直接放置到 B 数组就可以了：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将数组中剩下的元素放置B中</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完整的合并程序如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>B<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>high<span class="token operator">-</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//申请一个辅助数组</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span> j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//按从小到大存放到辅助数组B[]中</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将数组中剩下的元素放置B中</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>low<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>B<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>递归形式的合并排序算法</p><p>将序列分为两个子序列，然后对子序列进行递归排序，再把两个已排好序的子序列合并成一个有序的序列。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//取中点</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对A[low:mid]中的元素合并排序</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对A[mid+1:high]中的元素合并排序</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//合并</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 3-2</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>B<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>high<span class="token operator">-</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//申请一个辅助数组</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span> j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//按从小到大存放到辅助数组B[]中</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将数组中剩下的元素放置B中</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>low<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>B<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//取中点</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对A[low:mid]中的元素合并排序</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对A[mid+1:high]中的元素合并排序</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//合并</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> A<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入数列中的元素个数n为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入数列中的元素："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>       cin<span class="token operator">>></span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"合并排序结果："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>       cout<span class="token operator">&lt;&lt;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-1"><a href="#算法复杂度分析：-1" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p><strong>时间复杂度：</strong></p><ul><li>分解：这一步仅仅是计算出子序列的中间位置，需要常数时间 O(1)。</li><li>解决子问题：递归求解两个规模为 n&#x2F;2 的子问题，所需时间为 2T(n&#x2F;2)。</li><li>合并：Merge 算法可以在 O(n)的时间内完成。</li></ul><p>所以总运行时间为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023130510198.png" alt="image-20221023130510198"></p><p>当 n&gt;1 时，可以递推求解：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023130523916.png" alt="image-20221023130523916"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup> ，则x &#x3D; logn ，那么</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023130559888.png" alt="image-20221023130559888"></p><p>合并排序算法的时间复杂度为 O(nlogn)。</p><p><strong>空间复杂度：</strong></p><p>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，每调用一个 Merge()，会分配一个适当大小的缓冲区，且退出时释放。最多分配大小为 n，所以空间复杂度为 O(n)。递归调用所使用的栈空间是O(logn)：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023130703054.png" alt="image-20221023130703054"></p><p>递归调用时占用的栈空间是递归树的深度，  n &#x3D; 2<sup>x</sup> ，则 x &#x3D; logn ，递归树的深度为 logn。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>它的基本思想是通过一组排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此使所有数据变成有序序列。</p></blockquote><h3 id="算法设计：-2"><a href="#算法设计：-2" class="headerlink" title="算法设计："></a>算法设计：</h3><p>快速排序的基本思想是基于分治策略的，其算法思想如下。</p><ol><li>分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分解为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。</li><li>治理：对两个子序列进行快速排序。</li><li>合并：将排好序的两个子序列合并在一起，得到原问题的解。</li></ol><p>设当前待排序的序列为 R[low:high]，其中 low≤high，如果序列的规模足够小，则直接进行排序，否则分 3 步处理。</p><ol><li><p>分解：在 R[low: high]中选定一个元素 R[pivot]，以此为标准将要排序的序列划分为两个序列 R[low:pivot−1]和 R[pivot+1:high]，并使用序列 R[low:pivot−1]中所有元素的值小于等于 R[pivot]，序列 R[pivot+1:high]中所有元素均大于 R[pivot]，此时基准元素已经位于正确的位置，它无需参加后面的排序：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023225113169.png" alt="image-20221023225113169"></p></li><li><p>治理：对于两个子序列 R[low:pivot−1]和 R[pivot+1:high]，分别通过递归调用快速排序算法来进行排序。</p></li><li><p>合并：由于对 R[low:pivot−1]和 R[pivot+1:high]的排序是原地进行的，所以在R[low:pivot−1]和 R[pivot+1:high]都已经排好序后，合并步骤无需做什么，序列 R[low:high]就已经排好序了。</p></li></ol><blockquote><p>如何分解是一个难题，因为如果基准元素选取不当，有可能分解成规模为 0 和 n−1 的两个子序列，这样快速排序就退化为冒泡排序了。</p></blockquote><p>例如序列（30，24，5，58，18，36，12，42，39），第一次选取 5 做基准元素，第二次选取 12 做基准元素。这样做的效率是最差的，最理想的状态是把序列分解为两个规模相当的子序列，那么怎么选择基准元素呢？一般来说，基准元素选取有以下几种方法：</p><ul><li>取第一个元素。</li><li>取最后一个元素。</li><li>取中间位置元素。</li><li>取第一个、最后一个、中间位置元素三者之中位数。</li><li>取第一个和最后一个之间位置的随机数 k（low≤k≤high），选 R[k]做基准元素。</li></ul><h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li><p>划分函数</p><p>我们编写划分函数对原序列进行分解，分解为两个子序列，以基准元素 pivot 为界，左侧子序列都比 pivot 小，右侧子序列都比 pivot 大。先从右向左扫描，找小于等于 pivot 的数，找到后两者交换（r[i]和 r[j]交换后 i++）；再从左向右扫描，找比基准元素大的数，找到后两者交换（r[i]和 r[j]交换后 j−−）。扫描交替进行，直到 i&#x3D;j 停止，返回划分的中间位置 i。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//划分函数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>high<span class="token punctuation">,</span>pivot<span class="token operator">=</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//基准元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//向左扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换后i+1右移一位</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//向右扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换 后j-1左移一位</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token comment">//返回最终划分完成后基准元素所在的位置</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>快速排序递归算法</p><p>首先对原序列执行划分，得到划分的中间位置 mid，然后以中间位置为界，分别对左半部分（low，mid−1）执行快速排序，右半部分（mid+1，high）执行快速排序。递归结束的条件是 low≥high。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//实现快排算法</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mid<span class="token operator">=</span><span class="token function">Partition</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//基准位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左区间递归快排</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右区间递归快排</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 3-3</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//划分函数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>high<span class="token punctuation">,</span>pivot<span class="token operator">=</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//基准元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//向左扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换后i+1右移一位</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//向右扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换 后j-1左移一位</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token comment">//返回最终划分完成后基准元素所在的位置</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//实现快排算法</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mid<span class="token operator">=</span><span class="token function">Partition</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//基准位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左区间递归快排</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右区间递归快排</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>N<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请先输入要排序的数据的个数："</span><span class="token punctuation">;</span>    cin<span class="token operator">>></span>N<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入要排序的数据："</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin<span class="token operator">>></span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"排序后的序列为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span> <span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-2"><a href="#算法复杂度分析：-2" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p><strong>最好时间复杂度：</strong></p><ul><li>分解：划分函数 Partition 需要扫描每个元素，每次扫描的元素个数不超过 n，因此时间复杂度为 O(n)。</li><li>解决子问题：在最理想的情况下，每次划分将问题分解为两个规模为 n&#x2F;2 的子问题，递归求解两个规模为 n&#x2F;2 的子问题，所需时间为 2T(n&#x2F;2)。</li><li>合并：因为是原地排序，合并操作不需要时间复杂度。</li></ul><p>所以总运行时间为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023231955341.png" alt="image-20221023231955341"></p><p>当 n&gt;1 时，可以递推求解：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023232011137.png" alt="image-20221023232011137"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup>，则x &#x3D; logn，则快速排序算法最好的时间复杂度为 O(nlogn)。</p><p><strong>空间复杂度：</strong></p><p>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，递归调用所使用的栈空间是 O(logn)。</p><p><strong>最坏时间复杂度：</strong></p><ul><li><p>分解：划分函数 Partition 需要扫描每个元素，每次扫描的元素个数不超过 n，因此时间复杂度为 O(n)。</p></li><li><p>解决子问题：在最坏的情况下，每次划分将问题分解后，基准元素的左侧（或者右侧）没有元素，基准元素的另一侧为 1 个规模为 n−1 的子问题，递归求解这个规模为 n−1 的子问题，所需时间为 T(n−1)。</p></li><li><p>合并：因为是原地排序，合并操作不需要时间复杂度。</p><p>所以总运行时间为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023233135333.png" alt="image-20221023233135333"></p><p>当 n&gt;1 时，可以递推求解如下：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023233158324.png" alt="image-20221023233158324"></p><p>快速排序算法最坏的时间复杂度为 O(n<sup>2</sup> )。</p></li></ul><p><strong>平均时间复杂度：</strong></p><p>假设我们划分后基准元素的位置在第 k（k&#x3D;1，2，…，n）个，则：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023233714369.png" alt="image-20221023233714369"></p><p>由归纳法可以得出，T(n)的数量级也为 O(nlogn)。快速排序算法平均情况下，时间复杂度为 O(nlogn)，递归调用所使用的栈空间也是 O(logn)。</p><h3 id="优化拓展：-1"><a href="#优化拓展：-1" class="headerlink" title="优化拓展："></a>优化拓展：</h3><p>从上述算法可以看出，每次交换都是在和基准元素进行交换，实际上没必要这样做，我们的目的就是想把原序列分成以基准元素为界的两个子序列，左侧子序列小于等于基准元素，右侧子序列大于基准元素。</p><p>那么有很多方法可以实现，我们可以从右向左扫描，找小于等于 pivot 的数 R[j]，然后从左向右扫描，找大于 pivot 的数 R[i]，让 R[i]和 R[j]交换，一直交替进行，直到 i 和 j 碰头为止，这时将基准元素与 R[i]交换即可。这样就完成了一次划分过程，但交换元素的个数少了很多。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Partition2</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//划分函数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>high<span class="token punctuation">,</span>pivot<span class="token operator">=</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//基准元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//向左扫描</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//向右扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i-1]和r[low]交换</span>        <span class="token keyword">return</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//返回最终划分完成后基准元素所在的位置</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[low]交换</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token comment">//返回最终划分完成后基准元素所在的位置</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><blockquote><p>在解决两个大的整数相乘时，我们可以将一个大的整数乘法分而治之，将大问题变成小问题，变成简单的小数乘法再进行合并。</p></blockquote><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><ul><li><p>分解：首先将 2 个大整数 a（n 位）、b（m 位）分解为两部分：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025105405840.png" alt="image-20221025105405840"></p><p>ah 表示大整数 a 的高位，al 表示大整数 a 的低位。bh 表示大整数 b 的高位，bl 表示大整数 b 的低位。</p><p>2 个大整数 a（n 位）、b（m 位）相乘转换成了 4 个乘法运算 *ah bh、 *ah bl、 *al bh、 *al bl ，而<strong>乘数的位数变为了原来的一半</strong>。</p></li><li><p>求解子问题</p><p>继续分解每个乘法运算，直到分解有一个乘数为 1 位数时停止分解，进行乘法运算并记录结果。</p></li><li><p>合并</p><p>将计算出的结果相加并回溯，求出最终结果。</p></li></ul><p>具体如何处理呢？</p><ol><li><p>首先将两个大数以字符串的形式输入，转换成数字后，<strong>倒序存储</strong>在数组 s[]中，l 用来表示数的长度，c 表示次幂。两个大数的初始次幂为 0。</p><blockquote><p>倒序存储的原因——因为乘法加法运算中有可能产生进位，倒序存储时可以让进位存储在数组的末尾</p></blockquote><ul><li>cp()函数：用于将一个 n 位的数分成两个 n&#x2F;2 的数并存储，记录它的长度和次幂。</li><li>mul()函数：用于将两个数进行相乘，不断地进行分解，直到有一个乘数为 1 位数时停止分解，进行乘法运算并记录结果。</li><li>add()函数：将分解得到的数进行相加合并。</li></ul></li><li><p>乘法运算：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025110347497.png" alt="image-20221025110347497"></p><p>3 首先和 1 相乘得到 3 存储在下面数组的第 0 位；然后 3 和 4 相乘得到 12，先存储先存储 12%10&#x3D;2，然后存储进位 12&#x2F;10&#x3D;1，这样乘法运算的结果是 321，<strong>注意是倒序</strong>，实际含义是 3×41&#x3D;123；两数相乘时，结果的次幂是两个乘数次幂之和，3×10<sup>3</sup> ×41×10<sup>3</sup> &#x3D;123×10<sup>6</sup>。</p></li></ol><h3 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li><p>数据结构</p><p>将两个大数以字符串的形式输入，然后定义结构体 Node，其中 s[]数组用于存储大数，注意是倒序存储！l 用于表示长度，c 表示次幂。两个大数的初始次幂为 0。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">char</span> sa<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> sb<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_Node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l<span class="token punctuation">;</span>            <span class="token comment">//代表字符串的长度</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Node<span class="token punctuation">,</span><span class="token operator">*</span>pNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>划分函数</p><p>其中，cp()函数用于将一个 n 位的数分成两个 n&#x2F;2 的数并存储，记录它的次幂。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">cp</span><span class="token punctuation">(</span>pNode src<span class="token punctuation">,</span> pNode des<span class="token punctuation">,</span> <span class="token keyword">int</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//src 表示待分解的数结点，des 表示分解后得到的数结点</span>    <span class="token comment">//st 表示从 src 结点数组中取数的开始位置，l 表示取数的长度</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>st<span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>st<span class="token operator">+</span>l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//从 src 结点数组中 st 位置开始，取 l 个数</span>    <span class="token punctuation">&#123;</span>        des<span class="token operator">-></span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将这些数放入到 des 结点的数组中</span>    <span class="token punctuation">&#125;</span>    des<span class="token operator">-></span>l <span class="token operator">=</span> l<span class="token punctuation">;</span><span class="token comment">//des 长度等于取数的长度</span>    des<span class="token operator">-></span>c <span class="token operator">=</span> st <span class="token operator">+</span> src<span class="token operator">-></span>c<span class="token punctuation">;</span>  <span class="token comment">//des 次幂等于开始取数的位置加上 src 次幂</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>乘法运算</p><p>定义的 mul()函数用于将两个数进行相乘，不断地进行分解，<strong>直到有一个乘数为 1 位时停止</strong>，让这两个数相乘，并记录结果回溯。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mul</span><span class="token punctuation">(</span>pNode pa<span class="token punctuation">,</span> pNode pb<span class="token punctuation">,</span> pNode ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> cc<span class="token punctuation">,</span> w<span class="token punctuation">;</span>    <span class="token keyword">int</span> ma <span class="token operator">=</span> pa<span class="token operator">-></span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">,</span> mb <span class="token operator">=</span> pb<span class="token operator">-></span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//长度除2</span>    Node ah<span class="token punctuation">,</span> al<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> bl<span class="token punctuation">;</span>    Node t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">,</span> t4<span class="token punctuation">,</span> z<span class="token punctuation">;</span>    pNode temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ma <span class="token operator">||</span> <span class="token operator">!</span>mb<span class="token punctuation">)</span> <span class="token comment">//如果其中个数为1</span>    <span class="token punctuation">&#123;</span>    <span class="token comment">//如果!ma 说明 ma=0，即 a 的长度为 1，该乘数为 1 位数</span>    <span class="token comment">//如果!mb 说明 mb=0，即 b 的长度为 1，该乘数为 1 位数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ma<span class="token punctuation">)</span>   <span class="token comment">//如果a串的长度为1，pa,pb交换，pa的长度大于等于pb的长度</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> pa<span class="token punctuation">;</span>            pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>            pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans<span class="token operator">-></span>c <span class="token operator">=</span> pa<span class="token operator">-></span>c <span class="token operator">+</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>        w <span class="token operator">=</span> pb<span class="token operator">-></span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//此时的进位为c</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pa<span class="token operator">-></span>l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>w<span class="token operator">*</span>pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            cc<span class="token operator">=</span> <span class="token punctuation">(</span>w<span class="token operator">*</span>pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>            ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> cc<span class="token punctuation">;</span> <span class="token comment">//如果到最后还有进位，则存入结果</span>        ans<span class="token operator">-></span>l <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token comment">//记录结果的长度</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//分治的核心</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> ma<span class="token punctuation">,</span> pa<span class="token operator">-></span>l<span class="token operator">-</span>ma<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//先分成4部分al,ah,bl,bh</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ma<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> mb<span class="token punctuation">,</span> pb<span class="token operator">-></span>l<span class="token operator">-</span>mb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//分成4部分相乘</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t4<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> ans<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并函数</p><p>add()函数将分解得到的数进行相加合并。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>pNode pa<span class="token punctuation">,</span> pNode pb<span class="token punctuation">,</span> pNode ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>cc<span class="token punctuation">,</span>k<span class="token punctuation">,</span>palen<span class="token punctuation">,</span>pblen<span class="token punctuation">,</span>len<span class="token punctuation">;</span>    <span class="token keyword">int</span> ta<span class="token punctuation">,</span> tb<span class="token punctuation">;</span>    pNode temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pa<span class="token operator">-></span>c<span class="token operator">&lt;</span>pb<span class="token operator">-></span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//保证Pa的次幂大</span>    <span class="token punctuation">&#123;</span>        temp <span class="token operator">=</span> pa<span class="token punctuation">;</span>        pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>        pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ans<span class="token operator">-></span>c <span class="token operator">=</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    cc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    palen<span class="token operator">=</span>pa<span class="token operator">-></span>l <span class="token operator">+</span> pa<span class="token operator">-></span>c<span class="token punctuation">;</span>    pblen<span class="token operator">=</span>pb<span class="token operator">-></span>l <span class="token operator">+</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>palen<span class="token operator">></span>pblen<span class="token punctuation">)</span>        len<span class="token operator">=</span>palen<span class="token punctuation">;</span>    <span class="token keyword">else</span>        len<span class="token operator">=</span>pblen<span class="token punctuation">;</span>    k<span class="token operator">=</span>pa<span class="token operator">-></span>c <span class="token operator">-</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token operator">-</span>ans<span class="token operator">-></span>c<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//结果的长度最长为pa，pb之中的最大长度减去最低次幂</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">)</span>            ta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            ta <span class="token operator">=</span> pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//次幂高的补0，大于低的长度后与0进行计算</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>pb<span class="token operator">-></span>l<span class="token punctuation">)</span>            tb <span class="token operator">=</span> pb<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            tb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>pa<span class="token operator">-></span>l<span class="token operator">+</span>k<span class="token punctuation">)</span>            ta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ta <span class="token operator">+</span> tb <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token punctuation">(</span>ta <span class="token operator">+</span> tb <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>        ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> cc<span class="token punctuation">;</span>    ans<span class="token operator">-></span>l <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 3-4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">char</span> sa<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> sb<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_Node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l<span class="token punctuation">;</span>            <span class="token comment">//代表字符串的长度</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Node<span class="token punctuation">,</span><span class="token operator">*</span>pNode<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">cp</span><span class="token punctuation">(</span>pNode src<span class="token punctuation">,</span> pNode des<span class="token punctuation">,</span> <span class="token keyword">int</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>st<span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>st<span class="token operator">+</span>l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        des<span class="token operator">-></span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    des<span class="token operator">-></span>l <span class="token operator">=</span> l<span class="token punctuation">;</span>    des<span class="token operator">-></span>c <span class="token operator">=</span> st <span class="token operator">+</span> src<span class="token operator">-></span>c<span class="token punctuation">;</span>  <span class="token comment">//次幂</span><span class="token punctuation">&#125;</span><span class="token comment">/*分治法 大数乘法X = A*10^n + BY = C*10^m + DX*Y = A*C*10^(n+m) + A*D*10^n + B*C*10^m + B*D*/</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>pNode pa<span class="token punctuation">,</span> pNode pb<span class="token punctuation">,</span> pNode ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>cc<span class="token punctuation">,</span>k<span class="token punctuation">,</span>palen<span class="token punctuation">,</span>pblen<span class="token punctuation">,</span>len<span class="token punctuation">;</span>    <span class="token keyword">int</span> ta<span class="token punctuation">,</span> tb<span class="token punctuation">;</span>    pNode temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pa<span class="token operator">-></span>c<span class="token operator">&lt;</span>pb<span class="token operator">-></span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//保证Pa的次幂大</span>    <span class="token punctuation">&#123;</span>        temp <span class="token operator">=</span> pa<span class="token punctuation">;</span>        pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>        pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ans<span class="token operator">-></span>c <span class="token operator">=</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    cc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    palen<span class="token operator">=</span>pa<span class="token operator">-></span>l <span class="token operator">+</span> pa<span class="token operator">-></span>c<span class="token punctuation">;</span>    pblen<span class="token operator">=</span>pb<span class="token operator">-></span>l <span class="token operator">+</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>palen<span class="token operator">></span>pblen<span class="token punctuation">)</span>        len<span class="token operator">=</span>palen<span class="token punctuation">;</span>    <span class="token keyword">else</span>        len<span class="token operator">=</span>pblen<span class="token punctuation">;</span>    k<span class="token operator">=</span>pa<span class="token operator">-></span>c <span class="token operator">-</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token operator">-</span>ans<span class="token operator">-></span>c<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//结果的长度最长为pa，pb之中的最大长度减去最低次幂</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">)</span>            ta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            ta <span class="token operator">=</span> pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//次幂高的补0，大于低的长度后与0进行计算</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>pb<span class="token operator">-></span>l<span class="token punctuation">)</span>            tb <span class="token operator">=</span> pb<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            tb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>pa<span class="token operator">-></span>l<span class="token operator">+</span>k<span class="token punctuation">)</span>            ta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ta <span class="token operator">+</span> tb <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token punctuation">(</span>ta <span class="token operator">+</span> tb <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>        ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> cc<span class="token punctuation">;</span>    ans<span class="token operator">-></span>l <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">mul</span><span class="token punctuation">(</span>pNode pa<span class="token punctuation">,</span> pNode pb<span class="token punctuation">,</span> pNode ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> cc<span class="token punctuation">,</span> w<span class="token punctuation">;</span>    <span class="token keyword">int</span> ma <span class="token operator">=</span> pa<span class="token operator">-></span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">,</span> mb <span class="token operator">=</span> pb<span class="token operator">-></span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//长度除2</span>    Node ah<span class="token punctuation">,</span> al<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> bl<span class="token punctuation">;</span>    Node t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">,</span> t4<span class="token punctuation">,</span> z<span class="token punctuation">;</span>    pNode temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ma <span class="token operator">||</span> <span class="token operator">!</span>mb<span class="token punctuation">)</span> <span class="token comment">//如果其中个数为1</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ma<span class="token punctuation">)</span>   <span class="token comment">//如果a串的长度为1，pa,pb交换，pa的长度大于等于pb的长度</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> pa<span class="token punctuation">;</span>            pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>            pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans<span class="token operator">-></span>c <span class="token operator">=</span> pa<span class="token operator">-></span>c <span class="token operator">+</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>        w <span class="token operator">=</span> pb<span class="token operator">-></span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//此时的进位为c</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pa<span class="token operator">-></span>l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>w<span class="token operator">*</span>pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            cc<span class="token operator">=</span> <span class="token punctuation">(</span>w<span class="token operator">*</span>pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>            ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> cc<span class="token punctuation">;</span> <span class="token comment">//如果到最后还有进位，则存入结果</span>        ans<span class="token operator">-></span>l <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token comment">//记录结果的长度</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//分治的核心</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> ma<span class="token punctuation">,</span> pa<span class="token operator">-></span>l<span class="token operator">-</span>ma<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//先分成4部分al,ah,bl,bh</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ma<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> mb<span class="token punctuation">,</span> pb<span class="token operator">-></span>l<span class="token operator">-</span>mb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//分成4部分相乘</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t4<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> ans<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node ans<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入大整数 a:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> sa<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入大整数 b:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> sb<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>l<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//sa,sb以字符串进行处理</span>    b<span class="token punctuation">.</span>l<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> a<span class="token punctuation">.</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        a<span class="token punctuation">.</span>s<span class="token punctuation">[</span>z<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>             <span class="token comment">//倒向存储</span>    a<span class="token punctuation">.</span>c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> b<span class="token punctuation">.</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        b<span class="token punctuation">.</span>s<span class="token punctuation">[</span>z<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> sb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最终结果为："</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> ans<span class="token punctuation">.</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">.</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">//ans用来存储结果，倒向存储</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-3"><a href="#算法复杂度分析：-3" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p><strong>时间复杂度：</strong></p><p>我们假设大整数 a、b 都是 n 位数，根据分治策略， ab 相乘将转换成了 4 个乘法运算ah×bh、ah×bl、al×bh、al×bl，而<strong>乘数的位数变为了原来的一半</strong>。直到最后递归分解到其中一个乘数为 1 位为止，每次递归就会使数据规模减小为原来的一半。假设两个 n 位大整数相乘的时间复杂度为 T(n)，则：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025113307465.png" alt="image-20221025113307465"></p><p>当 n&gt;1 时，可以递推求解如下：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025113650106.png" alt="image-20221025113650106"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup> 则x &#x3D; logn，所以大整数乘法的时间复杂度为O(n<sup>2</sup>)</p><p><strong>空间复杂度：</strong></p><p>程序中变量占用了一些辅助空间，都是常数阶的，但合并时结点数组占用的辅助空间为 O(n)，递归调用所使用的栈空间是 O(logn)，大整数乘法的空间复杂度为O(n<sup>2</sup>)</p><h3 id="优化拓展：-2"><a href="#优化拓展：-2" class="headerlink" title="优化拓展："></a>优化拓展：</h3><p>如果两个大整数都是 n 位数，那么有：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114210441.png" alt="image-20221025114210441"></p><p>还记得快速算出 1+2+3+…+100 的小高斯吗？这孩子长大以后更聪明，他把 4 次乘法运算变成了 3 次乘法：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114312929.png" alt="image-20221025114312929"></p><p>这样公式中，只需要进行 3 次乘法。</p><p>那么时间复杂度为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114401541.png" alt="image-20221025114401541"></p><p>当 n&gt;1 时，可以递推求解如下：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114416856.png" alt="image-20221025114416856"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup> ，则 x &#x3D; logn，那么有：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114522459.png" alt="image-20221025114522459"></p><p>优化改进后的大整数乘法的时间复杂度从 O(n2 )降为 O(n1.59 )，这是一个巨大的改进！</p><p>但是需要注意：在上面的公式中，A 和 B 必须 2<sup>n</sup> 位。很容易证明，如果不为 2<sup>n</sup>，那么 A或者 B 在分解过程中必会出现奇数，那么 a<em>c 和（（a−b）（d−c）+a</em>c+b*d）的次幂就有可能不同，无法变为 3 次乘法了，解决方法也很简单，只需要补齐位数即可，在数前（高位）补 0。</p><h2 id="分治算法复杂度求解秘籍"><a href="#分治算法复杂度求解秘籍" class="headerlink" title="分治算法复杂度求解秘籍"></a>分治算法复杂度求解秘籍</h2><p>分治法的道理非常简单，就是把一个大的复杂问题分为 a（a&gt;1）个形式相同的子问题，这些子问题的规模为 n&#x2F;b，如果分解或者合并的复杂度为 f(n)，那么总的时间复杂度可以表示为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114832010.png" alt="image-20221025114832010"></p><p>上面的求解方式都是递推求解，写出其递推式，最后求出结果。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-图</title>
      <link href="/2022/10/03/shu-ju-jie-gou-ru-men-tu/"/>
      <url>/2022/10/03/shu-ju-jie-gou-ru-men-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote><p>图形结构是<strong>多对多</strong>的关系，任何两个数据元素都可能有关系，每个节点可以有多个前驱和后继。</p></blockquote><h3 id="图的基本术语"><a href="#图的基本术语" class="headerlink" title="图的基本术语"></a>图的基本术语</h3><p>图通常用一个二元组 G&#x3D;&lt;V, E&gt;表示，V 表示顶点集，E 表示边集。</p><ul><li>|V|表示顶点集中元素的个数，即顶点数，n 个顶点的图称为 n 阶图。</li><li>|E|表示边集中元素的个数，即边数。</li></ul><blockquote><p>注意：顶点集 V 和边集 E 均为有限集合，其中 <strong>E 可以为空集，V 不可以为空集</strong>，但在运算中，可能产生 V 为空集。</p><p><strong>V 为空集</strong>的图称为空图，记为φ 。</p></blockquote><ol><li><p><strong>无向图</strong></p><p>若图 G 中每条边都是没有方向的，则称为无向图。</p><p>每条边都是两个顶点组成的无序对，例如顶点 v<sub>1</sub> 和顶点 v<sub>3</sub> 之间的边，记为（v<sub>1</sub> , v<sub>3</sub>）或（v<sub>3</sub> , v<sub>1</sub>）</p></li><li><p><strong>有向图</strong></p><p>若图 G 中每条边都是有方向的，则称为有向图。</p><p>有向边也称为<strong>弧</strong>，每条弧都是由两个顶点组成的有序对，例如从顶点 v<sub>1</sub> 到顶点 v<sub>3</sub> 的弧，记为&lt;v<sub>1</sub>，v<sub>3</sub> &gt;，v<sub>1</sub> 称为弧尾，v<sub>3</sub> 称为弧头。</p></li><li><p><strong>简单图</strong></p><p>既不含平行边也不含环的图称为简单图。</p><ul><li><p>平行边：</p><p>在无向图中，若关联一对顶点的无向边多于一条，则称这些边为平行边，平行边的条数称为重数；</p><p>在有向图中，若关联一对顶点的有向边多于一条，并且这些边的始点和终点相同（<strong>方向一致</strong>），则称这些边为平行边</p><blockquote><p>含有平行边的图称为多重图。平行边的条数称为重数。</p></blockquote></li><li><p>自环：</p><p>自环是指一条边关联的两个顶点为同一个顶点，也就是说自己到自己有一条边。</p></li></ul></li><li><p><strong>完全图</strong></p><p>在无向图中，若<strong>任意两个点都有一条边</strong>，则该图称为无向完全图。</p><blockquote><p>含有 n 个顶点的无向图，每个顶点到其他的 n−1 个顶点都有边，一共有 n(n−1)&#x2F;2 条边。</p></blockquote><p>在有向图中，若<strong>任意两个点都有两条方向相反的两条弧</strong>，则该图称为有向完全图。</p><blockquote><p>含有 n 个顶点的有向图，每个顶点发出 n−1 条边，并且进来 n−1 条边，一共有 n(n−1)条边。</p></blockquote></li><li><p><strong>稀疏图和稠密图</strong></p><p>有很少边或弧的图称为稀疏图，反之，则称为稠密图。这是一个非常模糊的概念，很难讲多少算稀疏，多少算稠密，一般来说，若图 G 满足|E|&lt;|V|×log|V|，则称 G 为稀疏图。</p></li><li><p><strong>网</strong></p><p>在实际应用中，经常在边上标注如距离、时间、耗费等数值，该数值称为边的权值。带权的图称为网。</p></li><li><p><strong>邻接和关联</strong></p><p>邻接是指<strong>顶点和顶点</strong>之间的关系，关联是指<strong>边和顶点</strong>之间的关系。</p><p>有边&#x2F;弧相连的两个顶点之间的关系，如无向边(v<sub>i</sub>, v<sub>j</sub>)，则称 v<sub>i</sub> 和 v<sub>j</sub> 互为邻接点；有向边&lt;v<sub>i</sub>, v<sub>j</sub>&gt;，则称 v<sub>i</sub> 邻接到v<sub>j</sub>，v<sub>j</sub> 邻接于 v<sub>i</sub>。若存在(v<sub>i</sub>, v<sub>j</sub>)或&lt;v<sub>i</sub>, v<sub>j</sub>&gt;，则称该边或弧关联于 v<sub>i</sub> 和 v<sub>j</sub>，</p></li><li><p><strong>顶点的度</strong></p><p>顶点的度是指与该顶点相关联的边的数目，记为 TD(v)。</p><p><strong>握手定理</strong>：<strong>度数之和等于边数的两倍</strong></p><p><img src="/2022/10/03/shu-ju-jie-gou-ru-men-tu/image-20221003105732197.png" alt="image-20221003105732197"></p><p>如果在计算度数时，每算一度划一条线，则可以看出每条边被计算了两次。</p><p>在有向图中，顶点的度又分为入度和出度：</p><ul><li>顶点 v 的入度是以 v 为终点的有向边的条数，记作 ID(v)，即进来的边数。</li><li>顶点 v 的出度是以 v 为始点的有向边的条数，记作 OD(v)，即发出的边数。</li></ul><p>顶点 v 的度等于其入度和出度之和，即：</p><p><img src="/2022/10/03/shu-ju-jie-gou-ru-men-tu/image-20221003105848735.png" alt="image-20221003105848735"></p><p>在有向图中，所有顶点的入度之和等于出度之和，又因为所有顶点度数之和等于边的 2倍，因此：</p><p><img src="/2022/10/03/shu-ju-jie-gou-ru-men-tu/image-20221003110514033.png" alt="image-20221003110514033"></p></li><li><p><strong>路径、路径长度和距离</strong></p><p>路径：接续的边的顶点构成的序列。</p><p>路径长度：路径上边或弧的数目。</p><p>距离：从顶点到另一顶点的最短路径长度。</p></li><li><p><strong>回路（环）、简单路径和简单回路</strong></p><p>回路（环）：第一个顶点和最后一个顶点相同的路径。</p><p>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。</p><p>简单回路：除路径起点和终点相同外，其余顶点均不相同的路径。</p></li><li><p><strong>子图与生成子图</strong></p><p>子图：设有两个图 G&#x3D;(V, E)、G1 &#x3D;(V1 , E1 )，若 V1⊆V，E1 ⊆ E，则称 G1 是 G 的子图。从图中选择若干个顶点、若干条边构成的图称为原图的子图。</p><p>生成子图：从图中选择所有顶点，若干条边构成的图称为原图的生成子图。</p></li><li><p><strong>连通图和连通分量</strong></p><p>连通图：在无向图中，如果顶点 v i 到 v j 有路径，则称 v i 和 vj 是连通的。</p><p>如果图中<strong>任何两个顶点都是连通的</strong>，则称 G 为连通图。</p><p>连通分量：无向图 G 的极大连通子图称为 G 的连通分量。极大连通子图意思是：该子图是 G 的连通子图，<strong>如果再加入一个顶点，该子图不连通</strong>。</p><blockquote><p>对于连通图，其连通分量就是它自己；对于非连通图，则有 2 个以上连通分量。</p></blockquote></li><li><p><strong>强连通图和强连通分量</strong></p><p>强连通图：<strong>在有向图中</strong>，如果图中任何两个顶点 v i 到 v j 有路径，且 v j 到 v i 也有路径，则称 G 为强连通图。</p><p>强连通分量：有向图 G 的极大强连通子图称为 G 的强连通分量。极大强连通子图意思是：该子图是 G 的强连通子图，如果再加入一个顶点，该子图不再是强连通的。</p></li><li><p><strong>树和有向树</strong></p><p>从图论的角度来看，树是一个无环连通图。</p><p>一个含 n 个顶点、m 条边的图，只要满足下列 5 个条件之一就是一棵树：</p><ul><li>G 是连通图且 m&#x3D;n−1；</li><li>G 是连通图且无环；</li><li>G 是连通图，但删除任意一条边就不连通；</li><li>G 是无环图，但添加任意一条边就会产生环；</li><li>G 中任意一对顶点之间仅存在一条简单路径。</li></ul><blockquote><p>有向树：<strong>只有一个顶点入度为 0，其余顶点入度均为 1 的有向图</strong></p></blockquote></li><li><p><strong>生成树和生成森林</strong></p><p>极小连通子图：该子图是 G 的连通子图，在<strong>该子图中删除任何一条边，该子图不再连通</strong>。</p><p>生成树：包含无向图 G <strong>所有顶点的极小连通子图</strong>。</p><blockquote><p>因为生成树包含所有顶点，因此只有连通图才有生成树，而非连通图，每一个连通分量会有一棵生成树。</p></blockquote><p>生成森林：对非连通图，由各个连通分量的生成树组成的集合。</p></li><li><p><strong>二分图</strong></p><p>二分图，又称为二部图，是图论中的一种特殊模型。设 G&#x3D;&lt;V，E&gt;是一个无向图，如果顶点集 V 可分割为两个互不相交的子集 V1、V2，并且图中的每条边(i, j)所关联的两个顶点 i 和 j 分别属于这两个不同的顶点集(i∈V1 , j∈V2 )，则称图 G 为二分图：</p><p><img src="/2022/10/03/shu-ju-jie-gou-ru-men-tu/image-20221003114408992.png" alt="image-20221003114408992"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英雄联盟大乱斗攻略</title>
      <link href="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/"/>
      <url>/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="英雄联盟大乱斗攻略"><a href="#英雄联盟大乱斗攻略" class="headerlink" title="英雄联盟大乱斗攻略"></a>英雄联盟大乱斗攻略</h2><blockquote><p><strong>版本：12.16版本 2022.08.25</strong></p></blockquote><h3 id="乱斗须知："><a href="#乱斗须知：" class="headerlink" title="乱斗须知："></a>乱斗须知：</h3><ol><li>大乱斗生态里<strong>战士最高</strong>，<strong>法师最低</strong>、<strong>射手是后期的绝对保障</strong>。原因是法师后期刮痧（只有少数法师具有高爆发），丢丢怪一冲就烂。</li><li>但是在路人局里，丢丢怪<strong>前期压制力高</strong>、<strong>操作简单</strong>、<strong>通用性强</strong>，因此胜率明显更高。</li><li>大乱斗作为一个随机模式，一个英雄的胜率并不完全等于其强度。</li></ol><h3 id="BP环节："><a href="#BP环节：" class="headerlink" title="BP环节："></a>BP环节：</h3><ol><li>（<strong>优先</strong>）确保己方清线没有问题。——<strong>线权优先</strong><ul><li>线权是推塔守塔的基础，尤其是“炮车线”，这时候可以用各种手段压制对面不能轻易守塔（越塔，死歌去送，大树大招，兰博大招等），配合“炮车线”能把塔打到半血以下甚至推掉。</li><li>部分英雄需要兵线与技能配合：亚索、永恩、狗头、小法、格温、刀妹、吸血鬼、大树</li></ul></li><li>（<strong>优先</strong>）确保己方控制没有问题。——<strong>团战优先</strong></li><li>确保OB英雄别同时出场太多。——类似发育型提莫、天使，观战型寡妇、小丑</li><li>尽量倾向：前排有威胁、射手有消耗、法师有控制<ul><li>前排有威胁指的是敌人不可能无视你越过你去攻击你的队友。只要能让对面优先针对你，那你就是合格的前排。</li><li>射手有消耗指的是射手可以随时随地打输出，不必强迫自家前排去开团自己再开始A人。</li><li>法师有控制法师几乎全有控制，所以法师的控制指的是要有“摸奖型控制”。摸奖型控制不需要在特定的情况下使用，决定了队伍绝对的先手权。</li></ul></li></ol><blockquote><p>注意：</p><ul><li><strong>前排不一定是坦克</strong>，类似死歌、冰女也算前排。</li><li><strong>前排≥2；1≤ADC≤2；法师+辅助≤2</strong>。特殊情况：1ADC或4ADC。</li></ul></blockquote><hr><p><strong>大乱斗前排基本玩法：</strong></p><ol><li>给己方后排当保镖，永不先手，谁过来打谁，比如盖伦布隆。——仅限己方后排比对方后排强的时候</li><li>追着对方后排控，即便打不死也要让对方无法输出，而且确保自己也不会轻易死。——对方后排比己方后排强的时候</li><li>打先手直接进人堆强拉仇恨，比如石头木木。——当己方团战更强时</li><li>让己方后排拉仇恨，对面切后排时直接忽视，躲草丛强冲对方后排，比如瑞雯剑圣。——当自己是个很强的输出型近战时</li></ol><h3 id="大乱斗专属机制BUFF："><a href="#大乱斗专属机制BUFF：" class="headerlink" title="大乱斗专属机制BUFF："></a>大乱斗专属机制BUFF：</h3><p><strong>远程削弱：</strong>来自1000码外的英雄伤害会削减15%，不包含大招和DOT伤害。</p><p><strong>治疗机制：</strong>友军治疗减少50%。血包回复8%已损状态，2.5s的光环回复16%已损状态。</p><p><strong>近战福利：</strong>近战直接获得10点魔抗。近战对防御塔造成20%额外伤害。</p><p><strong>兵线机制：</strong>AOE伤害对小兵仅造成75%伤害。兵线生成效率为1波&#x2F;(25s-13s)。</p><p><strong>骰子机制：</strong>Points&#x3D;65+1.5\times 点数满250点则提供一个骰子（可积累最多2个）。国服乱斗提供：3周周免 + 4永久 &#x3D; 49英雄</p><h3 id="嚎哭深渊光环："><a href="#嚎哭深渊光环：" class="headerlink" title="嚎哭深渊光环："></a>嚎哭深渊光环：</h3><ol><li>+70召唤师技能急速</li><li>每秒回复0.15%最大法力值</li><li>每秒获得5点经验</li><li>友军治疗减少50%</li><li>附近非你击杀的敌方小兵提供6金币</li><li>近战英雄，获得10点额外魔抗</li><li>近战英雄，普通攻击对炮车和超级兵造成额外20%伤害</li><li>近战英雄，对建筑物造成额外20%伤害</li><li>所有英雄，对建筑物造成0~25%额外伤害（随时间增长，于18：00达到最大值）。<br>——8.9条不会同时生效，仅会取较大值</li><li>来自1000码外的英雄伤害会减少15%，不包括DOT和大招伤害</li></ol><h3 id="兵线机制："><a href="#兵线机制：" class="headerlink" title="兵线机制："></a>兵线机制：</h3><ol><li><p>兵线每隔（25秒~13秒）出发一波。</p><p>——该时间随着游戏时间增加而缩短。<br>——送头回家之前要计算兵线的进程。<br>（两个高地之间走路需要耗时22s）</p></li><li><p>兵线的移动速度变化是（325~425），基于游戏时间增长。</p></li><li><p>每“第3波”兵线会伴随1个炮车，炮车会探索1100码内的陷阱。</p><p>发现陷阱后4秒内，如果没有发现新的陷阱，炮车会失去这个技能。</p></li><li><p>小兵仅会受到75%的群体伤害。</p></li><li><p>受到英雄伤害后，超过<strong>15s</strong>送塔才算塔杀</p></li></ol><h3 id="赏金机制："><a href="#赏金机制：" class="headerlink" title="赏金机制："></a>赏金机制：</h3><ol><li>击杀提供180金币。</li><li>助攻者平分90金币的50%~100%（基于游戏时间）。</li><li>一血提供额外50%的击杀和助攻助攻金币。</li><li>终结额外赏金对应：2连杀+150；3连杀+300；4连杀+375；5连杀+450；6连杀+600。</li><li>和峡谷一样，死多了也会掉身价（指低于180）。</li></ol><p>从计算中可以看出来，击杀之后被终结的话，双方的经济其实是差不多的。所以，大乱斗想赢游戏，绝对不是靠杀人，而是靠兵线和防御塔的运营。</p><h3 id="血包机制："><a href="#血包机制：" class="headerlink" title="血包机制："></a>血包机制：</h3><ol><li><p>捡血包的人会回复8%的已损失血量和蓝量。</p></li><li><p>光环在2.5s后落下，范围内的人会回复16%的已损失血量和蓝量。</p><p>根据计算，如果已损失血量为1000，两段之和比第二段仅仅多回复67血。<br>前期谁吃无所谓不用让，重要的是大家一起吃就好。</p></li><li><p>龙女吃到敌方半区的治疗光环，会永久获得双抗和怒气恢复速度。（1护甲+1魔抗+0.05怒气恢复速度）</p></li></ol><h3 id="符文调整："><a href="#符文调整：" class="headerlink" title="符文调整："></a>符文调整：</h3><p>——削弱——</p><p>气定神闲：回复量由20%最大法力值<strong>降低</strong>至10%；对英雄造成伤害回蓝</p><p>黑暗收割：每层伤害由5<strong>降低</strong>至2</p><p>凯旋：回复量由12%已损失生命值<strong>降低</strong>至6%；金币由20<strong>降低</strong>至10</p><p>爆破： 充能伤害由（100+35%最大生命值）<strong>降低</strong>至（50+25%最大生命值）</p><p>——增强——</p><p>不灭之握：近战英雄获得的生命值由5<strong>提高</strong>到10；远程英雄获得的生命值由3<strong>提高</strong>到6</p><p>电刑：CD由25-20s<strong>降低</strong>至15-10s</p><p>血之滋味：CD由20s<strong>降低</strong>至15s</p><p>无效法球：CD由60s<strong>降低</strong>至30s</p><p>风暴聚集：自变量由10min<strong>减少</strong>至6min</p><p>调节： 生效时间由12min<strong>降低</strong>至8min</p><p>过度生长：获得的生命值由3<strong>提高</strong>到5；获得3.5%额外最大生命值的要求数量由120<strong>降低</strong>至80</p><p>神奇之鞋：生效时间由（12min-45s击杀）<strong>降低</strong>至（8min-30s击杀）</p><h3 id="符文选择："><a href="#符文选择：" class="headerlink" title="符文选择："></a>符文选择：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921103913715.png" alt="image-20220921103913715"></p><h3 id="符文通用模板："><a href="#符文通用模板：" class="headerlink" title="符文通用模板："></a>符文通用模板：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921104135297.png" alt="image-20220921104135297"></p><h3 id="出装通用模板："><a href="#出装通用模板：" class="headerlink" title="出装通用模板："></a>出装通用模板：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921104555438.png" alt="image-20220921104555438"></p><h3 id="装备选择雷区："><a href="#装备选择雷区：" class="headerlink" title="装备选择雷区："></a>装备选择雷区：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921104706893.png" alt="image-20220921104706893"></p><p>——在全联盟回血都被砍的情况下，振奋的百分之25回血回盾是很不错的装备，适用于被动回血回盾或者小技能回血回盾的英雄，虽然说没有自然之力魔抗强但是续航能力会高上不少（例如鳄鱼）</p><p>——战士装备可选：咳血+血手&#x2F;死舞+振奋</p><h3 id="大乱斗黄金节点："><a href="#大乱斗黄金节点：" class="headerlink" title="大乱斗黄金节点："></a>大乱斗黄金节点：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921105115254.png" alt="image-20220921105115254"></p><h3 id="大乱斗送死时机："><a href="#大乱斗送死时机：" class="headerlink" title="大乱斗送死时机："></a>大乱斗送死时机：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921105220294.png" alt="image-20220921105220294"></p><blockquote><p>转载于<a href="https://tieba.baidu.com/p/7993064213?pn=1">【图片】【12.16】大乱斗攻略&amp;全英雄玩法分析～【极地大乱斗吧】_百度贴吧 (baidu.com)</a>，作者果知芽。</p></blockquote><p>附上最近打的几把乱斗：</p><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220922174649602.png" alt="image-20220922174649602"></p><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220922174732483.png" alt="image-20220922174732483"></p><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220922174810604.png" alt="image-20220922174810604"></p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门--树</title>
      <link href="/2022/09/19/shu-ju-jie-gou-ru-men-shu/"/>
      <url>/2022/09/19/shu-ju-jie-gou-ru-men-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>可以从集合论和图论两个角度定义树。本章从集合论的角度递归定义树，后续将从图论的角度再次定义树，读者可以体会两种定义的不同之处。</p><blockquote><p>树（tree）是 n（n≥0）个节点的有限集合，当 n&#x3D;0 时，为空树；n&gt;0 时，为非空树。</p></blockquote><p>任意一棵非空树，满足以下两个条件：</p><ol><li><strong>有且仅有一个称为根的节点</strong></li><li><strong>除根节点以外，其余节点可分为 m（m＞0）个互不相交的有限集 T1 , T2 , …, Tm</strong>，其中每一个集合本身又是一棵树，并且称为根的子树（subtree）</li></ol><p>与树相关的术语：</p><ul><li><p><strong>节点</strong>——节点包含数据元素及若干指向子树的分支信息。</p></li><li><p><strong>节点的度</strong>——节点拥有的子树个数。</p></li><li><p><strong>树的度</strong>——树中节点的最大度数。</p></li><li><p><strong>终端节点</strong>——度为 0 的节点，又称为叶子。</p></li><li><p><strong>分支节点</strong>——度大于 0 的节点。除了叶子都是分支节点。</p></li><li><p><strong>内部节点</strong>——除了树根和叶子都是内部节点。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919154441720.png" alt="image-20220919154441720"></p></li><li><p><strong>节点的层次</strong>——从根到该节点的层数（根节点为第 1 层）。</p></li><li><p><strong>树的深度（或高度）</strong>——指所有节点中最大的层数。例如，一棵树如图所示，根为第 1 层，根的子节点为第 2 层……该树的最大层次为 4，因此树的深度为 4。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919160646531.png" alt="image-20220919160646531"></p></li><li><p><strong>路径</strong>——树中两个节点之间所经过的节点序列。</p></li><li><p><strong>路径长度</strong>——两节点之间路径上经过的边数。例如，一棵树如图所示，D 到 A的路径为 D—B—A，D 到 A 的路径长度为 2。由于树中没有环，因此树中任意两个节点之间的路径都是唯一的。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919160705691.png" alt="image-20220919160705691"></p></li><li><p><strong>双亲、孩子</strong>——节点的子树的根称为该节点的孩子，反之，该节点为其孩子的双亲。</p></li><li><p><strong>兄弟</strong>——双亲相同的节点互称兄弟。</p></li><li><p><strong>堂兄弟</strong>——双亲是兄弟的节点互称堂兄弟。</p></li><li><p><strong>祖先</strong>——从该节点到树根经过的所有节点称为该节点的祖先。</p></li><li><p><strong>子孙</strong>——节点的子树中的所有节点都称为该节点的子孙。</p></li><li><p><strong>有序树</strong>——节点的各子树从左至右有序，不能互换位置。</p></li><li><p><strong>无序树</strong>——节点各子树可互换位置。</p></li><li><p><strong>森林</strong>——由 m（m≥0）棵不相交的树组成的集合。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919160717545.png" alt="image-20220919160717545"></p></li></ul><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>顺序存储采用一段连续的存储空间，因为树中节点的数据关系是一对多的逻辑关系，不仅要存储数据元素，<strong>还要存储它们之间的逻辑关系</strong>。</p><p>以下图为例，讲述三种顺序存储方法：双亲表示法、孩子表示法和双亲孩子表示法。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919161018120.png" alt="image-20220919161018120"></p><ol><li><p><strong>双亲表示法</strong></p><blockquote><p>双亲表示法，除了存储数据元素之外，还存储其双亲节点的存储位置下标，其中“−1”表示不存在。</p></blockquote><p>每一个节点有两个域，即数据域 data 和双亲域 parent：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919170529719.png" alt="image-20220919170529719"></p><p>树根 A 没有双亲，双亲记为−1，B、C、D 的双亲为 A，而 A 的存储位置下标为 0，因此，B、C、D 的双亲记为 0。同样，E、F 的双亲为 B，而 B 的存储位置下标为 1，因此，E、F 的双亲记为 1。同理，其他节点也这样存储。</p></li><li><p><strong>孩子表示法</strong></p><p>孩子表示法是指除了存储数据元素之外，还存储其所有孩子的存储位置下标。</p><p>A 有 3 个孩子 B、C 和 D，而 B、C 和 D 的存储位置下标为 1、2 和 3，因此将 1、2 和 3 存入 A 的孩子域。同样，B 有 2 个孩子 E 和 F，而 E 和 F 的存储位置下标为 4 和 5，因此，将 4 和 5 存入 B 的孩子域。因为本题中每个节点都分配了 3 个孩子域（想一想，为什么？–树的度即节点的最大度为3），B 只有两个孩子，另一个孩子域记为−1，表示不存在。同理，其他节点也这样存储。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920112818666.png" alt="image-20220920112818666"></p></li><li><p><strong>双亲孩子表示法</strong></p><p>双亲孩子表示法是指除了存储数据元素之外，还存储其双亲和所有孩子的存储位置下标。此方法其实就是在孩子表示法的基础上增加了一个双亲域，其他<br>的都和孩子表示法相同，是双亲表示法和孩子表示法的结合体。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920112949426.png" alt="image-20220920112949426"></p></li></ol><p><strong>三种方法的优缺点：</strong></p><ul><li>双亲表示法只记录了每个节点的双亲，无法直接得到该节点的孩子。</li><li>孩子表示法可以得到该节点的孩子，但是无法直接得到该节点的双亲，而且由于不知道每个节点到底有多少个孩子，因此只能按照树的度（树中节点的最大度）分配孩子空间，这样做可能会浪费很多空间。</li><li>双亲孩子表示法是在孩子表示法的基础上，增加了一个双亲域，可以快速得到节点的双亲和孩子，其缺点和孩子表示法一样，可能浪费很多空间。</li></ul><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>由于树中每个节点的孩子数量无法确定，因此在使用链式存储时，<strong>孩子指针域不确定分配多少个合适</strong>。</p><p>如果采用“异构型”数据结构，每个节点的指针域个数按照节点的孩子数分配，则数据结构描述困难；如果采用每个节点都分配固定个数（如树的度）的指针域，则浪费很多空间。</p><blockquote><p>一种是采用<strong>邻接表</strong>的思路，将节点的所有孩子存储在一个单链表中，称为<strong>孩子链表表示法</strong>；</p><p>一种是采用<strong>二叉链表</strong>的思路，左指针存储第一个孩子，右指针存储右兄弟，称为<strong>孩子兄弟表示法</strong>。</p></blockquote><ol><li><p>孩子链表表示法</p><p>孩子链表表示法类似于邻接表，表头包含数据元素并指向第一个孩子指针，将所有孩子放入一个单链表中。</p><blockquote><p>在表头中，<code>data</code> 存储数据元素，<code>first</code> 为指向第 1 个孩子的指针。单链表中的节点记录<strong>该节点的下标和下一个节点的地址</strong>。</p></blockquote><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920120139111.png" alt="image-20220920120139111"></p><p>孩子链表表示法中，如果在表头中再增加一个双亲域 parent，则为双亲孩子链表表示法。</p></li><li><p>孩子兄弟表示法</p><blockquote><p>节点除了存储数据元素之外，还有两个指针域 lchild 和 rchild，被称为二叉链表。lchild 存储第一个孩子地址，rchild 存储右兄弟地址。</p></blockquote><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920121102928.png" alt="image-20220920121102928"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920121208519.png" alt="image-20220920121208519"></p><blockquote><p>孩子兄弟表示法的<strong>秘诀</strong>：<strong>长子当作左孩子，兄弟关系向右斜。</strong></p></blockquote></li></ol><h3 id="树、森林和二叉树的转换"><a href="#树、森林和二叉树的转换" class="headerlink" title="树、森林和二叉树的转换"></a>树、森林和二叉树的转换</h3><ol><li><p><strong>树和二叉树的转换</strong></p><p>根据树转换为二叉链表的秘诀，可以把任何一棵树转换为二叉树：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920152155413.png" alt="image-20220920152155413"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920152319975.png" alt="image-20220920152319975"></p></li><li><p><strong>森林和二叉树的转换</strong></p><p>森林是由 m（m≥0）棵不相交的树组成的集合。</p><p>可以把森林中的每棵树的树根看作兄弟关系，因此 3 棵树的树根 B、C 和 D 是兄弟，兄弟关系在右斜线上，其他的转换和树转二叉树一样，<strong>长子当作左孩子</strong>，<strong>兄弟关系向右斜</strong>。</p><p>或者把森林中的每一棵树转换成二叉树，然后把每棵树的根节点连接在右斜线上即可。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920152500257.png" alt="image-20220920152500257"></p></li></ol><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920152559528.png" alt="image-20220920152559528"></p><blockquote><p>由于普通的树每个节点的子树个数不同，存储和运算都比较困难，因此在实际应用中，可以将树或森林转换为二叉树，然后进行存储和运算。</p><p>二者存在唯一的对关系，因此不影响其结果。</p></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树（binary tree）是 n（n≥0）个节点构成的集合，它或为空树（n&#x3D;0），或满足以下两个条件：</p><ol><li><strong>有且仅有一个称为根的节点</strong>；</li><li>除根节点以外，其余节点分为两个互不相交的子集 T1 和 T2，分别称为 T 的<strong>左子树</strong>和<strong>右子树</strong>，且 T1 和 T2 本身都是二叉树。</li></ol><p>二叉树是一种特殊的树，<strong>它最多有两个子树</strong>，分别为左子树和右子树，<strong>二者是有序的</strong>，不可以互换。</p><blockquote><p><strong>也就是说，二叉树中不存在度大于 2 的节点。</strong></p></blockquote><p>二叉树一共有 5 种形态：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920153010650.png" alt="image-20220920153010650"></p><p>二叉树的结构最简单，规律性最强，因此通常被作为重点讲解。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><blockquote><p><strong>性质 1：在二叉树的第 i 层上至多有 2<sup>(i−1)</sup>个节点。</strong></p></blockquote><p>因为上一层的每个节点最多有两个孩子，因此当前层最多是上一层节点数的 2 倍：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920154158302.png" alt="image-20220920154158302"></p><blockquote><p><strong>性质 2：深度为 k 的二叉树至多有 2<sup>k</sup>−1 个节点。</strong></p></blockquote><p>把每层的节点数加起来就是整棵二叉树的最大节点数:</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920154419331.png" alt="image-20220920154419331"></p><blockquote><p><strong>性质 3：对于任何一棵二叉树，若叶子数为 n<sub>0</sub>，度为 2 的节点数为 n<sub>2</sub>，则 n<sub>0</sub>&#x3D;n<sub>2</sub>+1。</strong></p></blockquote><p><strong>证明：</strong>二叉树中的节点度数不超过 2，因此一共有 3 种节点，即度为 0、度为 1、度为 2。设二叉树总的节点数为 n，度为 0 的节点数为 n<sub>0</sub>，度为 1 的节点数为 n<sub>1</sub>，度为 2 的节点数为n<sub>2</sub>，总节点数等于 3 种节点数之和，即 n&#x3D;n<sub>0</sub> +n<sub>1</sub> +n<sub>2</sub>。</p><p>而总节点数又等于“<strong>分支数 b+1</strong>”，即 n&#x3D;b+1。为什么呢？</p><p>从下向上看，每一个节点对应一个分支，<strong>只有树根没有对应分支</strong>，因此总的节点数为“分支数 b+1”：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920161555719.png" alt="image-20220920161555719"></p><p>而分支数 b 怎么计算呢？</p><p>从上向下看，每个度为 2 的节点产生 2 个分支，度为 1 的节点产生 1个分支，度为 0 的节点没有分支，因此分支数 b&#x3D;n<sub>1</sub> +2n<sub>2</sub>，则 n&#x3D;b+1&#x3D;n<sub>1</sub>+2n<sub>2</sub> +1。而前面已经得到 n&#x3D;n<sub>0</sub> +n<sub>1</sub> +n<sub>2</sub>，两式联合得：n<sub>0</sub> &#x3D;n<sub>2</sub> +1。</p><p>有两种比较特殊的二叉树：满二叉树和完全二叉树。</p><ul><li><p><strong>满二叉树</strong>：一棵深度为 k 且有 2<sup>k</sup> −1 个节点的二叉树。满二叉树每一层都“充满”了节点，达到最大节点数。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920162104772.png" alt="image-20220920162104772"></p></li><li><p><strong>完全二叉树：</strong>除了最后一层外，每一层都是满的（达到最大节点数），最后一层节点是从左向右出现的（必须从左向右排列）。</p><p>深度为 k 的完全二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中编号 1～n 的节点<strong>一一对应</strong>。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920162233489.png" alt="image-20220920162233489"></p><blockquote><p>也就是说，如果 2 没有左孩子，就不可以有右孩子；如果 2 没有右孩子，3 不可以有左孩子。</p></blockquote></li></ul><blockquote><p><strong>性质 4：具有 n 个节点的完全二叉树的深度必为⎣log<sub>2</sub>n⎦ +1。</strong></p></blockquote><p>证明：假设完全二叉树的深度为 k，那么除了最后一层外，前 k−1 层都是满的，最后一层最少有一个节点，最后一层最多也可以充满节点，即 2<sup>k−1 </sup>个节点：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920163644646.png" alt="image-20220920163644646"></p><p>因此，2<sup>k−1</sup>≤n≤2<sup>k</sup>−1，右边放大后，2<sup>k−1</sup>≤n&lt;2<sup>k</sup>，同时取对数，k−1≤log<sub>2</sub>n&lt;k，所以k&#x3D;⎣log<sub>2</sub>n⎦+1。其中，⎣⎦表示取下限，⎣x⎦表示小于 x 的最大整数，如⎣3.6⎦&#x3D;3。</p><blockquote><p><strong>性质 5：对于完全二叉树，若从上至下、从左至右编号，则编号为 i 的节点，其左孩子编号必为 2i，其右孩子编号必为 2i +1，其双亲的编号必为 i&#x2F;2。</strong></p></blockquote><p><strong>例题 1：</strong>一棵完全二叉树有 1001 个节点，其中叶子节点的个数是多少？</p><p><strong>解题思路：</strong>首先找到最后一个节点 1001 的双亲节点，其双亲节点编号为 1001&#x2F;2&#x3D;500，该节点是最后一个拥有孩子的节点，其后面全是叶子，即 1001−500&#x3D;501 个叶子。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920170039952.png" alt="image-20220920170039952"></p><p><strong>例题 2：</strong>一棵完全二叉树第 6 层有 8 个叶子，则该完全二叉树最少有多少节点，最多有多少个节点？</p><p><strong>解题思路：完全二叉树的叶子分布在最后一层或倒数第二层</strong>，因此该树有可能为 6 层或 7 层。</p><p>节点最少的情况（6 层）：8 个叶子在最后一层，即第 6 层，前 5 层是满的。最少有 2<sup>5</sup>−1+8&#x3D;39 个节点。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920170949639.png" alt="image-20220920170949639"></p><p>节点最多的情况（7 层）：8 个叶子在倒数第二层，即第 6 层，前 6 层是满的，第 7 层最少缺失了 8×2 个节点，因为第 6层的 8 个叶子如果生成孩子的话，会有 16个节点。最多有 27−1−16&#x3D;111 个节点。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920171052194.png" alt="image-20220920171052194"></p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>二叉树也可以采用顺序存储，按完全二叉树的节点层次编号，依次存放二叉树中的数据元素。</p><p>完全二叉树很适合顺序存储方式，而普通二叉树在顺序存储时需要补充为完全二叉树，在对应完全二叉树没有孩子的位置<strong>补 0</strong>：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920171448183.png" alt="image-20220920171448183"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920171504011.png" alt="image-20220920171504011"></p><blockquote><p>显然，普通二叉树不适合顺序存储方式，因为有可能在补充为完全二叉树过程中，补充太多的 0，而<strong>浪费大量空间</strong>，因此普通二叉树可以使用链式存储。</p></blockquote><h4 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h4><p>二叉树采用链式存储方式：每个节点包含一个数据域，存储节点信息；还包含两个指针域，指向左右两个孩子。这种存储方式称为二叉链表：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920171945572.png" alt="image-20220920171945572"></p><p>一般情况下，二叉树采用二叉链表存储即可，但是在实际问题中，如果经常需要访问双亲节点，二叉链表存储则必须从根出发查找其双亲节点，这样做非常麻烦。</p><p>为了解决这一问题，<strong>可以增加一个指向双亲节点的指针域</strong>，这样每个节点就包含3 个指针域，分别指向两个孩子节点和双亲节点，还包含一个数据域，用来存储节点信息。这种存储方式称为三叉链表：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920172044758.png" alt="image-20220920172044758"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920172134453.png" alt="image-20220920172134453"></p><h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><p>如果对二叉树进行操作，必须先创建一棵二叉树。如何创建一棵二叉树呢？</p><blockquote><p>从二叉树的定义就可以看出，它是递归定义的（除了根之外，左、右子树也是一棵二叉树），因此可以用<strong>递归</strong>来创建二叉树。</p></blockquote><p>递归创建二叉树有两种方法，分别是询问法和补空法。</p><ol><li><p><strong>询问法</strong></p><p>每次输入节点信息后，询问是否创建该节点的左子树，如果是，则递归创建其左子树，否则其左子树为空；询问是否创建该节点的右子树，如果是，则递归创建其右子树，否则其右子树为空。</p><p><strong>算法步骤：</strong></p><ol><li>输入节点信息，创建一个节点 T。</li><li>询问是否创建 T 的左子树，如果是，则递归创建其左子树，否则其左子树为 NULL。</li><li>询问是否创建 T 的右子树，如果是，则递归创建其右子树，否则其右子树为 NULL。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Bnode</span><span class="token punctuation">&#123;</span> <span class="token comment">/*定义二叉树存储结构*/</span><span class="token keyword">char</span> data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Bnode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Bnode<span class="token punctuation">,</span><span class="token operator">*</span>Btree<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">createtree</span><span class="token punctuation">(</span>Btree <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token comment">/*创建二叉树函数*/</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> check<span class="token punctuation">;</span><span class="token comment">/*判断是否创建左右孩子*/</span>    T<span class="token operator">=</span><span class="token keyword">new</span> Bnode<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入结点信息:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">/*输入根结点数据*/</span>    cin<span class="token operator">>></span>T<span class="token operator">-></span>data<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"是否添加 "</span><span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"的左孩子? (Y/N)"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">/*询问是否创建T的左子树*/</span>    cin<span class="token operator">>></span>check<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>check<span class="token operator">==</span><span class="token char">'Y'</span><span class="token punctuation">)</span>        <span class="token function">createtree</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        T<span class="token operator">-></span>lchild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"是否添加"</span><span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"的右孩子? (Y/N)"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">/*询问是否创建T的右子树*/</span>    cin<span class="token operator">>></span>check<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>check<span class="token operator">==</span><span class="token char">'Y'</span><span class="token punctuation">)</span>        <span class="token function">createtree</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        T<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>补空法</strong></p><p>补空法是指如果左子树或右子树为空时，则用特殊字符补空，如“#”，然后按照根、左子树、右子树的顺序，得到先序遍历序列，根据该序列递归创建二叉树：</p><p><strong>算法步骤：</strong></p><ol><li>输入补空后的二叉树先序遍历序列。</li><li>如果 ch&#x3D;&#x3D;’#’，T&#x3D;NULL；否则创建一个新节点 T，令 T-&gt;data&#x3D;ch；递归创建 T 的左子树；递归创建 T 的右子树。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span><span class="token comment">//引入队列头文件</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Bnode</span><span class="token punctuation">&#123;</span><span class="token comment">/*定义二叉树存储结构*/</span><span class="token keyword">char</span> data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Bnode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Bnode<span class="token punctuation">,</span><span class="token operator">*</span>Btree<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Createtree</span><span class="token punctuation">(</span>Btree <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token comment">/*创建二叉树函数*/</span><span class="token punctuation">&#123;</span>    <span class="token comment">//按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span><span class="token keyword">char</span> ch<span class="token punctuation">;</span>cin<span class="token operator">>></span>ch<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token char">'#'</span><span class="token punctuation">)</span>        T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//递归结束，建空树</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>T<span class="token operator">=</span><span class="token keyword">new</span> Bnode<span class="token punctuation">;</span>T<span class="token operator">-></span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span><span class="token comment">//生成根结点</span><span class="token function">Createtree</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归创建左子树</span><span class="token function">Createtree</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归创建右子树</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><blockquote><p>二叉树的遍历就是按某条搜索路径访问二叉树中的每个节点一次且只有一次。</p></blockquote><p>按照根的访问顺序不同，根在前面称为<strong>先序遍历</strong>（DLR），根在中间称为<strong>中序遍历</strong>（LDR），根在最后称为<strong>后序遍历</strong>（LRD）。</p><p>因为树的定义本身就是递归的，因此树和二叉树的基本操作用递归算法很容易实现。</p><h4 id="先序遍历："><a href="#先序遍历：" class="headerlink" title="先序遍历："></a>先序遍历：</h4><p>先序遍历是指先访问根，然后先序遍历左子树，再先序遍历右子树，即 DLR。</p><p><strong>算法步骤：</strong></p><p>如果二叉树为空，则空操作，否则：</p><ol><li>访问根节点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><blockquote><p><strong>左子树为空或已遍历才可以遍历右子树。</strong></p></blockquote><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//先序遍历</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout<span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>       <span class="token function">preorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">preorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h4><p>中序遍历是指中序遍历左子树，然后访问根，再中序遍历右子树，即 LDR。</p><p><strong>算法步骤：</strong></p><p>如果二叉树为空，则空操作，否则：</p><ol><li><p>中序遍历左子树</p></li><li><p>访问根节点</p></li><li><p>中序遍历右子树</p><blockquote><p><strong>左子树为空或已遍历才可以访问根</strong></p></blockquote></li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//中序遍历</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token function">inorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>       cout<span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>       <span class="token function">inorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h4><p>后序遍历是指后序遍历左子树，后序遍历右子树，然后访问根，即 LRD。</p><p><strong>算法步骤：</strong></p><p>如果二叉树为空，则空操作，否则：</p><ol><li><p>后序遍历左子树</p></li><li><p>后序遍历右子树</p></li><li><p>访问根节点</p><blockquote><p><strong>左子树、右子树为空或已遍历才可以访问根</strong></p></blockquote></li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">posorder</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//后序遍历</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token function">posorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">posorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>       cout<span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="投影法："><a href="#投影法：" class="headerlink" title="投影法："></a>投影法：</h4><p>如果不需要按照程序执行流程，那么只要写出二叉树的遍历序列即可，还可以使用投影法快速得到遍历序列。</p><p>原图：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122047322.png" alt="image-20220922122047322"></p><ol><li><p>中序遍历：</p><p>中序遍历就像在无风的情况下，遍历顺序为左子树、根、右子树，太阳直射，将所有的节点投影到地上</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922120407427.png" alt="image-20220922120407427"></p></li><li><p>先序遍历：</p><p>先序遍历就像在左边大风的情况下，将二叉树树枝刮向右方，且顺序为根、左子树、右子树，太阳直射，将所有的节点投影到地上</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922120828446.png" alt="image-20220922120828446"></p></li><li><p>后序遍历：</p><p>后序遍历就像在右边大风的情况下，将二叉树树枝刮向左方，且顺序为左子树、右子树、根，太阳直射，将所有的节点投影到地上</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122118027.png" alt="image-20220922122118027"></p></li></ol><h4 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h4><blockquote><p>首先遍历第 1 层，然后第 2层……同一层按照从左向右的顺序访问，直到最后一层。</p></blockquote><p>程序是怎么实现层次遍历的呢？</p><p>通过观察可以发现，先被访问的节点，其孩子也先被访问，先来先服务，因此可以用<strong>队列</strong>实现</p><p>下面以下图中的二叉树为例，展示该二叉树层次遍历的过程：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122047322.png" alt="image-20220922122047322"></p><p><strong>算法步骤：</strong></p><ol><li><p>首先创建一个队列 Q，令树根入队。（注意：实际上是指向树根 A 的指针入队，这里为了图解方便，直接把数据入队了。）</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122713832.png" alt="image-20220922122713832"></p></li><li><p>队头元素出队，输出 A，同时令 A 的孩子 B、C 入队（从左向右顺序，如果是普通树，则包含所有孩子）</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122738214.png" alt="image-20220922122738214"></p></li><li><p>队头元素出队，输出 B，同时令 B 的孩子 D、E 入队：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122809548.png" alt="image-20220922122809548"></p></li><li><p>队头元素出队，输出 C，同时令 C 的孩子 F 入队：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122845581.png" alt="image-20220922122845581"></p></li><li><p>队头元素出队，输出 D，同时令 D 的孩子入队，D 没有孩子，什么也不做。</p></li><li><p>以此类推，直到队列为空，算法结束。</p></li></ol><p><strong>代码步骤：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Leveltraverse</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Btree p<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>Btree<span class="token operator">></span>Q<span class="token punctuation">;</span> <span class="token comment">//创建一个普通队列(先进先出)，里面存放指针类型</span>    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根指针入队</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果队列不空</span>    <span class="token punctuation">&#123;</span>        p<span class="token operator">=</span>Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取出队头元素作为当前扩展结点livenode</span>        Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//队头元素出队</span>        cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span>            Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//左孩子指针入队</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span>            Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//右孩子指针入队</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>二叉树是非线性数据结构，而遍历序列是线性序列，二叉树遍历实际上是将一个非线性结构进行线性化的操作。</p><p>根据线性序列的特性，除了第一个元素外，每一个节点都有唯一的前驱，除了最后一个元素外，每一个节点都有唯一的后继。而根据遍历序列的不同，每个节点的前驱和后继也不同。</p><blockquote><p>采用二叉链表存储时，只记录了左、右孩子的信息，无法直接得到每个节点的前驱和后继。</p></blockquote><h3 id="线索二叉树存储结构"><a href="#线索二叉树存储结构" class="headerlink" title="线索二叉树存储结构"></a>线索二叉树存储结构</h3><p>二叉树采用二叉链表存储时，每个节点有两个指针域。如果二叉链表有 n 个节点，则一共有 2n 个指针域，而只有 n−1 个是实指针，其余 n+1 个都是空指针，为什么呢？</p><p><strong>推导过程：</strong></p><p>因为二叉树有 n−1 个分支，每个分支对应一个实指针，每一个节点对应一个分支，只有树根没有对应分支，因此分支数等于节点数减 1，即 b&#x3D;n−1。</p><p>每个分支对应一个实指针，所以有 n−1 个实指针。</p><p>总的的指针数减去实指针数，即为空指针数，即 2n− (n−1)&#x3D;n+1。</p><blockquote><p>n 个节点的二叉链表中有 n+1 个空指针，<strong>可以充分利用空指针记录节点的前驱或后继信息，从而加快查找节点前驱和后继的速度</strong>。</p></blockquote><hr><p>每个节点还是两个指针域，如果节点有左孩子，则 lchild 指向左孩子，否则 lchild 指向其前驱；如果节点有右孩子，则 rchild 指向右孩子，否则 rchild 指向其后继。</p><blockquote><p>那么怎么区分到底存储的是左孩子和右孩子，还是前驱和后继信息呢？</p></blockquote><p>为了避免混淆，增加两个标志域 <strong>ltag</strong> 和 <strong>rtag</strong>：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922131353508.png" alt="image-20220922131353508"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922131359613.png" alt="image-20220922131359613"></p><hr><p>这种带有标志域的二叉链表称为<strong>线索链表</strong>，</p><p>指向前驱和后继的指针称为<strong>线索</strong>，</p><p>带有线索的二叉树称为<strong>线索二叉树</strong>，</p><p>以某种遍历方式将二叉树转化为线索二叉树的过程称为<strong>线索化</strong>。</p><h3 id="构造线索二叉树"><a href="#构造线索二叉树" class="headerlink" title="构造线索二叉树"></a>构造线索二叉树</h3><p>每种遍历顺序不同，节点的前驱和后继也不同，因此二叉树线索化必须指明是什么遍历顺序的线索化</p><p>线索二叉树分为前序线索二叉树、中序线索二叉树和后序线索二叉树。</p><blockquote><p><strong>二叉树线索化的过程，实际上是在遍历过程中修改空指针的过程。</strong></p></blockquote><p>可以设置两个指针，一个指针 pre 指向刚刚访问的节点，另一个指针 p 指向当前节点。也就是说，pre 指向的节点为 p 指向的节点的前驱，反之，p 指向的节点为 pre 指向的节点的后继。</p><blockquote><p>在遍历的过程中，如果当前节点 p 的左孩子为空，则该节点的 lchild 指向其前驱，即 p-&gt;lchild&#x3D;pre；</p><p>如果 pre节点的右孩子为空，则该节点的 rchild 指向其后继，即 pre-&gt;rchild&#x3D;p。</p></blockquote><p><strong>算法步骤：</strong></p><ol><li>指针 p 指向根节点，pre 初始化为空，pre 永远指向 p 的前驱。</li><li>若 p 非空，则重复下面操作：<ul><li>中序线索化 p 的左子树。</li><li>若 p 的左子树为空，则给 p 加上左线索，即 p-&gt;ltag&#x3D;1，p 的左子树指针指向 pre（前驱），即 p-&gt;lchild&#x3D;pre；否则令 p-&gt;ltag&#x3D;0。</li><li>若 pre 非空，则判断如果 pre 的右子树为空，给 pre 加上右线索，即 pre-&gt;rtag&#x3D;1，pre的右孩子指针指向 p（后继），即 pre-&gt;rchild&#x3D;p，否则令 pre-&gt;rtag&#x3D;0。</li><li>p 赋值给 pre，转向 p 的右子树。</li><li>中序线索化 p 的右子树。</li></ul></li><li>处 理 最 后 一 个 节 点 ， 令 其 后 继 为 空 ， 即pre-&gt;rchild&#x3D;NULL; pre-&gt;rtag&#x3D;1。</li></ol><hr><p>注意：如果在考试当中只要求绘图，则没必要按照程序执行的过程进行线索化，可以直接写出遍历序列。</p><blockquote><p><strong>根据该遍历序列的先后顺序，对所有的空指针域进行线索化，左指针为空，则令其指向前驱；右指针为空，则令其指向后继。</strong></p></blockquote><p>示例：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922163836111.png" alt="image-20220922163836111"></p><ol><li><p>首先写出二叉树的中序遍历序列，即 DBEAFGC，然后按照该遍历序列，对所有的空指针进行线索化。</p></li><li><p>D 的左指针为空，但在中序遍历序列中，D 是第一个元素，没有前驱，赋值为 NULL。</p></li><li><p>D 的右指针为空，中序遍历序列中 D 的后继是 B，因此 D 的右指针指向 B 节点。</p></li><li><p>同理，从中序遍历序列中可以很清楚地知道每个节点的前驱和后继，分别对所有节点的空指针进行线索化即可。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922164012944.png" alt="image-20220922164012944"></p></li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InThread</span><span class="token punctuation">(</span>BTtree <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token comment">//中序线索化</span><span class="token punctuation">&#123;</span><span class="token comment">//pre是全局变量，指向当前结点p的前驱</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">InThread</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//左子树递归线索化</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span>   <span class="token comment">//p的左孩子为空</span><span class="token punctuation">&#123;</span>p<span class="token operator">-></span>ltag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//给p加上左线索</span>p<span class="token operator">-></span>lchild<span class="token operator">=</span>pre<span class="token punctuation">;</span> <span class="token comment">//p的左孩子指针指向pre（前驱）</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span>p<span class="token operator">-></span>ltag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token operator">-></span>rchild<span class="token punctuation">)</span>  <span class="token comment">//pre的右孩子为空</span>            <span class="token punctuation">&#123;</span>                pre<span class="token operator">-></span>rtag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//给pre加上右线索</span>                pre<span class="token operator">-></span>rchild<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//pre的右孩子指针指向p（后继）</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>                pre<span class="token operator">-></span>rtag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>pre<span class="token operator">=</span>p<span class="token punctuation">;</span>                     <span class="token comment">//保持pre指向p的前驱</span><span class="token function">InThread</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//右子树递归线索化</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h3><p>线索二叉树的线索记录了前驱和后继信息，因此可以利用这些信息进行遍历。下面以中序线索二叉树遍历为例，讲述遍历过程。</p><p><strong>算法步骤：</strong></p><ol><li>指针 p 指向根节点。</li><li>若 p 非空，则重复以下操作：<ul><li>p 指针沿左孩子向下，找到最左节点，它是中序遍历的第一个节点；</li><li>访问 p 节点；</li><li>沿着右线索查找当前节点 p 的后继节点并访问，直到右线索为 0 或遍历结束。</li></ul></li><li>遍历 p 的右子树。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InorderThread</span><span class="token punctuation">(</span>BTtree T<span class="token punctuation">)</span><span class="token comment">//遍历中序线索二叉树</span><span class="token punctuation">&#123;</span>    BTtree p<span class="token punctuation">;</span>    p<span class="token operator">=</span>T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>ltag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> p<span class="token operator">=</span>p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>  <span class="token comment">//找最左结点</span>       cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span><span class="token comment">//输出结点信息</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rtag<span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span> <span class="token comment">//右孩子为线索化，指向后继</span>       <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>   <span class="token comment">//访问后继结点</span>cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span><span class="token comment">//输出结点信息</span>       <span class="token punctuation">&#125;</span>       p<span class="token operator">=</span>p<span class="token operator">-></span>rchild<span class="token punctuation">;</span><span class="token comment">//转向p的右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于频繁查找前驱和后继的运算，线索二叉树优于普通二叉树。但是对于插入和删除操作，线索二叉树比普通二叉树开销大，因为除插入和删除操作外，还要修改相应的线索。</p><h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的遍历："><a href="#树的遍历：" class="headerlink" title="树的遍历："></a>树的遍历：</h3><p>树的遍历操作包括先根遍历和后根遍历两种方式。</p><ul><li>先根遍历：如果树非空，则先访问根节点，然后按从左向右的顺序，先根遍历根节点的每一棵子树。树的先根遍历顺序与该树对应的二叉树的先序遍历顺序相同。</li><li>后根遍历：如果树非空，则按从左向右的顺序，后根遍历根节点的每一棵子树，然后访问根节点。树的后根遍历顺序与该树对应的二叉树的中序遍历顺序相同。</li></ul><ol><li><p>先根遍历</p><p>先根遍历时，先访问根，然后按从左向右的顺序，先根遍历根节点的每一棵子树，第一棵子树遍历完毕，才可以遍历第二棵子树……</p></li><li><p>后根遍历</p><p>后根遍历时，先按从左向右的顺序后根遍历每一棵子树，没有子树或子树已遍历完毕，才可以访问根。</p></li></ol><h3 id="森林的遍历："><a href="#森林的遍历：" class="headerlink" title="森林的遍历："></a>森林的遍历：</h3><p>森林的遍历操作有先序遍历和中序遍历两种方式。</p><ul><li><p>先序遍历：</p><p>如果森林非空，则：</p><ul><li>访问第一棵树的根节点；</li><li>先序遍历第一棵树的根节点的子树森林；</li><li>先序遍历除第一个棵树之外，剩余的树构成的森林。</li></ul><p>其访问顺序与该森林对应的二叉树的先序遍历顺序相同。</p></li><li><p>中序遍历</p><p>如果森林非空，则：</p><ul><li>中序遍历第一棵树的根节点的子树森林；</li><li>访问第一棵树的根节点；</li><li>中序遍历除第一个棵树之外，剩余的树构成的森林。</li></ul><p>其访问顺序与该森林对应的二叉树的中序遍历顺序相同。</p></li></ul><h2 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h2><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>首先考虑特殊情况，如果二叉树为空，则深度为 0；一般情况下，二叉树的深度等于二叉树左右子树的<strong>深度最大值加 1</strong>。</p><p><strong>算法步骤：</strong></p><ol><li>如果二叉树为空，则深度为 0。</li><li>否则为根的左、右子树的深度最大值加 1。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//求二叉树的深度</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span>n<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//如果为空树，深度为0</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>m<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归计算左子树深度</span>n<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归计算左子树深度</span><span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">></span>n<span class="token punctuation">)</span><span class="token keyword">return</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//返回左右子树最大值加1</span><span class="token keyword">else</span><span class="token keyword">return</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的叶子数"><a href="#二叉树的叶子数" class="headerlink" title="二叉树的叶子数"></a>二叉树的叶子数</h3><p>首先考虑特殊情况，如果二叉树为空，则叶子数为 0；如果根的左、右子树都为空，则叶子数为 1；</p><blockquote><p><strong>一般情况下，二叉树的叶子数等于左子树的叶子数与右子树的叶子数之和。</strong></p></blockquote><p><strong>算法步骤：</strong></p><ol><li>如果二叉树为空，则叶子数为 0。</li><li>如果根的左、右子树都为空，则叶子数为 1。</li><li>否则求左子树的叶子数和右子树的叶子数之和，即为二叉树的叶子数。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">LeafCount</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//求二叉树的叶子数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//如果为空树，深度为0</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>T<span class="token operator">-></span>rchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//左右子树均为空，则叶子数为1</span>           <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>           <span class="token keyword">return</span> <span class="token function">LeafCount</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">LeafCount</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归计算左子树和右子树的叶子数之和</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，要计算二叉树的节点数，如果二叉树为空，则节点数为 0；</p><blockquote><p><strong>否则，二叉树的节点数等于左子树与右子树的节点数之和加 1。</strong></p></blockquote><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//求二叉树的结点数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//如果为空树，深度为0</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//递归计算左子树和右子树的结点数之和加1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>此类问题只需要考虑特殊情况，例如树空、只有一个根节点等，一般情况下，直接递归即可。</strong></p></blockquote><h3 id="三元组创建二叉树"><a href="#三元组创建二叉树" class="headerlink" title="三元组创建二叉树"></a>三元组创建二叉树</h3><p>假设以三元组(F, C, L&#x2F;R)的形式输入一棵二叉树的诸边（其中 F 是双亲节点的标识，C是孩子节点标识，L&#x2F;R 表示 C 为 F 的左孩子或右孩子），且在输入的三元组序列中，C 是按层次顺序出现的。</p><p>设节点的标识是字符类型，F 为 NULL 时，C 为根节点标识，若 C 亦为NULL，则表示输入结束。</p><p><strong>算法步骤：</strong></p><ol><li>输入第一组数据，创建根节点入队。因为是按层次输入的，所以可以借助队列实现。</li><li>输入下一组数据。</li><li>如果队列非空且输入数据<strong>前两项</strong>非空，则队头元素出队。</li><li><strong>判断输入数据中的双亲是否和队头元素相等</strong>，如果不相等，则转向第 3 步；如果相等，则创建一个新节点，判断该节点是其双亲的左孩子还是右孩子并做相应的处理，然后新节点入队。输入下一组数据，转向第 4 步（因为一个队头元素可能有两个孩子，所以不能创建一个孩子就结束）</li><li>直到队列为空或者输入数据前两项为空，算法停止。</li><li>输出先序、中序和后序序列。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">/*输入三元组 (F、C、L/R) 序列输入一棵二叉树的诸边(其中 F 表示双亲结点的标识，C 表示孩子结点标识，L/R 表示 C 为 F 的左孩子或右孩子)，且在输入的三元组序列中，C 是按层次顺序出现的。设结点的标识是字符类型。F=NULL时 C 为根结点标识，若 C 亦为NULL，则表示输入结束。试编写算法，由输入的三元组序列建立二叉树的二叉链表,并以先序、中序、后序序列输出。*/</span><span class="token comment">/*测试数据NULL A LA B LA C RB D RC E LC F RD G LF H LNULL NULL L*/</span><span class="token keyword">struct</span> <span class="token class-name">biTnode</span><span class="token punctuation">&#123;</span>    string data<span class="token punctuation">;</span>    biTnode <span class="token operator">*</span>lChild<span class="token punctuation">,</span><span class="token operator">*</span>rChild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> biTnode<span class="token operator">*</span> T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">CreatebiTree</span><span class="token punctuation">(</span>biTnode<span class="token operator">*</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    biTnode <span class="token operator">*</span>node<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>biTnode<span class="token operator">*</span><span class="token operator">></span>q<span class="token punctuation">;</span>    cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token operator">>></span>c<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token string">"NULL"</span><span class="token operator">&amp;&amp;</span>b<span class="token operator">!=</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token comment">//创建根结点</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">=</span><span class="token keyword">new</span> biTnode<span class="token punctuation">;</span>        node<span class="token operator">-></span>data<span class="token operator">=</span>b<span class="token punctuation">;</span>        node<span class="token operator">-></span>lChild<span class="token operator">=</span>node<span class="token operator">-></span>rChild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        T<span class="token operator">=</span>node<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token operator">>></span>c<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>a<span class="token operator">!=</span><span class="token string">"NULL"</span><span class="token operator">&amp;&amp;</span>b<span class="token operator">!=</span><span class="token string">"NULL"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token operator">==</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            node<span class="token operator">=</span><span class="token keyword">new</span> biTnode<span class="token punctuation">;</span>            node<span class="token operator">-></span>data<span class="token operator">=</span>b<span class="token punctuation">;</span>            node<span class="token operator">-></span>lChild<span class="token operator">=</span>node<span class="token operator">-></span>rChild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">"L"</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                p<span class="token operator">-></span>lChild<span class="token operator">=</span>node<span class="token punctuation">;</span>                cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"'s lChild is "</span><span class="token operator">&lt;&lt;</span>node<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                p<span class="token operator">-></span>rChild<span class="token operator">=</span>node<span class="token punctuation">;</span>                cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"'s rChild is "</span><span class="token operator">&lt;&lt;</span>node<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token operator">>></span>c<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历序列还原树"><a href="#遍历序列还原树" class="headerlink" title="遍历序列还原树"></a>遍历序列还原树</h3><p>根据遍历序列可以还原树，包括二叉树还原、树还原和森林还原 3 种。</p><h4 id="二叉树还原"><a href="#二叉树还原" class="headerlink" title="二叉树还原"></a>二叉树还原</h4><p>由二叉树的前序序列和中序序列，或者中序序列和后序序列，可以唯一地还原一棵二叉树。</p><blockquote><p><strong>注意：由二叉树的前序序列和后序序列不能唯一地还原一棵二叉树。</strong></p></blockquote><p><strong>算法步骤：</strong></p><ol><li><p>先序序列的第一个字符为根。</p></li><li><p>在中序序列中，以根为中心划分左右子树。</p></li><li><p>还原左右子树。</p><ul><li><p>先序序列的第一个字符 A 为根，在中序序列中以 A 为中心划分左右子树，左子树包含 DBE 三个节点，右子树包含 FGC 三个节点：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922222408128.png" alt="image-20220922222408128"></p></li><li><p>左子树 DBE，在先序序列中的顺序为 BDE，第一个字符 B 为根，在中序序列中以 B为中心划分左右子树，左右子树只有一个节点，因此直接作为 B 的左右孩子即可：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922222418292.png" alt="image-20220922222418292"></p></li><li><p>右子树 FGC，在先序序列中的顺序为 CFG，第一个字符 C 为根，在中序序列中以 C为中心划分左右子树，左子树包含 FG 节点，右子树为空：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922222429323.png" alt="image-20220922222429323"></p></li><li><p>左子树 FG，在先序序列中的顺序为 FG，第一个字符 F 为根，在中序序列中以 F 为中心划分左右子树，左为空，右子树只有一个节点 G，作为 F 的右孩子即可：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922222438266.png" alt="image-20220922222438266"></p></li></ul></li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span>BiTree <span class="token function">pre_mid_createBiTree</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>mid<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token comment">//前序中序还原建立二叉树</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ch<span class="token operator">=</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//找到先序中的第一个结点</span>    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>mid<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span>ch<span class="token punctuation">)</span><span class="token comment">//在中序中找到的根结点的左边为该结点的左子树，右边为右子树</span>    <span class="token punctuation">&#123;</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    BiTree T<span class="token operator">=</span><span class="token keyword">new</span> BiTNode<span class="token punctuation">;</span><span class="token comment">//创建根结点</span>    T<span class="token operator">-></span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>    T<span class="token operator">-></span>lchild<span class="token operator">=</span><span class="token function">pre_mid_createBiTree</span><span class="token punctuation">(</span>pre<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>mid<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立左子树</span>    T<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token function">pre_mid_createBiTree</span><span class="token punctuation">(</span>pre<span class="token operator">+</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>mid<span class="token operator">+</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token operator">-</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立右子树</span>    <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码解释：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BiTree <span class="token function">pre_mid_createBiTree</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>mid<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数有 3 个参数，pre 和 mid 为指针类型，分别指向前序、中序序列的首地址；len为序列的长度。前序和中序的序列长度一定是相同的。<br>首先，先序序列的第一个字符 pre[0]为根，然后在中序序列中查找根所在的位置，用 index记录查找长度，找到后以根为中心，划分出左右子树。</p><ul><li>左子树：先序序列中的首地址为 pre+1，中序序列的首地址为 mid，长度为 index</li><li>右子树：先序序列中的首地址为 pre+index+1，中序序列的首地址为 mid+index+1，长度为 len−index−1；右子树的长度为总长度减去左子树的长度，再减去根。</li></ul><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922225011925.png" alt="image-20220922225011925"></p><p>由二叉树的后序序列和中序序列也可以唯一确定一棵二叉树，方法和上面一样，只不过后序序列的最后一个字符为根，然后在中序序列中以根为中心划分左右子树。</p><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BiTree <span class="token function">pro_mid_createBiTree</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>last<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>mid<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token comment">//后序中序还原建立二叉树</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>       <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ch<span class="token operator">=</span>last<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取得后序遍历顺序中最后一个结点</span>    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//在中序序列中找根结点，并用index记录长度</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>mid<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span>ch<span class="token punctuation">)</span><span class="token comment">//在中序中找到根结点，左边为该结点的左子树，右边为右子树</span>       index<span class="token operator">++</span><span class="token punctuation">;</span>    BiTree T<span class="token operator">=</span><span class="token keyword">new</span> BiTNode<span class="token punctuation">;</span><span class="token comment">//创建根结点</span>    T<span class="token operator">-></span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>    T<span class="token operator">-></span>lchild<span class="token operator">=</span><span class="token function">pro_mid_createBiTree</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立左子树</span>    T<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token function">pro_mid_createBiTree</span><span class="token punctuation">(</span>last<span class="token operator">+</span>index<span class="token punctuation">,</span>mid<span class="token operator">+</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token operator">-</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立右子树</span>    <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>先序遍历和中序遍历还原二叉树<strong>秘籍：先序找根，中序分左右。</strong></p><p>后序遍历和中序遍历还原二叉树<strong>秘籍：后序找根，中序分左右。</strong></p></blockquote><h4 id="树还原"><a href="#树还原" class="headerlink" title="树还原"></a>树还原</h4><p>由于树的先根遍历和后根遍历与其对应二叉树的先序遍历和中序遍历相同，因此可以根据该对应关系，先还原为二叉树，然后再把二叉树转换为树。</p><h4 id="森林还原"><a href="#森林还原" class="headerlink" title="森林还原"></a>森林还原</h4><p>由于森林的先序遍历和中序遍历与其对应二叉树的先序遍历和中序遍历相同，因此可以根据该对应关系，先还原为二叉树，然后再把二叉树转换为森林。</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼编码的基本思想是以<strong>字符的使用频率</strong>作为权来构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。</p><p>哈夫曼树是通过将所要编码的字符作为叶子节点，将该字符在文件中的使用频率作为叶子节点的权值，以自底向上的方式，做 n−1 次“合并”运算构造出来的。</p><blockquote><p>哈夫曼编码被广泛地应用于数据压缩，尤其是远距离通信和大容量数据存储，常用的 JPEG 图片就是采用哈夫曼编码压缩的。</p></blockquote><blockquote><p><strong>哈夫曼编码的核心思想是让权值大的叶子离根最近。</strong></p></blockquote><p>哈夫曼算法采取的<strong>贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树</strong>，构造一棵新树，新树根节点的权值为其左右孩子节点权值之和，并将新树插入树的集合中。</p><p><strong>算法步骤：</strong></p><ol><li>确定合适的数据结构。编写程序前需要考虑的情况如下：<ul><li>哈夫曼树中没有度为 1 的节点，则一棵有 n 个叶子节点的哈夫曼树共有 2n−1 个节点（n−1 次“合并”，每次产生一个新节点）。</li><li>构成哈夫曼树后，为求编码需从叶子节点出发走一条从叶子到根的路径。</li><li>译码需要从根出发走一条从根到叶子的路径。那么对每个节点而言，需要知道每个节点的权值、双亲、左孩子、右孩子和节点信息。</li></ul></li><li>初始化。构造 n 棵节点为 n 个字符的单节点树集合 T&#x3D;{t1, t2 , t3 , …, tn}，每棵树只有一个带权的根节点，权值为该字符的使用频率。</li><li>如果 T 中只剩下一棵树，则哈夫曼树构造成功，跳到第 6 步。否则，从集合 T 中取出没有双亲且权值最小的两棵树 t i 和 t j，将它们合并成一棵新树 zk，新树的左孩子为 t i，右孩子为 t j，zk 的权值为 t i 和 t j 的权值之和。</li><li>从集合 T 中删去 t i、t j，加入 zk。</li><li>重复以上第 3 步和第 4 步。</li><li>约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子节点到根节点逆向求出每个字符的哈夫曼编码，那么从根节点到叶子节点路径上的字符组成的字符串为该叶子节点的哈夫曼编码，算法结束。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA算法在人脸识别中的应用</title>
      <link href="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/"/>
      <url>/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="PCA（主成分分析）算法介绍"><a href="#PCA（主成分分析）算法介绍" class="headerlink" title="PCA（主成分分析）算法介绍"></a>PCA（主成分分析）算法介绍</h2><p>PCA是多元统计同用来分析数据的一种方法。通过<strong>正交变换</strong>将一组可能存在相关性的变量转换为一组线性不相关的向量，转换后的这组变量叫做主成分。</p><p>而这个转换的过程中，可以<strong>丢弃</strong>很多相关的成分或者对描述这个物体不重要的成分。<strong>从而达到对原始数据降维，提取重要特征的目的。</strong></p><p><strong>为什么要降维？</strong></p><blockquote><ol><li>简化计算，便于分析</li><li>去掉冗余，显现特征</li></ol></blockquote><h3 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h3><p>首先需要知道几个相关的数学概念，这是我们进行PCA分析的基础：标准差（Standard Deviation）、方差（Variance）、协方差（Covariance）、特征向量（eigenvectors）、特征值（eigenvalues）</p><ol><li><h3 id="Standard-Deviation（标准差）"><a href="#Standard-Deviation（标准差）" class="headerlink" title="Standard Deviation（标准差）"></a>Standard Deviation（标准差）</h3><p>标准差就是用来描述<strong>一组数据与平均值的偏离程度</strong>，反映了一组数据的<strong>波动情况</strong>，平均值数学表达公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181158607.png" alt="image-20220918181158607"></p><p>标准差的表达公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181218236.png" alt="image-20220918181218236"></p><p>需要注意的是分母是选择<code>n</code>还是<code>n-1</code>，取决于你选取的数据是整个完整数据还是数据中的一部分。</p></li><li><h3 id="Variance（方差）"><a href="#Variance（方差）" class="headerlink" title="Variance（方差）"></a>Variance（方差）</h3><p>方差是数据集中数据分布的另一种度量。实际上，它几乎与标准差相同。</p><p>方差的数学表达公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181303373.png" alt="image-20220918181303373"></p></li><li><h3 id="Covariance（协方差）"><a href="#Covariance（协方差）" class="headerlink" title="Covariance（协方差）"></a>Covariance（协方差）</h3><p>标准差与方差只针对一维数据进行衡量的指标，协方差是<strong>针对二维数据或者是更高维的数据</strong>进行的衡量指标，主要用来表示<strong>多维度与平均值的偏离程度</strong>。</p><p>协方差的数学表达公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181435902.png" alt="image-20220918181435902"></p></li><li><h3 id="The-covariance-Matrix（协方差矩阵）"><a href="#The-covariance-Matrix（协方差矩阵）" class="headerlink" title="The covariance Matrix（协方差矩阵）"></a>The covariance Matrix（协方差矩阵）</h3><p>协方差矩阵主要是用于当数据的维度超过3或者更多的时候，我们可以通过<strong>一个矩阵来存储各个维度的协方差</strong>，这个矩阵就被称为“协方差矩阵”。</p><p>用数学方法来表示一个N为数据的协方差矩阵可以表示为：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181804542.png" alt="image-20220918181804542"></p><p>现在假设我们有一个三个维度的数据，使用一个协方差矩阵将这三维数据的协方差表示如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181822893.png" alt="image-20220918181822893"></p></li><li><h3 id="Eigenvectors（特征向量）"><a href="#Eigenvectors（特征向量）" class="headerlink" title="Eigenvectors（特征向量）"></a>Eigenvectors（特征向量）</h3><p>在矩阵论中，我们可以这样去理解特征值和特征向量，一个矩阵由一个变换到另一个矩阵，Aα&#x3D;λα，其中α称为矩阵A 的一个特征向量，λ称为矩阵A的一个特征值。</p><blockquote><p><strong>特征向量确定了矩阵变换的方向，特征值确定了矩阵变换的比例。</strong></p></blockquote><p>在协方差矩阵中，协方差矩阵的特征向量又反应了什么物理意义呢？</p><p>协方差矩阵的特征向量代表的意思是<strong>方差最大的数据所在的方向</strong>。</p><p>在n维数据空间中，第一特征向量指向的是<strong>数据方差最大的方向</strong>，第二特征向量是与第一特征向量垂直的数据方差最大的方向，第三特征向量是与第二特征向量垂直的数据方差最大的方向，以此类推。</p></li><li><h3 id="Choosing-components-and-forming-a-feature-vector（选择主成分并生成特征向量）"><a href="#Choosing-components-and-forming-a-feature-vector（选择主成分并生成特征向量）" class="headerlink" title="Choosing components and forming a feature vector（选择主成分并生成特征向量）"></a>Choosing components and forming a feature vector（选择主成分并生成特征向量）</h3><blockquote><p>一个协方差矩阵有着不同的特征值与特征向量，事实上<strong>最高特征值的对应的特征向量就是这个数据集的主成分</strong>。</p></blockquote><p>通常来说，一旦协方差矩阵的特征值和特征向量被计算出来了之后，就是按照特征值的大小从高到低依次排列。特征值的大小确定了主成分的重要性。</p></li></ol><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>PCA原理就是将一个高维向量<em><strong>x</strong></em>,通过一个特殊的特征向量矩阵<em><strong>U</strong></em>，投影到一个低维的向量空间中，表征为一个低维向量<em><strong>y</strong></em>，并且仅仅损失了一些次要信息。</p><blockquote><p>也就是说，<strong>通过低维表征的向量和特征向量矩阵，可以基本重构出所对应的原始高维向量。</strong></p><p>即<strong>选择特征值较大的作为主成分，从而进行降维。</strong></p></blockquote><p>比如：一开始你的数据集是N维的，在进行了协方差矩阵的特征值计算后， 你得到了N个特征值和与这些特征值相对应的特征向量。然后在主成分分析时，你选取了前P个较大的特征值，如此一来，就将原来N维的数据降维到只有P维。这样就起到了降维的效果了。</p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>其方法主要是通过<strong>对协方差矩阵进行特征分解</strong>，以得出数据的主成分（即<strong>特征向量</strong>）与它们的权值（即<strong>特征值</strong>）。</p><p>计算新生成的数据集的公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918182958926.png" alt="image-20220918182958926"></p><p>其中rowFeatureVector是由<strong>模式矢量作为列组成的矩阵</strong>的<strong>转置</strong>，因此它的行就是原来的模式矢量，而且对应<strong>最大特征值的特征矢量在该矩阵的最上一行</strong>。rowdataAdjust是<strong>每一维数据减去均值后，所组成矩阵的转置</strong>，即数据项目在每一列中，每一行是一维，对我们的样本来说即是，第一行为x维上数据，第二行为y维上的数据。</p><p>正是由于特征向量是两两正交的，那么我们就可以使用任何的特征向量来<strong>将原始数据变换到正交的这些坐标轴</strong>上。</p><p>在计算出协方差矩阵的特征值及特征向量后，接下来，我们<strong>选取一个较大的特征值对应的特征向量将原始数据降到一维</strong>：</p><blockquote><p><strong>将较大的特征值对应的特征向量转置然后乘以原始数据集，这样就得到新的降维后的一维数据。</strong></p></blockquote><p>换而言之，PCA提供了一种降低数据维度的有效办法；如果分析者在原数据中除掉最小的特征值所对应的成分，那么所得的低维度数据必定是最优化的（也即，这样降低维度必定是失去讯息最少的方法）。主成分分析在分析复杂数据时尤为有用，比如人脸识别。</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>设有m条n维数据（训练集）：</p><ol><li>将原始数据按列组成n行m列矩阵X</li><li>将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</li><li>求出协方差矩阵C&#x3D;(1&#x2F;m)XX^T（实对称矩阵）</li><li>求出协方差矩阵的特征值及对应的特征向量</li><li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</li><li>Y&#x3D;PX 即为降维到k维后的数据</li></ol><h2 id="PCA应用–人脸识别"><a href="#PCA应用–人脸识别" class="headerlink" title="PCA应用–人脸识别"></a>PCA应用–人脸识别</h2><p>主要思想就是用主成分分析的思想将图像从欧氏空间降维映射到特征空间中，根据<strong>不同人脸图像在特征空间中的度量距离来判断其相似度</strong>，从而实现人脸识别。</p><h3 id="主要流程："><a href="#主要流程：" class="headerlink" title="主要流程："></a>主要流程：</h3><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184204177.png" alt="image-20220918184204177"></p><p>通过上图的PCA人脸识别流程可以看出，PCA方法可以总结为以下几个阶段：训练样本、特征提取、构造特征空间、投影计算。</p><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol><li><p>使用ORL数据库。人脸图像总样本为（Q&#x3D;400），共有P（P&#x3D;40）个人，每人人均L（L&#x3D;10）幅图像，每张图像大小为 112 x 92 &#x3D; 10304。</p></li><li><p>对每张图片进行矢量化处理。其中Xi为由第i个人的图像的每一列向量堆叠而成的一列M*N维列向量，即把矩阵向量化。需要注意的是，由于每个人都有L张图像，所以Xi对应的是每个人的平均脸，其中Xij为第i个人第j个样本：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184801736.png" alt="image-20220918184801736"></p></li><li><p>计算所有训练图像的平均脸：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184914111.png" alt="image-20220918184914111"></p></li><li><p>计算每张人脸与平均脸的差值（去均值）：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184940831.png" alt="image-20220918184940831"></p></li><li><p>构造协方差矩阵：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184952241.png" alt="image-20220918184952241"></p></li><li><p>是求解协方差矩阵的特征值和特征向量，构造特征脸：</p><ul><li>求出协方差矩阵的特征向量<em><strong>ui</strong></em>和对应的特征值<em><strong>λi</strong></em>，这些特征向量组成的矩阵<em><strong>U</strong></em>就是人脸空间的正交基底，用它们的线性组合可以重构出样本中任意的人脸图像。<strong>并且图像信息集中在特征值大的特征向量中，即使丢弃特征值小的向量也不会影响图像质量</strong>：</li></ul><blockquote><p>为什么用特征向量和特征值的线性组合可以重构出样本中任意的人脸图像？</p></blockquote><ol><li><p>在人脸识别过程中，对输入的一个测试样本x，求出它与平均脸的偏差，则这个偏差在特征脸空间U的投影，可以表示为系数向量y：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918191044392.png" alt="image-20220918191044392"></p><p>U的维数为M×d（d为特征值个数），偏差的维数为M×1，y的维数为d×1。若<strong>M</strong>为200*200&#x3D;40000维，取200个主成分，即200个特征向量，则最后投影的系数向量y维数降维200维。</p></li><li><p>根据上述式子，可以得出：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918191404110.png" alt="image-20220918191404110"></p><p>这里的x就是根据投影系数向量y重构出的人脸图像，丢失了部分图像信息，但不会影响图像质量。</p></li></ol><ul><li>将协方差矩阵的<strong>特征值按大到小排序</strong>，λ 1 &gt; λ 2 . . . &gt; λ t &gt; λ P。根据特征值的贡献率选取前t个<strong>最大</strong>的特征值及其对应的特征向量v i 。</li><li>按列取前r个特征向量，r为想降低到r维度。将r个特征向量向每一维数据减去均值后，所组成矩阵的转置矩阵的特征向量过渡。</li><li>特征向量归一化后，得到测试脸在特征向量下的数据。</li><li>获取训练数据与测试脸之间的距离，其中最小的数据对应的类别就是该类别人脸。</li></ul></li></ol><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p>首先定义一个函数用于将人脸图像矢量化为一个向量，向量的大小与图片的像素有关，代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 图片矢量化</span><span class="token keyword">def</span> <span class="token function">img2vector</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">:</span>    img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>image<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 读取图片</span>    rows<span class="token punctuation">,</span> cols <span class="token operator">=</span> img<span class="token punctuation">.</span>shape  <span class="token comment">#获取图片的像素</span>    imgVector <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> rows <span class="token operator">*</span> cols<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#初始值均设置为0，大小就是图片像素的大小</span>    imgVector <span class="token operator">=</span> np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> rows <span class="token operator">*</span> cols<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#使用imgVector变量作为一个向量存储图片矢量化信息</span>    <span class="token keyword">return</span> imgVector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来定义一个函数用来选取训练图片，并对每张图片进行前面定义过的矢量化处理：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">load_orl</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#参数K代表选择K张图片作为训练图片使用</span>    <span class="token triple-quoted-string string">'''    对训练数据集进行数组初始化，用0填充，每张图片尺寸都定为112*92,    现在共有40个人，每个人都选择k张，则整个训练集大小为40*k,112*92    '''</span>    train_face <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">*</span> k<span class="token punctuation">,</span> <span class="token number">112</span> <span class="token operator">*</span> <span class="token number">92</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    train_label <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">*</span> k<span class="token punctuation">)</span>  <span class="token comment"># [0,0,.....0](共40*k个0)</span>    test_face <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">112</span> <span class="token operator">*</span> <span class="token number">92</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    test_label <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># sample=random.sample(range(10),k)#每个人都有的10张照片中，随机选取k张作为训练样本(10个里面随机选取K个成为一个列表)</span>    sample <span class="token operator">=</span> random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 随机排序1-10 (0-9）+1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 共有40个人</span>        people_num <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 每个人都有10张照片</span>            image <span class="token operator">=</span> orlpath <span class="token operator">+</span> <span class="token string">'/s'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>people_num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'/'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>sample<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg'</span>            <span class="token comment"># 读取图片并进行矢量化</span>            img <span class="token operator">=</span> img2vector<span class="token punctuation">(</span>image<span class="token punctuation">)</span>            <span class="token keyword">if</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>                <span class="token comment"># 构成训练集</span>                train_face<span class="token punctuation">[</span>i <span class="token operator">*</span> k <span class="token operator">+</span> j<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> img                train_label<span class="token punctuation">[</span>i <span class="token operator">*</span> k <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> people_num            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 构成测试集</span>                test_face<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> img                test_label<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> people_num    <span class="token keyword">return</span> train_face<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> test_face<span class="token punctuation">,</span> test_label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前期将所有训练图片矢量化之后，开始进行PCA算法的降维操作：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PCA</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#参数r代表降低到r维</span>    data <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>    rows<span class="token punctuation">,</span> cols <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    data_mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 对列求平均值</span>    A <span class="token operator">=</span> data <span class="token operator">-</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>data_mean<span class="token punctuation">,</span> <span class="token punctuation">(</span>rows<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 将所有样例减去对应均值得到A</span>    C <span class="token operator">=</span> A <span class="token operator">*</span> A<span class="token punctuation">.</span>T  <span class="token comment"># 得到协方差矩阵</span>    D<span class="token punctuation">,</span> V <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>eig<span class="token punctuation">(</span>C<span class="token punctuation">)</span>  <span class="token comment"># 求协方差矩阵的特征值和特征向量</span>    V_r <span class="token operator">=</span> V<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>  <span class="token comment"># 按列取前r个特征向量</span>    V_r <span class="token operator">=</span> A<span class="token punctuation">.</span>T <span class="token operator">*</span> V_r  <span class="token comment"># 小矩阵特征向量向大矩阵特征向量过渡</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>        V_r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> V_r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>V_r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 特征向量归一化</span>    final_data <span class="token operator">=</span> A <span class="token operator">*</span> V_r    <span class="token keyword">return</span> final_data<span class="token punctuation">,</span> data_mean<span class="token punctuation">,</span> V_r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们进行初次训练，随机选取每个人物的五张图片作为训练图片使用。将降低的维数设定为10维，查看一下训练效果如何：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">face_recongize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#对每一个人随机选取5张照片作为训练数据</span>  train_face<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> test_face<span class="token punctuation">,</span> test_label <span class="token operator">=</span> load_orl<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#随机选择每个人物的5张图片作为训练数据</span>  x_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  y_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">#将图片降维到10维</span>  data_train_new<span class="token punctuation">,</span> data_mean<span class="token punctuation">,</span> V_r <span class="token operator">=</span> PCA<span class="token punctuation">(</span>train_face<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  num_train <span class="token operator">=</span> data_train_new<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 训练脸总数</span>  num_test <span class="token operator">=</span> test_face<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 测试脸总数</span>  temp_face <span class="token operator">=</span> test_face <span class="token operator">-</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>data_mean<span class="token punctuation">,</span> <span class="token punctuation">(</span>num_test<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  data_test_new <span class="token operator">=</span> temp_face <span class="token operator">*</span> V_r  <span class="token comment"># 得到测试脸在特征向量下的数据</span>  data_test_new <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>data_test_new<span class="token punctuation">)</span>  <span class="token comment"># mat change to array</span>  data_train_new <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>data_train_new<span class="token punctuation">)</span>  true_num <span class="token operator">=</span> <span class="token number">0</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_test<span class="token punctuation">)</span><span class="token punctuation">:</span>      testFace <span class="token operator">=</span> data_test_new<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>      diffMat <span class="token operator">=</span> data_train_new <span class="token operator">-</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>testFace<span class="token punctuation">,</span> <span class="token punctuation">(</span>num_train<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 训练数据与测试脸之间距离</span>      sqDiffMat <span class="token operator">=</span> diffMat <span class="token operator">**</span> <span class="token number">2</span>      sqDistances <span class="token operator">=</span> sqDiffMat<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 按行求和</span>      sortedDistIndicies <span class="token operator">=</span> sqDistances<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 对向量从小到大排序，使用的是索引值,得到一个向量</span>      indexMin <span class="token operator">=</span> sortedDistIndicies<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 距离最近的索引</span>      <span class="token keyword">if</span> train_label<span class="token punctuation">[</span>indexMin<span class="token punctuation">]</span> <span class="token operator">==</span> test_label<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>          true_num <span class="token operator">+=</span> <span class="token number">1</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>          <span class="token keyword">pass</span>  accuracy <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>true_num<span class="token punctuation">)</span> <span class="token operator">/</span> num_test  x_value<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  y_value<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">round</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当对每个人随机选择%d张照片降低至%d维进行训练时，The classify accuracy is: %.2f%%'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span> accuracy <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终训练得到的结果如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918193440884.png" alt="image-20220918193440884"></p><p>为了对比实验，我们分别选取5张、7张、9张，还是降低到10维进行对比实验：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918193452524.png" alt="image-20220918193452524"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像识别 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门--数组与广义表</title>
      <link href="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/"/>
      <url>/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h2><p>数组是由相同类型的数据元素构成的有限集合。</p><p>数组一般采用顺序存储结构，因为存储单元是一维的，而数组可以是多维的，如何用一组连续的存储单元来存储多维数组呢？</p><p>以二维数组为例，可以按行序存储，即先存第一行，再存第二行……也可以按列序存储，先存第一列，再存第二列……</p><ol><li><p>按行序存储</p><p><strong>如果按行序存储，怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储 a ij 之前，前面已经存储了多少个元素：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916163751007.png" alt="image-20220916163751007"></p><p>在 a ij 之前一共有 i×n+j 个元素，如果每个元素占用 L 字节，那么共需要 (i×n+j)×L 字节，只需要用基地址加上这些字节就可以得到 a ij 的存储地址了。</p><p>按行序存储，a ij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916164635719.png" alt="image-20220916164635719"></p><p>LOC(a 00 )表示第一个元素的存储地址，即基地址，LOC(a ij)表示 a ij 的存储地址。</p></li><li><p>按列序存储</p><p><strong>如果按列序存储，怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储 a ij 之前，前面已经存储了多少个元素：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916164855734.png" alt="image-20220916164855734"></p><p>在 a ij 之前一共有 j×m+i 个元素，如果每个元素占用 L 字节，那么共需要(j×m+i)×L 字节，只需要用基地址加上这些字节就可以得到 a ij 的存储地址了。</p><p>按列序存储，a ij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916164922583.png" alt="image-20220916164922583"></p><p>LOC(a00 )表示第一个元素的存储地址，即基地址，LOC(a ij)表示 a ij 的存储地址。</p><blockquote><p><strong>注意：如果二维数组的下标是从 1 开始的，那么情形就变了。</strong></p></blockquote><p>先看看存储 a ij 之前，前面已经存储了多少个元素：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916165028591.png" alt="image-20220916165028591"></p><p>行数和个数都少 1，在 a ij 之前一共有 <strong>(i−1)×n+j−1</strong> 个元素，如果每个元素占用 L 字节，那么共需要 <strong>((i−1)×n+j−1)×L</strong> 字节，只需要用基地址加上这些字节就可以得到 a ij 的存储地址了。</p><p>如果二维数组下标从 1 开始，按行序存储，a ij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916165312801.png" alt="image-20220916165312801"></p><p>LOC(a11 )表示第一个元素的存储地址，即基地址，LOC(a ij)表示 a ij 的存储地址。</p><p>如果二维数组下标从 1 开始，按列序存储，a ij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916165344784.png" alt="image-20220916165344784"></p><p>也就是说，如果下标是从 1 开始的，相应的公式需要行减 1，列减 1。</p></li></ol><blockquote><p>存储地址计算秘籍：<strong>a ij 的存储地址等于第一个元素的存储地址，加上前面的元素个数乘以每个元素占用的字节数。</strong></p><p>LOC(aij) &#x3D; LOC(第一个元素) +(aij 前面的元素个数) × 每个元素占的字节</p></blockquote><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><ul><li><strong>什么是压缩存储？</strong>给多个相同的元素分配一个存储空间，元素为 0 的不分配空间。</li><li><strong>什么样的矩阵能够压缩？</strong>一些特殊矩阵，如对称矩阵、三角矩阵、对角矩阵、稀疏矩阵等。</li><li><strong>什么叫稀疏矩阵？</strong>矩阵中非零元素的个数较少，怎样才算是较少呢？一般认为非零元素个数小于 5%的矩阵为稀疏矩阵。</li></ul><h3 id="对称矩阵："><a href="#对称矩阵：" class="headerlink" title="对称矩阵："></a>对称矩阵：</h3><p>对称矩阵比较特殊，其数据元素沿着对角线对称，即：aij &#x3D; aji</p><p>那么，因为上三角和下三角是一样的，因此只存储其中的一个就可以了。如果用一维数组存储下三角，则只需要 <strong>n(n+1)&#x2F;2</strong> 个空间，比全部存储需要 n^2 个空间少了很多。</p><p><strong>如果按行序存储下三角，那么怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储下三角中的 a ij 之前，前面已经存储了多少个元素:</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916171702433.png" alt="image-20220916171702433"></p><p>如果将对称矩阵的下三角（i≥j）存储在一维数组 s[]中，那么下三角中 a ij 的下标就是 <strong>i(i−1)&#x2F;2+j−1</strong></p><p>而上三角的元素（i&lt;j），根据对称性，a ij &#x3D; a ji，可以直接读取下三角中的 a ji，因此按行序存储下三角时，a ij 的下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916172113874.png" alt="image-20220916172113874"></p><p><strong>存储下标计算秘籍：</strong>如果用一维数组 s[]存储（下标从 0 开始），则 a ij 的存储下标 k 等于a ij 前面的元素个数。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916174820163.png" alt="image-20220916174820163"></p><p>如果一维数组的下标从 1 开始呢？——公式后面再加 1 就行了。</p><p>上面的公式是计算一维数组存储的下标，如果给了基地址（a11 的存储地址），那么 aij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916175406759.png" alt="image-20220916175406759"></p><p>即 LOC(a ij)&#x3D;LOC(第一个元素)+(a ij 前面的元素个数)×每个元素占用的字节。</p><h3 id="三角矩阵："><a href="#三角矩阵：" class="headerlink" title="三角矩阵："></a>三角矩阵：</h3><p>三角矩阵比较特殊，分为下三角矩阵和上三角矩阵，下三角矩阵是指矩阵的下三角有数据，而其余的都是常数 c 或者为 0：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916180925565.png" alt="image-20220916180925565"></p><p>在下三角矩阵存储时，<strong>只需要存储其下三角中的元素，最后一个空间存储常数 c 即可。如果上面全为 0，则不需要存储</strong>；下三角也是如此。</p><p>例如下三角矩阵按行存储在一维数组 s[]中：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917122504003.png" alt="image-20220917122504003"></p><p><strong>下三角矩阵如果按行序存储，怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储 a ij 之前，前面已经存储了多少个元素：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917164303544.png" alt="image-20220917164303544"></p><p>如果一维数组的下标从零开始，那么下三角中 a ij 的下标就是 i(i−1)&#x2F;2+j−1。而上三角的元素因为全是常数 c 或者为 0，最后一个空间（下标为 n(n+1)&#x2F;2）存储常数 c 即可，如果是 0，则不需要存储。</p><p>因此下三角矩阵按行序存储时，a ij 的下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917164625796.png" alt="image-20220917164625796"></p><p><strong>上三角矩阵如果按行序存储，怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储 a ij 之前，前面已经存储了多少个元素（梯形公式）：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917164934887.png" alt="image-20220917164934887"></p><p>如果一维数组的下标从 0 开始，那么上三角中 aij 的下标就是(i−1)(2n−i+2)&#x2F;2+j−i。而下三角的元素全是常数 c 或者为 0，最后一个空间（下标为 n(n+1)&#x2F;2）存储常数 c 即可。</p><p>因此上三角矩阵按行序存储时，a ij 的下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917165936889.png" alt="image-20220917165936889"></p><h3 id="对角矩阵："><a href="#对角矩阵：" class="headerlink" title="对角矩阵："></a>对角矩阵：</h3><p>对角矩阵又称为带状矩阵，是指在 n×n 的矩阵中非零元素集中在主对角线及其两侧，共 L（奇数）条对角线的带状区域内，称为 L 对角矩阵：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917170215104.png" alt="image-20220917170215104"></p><ol><li><p><strong>L 对角矩阵非零元素个数</strong></p><p>首先将每一行以对角线为中心进行补零，让每一行都达到带宽 L 个元素。一共补了多少个零呢？第一行补 d 个 0，第二行补 d−1 个 0 左上角补零个数为 d (d+1)&#x2F;2。同理，右下角补零个数也为 d(d+1)&#x2F;2，总的补零个数为 d(d+1)。那么每行按 L 个元素计算，再减去补零元素个数即可，即带状区域元素个数为 L×n−d(d+1)。因为 d&#x3D;(L−1)&#x2F;2，即 L&#x3D;2d+1，所以带状区域元素个数也可以表达为(2d+1)×n−d(d+1)。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917171101974.png" alt="image-20220917171101974"></p></li><li><p><strong>按行序存储</strong></p><p>补零后每行都有 L 个元素，需要 L×n 个空间。为了节省空间，第一行前面和最后一行后面的 d 个 0 可以不存储，“<strong>掐头去尾</strong>”，需要 L×n−2d 个空间。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917172219604.png" alt="image-20220917172219604"></p><p><strong>怎么找到 a ij 的存储位置呢？</strong></p><p>首先找到 aii 的存储位置，因为 aii 是对角线上的元素，以对角线为中心，左右两侧都是d 个元素。a ii 之前有 i−1 行，每行 L 个元素，a ii 所在行左侧有 d 个元素，因此 a ii 之前有(i−1)×L+d 个元素。</p><p>因为第一行前面的 d 个 0“<strong>掐头去尾</strong>”没有存储，所以 a ii 之前有(i−1)×L 个元素。aii 的存储位置为：(i−1)×L。而 aij 和 aii 相差 j−i 个元素，也就是说，aij的存储位置为：(i−1)×L+j−i：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917175712065.png" alt="image-20220917175712065"></p><p>如果 a ij 在 a ii 的左侧（i&gt;j）呢？它们之间相差 i−j 个元素。只需要计算出 a ii 的存储位置，减去它们之间的差值就可以了。<br>即 aij 的存储位置为(i−1)×L−(i−j)&#x3D;(i−1)×L+j−i。</p><p><strong>公式总结：</strong></p><p>按行序，用一维数组（下标从 0 开始）存储 L 对角矩阵，a ij 的存储位置为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180013907.png" alt="image-20220917180013907"></p><p>例如3对角矩阵中 a ij 的存储位置为 k&#x3D;3(i−1)+j−i&#x3D;2i+j−3，如果一维数组的下标从 1 开始，公式后面再加 1 即可。</p></li><li><p><strong>按对角线存储</strong></p><p>对角矩阵还有一种按对角线的顺序存储方式：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180434868.png" alt="image-20220917180434868"></p><p>即对角线作为 0 行，左侧分别为 1, 2, …, d行，右侧分别为−1, −2, …, −d 行。相当于行转换为 i′&#x3D;i−j，列值 j 不变，把 n×n 的 L 对角矩阵转换为 L×n 的矩阵：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180505020.png" alt="image-20220917180505020"></p><p>将其他位置补零：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180540927.png" alt="image-20220917180540927"></p><p>用一维数组 s[]（下标从 0 开始）按行序存储，仍然采用“掐头去尾”，第一行前面和最后一行后面的 d 个 0 不存储：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180602358.png" alt="image-20220917180602358"></p><p><strong>怎么找到 a ij 的存储位置呢？</strong></p><p>a i′j 之前有 i′+d行，每行有 n 个元素，a i′j 所在行左侧有 j−1 个元素，因此 ai′j 之前有(i′+d)×n+j−1 个元素。</p><p>因为第一行前面的 d 个 0“掐头去尾”没有存储，所以 a i′j 之前有(i′+d)×n+j−1−d 个元素。a i′j的存储位置为：(i′+d)×n+j−1−d。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917181451463.png" alt="image-20220917181451463"></p><p>如果用一维数组（下标从 0 开始）按行序存储，a i′j 的下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917181526649.png" alt="image-20220917181526649"></p><p>又因为 i′&#x3D;i−j，因此对角矩阵中的 a ij 下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917181539937.png" alt="image-20220917181539937"></p><p><strong>公式总结：</strong></p><p>按对角线存储，对角矩阵中的 a ij 下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917181629298.png" alt="image-20220917181629298"></p></li></ol><h3 id="稀疏矩阵："><a href="#稀疏矩阵：" class="headerlink" title="稀疏矩阵："></a>稀疏矩阵：</h3><p>稀疏矩阵是指非零元素个数较少，且分布没有规律可言，那么少到什么程度才算稀疏呢？一般认为非零元素小于 5%时，属于稀疏矩阵。</p><p>当然也没那么绝对，只要非零元素个数远远小于矩阵元素个数，就可以认为是稀疏矩阵。</p><blockquote><p><strong>为了节省空间，只需要记录每个非零元素的行、列和数值即可，这就是三元组存储法</strong></p></blockquote><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917183620395.png" alt="image-20220917183620395"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表是线性表的推广，也称为列表。</p><blockquote><p>它是 n(n≥0)个表元素组成的有限序列，记作 **LS&#x3D; (a0 , a1, a2 , …, a n−1 )**。LS 是表名，a i 是表元素，它可以是表（称为子表），也可以是数据元素(称为原子)。</p><p>n 为表的长度，n&#x3D;0 的广义表为空表。</p></blockquote><p>广义表最常见的操作就是求表头和表尾。</p><ul><li><p>表头 GetHead(L)：</p><p>非空广义表的第一个元素，可以是一个单元素，也可以是一个子表。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220918093948840.png" alt="image-20220918093948840"></p></li><li><p>表尾 GetTail(L)：</p><p>删除表头元素后余下的元素所构成的表。表尾一定是一个表。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220918094015252.png" alt="image-20220918094015252"></p></li></ul><h2 id="数组与广义表学习技巧"><a href="#数组与广义表学习技巧" class="headerlink" title="数组与广义表学习技巧"></a>数组与广义表学习技巧</h2><p><strong>存储地址计算秘籍：</strong>a ij 的存储地址等于第一个元素的存储地址，加上前面的元素个数乘以每个元素占用的字节数。计算公式为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220918105951420.png" alt="image-20220918105951420"></p><p>LOC(第一个元素)表示第一个元素的存储地址，即基地址，LOC(a ij)表示 aij 的存储地址。</p><p><strong>存储下标计算秘籍：</strong>如果用一维数组 s[]存储（下标从 0 开始），则 aij 的存储下标 k 等于a ij 前面的元素个数。计算公式为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220918110119654.png" alt="image-20220918110119654"></p><p>如果一维数组的下标从 1 开始，公式后面再加 1 就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-字符串</title>
      <link href="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/"/>
      <url>/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>串：</strong>又称字符串，是由零个或多个字符组成的有限序列。</p><p><strong>串长：</strong>串中字符的个数，例如 S 的串长为 6。</p><p><strong>空串：</strong>零个字符的串，串长为 0。</p><p><strong>子串：</strong>串中任意个连续的字符组成的子序列，称为该串的子串，原串称为子串的主串。</p><blockquote><p>注意：空格也算一个字符。</p></blockquote><p><strong>空格串：</strong>全部由空格组成的串为空格串。</p><blockquote><p>注意：空格串不是空串。</p></blockquote><h3 id="顺序存储："><a href="#顺序存储：" class="headerlink" title="顺序存储："></a>顺序存储：</h3><ol><li><p>以’\0’表示字符串结束：</p><p>在 C、C++、Java 语言中，通常用’\0’表示字符串结束，’\0’不算在字符串长度内。</p></li><li><p>在 0 空间存储字符串的长度：</p><p>下标为 0 的空间不使用，因此可以预先分配 Maxsize+1 的空间，在下标为 0 的空间中存储字符串长度。</p></li><li><p>结构体变量存储字符串的长度：</p><p>串的运算如合并、插入、替换等操作，容易超过最大长度，出现溢出。为了解决这个问题，可以采用动态分配空间的方法，其结构体定义如下。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>  <span class="token comment">//指向字符串指针</span><span class="token keyword">int</span> length<span class="token punctuation">;</span>  <span class="token comment">//字符串的长度</span><span class="token punctuation">&#125;</span>SString<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="链式存储："><a href="#链式存储：" class="headerlink" title="链式存储："></a>链式存储：</h3><p>单链表存储字符串时，虽然插入和删除非常容易，但是这样做也有一个问题：一个节点只存储一个字符，如果需要存储的字符特别多，会浪费很多空间。</p><p>因此也可以考虑<strong>一个节点存储多个字符</strong>的形式，例如一个节点存储 3 个字符，最后一个节点不够 3 个时用#代替。</p><p>但是这样做也有一个大问题：如在第 2 个字符之前插入一个元素，就需要将 b 和 c 后移，那么这种后移还要跨到第二个节点，如同“蝴蝶效应”，一直波及最后一个节点，麻烦就大了！</p><p><strong>因此字符串很少使用链式存储结构，还是使用顺序存储结构更灵活一些。</strong></p><h2 id="模式匹配BF算法"><a href="#模式匹配BF算法" class="headerlink" title="模式匹配BF算法"></a>模式匹配BF算法</h2><p><strong>模式匹配：</strong>子串的定位运算称为串的模式匹配或串匹配。</p><p>假设有两个串 S、T，设 S 为主串，也称正文串；T 为子串，也称模式。</p><blockquote><p><strong>在主串 S 中查找与模式 T 相匹配的子串，如果查找成功，返回匹配的子串第一个字符在主串中的位置。</strong></p></blockquote><p>最笨的办法就是穷举所有 S 的所有子串，判断是否与 T 匹配，该算法称为 <strong>BF（Brute Force）</strong>算法。</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>从 S 第 1 个字符开始，与 T 第 1 个字符比较，如果相等，继续比较下一个字符，否则转向下一步；</li><li>从 S 第 2 个字符开始，与 T 第 1 个字符比较，如果相等，继续比较下一个字符，否则转向下一步，以此类推；</li><li>如果 T 比较完毕，则返回 T 在 S 中第一个字符出现的位置；</li><li>如果 S 比较完毕，则返回 0，说明 T 在 S 中未出现。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> SString<span class="token punctuation">[</span>Maxsize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//0号单元存放串的长度</span><span class="token keyword">bool</span> <span class="token function">StrAssign</span><span class="token punctuation">(</span>SString <span class="token operator">&amp;</span>T<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>chars<span class="token punctuation">)</span><span class="token comment">//生成一个其值等于chars的串T</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token operator">></span>Maxsize<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>chars<span class="token operator">+</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout<span class="token operator">&lt;&lt;</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Index_BF</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token comment">//BF算法</span><span class="token punctuation">&#123;</span> <span class="token comment">// 求T在主串S中第pos个字符之后第一次出现的位置</span><span class="token comment">//其中，T非空，1≤pos≤s[0],s[0]存放S串的长度</span><span class="token keyword">int</span> i<span class="token operator">=</span>pos<span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        sum<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 如果相等，则继续比较后面的字符</span><span class="token punctuation">&#123;</span>i<span class="token operator">++</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>i<span class="token operator">=</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//i退回到上一轮开始比较的下一个字符</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//j退回到第1个字符</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"一共比较了"</span><span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span><span class="token string">"次"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 匹配成功</span><span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析："><a href="#算法复杂度分析：" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p>设 S、T 串的长度分别为 n、m，则 BF 算法的时间复杂度分为以下两种情况：</p><ol><li><p>最好情况</p><p>在最好情况下，每一次匹配都在第一次比较时发现不等。</p><p>假设第 i 次匹配成功，则前 i−1 次匹配都进行了 1 次比较，一共 i−1 次，第 i 次匹配成功时进行了 m 次比较，则总的比较次数为 <strong>i−1+m</strong></p><p><strong>即模式串正好在主串的最后端。</strong></p><p>假 设 每 一 次 匹 配 成 功 的 概 率 均 等 ， 概 率p i &#x3D;1&#x2F;(n−m+1)，则在最好情况下，匹配成功的平均比较次数为：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914180721501.png" alt="image-20220914180721501"></p><p>最好情况下的平均时间复杂度为 O(n+m)。</p></li><li><p>最差情况</p><p>在最坏情况下，每一次匹配都比较到 T 的最后一个字符发现不等，回退重新开始，这样每次匹配都需要比较 m 次</p><p>假设第 i 次匹配成功，则前 i−1 次匹配都进行了 m 次比较，第 i 次匹配成功时也进行 m次比较，则总的比较次数为 <strong>i×m</strong></p><p>在匹配成功的情况下，最多需要 n−m+1 次匹配，<strong>即模式串正好在主串的最后端</strong></p><p>假设每一次匹配成功的概率均等，概率 p i&#x3D;1&#x2F;(n−m+1)，则在最坏情况下，匹配成功的平均比较次数为：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914180846050.png" alt="image-20220914180846050"></p><p>最坏情况下的平均时间复杂度为 O(n×m)。</p></li></ol><h2 id="模式匹配KMP算法"><a href="#模式匹配KMP算法" class="headerlink" title="模式匹配KMP算法"></a>模式匹配KMP算法</h2><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><p>按照 BF 算法，如果匹配的字符串不等，则 i 回退到 i−j+2，j 回退到 1，即 i&#x3D;2，j&#x3D;1：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914215010257.png" alt="image-20220914215010257"></p><p>其实 i 不用回退，让 j 回退到第 3 个位置，接着比较即可：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914215026957.png" alt="image-20220914215026957"></p><p>那怎么知道 T 中开头的两个字符和 i 指向的字符前面的两个字符一模一样？难道还要比较？</p><p>我们发现 i 指向的字符前面的两个字符和 T 中 j 指向的字符前面两个字符一模一样，<strong>因为它们一直相等， i++、j++才会走到当前的位置</strong>：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914215201151.png" alt="image-20220914215201151"></p><p>也就是说，我们不必判断开头的两个字母和 i 指向的字符前面的两个字符是否一样，只需要在 T 本身比较就可以了。</p><p>假设 T 中当前 j 指向的字符前面的所有字符为 T′，<strong>只需要比较T′的前缀和 T′的后缀即可</strong>：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914215308905.png" alt="image-20220914215308905"></p><blockquote><p>注意：前缀和后缀不可以取字符串本身。如果串的长度为 n，前缀和后缀长度最多达到 <strong>n−1</strong></p></blockquote><p>因此，当 i、j 指向的字符不等时，只需要求出 T′的相等前缀后缀的最大长度 l，<strong>i 不变，j 回退到 l+1的位置继续比较即可</strong>。</p><p><strong>这样找所有的前缀和后缀比较，是不是也是暴力穷举？那怎么办呢？</strong>可以用动态规划递推</p><blockquote><p>有了 next[]数组，就很容易进行模式匹配了，当 S[i]≠T[j]时，i 不动，j 回退到 next[j]的位置继续比较即可。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//计算next函数值</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>            next<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">++</span>k<span class="token punctuation">;</span><span class="token keyword">else</span>k<span class="token operator">=</span>next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"-----next[]-------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Index_KMP</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//KMP算法</span><span class="token punctuation">&#123;</span> <span class="token comment">// 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><span class="token comment">//其中，T非空，1≤pos≤StrLength(S)</span><span class="token keyword">int</span> i<span class="token operator">=</span>pos<span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        sum<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 继续比较后面的字符</span><span class="token punctuation">&#123;</span>i<span class="token operator">++</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span>j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 模式串向右移动</span>    <span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"一共比较了"</span><span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span><span class="token string">"次"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 匹配成功</span><span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-1"><a href="#算法复杂度分析：-1" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p>设 S、T 串的长度分别为 n、m。KMP 算法的特点是：i 不回退，当 S[i]≠T[j]时，j 回退到 next[j]，重新开始比较。</p><p><strong>最坏情况下扫描整个 S 串，其时间复杂度为 O(n)。</strong></p><p><strong>计算 next[]数组需要扫描整个 T 串，其时间复杂度为 O(m)，因此总的时间复杂度为 O(n+m)。</strong></p><p>需要注意的是，尽管 BF 算法最坏情况下时间复杂度为 O(n×m)，KMP 算法的时间复杂度为 O(n+m)。但是在实际运用中，BF 算法的时间复杂度一般为 O(n+m)，因此仍然有很多地方用 BF 算法进行模式匹配。</p><blockquote><p><strong>只有在主串和子串有很多部分匹配的情况下，KMP 才显得更优越。</strong></p></blockquote><h2 id="改进的KMP算法"><a href="#改进的KMP算法" class="headerlink" title="改进的KMP算法"></a>改进的KMP算法</h2><h3 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h3><p>在 KMP 算法中，next[]求解非常方便、迅速，但是也有一个问题：当 s i≠t j 时，j 回退到 next[j]（k&#x3D;next[j]），然后 s i 与 t k 比较。这样的确没错，但是如果 t k&#x3D;t j，这次比较就没必要了，因为刚才就是因为 s i≠t j 才回退的，那么肯定 s i≠t k，完全没必要再比了：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220915111812301.png" alt="image-20220915111812301"></p><p>再向前回退，找下一个位置 next[k]，继续比较就可以了。当 si≠tj 时，本来应该 j 回退到next[j]（k&#x3D;next[j]），si 与 t k 比较。</p><p><strong>但是如果 t k&#x3D;t j，则不需要比较，继续回退到下一个位置 next[k]，减少了一次无效比较。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_next2</span><span class="token punctuation">(</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//计算next函数值改进算法</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span>k<span class="token operator">=</span>next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"-----next[]-------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-2"><a href="#算法复杂度分析：-2" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p>设 S、T 的长度分别为 n、m。改进的 KMP 算法只是在求解 next[]从常数上的改进，并没有降阶，因此其时间复杂度仍为 O(n+m)。</p><h2 id="字符串的应用–病毒检测"><a href="#字符串的应用–病毒检测" class="headerlink" title="字符串的应用–病毒检测"></a>字符串的应用–病毒检测</h2><p><strong>题目：</strong>疫情暴发，专家发现了一种新型环状病毒，这种病毒的 DNA 序列是环状的，而人类的 DNA 序列是线性的。专家把人类和病毒的 DNA 表示为字母组成的字符串序列，如果在某个患者的 DNA 中发现这种环状病毒，说明该患者已被感染病毒，否则没有感染。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>该问题属于字符串的模式匹配问题，可以使用前面讲的 BF 或 KMP 算法求解。这里需要对环状病毒进行处理，然后调用模式匹配算法即可。</p><p>处理环状病毒：</p><ol><li><p>环形处理</p><p>使用循环存储的方式，类似循环队列或循环链表的处理方式。假设病毒的 DNA 长度为m，依次从环状存储空间中每一个下标开始，取 m 个字符作为病毒序列：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220915165432322.png" alt="image-20220915165432322"></p></li><li><p>线性处理</p><p>将病毒序列扩大两倍，依次从每个下标开始，取 m 个字符，作为病毒序列。</p><p>例如，病毒序列：aabb，如图 4-45 所示。将该病毒序列扩大两倍。从每个下标（1、2、3、4）开始取 4 个字符，分别为 aabb、abba、bbaa、baab，这 4 个序列都是病毒序列的变种：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220915165525020.png" alt="image-20220915165525020"></p></li></ol><h3 id="步骤：-3"><a href="#步骤：-3" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>首先对环状病毒进行处理（环形处理或线性处理）。</li><li>依次把每一个环状病毒变种作为子串，把患者 DNA 序列作为主串，进行模式匹配。一旦匹配成功，立即结束，返回已感染病毒。</li><li>重复运行第 2 步。</li><li>如果检测所有病毒变种都未匹配成功，返回未感染病毒。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Virus_detection</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span> SString T<span class="token punctuation">)</span><span class="token comment">//病毒检测</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    SString temp<span class="token punctuation">;</span><span class="token comment">//temp记录病毒变种</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//将T串扩大一倍，T[0]为病毒长度</span>        T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//依次检测T[0]个病毒变种</span>    <span class="token punctuation">&#123;</span>        temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">////病毒变种长度为T[0]</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//取出一个病毒变种</span>            temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>T<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Index_KMP</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>temp<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//检测到病毒</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-3"><a href="#算法复杂度分析：-3" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p>假设病毒 DNA 序列长度为 m，则一共有 m 个变种，需要进行 m 次模式匹配，每次模式匹配如果使用 KMP 算法，其时间复杂度为 O(n+m)，则总的时间复杂度为 O(m×(n+m))。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-栈和队列</title>
      <link href="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/"/>
      <url>/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote><p><strong>后进先出（Last In First Out，LIFO）</strong>的线性序列，称为“栈”。栈也是一种线性表，只不过它是操作受限的线性表，只能在一端进出操作。</p><p>进出的一端称为栈顶（top），另一端称为栈底（base）。栈可以用顺序存储，也可以用链式存储，分别称为顺序栈和链栈。</p></blockquote><h3 id="顺序栈："><a href="#顺序栈：" class="headerlink" title="顺序栈："></a>顺序栈：</h3><p>顺序栈需要两个指针，base 指向栈底，top 指向栈顶。栈定义好了之后，还要先定义一个最大的分配空间，顺序结构都是如此，需要预先分配<br>空间。</p><blockquote><p>注意：栈只能在一端操作，后进先出，是人为规定的，也就是说<strong>不允许在中间查找、取值、插入、删除等操作</strong>。</p></blockquote><p>顺序栈本身是顺序存储的，有人就想：我偏要从中间取一个元素，不行吗？那肯定可以，但是这样做，就不是栈了。</p><h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><ol><li>初始化一个空栈，动态分配 Maxsize 大小的空间，用 S.top 和 S.base 指向该空间的基地址</li><li>注意判断空间分配是否成功</li></ol><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220910165857429.png" alt="image-20220910165857429"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//预先分配空间，这个数值根据实际需要预估确定；</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SqStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> <span class="token operator">*</span>base<span class="token punctuation">;</span> <span class="token comment">//栈底指针</span><span class="token keyword">int</span> <span class="token operator">*</span>top<span class="token punctuation">;</span> <span class="token comment">//栈顶指针</span><span class="token punctuation">&#125;</span>SqStack<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span> <span class="token comment">//构造一个空栈S</span><span class="token punctuation">&#123;</span>S<span class="token punctuation">.</span>base<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//为顺序栈分配一个最大容量为Maxsize的空间</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>    <span class="token comment">//空间分配失败</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>S<span class="token punctuation">.</span>top<span class="token operator">=</span>S<span class="token punctuation">.</span>base<span class="token punctuation">;</span>  <span class="token comment">//top初始为base，空栈</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入栈："><a href="#入栈：" class="headerlink" title="入栈："></a>入栈：</h4><p>入栈前要判断是否栈满，如果栈已满，则入栈失败；否则将元素放入栈顶，栈顶指针向上移动一个位置（top++）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token comment">// 插入元素e为新的栈顶元素</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span>S<span class="token punctuation">.</span>base<span class="token operator">==</span>Maxsize<span class="token punctuation">)</span> <span class="token comment">//栈满</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//元素e压入栈顶，然后栈顶指针加1，等价于*S.top=e; S.top++;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出栈："><a href="#出栈：" class="headerlink" title="出栈："></a>出栈：</h4><p>出栈前要判断是否栈空，如果栈是空的，则出栈失败；否则将栈顶元素暂存给一个变量，栈顶指针向下移动一个位置（top−−）。</p><ol><li><p>栈顶元素所在的位置实际上是 S.top −1，因此把该元素取出来，暂存在变量 e 中，然后 S.top 指针向下移动一个位置。</p></li><li><p>因此<strong>可以先移动一个位置</strong>，即− −S.top，然后再取元素。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220910170541077.png" alt="image-20220910170541077"></p></li></ol><blockquote><p>因为顺序存储删除一个元素时，并没有销毁该空间，所以 4 其实还在那个位置，只不过下次再有元素进栈时，就把它<strong>覆盖</strong>了。</p><p>相当于该元素已出栈，因为栈的内容是 S.base 到 S.top−1。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除S的栈顶元素，暂存在变量e中</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>base<span class="token operator">==</span>S<span class="token punctuation">.</span>top<span class="token punctuation">)</span> <span class="token comment">//栈空</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>e<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>S<span class="token punctuation">.</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//栈顶指针减1，将栈顶元素赋给e</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取栈顶元素："><a href="#取栈顶元素：" class="headerlink" title="取栈顶元素："></a>取栈顶元素：</h4><p>取栈顶元素和出栈不同。取栈顶元素只是把栈顶元素复制一份，栈顶指针未移动，栈内元素个数未变。</p><p>而出栈是指栈顶指针向下移动一个位置，栈内不再包含这个元素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">GetTop</span><span class="token punctuation">(</span>SqStack S<span class="token punctuation">)</span> <span class="token comment">//返回S的栈顶元素，栈顶指针不变</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">!=</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>  <span class="token comment">//栈非空</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回栈顶元素的值，栈顶指针不变</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链栈："><a href="#链栈：" class="headerlink" title="链栈："></a>链栈：</h3><p>链栈每个节点的地址是不连续的，只需要一个栈顶指针即可。</p><p>链栈的每个节点都包含两个域：数据域和指针域。是不是和单链表一模一样？可以把链栈看作一个不带头节点的单链表，但只能在头部进行插入、删除、取值等操作，不可以在中间和尾部操作。</p><h4 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h4><p>初始化一个空的链栈是不需要头节点的，因此只需要让栈顶指针为空即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Snode</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//数据域</span><span class="token keyword">struct</span> <span class="token class-name">Snode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span>Snode<span class="token punctuation">,</span><span class="token operator">*</span>LinkStack<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token comment">//构造一个空栈S</span><span class="token punctuation">&#123;</span>S<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入栈：-1"><a href="#入栈：-1" class="headerlink" title="入栈："></a>入栈：</h4><p>入栈是将新元素节点压入栈顶。因为链栈中第一个节点为栈顶，因此将新元素节点插到第一个节点的前面，然后修改栈顶指针指向新节点即可。</p><ol><li><p>生成新节点。入栈前要创建一个新节点，将元素 e 存入该节点的数据域。</p></li><li><p>将新元素节点插到第一个节点的前面，然后修改栈顶指针指向新节点。</p><ul><li>p-&gt;next&#x3D;S：将 S 的地址赋值给 p 的指针域，即新节点 p 的 next 指针指向 S。</li><li>S&#x3D;p：修改新的栈顶指针为 p。</li></ul><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220910182149962.png" alt="image-20220910182149962"></p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Push</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token comment">//在栈顶插入元素e</span><span class="token punctuation">&#123;</span>LinkStack p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token keyword">new</span> Snode<span class="token punctuation">;</span> <span class="token comment">//生成新结点</span>p<span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//将e放在新结点数据域</span>p<span class="token operator">-></span>next<span class="token operator">=</span>S<span class="token punctuation">;</span> <span class="token comment">//将新结点的指针域指向S，即将S的地址赋值给新结点的指针域</span>S<span class="token operator">=</span>p<span class="token punctuation">;</span>    <span class="token comment">//修改栈顶指针为p</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出栈：-1"><a href="#出栈：-1" class="headerlink" title="出栈："></a>出栈：</h4><p>出栈就是把栈顶元素删除，让栈顶指针指向下一个节点，然后释放该节点空间。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220910183055312.png" alt="image-20220910183055312"></p><ul><li>p&#x3D;S：将 S 的地址赋值给 p，即 p 指向栈顶元素节点。</li><li>S&#x3D;S-&gt;next：将 S 的后继节点的地址赋值给 S，即 S 指向它的后继节点。</li><li>delete p：最后释放 p 指向的节点空间，即 delete p。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Pop</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除S的栈顶元素，用e保存其值</span><span class="token punctuation">&#123;</span>LinkStack p<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//栈空</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>e<span class="token operator">=</span>S<span class="token operator">-></span>data<span class="token punctuation">;</span>  <span class="token comment">//将栈顶元素赋给e</span>p<span class="token operator">=</span>S<span class="token punctuation">;</span>  <span class="token comment">//用p保存栈顶元素地址，以备释放</span>S<span class="token operator">=</span>S<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">//修改栈顶指针，指向下一个结点</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span>  <span class="token comment">//释放原栈顶元素的空间</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取栈顶元素：-1"><a href="#取栈顶元素：-1" class="headerlink" title="取栈顶元素："></a>取栈顶元素：</h4><p>取栈顶元素和出栈不同，取栈顶元素只是把栈顶元素复制一份，栈顶指针并没有改变。而出栈是指删除栈顶元素，栈顶指针指向了下一个元素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">GetTop</span><span class="token punctuation">(</span>LinkStack S<span class="token punctuation">)</span> <span class="token comment">//返回S的栈顶元素，不修改栈顶指针</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//栈非空</span><span class="token keyword">return</span> S<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//返回栈顶元素的值，栈顶指针不变</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>顺序栈和链栈的所有基本操作都只需要常数时间，所以在时间效率上难分伯仲。</p><p>在空间效率方面，顺序栈需要预先分配固定长度的空间，有可能造成空间浪费或溢出；链栈每次只分配一个节点，除非没有内存，否则不会出现溢出，但是每个节点需要一个指针域，结构性开销增加。</p><p>因此，如果<strong>元素个数变化较大，可以采用链栈</strong>；反之，可以采用顺序栈。在实际应用中，顺序栈比链栈应用更广泛。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p>这种<strong>先进先出（First In First Out，FIFO）</strong>的线性序列，称为“队列”。队列也是一种线性表，只不过它是操作受限的线性表，只能在两端操作：一端进，一端出。</p><p>进的一端称为队尾（rear），出的一端称为队头（front）。</p></blockquote><h3 id="顺序队列："><a href="#顺序队列：" class="headerlink" title="顺序队列："></a>顺序队列：</h3><p>队列的顺序存储采用一段连续的空间存储数据元素，并用两个整型变量记录队头和队尾元素的下标。顺序队列定义好了之后，还要先定义一个最大的分配空间，顺序结构都是如此，需要预先分配空间。</p><blockquote><p>注意：队列只能在一端进、一端出，<strong>不允许在中间查找、取值、插入、删除等操作</strong>，先进先出是人为规定的，如果破坏此规则，就不是队列了。</p></blockquote><h4 id="入队和出队操作："><a href="#入队和出队操作：" class="headerlink" title="入队和出队操作："></a>入队和出队操作：</h4><ol><li><p>开始时为空队，Q.front &#x3D; Q.rear:</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172051098.png" alt="image-20220911172051098"></p></li><li><p>元素进队，放入队尾 Q.rear 的位置，然后 Q.rear 后移一位：</p></li></ol><p>   <img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172109380.png" alt="image-20220911172109380"></p><ol start="3"><li><p>元素出队，队头 Q.front 后移一位：</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172134406.png" alt="image-20220911172134406"></p></li><li><p>若此时队尾 Q.rear 已经超过了数组的最大下标，无法再进队，但是前面有空间却出现了队满的情况，这种情况称为“假溢出”：</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172240405.png" alt="image-20220911172240405"></p></li><li><p>为了解决“假溢出”，此时已经超过了数组的最大下标，即 Q.rear+1&#x3D;Maxsize（最大空间数 6），那么如果前面有空闲，Q.rear 可以转向前面下标为 0 的位置：</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172256567.png" alt="image-20220911172256567"></p></li><li><p>当队列空间存满时，出现一个问题Q.front&#x3D;Q.rear，这和队空的条件一模一样，无法区分到底是队空，还是队满。有两种解决方法：</p><ul><li>一种办法是设置一个标志，标记队空和队满。</li><li>另一种办法是浪费一个空间，当队尾 Q.rear 的下一个位置 Q.front 时，就认为是队满。</li></ul></li></ol><p>上述到达尾部又向前存储的队列称为循环队列，<strong>为了避免“假溢出”，顺序队列通常采用循环队列</strong>。</p><h3 id="循环队列："><a href="#循环队列：" class="headerlink" title="循环队列："></a>循环队列：</h3><h4 id="队空："><a href="#队空：" class="headerlink" title="队空："></a>队空：</h4><p>无论队头和队尾在什么位置，只要 Q.rear 和 Q.front 指向同一个位置，就认为是队空。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911173711877.png" alt="image-20220911173711877"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="队满："><a href="#队满：" class="headerlink" title="队满："></a>队满：</h4><p>在此采用浪费一个空间的方法，当队尾 Q.rear 的下一个位置 Q.front 时，就认为是队满。</p><h5 id="临界状态："><a href="#临界状态：" class="headerlink" title="临界状态："></a>临界状态：</h5><p>但是 Q.rear 向后移动一个位置（Q.rear+1）后，很有可能超出了数组的最大下标，这时它的下一个位置应该为 0:</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911174340821.png" alt="image-20220911174340821"></p><p>队列的最大空间为 Maxsize，当 Q.rear&#x3D;Maxsize−1 时，Q.rear+1&#x3D;Maxsize。而根据循环队列的规则，Q.rear 的下一个位置为 0 才对，怎么才能变成 0 呢？</p><p>可以考虑<strong>取余运算</strong>，即(Q.rear+1)%Maxsize&#x3D;0。而此时 Q.front&#x3D;0，即(Q.rear+1)%Maxsize&#x3D;Q.front，此时为队满的临界状态。</p><h5 id="一般状态："><a href="#一般状态：" class="headerlink" title="一般状态："></a>一般状态：</h5><p>假如最大空间数 Maxsize&#x3D;100，当 Q.rear&#x3D;1 时，Q.rear+1&#x3D;2。取余后，(Q.rear+1)%Maxsize&#x3D;2，而此时 Q.front&#x3D;2，即(Q.rear+1)%Maxsize&#x3D;Q.front。</p><p>队满的一般状态也可以采用此公式判断队满。因为一个不大于 Maxsize 的数与 Maxsize 取余运算，结果仍然是该数本身，所以一般状态下，取余运算没有任何影响。</p><p><strong>只有在临界状态（Q.rear+1&#x3D;Maxsize）下，取余运算(Q.rear+1)%Maxsize 才会变为 0。</strong></p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911175419957.png" alt="image-20220911175419957"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h4><p>首先分配一个大小为 Maxsize 的空间，然后令 Q.front&#x3D;Q.rear&#x3D;0，即队头和队尾为 0，队列为空。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> <span class="token class-name">SqQueue</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> <span class="token operator">*</span>base<span class="token punctuation">;</span> <span class="token comment">//基地址</span><span class="token keyword">int</span> front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span> <span class="token comment">//头指针,尾指针</span><span class="token punctuation">&#125;</span>SqQueue<span class="token punctuation">;</span><span class="token comment">//循环队列的初始化</span><span class="token keyword">bool</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token comment">//注意使用引用参数，否则出了函数，其改变无效</span><span class="token punctuation">&#123;</span>Q<span class="token punctuation">.</span>base<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//分配空间</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//头指针和尾指针置为零，队列为空</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入队："><a href="#入队：" class="headerlink" title="入队："></a>入队：</h4><p>入队时，首先将元素 x 放入 Q.rear 所指空间，然后 Q.rear 后移一位。</p><p>当 Q.rear 后移一位时，为了处理临界状态（Q.rear+1&#x3D;Maxsize），需要加 1 后取余运算。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//循环队列的入队</span><span class="token keyword">bool</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token comment">//将元素e放入Q的队尾</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token operator">==</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> <span class="token comment">//尾指针后移一位等于头指针，表明队满</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//新元素插入队尾</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span> <span class="token comment">//队尾指针加1</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出队："><a href="#出队：" class="headerlink" title="出队："></a>出队：</h4><p>先用变量保存队头元素，然后队头 Q.front 后移一位。</p><p>当 Q.front 后移一位时，为了处理临界状态（Q.front+1&#x3D;Maxsize），需要加 1后取余运算。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//循环队列的出队</span><span class="token keyword">bool</span> <span class="token function">DeQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除Q的队头元素，用e返回其值</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">==</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//队空</span>e<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//保存队头元素</span>Q<span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span> <span class="token comment">//队头指针加1</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取队头元素："><a href="#取队头元素：" class="headerlink" title="取队头元素："></a>取队头元素：</h4><p>取队头元素时，只是把队头元素数据复制一份即可，并未改变队头位置，因此队列中的内容没有改变。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//取循环队列的队头元素</span><span class="token keyword">int</span> <span class="token function">GetHead</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span><span class="token comment">//返回Q的队头元素，不修改队头指针</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">!=</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span> <span class="token comment">//队列非空</span><span class="token keyword">return</span> Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="队列元素个数计算："><a href="#队列元素个数计算：" class="headerlink" title="队列元素个数计算："></a>队列元素个数计算：</h4><p>循环队列中的内容实际上为 Q.front～Q.rear−1 这一区间的数据元素，<strong>但是不可以直接用两个下标相减得到。因为队列是循环的</strong>，所以存在两种情况。</p><ul><li><p>Q.rear≥Q.front:</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911183047358.png" alt="image-20220911183047358"></p></li><li><p>Q.rear&lt;Q.front:</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911183539299.png" alt="image-20220911183539299"></p></li></ul><p>此时，Q.rear&#x3D;4，Q.front&#x3D;Maxsize−2，Q.rear-Q.front&#x3D;6−Maxsize。但是我们可以看到循环队列中的元素实际上为 6 个，那怎么办呢？当两者之差为负数时，可以将差值加上 Maxsize计算元素个数，即 Q.rear−Q.front+Maxsize&#x3D;6−Maxsize+Maxsize&#x3D;6，元素个数为 6。</p><blockquote><p>因此，在计算元素个数时，可以分两种情况判断。<br>1）<strong>Q.rear≥Q.front：元素个数为 Q.rear−Q.front。</strong><br>2）<strong>Q.rear&lt;Q.front：元素个数为 Q.rear−Q.front+Maxsize。</strong></p></blockquote><p>也可以采用取余的方法把两种情况巧妙地统一为一个语句:</p><blockquote><p><strong>队列中元素个数为：(Q.rear-Q.front+Maxsize)%Maxsize</strong></p><p>%Maxsize 是为了防止 Q.rear-Q.front 为正数的情况，</p><p>+Maxsize 是为了防止 Q.rear-Q.front为负数的情况</p></blockquote><h4 id="求队列的长度："><a href="#求队列的长度：" class="headerlink" title="求队列的长度："></a>求队列的长度：</h4><p>通过前面的分析，我们已经知道循环队列中元素个数为：(Q.rear−Q.front+Maxsize)%Maxsize，循环队列中元素个数即为循环队列的长度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//循环队列的长度</span><span class="token keyword">int</span> <span class="token function">QueueLength</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链队列："><a href="#链队列：" class="headerlink" title="链队列："></a>链队列：</h3><p>链队列类似一个单链表，需要两个指针 front 和 rear 分别指向队头和队尾。从队头出队，从队尾入队，为了出队时删除元素方便，可以增加一个头节点。</p><blockquote><p><strong>注意：链队列需要头节点</strong></p></blockquote><h4 id="初始化：-3"><a href="#初始化：-3" class="headerlink" title="初始化："></a>初始化：</h4><p>链队列的初始化，即创建一个头节点，头指针和尾指针指向头节点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> <span class="token class-name">Qnode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">Qnode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Qnode<span class="token punctuation">,</span><span class="token operator">*</span>Qptr<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  Qnode <span class="token operator">*</span>front<span class="token punctuation">;</span>  Qnode <span class="token operator">*</span>rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>LinkQueue<span class="token punctuation">;</span><span class="token comment">//链队的初始化</span><span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token comment">//注意使用引用参数，否则出了函数，其改变无效</span><span class="token punctuation">&#123;</span>Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token keyword">new</span> Qnode<span class="token punctuation">;</span> <span class="token comment">//创建头结点，头指针和尾指针指向头结点</span>Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入队：-1"><a href="#入队：-1" class="headerlink" title="入队："></a>入队：</h4><ol><li><p>先创建一个新节点，将元素 e 存入该节点的数值域。</p></li><li><p>然后将新节点插入队尾，尾指针后移。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911221232441.png" alt="image-20220911221232441"></p><ul><li>Q.rear-&gt;next&#x3D;s：把 s 节点的地址赋值给队列尾节点的 next 域，即尾节点的 next 指针指向 s。</li><li>Q.rear&#x3D;s：把 s 节点的地址赋值给尾指针，即尾指针指向 s，尾指针永远指向队尾。</li></ul></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//链队列的入队</span><span class="token keyword">void</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token comment">//将元素e放入队尾</span><span class="token punctuation">&#123;</span>Qptr s<span class="token punctuation">;</span>s<span class="token operator">=</span><span class="token keyword">new</span> Qnode<span class="token punctuation">;</span>s<span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>s<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment">//新元素插入队尾</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>s<span class="token punctuation">;</span>     <span class="token comment">//队尾指针后移</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出队：-1"><a href="#出队：-1" class="headerlink" title="出队："></a>出队：</h4><p>出队相当于删除第一个数据元素，即将第一个数据元素节点跳过去。</p><ol><li><p>首先用 p 指针指向第一个数据节点，然后跳过该节点，即 Q.front-&gt;next&#x3D;p-&gt;next。</p></li><li><p><strong>若队列中只有一个元素，删除后需要修改队尾指针。</strong></p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911222148596.png" alt="image-20220911222148596"></p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//链队列的出队</span><span class="token keyword">bool</span> <span class="token function">DeQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除Q的队头元素，用e返回其值</span><span class="token punctuation">&#123;</span>Qptr p<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">==</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token comment">//队空</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>p<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token punctuation">;</span>e<span class="token operator">=</span>p<span class="token operator">-></span>data<span class="token punctuation">;</span>     <span class="token comment">//保存队头元素</span>Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">==</span>p<span class="token punctuation">)</span> <span class="token comment">//若队列中只有一个元素，删除后需要修改队尾指针</span>        Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取队头元素：-1"><a href="#取队头元素：-1" class="headerlink" title="取队头元素："></a>取队头元素：</h4><p>队头实际上是 Q.front-&gt;next 指向的节点，即第一个数据节点，队头元素就是将该节点的数据域存储的元素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//取循环队列的队头元素</span><span class="token keyword">int</span> <span class="token function">GetHead</span><span class="token punctuation">(</span>LinkQueue Q<span class="token punctuation">)</span><span class="token comment">//返回Q的队头元素，不修改队头指针</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">!=</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span> <span class="token comment">//队列非空</span><span class="token keyword">return</span> Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈和队列的应用："><a href="#栈和队列的应用：" class="headerlink" title="栈和队列的应用："></a>栈和队列的应用：</h2><h3 id="数制的转换："><a href="#数制的转换：" class="headerlink" title="数制的转换："></a>数制的转换：</h3><p><strong>题目：</strong>将一个十进制数 n 转换为二进制数。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>十进制数转换为二进制，可以采用辗转相除、取余数的方法得到。例如十进制数 11 转二进制。先求余数 11%2&#x3D;1，求商 11&#x2F;2&#x3D;5，然后用商 5 再求余数，求商，直到商为 0，结束。</p><p>先求出的余数是二进制数的低位，后求出的余数是二进制数的高位，将得到的余数逆序输出就是所要的二进制数，即 11 的二进制数为 1011。如何将余数逆序输出呢？</p><p><strong>逆序输出正好符合栈的先入后出性质，因此可以借助栈来实现。</strong></p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>初始化一个栈 S。</li><li>如果 n!&#x3D;0，将 n%2 入栈 S，更新 n&#x3D;n&#x2F;2。</li><li>重复运行第 2 步，直到 n&#x3D;0 为止。</li><li>如果栈不空，弹出栈顶元素 e，输出 e，直到栈空。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> Elemtype<span class="token punctuation">;</span><span class="token comment">//先类型定义为int </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"sqstack.h"</span><span class="token comment">//引入自定义头文件,源码目录下名为sqstack.h的文件  </span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">binaryconversion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    SqStack S<span class="token punctuation">;</span><span class="token comment">//定义一个栈S</span>    <span class="token keyword">int</span> e<span class="token punctuation">;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Empty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果栈不空</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出栈</span>        cout<span class="token operator">&lt;&lt;</span>e<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token punctuation">;</span><span class="token comment">//输出栈顶元素</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析："><a href="#算法复杂度分析：" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>每次取余后除以 2，n 除以 2 多少次变为 1，那么第一个 while 语句就执行多少次。假设执行 x 次，则 n&#x2F;2x&#x3D;1，x&#x3D;log2n。因此，时间复杂度为 O(log2n)，使用的栈空间大小也是 log2n，空间复杂度也为 O(log 2n)。</p><h3 id="回文判定："><a href="#回文判定：" class="headerlink" title="回文判定："></a>回文判定：</h3><p><strong>题目：</strong>回文是指正读反读均相同的字符序列，如“abba”和“abcscba”均是回文，也就是说字符串沿中心线对称。试写一个算法判定给定的字符串是否为回文。</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p><strong>回文是中心对称的，可以将字符串前一半入栈，然后，栈中元素和字符串后一半进行比较。</strong>即将第一个出栈元素和后一半串中第一个字符比较，若相等，则再将出栈一个元素与后一个字符比较……直到栈空为止，则字符序列是回文。</p><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>初始化一个栈S。</li><li>求字符串长度，将前面一半的字符依次入栈 S。</li><li>如果栈不空，弹出栈顶元素 e，与字符串后一半元素比较。<strong>若 n 为奇数，则跳过中心点，比较中心点后面的元素。</strong>如果元素相等，则继续比较直到栈空，返回 true；如果元素不等，返回 false。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> Elemtype<span class="token punctuation">;</span><span class="token comment">//先类型定义为char </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"sqstack.h"</span><span class="token comment">//引入自定义头文件,源码目录下名为sqstack.h的文件   </span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">palindrome</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token comment">//判断字符串是否为回文</span><span class="token punctuation">&#123;</span>    SqStack S<span class="token punctuation">;</span><span class="token comment">//定义一个栈S</span>    <span class="token keyword">int</span> len<span class="token punctuation">,</span>i<span class="token punctuation">;</span>    <span class="token keyword">char</span> e<span class="token punctuation">;</span>    len<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回字符串长度</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化栈</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//将字符串前一半依次入栈</span>        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//字符串长度为奇数，跳过中心点</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Empty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果栈不空</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出栈</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token operator">!=</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//比较元素是否相等</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-1"><a href="#算法复杂度分析：-1" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>如果字符串长度为 n，将前一半入栈，后一半依次和出栈元素比较，相当于扫描了整个字符串，因此时间复杂度为 O(n)，使用的栈空间大小是 n&#x2F;2，空间复杂度也为 O(n)。</p><h3 id="双端队列："><a href="#双端队列：" class="headerlink" title="双端队列："></a>双端队列：</h3><p><strong>题目：</strong>设计一个数据结构，使其具有栈和队列两种特性。</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>栈是后进先出，队列是先进先出，如何具有这两种特性呢？<br>栈是在一端进出，队列是在一端进、另一端出，能否设计两端都可以进出呢？</p><blockquote><p>允许两端都可以进行入队和出队的队列，就是双端队列</p></blockquote><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912114829664.png" alt="image-20220912114829664"></p><p>循环队列表示的双端队列，可以用环形形象地表达出来。双端队列和普通循环队列的区别如图所示。</p><p>双端队列包括前端和后端，可以从前端进入、前端出队、后端进队、后端出队。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912115334112.png" alt="image-20220912115334112"></p><h4 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h4><ol><li><p>入队</p><ul><li><p>前端进队时，先令 Q.front 前移一位，再将元素放入 Q.front 的位置，a、b、c 依次从前端进队。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912121125792.png" alt="image-20220912121125792"></p></li><li><p>后端进队时，先将元素放入 Q.rear 的位置，再令 Q.rear 后移一位，d 从后端进队。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912121141406.png" alt="image-20220912121141406"></p></li></ul></li><li><p>出队</p><ul><li><p>从后端出队，先令 Q.rear 前移一位，再将 Q.rear 位置元素取出。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912121220588.png" alt="image-20220912121220588"></p></li><li><p>从前端出队，先将 Q.front 位置元素取出，再令 Q.front 后移一位。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912121233284.png" alt="image-20220912121233284"></p></li></ul></li></ol><blockquote><p><strong>后端进、前端出</strong>或者<strong>前端进、后端出</strong>体现了先进先出的特点，符合<strong>队列</strong>的特性。</p><p><strong>后端进、后端出</strong>或者<strong>前端进、前端出</strong>体现了后进先出的特点，符合<strong>栈</strong>的特性。</p></blockquote><h5 id="初始化：-4"><a href="#初始化：-4" class="headerlink" title="初始化："></a>初始化：</h5><p>初始化时，头指针和尾指针置为零，双端队列为空。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> <span class="token class-name">SqQueue</span><span class="token punctuation">&#123;</span>  ElemType base<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//一维数组存储，也可以设置指针动态分配空间</span>  <span class="token keyword">int</span> front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span> <span class="token comment">//头指针,尾指针</span><span class="token punctuation">&#125;</span>DuQueue<span class="token punctuation">;</span><span class="token comment">//初始化</span><span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token comment">//注意使用引用参数，否则出了函数，其改变无效</span><span class="token punctuation">&#123;</span>Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//头指针和尾指针置为零，队列为空</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="判队满："><a href="#判队满：" class="headerlink" title="判队满："></a>判队满：</h5><p>当队尾后移一位等于队头，表明队满。队尾后移一位即 Q.rear+1，加 1 后有可能等于Maxsize，此时下一个位置为 0，因此为处理临界状态，需要与 Maxsize 取余运算。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//判队满</span><span class="token keyword">bool</span> <span class="token function">isFull</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token operator">==</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> <span class="token comment">//尾指针后移一位等于头指针，表明队满</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>       <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="尾进："><a href="#尾进：" class="headerlink" title="尾进："></a>尾进：</h5><p>尾部进队，即后端进队时，先将元素放入 Q.rear 位置，然后 Q.rear 后移一位，后移时为处理边界情况，需要加 1 后模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token comment">//尾进</span><span class="token keyword">bool</span> <span class="token function">push_back</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//先放入</span>    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token comment">//向后移动一位</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="尾出："><a href="#尾出：" class="headerlink" title="尾出："></a>尾出：</h5><p>尾部出队，即后端出队时，先将 Q.rear 前移一位，然后取出元素。前移一位即 Q.rear−1，当 Q.rear 为 0 时，Q.rear−1 为负值，因此加上 Maxsize，正好是 Maxsize−1 的位置。那么，Q.rear−1 为正值时，加上 Maxsize 就超过了下标范围，需要模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//尾出</span><span class="token keyword">bool</span> <span class="token function">pop_back</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token comment">//向前移动一位</span>    x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取数据</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="头进："><a href="#头进：" class="headerlink" title="头进："></a>头进：</h5><p>头部进队，即前端进队时，先将 Q.front 前移一位，然后将元素先放入 Q.front 位置。队头前移一位即 Q.front−1，前移时为处理边界情况，需要加 Maxsize 再模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token comment">//头进</span><span class="token keyword">bool</span> <span class="token function">push_front</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token comment">//先向前移动一位</span>    Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//后放入</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="头出："><a href="#头出：" class="headerlink" title="头出："></a>头出：</h5><p>头部进队，即前端出队时，先取出元素，然后 Q.front 后移一位，即 Q.front+1，后移时为处理边界情况，需要模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//头出</span><span class="token keyword">bool</span> <span class="token function">pop_front</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取数据</span>    Q<span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token comment">//向后移动一位</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="取队头："><a href="#取队头：" class="headerlink" title="取队头："></a>取队头：</h5><p>取队头是指将 Q.front 位置的元素取出来，Q.front 未改变。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//取队头</span><span class="token keyword">bool</span> <span class="token function">get_front</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取队头数据;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="取队尾："><a href="#取队尾：" class="headerlink" title="取队尾："></a>取队尾：</h5><p><strong>因为 Q.rear 指针永远指向空</strong>，因此取队尾时，取 Q.rear 前面的那个位置，要想得到前面位置，为处理边界情况，需要加 Maxsize 再模 Maxsize取余。</p><blockquote><p><strong>注意：取队尾时，尾指针不移动。</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//取队尾</span><span class="token keyword">bool</span> <span class="token function">get_back</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="求长度："><a href="#求长度：" class="headerlink" title="求长度："></a>求长度：</h5><p>和普通循环队列求长度的方法一样，都是求从队头到队尾之间的元素个数。因为循环队列减法有可能有负值，因此需要加 Maxsize 再模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//求长度</span><span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h5><p>双端队列的遍历，即从头到尾输出整个队列中的元素，在输出过程中，队头和队尾并不移动，因此<strong>借助一个暂时变量即可</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//从头到尾输出整个队列元素（遍历）</span><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout<span class="token operator">&lt;&lt;</span><span class="token string">"DuQueue is empty"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> temp<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span><span class="token comment">//设置一个暂存变量，头指针未移动</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout<span class="token operator">&lt;&lt;</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token punctuation">;</span>       temp<span class="token operator">=</span><span class="token punctuation">(</span>temp<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"traverse is over!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>技巧：后移时，加 1 模 Maxsize；前移时，减 1 加 Maxsize 再模 Maxsize。</strong></p></blockquote><ol><li><p>输出受限的双端队列</p><p>允许在一端进队和出队，另一端只允许进队，这样的双端队列称为输出受限的双端队列。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164028211.png" alt="image-20220912164028211"></p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164110581.png" alt="image-20220912164110581"></p></li><li><p>输入受限的双端队列</p><p>允许在一端进队和出队，另一端只允许出队，这样的双端队列称为输入受限的双端队列。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164121646.png" alt="image-20220912164121646"></p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164134580.png" alt="image-20220912164134580"></p></li></ol><h2 id="栈和队列学习技巧："><a href="#栈和队列学习技巧：" class="headerlink" title="栈和队列学习技巧："></a>栈和队列学习技巧：</h2><h3 id="栈和队列的比较："><a href="#栈和队列的比较：" class="headerlink" title="栈和队列的比较："></a>栈和队列的比较：</h3><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164341735.png" alt="image-20220912164341735"></p><h3 id="栈解题技巧："><a href="#栈解题技巧：" class="headerlink" title="栈解题技巧："></a>栈解题技巧：</h3><ol><li>栈顶指针所指位置<ul><li>在顺序栈中，栈顶指针指向的是栈顶元素的上一个位置，即空位置，取栈顶元素时要取*(S.top−1)才可以</li><li>入栈时，先把元素放入栈顶位置，然后栈顶指针后移，即*S.top++&#x3D;e。</li><li>出栈时，栈顶指针前移，用变量暂存栈顶元素，即 e&#x3D;−−S.top。</li></ul></li><li>出栈只是栈顶指针移动，空间元素仍然存在，但下次入栈时会覆盖</li><li>本文以动态分配为例，静态分配的情况处理方式不同<ul><li>静态分配是使用一个固定长度的数组存储数据，然后用一个 int 型的变量 top 指向栈顶，top 实际上是数组的下标。当栈空时，S.top&#x3D;0。</li><li>入栈时，先把元素放入栈顶位置，然后栈顶指针后移，即 S.data[S.top++]&#x3D;e。</li><li>出栈时，栈顶指针前移，用变量暂存栈顶元素，即 e&#x3D;S.data[−−S.top]。</li></ul></li><li>栈和队列的灵活运用：<ul><li>栈具有后进先出的特性，可以利用此特性解决如<strong>逆序输出</strong>、<strong>括号匹配</strong>等问题。由于栈只能在一端操作，插入、删除都是在栈顶进行，不需要移动元素，因此大多使用顺序栈。</li><li>队列具有先进先出的特性，可以利用此特性解决一系列<strong>排队</strong>、<strong>先到先得</strong>等问题。在确定队列长度范围的情况下，大多使用循环队列。如果队列长度变化较大，则使用链队。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue动画与过渡</title>
      <link href="/2022/09/09/vue-dong-hua-yu-guo-du/"/>
      <url>/2022/09/09/vue-dong-hua-yu-guo-du/</url>
      
        <content type="html"><![CDATA[<h2 id="使用CSS-keyframes实现动画"><a href="#使用CSS-keyframes实现动画" class="headerlink" title="使用CSS keyframes实现动画"></a>使用CSS keyframes实现动画</h2><blockquote><p>animation: [name] [duration] [timing-function] [delay] [iteration-count] [direction] [fill-mode]</p></blockquote><ul><li><p>name：用于给@keyframes指定动画名称</p></li><li><p>duration：用于标记一个动画完成周期所需时间，非必填，默认0s</p></li><li><p>timing-function：用于描述一个动画数值变化方式，非必填，默认ease</p><ul><li><p>linear:表示值变化均匀，匀速播放动画。</p></li><li><p>ease:默认参数。表示值变化以低速率开始，逐渐加快，直到结束前速率降低。</p></li><li><p>ease-in:表示值变化以低速率开始，平均速率过渡，结尾戛然而止。</p></li><li><p>ease-out:表示值变化以平均速率开始，以低速率缓慢结尾。</p></li><li><p>ease-in-out:表示值变化以低速率开始和结尾。</p></li><li><p>steps(int,start|end):表示将值区间按一定数量隔开，每段时间间隔中值保持不变。第一个参数为整型，第二个参数为字符串。</p><ul><li><p>int:间隔数量，数量越小效果越明显。</p></li><li><p>start|end:字符串参数，start为从值区间头部开始计算，end为从值区间尾部开始计算。</p></li><li><p>举例：值区间[0,99]，参数steps(4,start|end)，start或end。</p><p>将0<del>99分为四段，分别为0</del>24，25<del>49，50</del>74，75~99。</p><p>首先值以匀速从0开始向99变化。当为start时，值一旦在0~24开始变化，开始于此段的头部值0，则立刻输出该段结尾值24，等待时间推动值变化进入下一段。</p><p>当为end时，值一旦在0~24开始变化，由于未触发此段的尾部值24，故一直保持输出该段的头部值0，等待时间推动值变化进入下一段。</p></li></ul></li><li><p>cubic-bezier(p1x,p1y,p2x,p2y):表示值变化v-t图遵循贝塞尔曲线图形。</p><ul><li>在二维直角坐标系中，首先有P0(p0x,p0y)，此时p0x&#x3D;0，p0y&#x3D;0，即原点，此点固定不变。其次有P3(p3x,p3y)，此时p3x&#x3D;1,p3y&#x3D;1，此点固定不变。</li><li>最后有两自由点P1(p1x,p1y)、P2(p2x,p2y)，由P0P1组成一条贝塞尔辅助线，由P2P3组成另一条贝塞尔辅助线，在这两条辅助线的作用下生成一条贝塞尔曲线，此曲线即值变化速度曲线v-t图，其中负值代表方向。</li></ul></li></ul></li><li><p>delay：用于标记一个动画完成周期所需时间，非必填，默认0s</p></li><li><p>iteration-count：用于描述一个动画循环次数，非必填，默认0s，不设置则不使用循环播放效果</p><ul><li>整型：表示播放次数。</li><li>infinite:字符串，表示无限循环播放。</li></ul></li><li><p>direction：用于设置是否循环往复播放动画，非必填，默认normal</p><ul><li>normal:默认参数。动画正常播放，不进行循环往复操作。</li><li>reverse:动画反向播放。</li><li>alternate:动画在奇数次正向播放，在偶数次反向播放。</li><li>alternate-reverse:动画在偶数次正向播放，在奇数次反向播放。</li><li>initial:动画重新设置为默认值。</li><li>inherit:动画设置为父元素属性。</li></ul></li><li><p>fill-mode：用于在动画不播放时（处于延时或完成的状态）设置动画的位置，非必填，<strong>样式可以分为在animation外部的初始样式，以及在keyframes中定义的动画样式。</strong></p><ul><li>none:默认参数。在动画不播放时不对动画产生任何作用。</li><li>forwards:在动画结束时应用动画样式效果，在动画延时中应用初始样式效果。</li><li>backwards:在动画结束时应用初始样式效果，在动画延时中应用动画样式效果。</li><li>both:在动画结束时应用动画样式效果，在动画延时中应用动画样式效果。</li><li>initial:动画重新设置为默认值。</li><li>inherit:动画设置为父元素属性。</li></ul></li></ul><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>duration<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> duration <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>    45deg<span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 60%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>300deg<span class="token punctuation">,</span> 90%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0.5em 1.4em<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>    <span class="token comment">/* animation: rotate 10s linear infinite; */</span>  <span class="token property">animation</span><span class="token punctuation">:</span> rotate <span class="token function">v-bind</span><span class="token punctuation">(</span>duration + <span class="token string">"s"</span><span class="token punctuation">)</span> linear infinite<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@keyframes</span> rotate</span> <span class="token punctuation">&#123;</span>  <span class="token selector">0%</span> <span class="token punctuation">&#123;</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>0deg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token selector">100%</span> <span class="token punctuation">&#123;</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>360deg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用CSS-Transition实现动画"><a href="#使用CSS-Transition实现动画" class="headerlink" title="使用CSS Transition实现动画"></a>使用CSS Transition实现动画</h2><blockquote><p>Transition强调过渡，即一个元素从一个状态进入另一个状态的过程；而keyframes强调动画的运动轨迹，可设置中间状态改变动画轨迹。</p></blockquote><h3 id="transform参数："><a href="#transform参数：" class="headerlink" title="transform参数："></a>transform参数：</h3><ol><li><p>translate ( n px )：</p><p><strong>一个值：</strong>transform:translate(100px)，表示水平方向移动的位移，等同于translateX(100px)</p><p>translateX(x):沿 X 轴位移</p><p>translateY(y):沿 Y 轴位移</p><p>translateZ(z):沿 Z 轴位移</p><p><strong>两个值：</strong> transform:translate(100px, 200px)，第一个表示水平方向移动的位移，第二个表示垂直方向移动的位移</p><p>translate(x,y) :沿 X Y 轴位移</p><p><strong>三个值：</strong>translate3d(10px,20px,10px)，表示3D三个方向移动的位移，顺序为X,Y,Z</p></li><li><p>rotate ( n deg )：</p><p><strong>以角度(deg)为单位，正数是顺时针旋转，负数是逆时针旋转</strong> </p><p>rotate():2D旋转</p><p>rotateX():沿着X轴3D旋转</p><p>rotateY():沿着Y轴3D旋转</p><p>rotateZ():沿着Z轴3D旋转.要在其父级配合transform-style: preserve-3d;使用</p><p>rotate3D(x,y,z,n deg): 3D旋转，接受四个参数，x,y,z介于0-1之间，n是旋转的度数。元素围绕着xyz在空间中确定的唯一坐标点和原点之间的连线旋转指定的角度。</p></li><li><p>scale ( n )：</p><p><strong>一个值：</strong>transform: scale(1) ，表示水平跟垂直方向同时放大1倍</p><p><strong>两个值：</strong>transform: scale(1,2)，第一个参数表示水平方向的缩放比例，第二个参数表示垂直方向的缩放比例，等同于scaleX (1)和 scaleY(2)</p><p><strong>三个值：</strong>scale3d(0.5,0.3,0.4)，表示3D三个方向缩放的比例，顺序为X,Y,Z轴</p><p>数值为负时为缩小</p></li><li><p>skew ( n deg )：</p><p><strong>一个值：</strong>transform:skew(10deg)，表示水平方向的倾斜角度，等同于skewX(10deg)</p><p>skewX:表示水平方向的倾斜角度</p><p>skewY：表示垂直方向的倾斜角度</p><p><strong>两个值：</strong>transform:skew(10deg,20deg)，第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度</p></li><li><p>transform-origin：</p></li></ol><blockquote><p><strong>值得注意的是:在进行以上的变形操作时，默认都是以元素的中心为基点.</strong></p></blockquote><p><strong>有两个参数：第一个表示距离元素左上角水平方向的距离，第二个表示距离元素左上角垂直方向的距离。</strong></p><p><strong>第一个参数可以设置为left、center、right，第二个参数可以设置为top、center、bottom。</strong></p><h3 id="transition参数："><a href="#transition参数：" class="headerlink" title="transition参数："></a>transition参数：</h3><ol><li>transition-property：定过渡或动态模拟的css属性，也就是指定究竟是哪个属性要执行动画效果。<ul><li>none：没有属性会获得过渡效果。</li><li>all：所有属性都将获得过渡效果。</li><li>property：定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。</li></ul></li><li>transition-duration：指定完成过渡所需的时间，单位是秒或毫秒。参数同keyframes。</li><li>transition-timing-function：指定过渡函数。参数同keyframes。</li><li>transition-delay：开始执行动画的延迟时间，单位是秒或毫秒。参数同keyframes。</li></ol><p>示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>    45deg<span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 60%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>300deg<span class="token punctuation">,</span> 90%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0.5em 1.4em<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>  <span class="token property">transition</span><span class="token punctuation">:</span> all 0.5s ease-in-out<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.box:hover</span> <span class="token punctuation">&#123;</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1.25<span class="token punctuation">)</span> <span class="token function">skewY</span><span class="token punctuation">(</span>-20deg<span class="token punctuation">)</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>20deg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目开发与部署</title>
      <link href="/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/"/>
      <url>/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>安装Vue.js devtools浏览器拓展：</p><p><img src="/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/image-20220909155504413.png" alt="image-20220909155504413"></p><p>调试页面如下：</p><p><img src="/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/image-20220909155640255.png" alt="image-20220909155640255"></p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>在使用Vue开发项目时，无论使用哪种脚手架，都属于在<strong>开发环境</strong>中开发。在开发环境下，Vue为了方便开发者调试，对代码与组件并没有进行优化，性能不会太好。</p><p>在项目开发完成后，我们需要将项目构建成<strong>生产版本</strong>，在生产版本中，Vue会进一步优化性能，缩减代码体积。</p><p>使用Vite进行打包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> run build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打包后会生产dist文件夹，结构如下图：</p><p><img src="/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/image-20220909160316461.png" alt="image-20220909160316461"></p><p>打包后进行本地测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> run serve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue背后机制</title>
      <link href="/2022/09/09/vue-bei-hou-ji-zhi/"/>
      <url>/2022/09/09/vue-bei-hou-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="响应性基础：Proxy"><a href="#响应性基础：Proxy" class="headerlink" title="响应性基础：Proxy"></a>响应性基础：Proxy</h2><blockquote><p>Proxy是ES6中新添加的特性，用于给一个对象创建代理，用来拦截对象的操作。这样可以添加额外的业务逻辑或对原对象进行保护。</p></blockquote><p>拦截方法参考：</p><p><img src="/2022/09/09/vue-bei-hou-ji-zhi/image-20220909103853546.png" alt="image-20220909103853546"></p><p><img src="/2022/09/09/vue-bei-hou-ji-zhi/image-20220909103911409.png" alt="image-20220909103911409"></p><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> objProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">访问了 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>target<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 中的 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">，值为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// return target[key];</span>    <span class="token comment">// return 10;</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用Reflect.get()直接返回原对象的属性值</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">修改了 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>target<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 中的 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">，值为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>value<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// target[key] = value;</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果不调用Reflect.set()则原对象的值不会发生变化，可用来验证修改是否合法，如果合法返回Reflect.get()，否则提示错误</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// console.log(objProxy.a);</span>objProxy<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">// 访问 proxy</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>objProxy<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 访问原始对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现一个响应性示例（简化版）："><a href="#实现一个响应性示例（简化版）：" class="headerlink" title="实现一个响应性示例（简化版）："></a>实现一个响应性示例（简化版）：</h3><blockquote><p>目标：在修改对象的属性后，自动更新原对象的属性。</p></blockquote><p>基础原理：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> reactiveObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reactiveObj<span class="token punctuation">.</span>a <span class="token operator">+</span> reactiveObj<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>封装一部分后：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> currentObserver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  currentObserver <span class="token operator">=</span> fn<span class="token punctuation">;</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  currentObserver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// observe</span><span class="token keyword">let</span> reactiveObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentObserver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> targetObserver <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>targetObserver<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        targetObserver<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentObserver<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        targetObserver<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>currentObserver<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> observersForkey <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    observersForkey<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>observers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reactiveObj<span class="token punctuation">.</span>a <span class="token operator">+</span> reactiveObj<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">observe</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后完整封装：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> currentObserver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  currentObserver <span class="token operator">=</span> fn<span class="token punctuation">;</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  currentObserver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  observers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">registerObserver</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">execute</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">registerObserver</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentObserver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> targetObserver <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>targetObserver<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      targetObserver<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentObserver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      targetObserver<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>currentObserver<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> observersForkey <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  observersForkey<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> reactiveObj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reactiveObj<span class="token punctuation">.</span>a <span class="token operator">+</span> reactiveObj<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reactiveObj<span class="token punctuation">.</span>a <span class="token operator">-</span> reactiveObj<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 类似于调用 computed()</span><span class="token function">observe</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">observe</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Virtual-DOM：Vue-渲染机制的核心"><a href="#Virtual-DOM：Vue-渲染机制的核心" class="headerlink" title="Virtual DOM：Vue 渲染机制的核心"></a>Virtual DOM：Vue 渲染机制的核心</h2><p>因为使用Vue编写的程序，经常因为响应性的变化而重新渲染视图，如果直接操作真实的DOM，会是比较耗时的操作。这是因为需要找到某个节点，并将其换为新的节点，这样会触发浏览器的重新布局和重绘流程，对性能会有影响。</p><p>VirtualDOM的结构：</p><p><img src="/2022/09/09/vue-bei-hou-ji-zhi/image-20220909111405303.png" alt="image-20220909111405303"></p><p>Vue有渲染工具，会将虚拟的DOM转换为真实的DOM，在节点变化后，会根据算法调整节点顺序或更换节点。这种比对算法Vue中称为Patch，其他框架有称为diff或reconciliation。</p><blockquote><p>对于静态的DOM元素，Vue会保存这些节点，后续使用时会直接使用之前的节点；</p><p>对于响应性的节点，Vue会对包含这些节点的父节点维护一个记录，包含响应性数据的节点在更新时直接更新记录中的节点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-线性表</title>
      <link href="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/"/>
      <url>/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><ul><li><p>静态分配</p><p>顺序表最简单的方法是使用一个定长数组data[]存储数据，最大空间为 Maxsize，用 length记录实际的元素个数，即顺序表的长度。</p></li><li><p>动态分配</p><p>在程序运行过程中，根据需要动态分配一段连续的空间（大小为 Maxsize），用 elem 记录该空间的基地址（首地址），用 length 记录实际的元素个数，即顺序表的长度。</p><p>采用动态存储方法，在运算过程中，如果发生溢出，可以另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储空间的目的。</p></li></ul><h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><p>分配Maxsize空间，<strong>注意判断分配失败的情况</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//最大空间</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> <span class="token operator">*</span>elem<span class="token punctuation">;</span><span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">// 顺序表的长度</span><span class="token punctuation">&#125;</span>SqList<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">InitList</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token comment">//构造一个空的顺序表L</span><span class="token punctuation">&#123;</span>   <span class="token comment">//L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</span><span class="token comment">//不加&amp;内部改变，跳出函数后无效</span>    L<span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//为顺序表分配Maxsize个空间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment">//存储分配失败</span>    L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//空表长度为0</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h4><ol><li>注意判断顺序表是否已满。</li><li>将数据 x 存入顺序表的第 i 个位置，即 L.elem[i]&#x3D;x，然后 i++。</li><li>注意顺序表长度增加1。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">CreateList</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token comment">//创建一个顺序表L</span><span class="token punctuation">&#123;</span>   <span class="token comment">//L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</span><span class="token comment">//不加&amp;内部改变，跳出函数后无效</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    cin<span class="token operator">>></span>a<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span>Maxsize<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"顺序表已满！"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>    cin<span class="token operator">>></span>a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取值："><a href="#取值：" class="headerlink" title="取值："></a>取值：</h4><p>顺序表中的<strong>任何一个元素都可以立即被找到</strong>，称为随机存取方式。</p><p>由于下标是从 0 开始的，因此第 i 个元素，其下标为 i−1，即对应元素为 L.elem[i−1]</p><blockquote><p>注意：位序是指第几个元素，<strong>位序和下标差1</strong>。</p></blockquote><p>注意判断i值的合理性。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906155828274.png" alt="image-20220906155828274"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">GetElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token comment">//判断i值是否合理，若不合理，返回false</span>e<span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//第i-1的单元存储着第i个数据</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h4><p>在顺序表中查找一个元素 e，可以从第一个元素开始顺序查找，<strong>依次比较每一个元素值</strong>。如果相等，则返回元素位置（位序，即第几个元素）；如果查找整个顺序表都没找到，则返回−1。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">LocateELem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token punctuation">)</span>  <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//第几个元素，例如第5个元素，下标其实为4</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="算法复杂度分析："><a href="#算法复杂度分析：" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h5><ul><li><p>最好情况：如果元素正好在第一个位置，比较一次查找成功，时间复杂度为 O(1)。</p></li><li><p>最坏情况：如果元素正好在最后一个位置，比较 n 次查找成功，时间复杂度为 O(n)。</p></li><li><p>平均情况：如果查找的元素在第一个位置需要比较 1 次，第二个位置需要比较 2次……最后一个位置需要比较 n 次。如果该元素在第 i 个位置，则需要比较 i 次，把每种情况比较次数乘以其查找概率 pi 并求和，即为平均时间复杂度。如果查找概率均等，即每个关键字的查找概率均为 1&#x2F;n，则平均时间复杂度为：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906160600617.png" alt="image-20220906160600617"></p><p>因此，假设每个关键字查找的概率均等，顺序表查找算法的平均时间复杂度为 **O(n)**。</p></li></ul><h4 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h4><p>在顺序表中第 i 个位置之前插入一个元素 e，需要从最后一个元素开始，<strong>后移一位</strong>，直到把第 i 个元素也后移一位，然后把 e 放入第 i 个位置。</p><ol><li>注意判断位置i是否合法（<strong>1≤i≤L.length+1</strong>）。</li><li>注意判断顺序表的存储空间是否已满。</li><li>将第 L.length 至第 i 个元素<strong>依次向后移动一个位置</strong>，空出第 i 个位置并放入新元素。</li><li>注意表长加一。</li><li><strong>时刻注意位序和下标的关系！</strong></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//i值不合法</span><span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span>Maxsize<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//存储空间已满</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>       L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//从最后一个元素开始后移，直到第i个元素后移</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span>              <span class="token comment">//将新元素e放入第i个位置</span>L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">//表长增1</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="算法复杂度分析：-1"><a href="#算法复杂度分析：-1" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h5><p>可以在第 1 个位置之前插入，也可以在第 2 个位置之前……第 n 个位置之前，第 n+1 个位置之前插入，一共有 n+1 种情况，每种情况移动元素的个数是 n−i+1。把每种情况移动次数乘以其插入概率 p i 并求和，即为平均时间复杂度。如果插入概率均等，即每个位置的插入概率均为 1&#x2F;(n+1)，则平均时间复杂度为：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906161747867.png" alt="image-20220906161747867"></p><p>因此，假设每个位置插入的概率均等，顺序表插入算法平均时间复杂度为 **O(n)**。</p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><p>在顺序表中删除第 i 个元素，需要把该元素暂存到变量 e 中，然后从 i+1 个元素<strong>开始前移.</strong>…..直到把第 n 个元素也前移一位，即可完成删除操作。</p><ol><li>注意判断位置i是否合法（<strong>1≤i≤L.length+1</strong>）。</li><li>将欲删除的元素保存在 e 中。</li><li>将第 i+1 至第 n 个元素<strong>依次向前移动一个位置</strong>。</li><li>注意表长减1。</li><li><strong>时刻注意位序和下标的关系！</strong></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListDelete_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//i值不合法</span>   e<span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//将欲删除的元素保留在e中</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//被删除元素之后的元素前移</span>   L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//表长减1</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="算法复杂度分析：-2"><a href="#算法复杂度分析：-2" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h5><p>顺序表元素删除一共有 n 种情况，每种情况移动元素的个数是 n−i。把每种情况移动次数乘以其删除概率 p i 并求和，即为平均时间复杂度。假设删除每个元素的概率均等，即每个元素的删除概率均为 1&#x2F;n，则平均时间复杂度为：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906162308243.png" alt="image-20220906162308243"></p><p>因此，假设每个元素删除的概率均等，顺序表删除算法平均时间复杂度为 **O(n)**。</p><h3 id="顺序表的优点和缺点："><a href="#顺序表的优点和缺点：" class="headerlink" title="顺序表的优点和缺点："></a>顺序表的优点和缺点：</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>操作简单，存储密度高，<strong>可以随机存取</strong>，只需要 O(1)的时间就可以取出第 i 个元素。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>需要预先分配最大空间，最大空间数估计过大或过小会造成空间浪费或溢出。<strong>插入和删除操作需要移动大量元素</strong>。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>可以给每个元素附加一个指针域，指向下一个元素的存储位置，如图所示：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906165619151.png" alt="image-20220906165619151"></p><p>每个节点包含两个域：<strong>数据域</strong>和<strong>指针域</strong>。<strong>数据域存储数据元素，指针域存储下一个节点的地址</strong>，因此指针指向的类型也是节点类型。每个指针都指向下一个<br>节点，都是朝一个方向的，这样的链表称为单向链表或单链表。</p><p>只要给这个单链表设置一个头指针，这个链表中的每个节点就都可以找到了。有时为了操作方便，还会给链表增加一个不存放数据的头节点（也可以存放表长等信<br>息）。</p><h4 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h4><ol><li>创建头节点，<strong>令其指针域为空</strong>。</li><li>注意判断生成节点失败的情况。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//结点的数据域</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//结点的指针域</span><span class="token punctuation">&#125;</span>LNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span> <span class="token comment">//LinkList为指向结构体LNode的指针类型</span><span class="token keyword">bool</span> <span class="token function">InitList_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//构造一个空的单链表L</span><span class="token punctuation">&#123;</span>    L<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span>     <span class="token comment">//生成新结点作为头结点，用头指针L指向头结点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//生成结点失败</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">//头结点的指针域置空</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建：-1"><a href="#创建：-1" class="headerlink" title="创建："></a>创建：</h4><h5 id="头插法："><a href="#头插法：" class="headerlink" title="头插法："></a>头插法：</h5><blockquote><p>头插法是指每次把新节点插到头节点之后，<strong>其创建的单链表和数据输入顺序正好相反</strong>，因此也称为逆序建表。</p></blockquote><ol><li><p>初始化链表后，创建新节点，把元素1放入新节点数据域：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906170511493.png" alt="image-20220906170511493"></p></li><li><p>头插操作，插入 头节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906170546723.png" alt="image-20220906170546723"></p></li><li><p>同理插入元素2，插入头节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906170601300.png" alt="image-20220906170601300"></p><blockquote><p>赋值语句的两端：<strong>等号的右侧是节点的地址</strong>，<strong>等号的左侧是节点的指针域</strong>。</p></blockquote><ol><li>s-&gt;next&#x3D;L-&gt;next：L-&gt;next 存储的是下一个节点地址“9630”，将该地址赋值给 s-&gt;next指针域，即 s 节点的 next 指针指向 1 节点。</li><li>L-&gt;next&#x3D;s：将 s 节点的地址“2046”赋值给 L-&gt;next 指针域，即 L 节点的 next 指针指向 s 节点。</li></ol><p><strong>为什么要先修改后面那个指针呢？</strong></p><p>因为一旦修改了 L 节点的指针域指向 s，那么原来 L 节点后面的节点就找不到了，因此修改指针是有顺序的。</p><blockquote><p>修改指针的顺序原则：<strong>先修改没有指针标记的那一端</strong></p></blockquote><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906171402128.png" alt="image-20220906171402128"></p><p>如果要插入节点的两端都有标记，例如，再定义一个指针 q 指向 L 节点后面的节点，那么先修改哪个指针都无所谓了：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906171436712.png" alt="image-20220906171436712"></p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CreateList_H</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//前插法创建单链表</span><span class="token punctuation">&#123;</span><span class="token comment">//输入n个元素的值，建立到头结点的单链表L</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>LinkList s<span class="token punctuation">;</span> <span class="token comment">//定义一个指针变量</span>L<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//先建立一个带头结点的空链表</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入元素个数n："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入n个元素："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"前插法创建单链表..."</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>s<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span> <span class="token comment">//生成新结点s</span>cin<span class="token operator">>></span>s<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//输入元素值赋给新结点的数据域</span>s<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span>L<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//将新结点s插入到头结点之后</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="尾插法："><a href="#尾插法：" class="headerlink" title="尾插法："></a>尾插法：</h5><blockquote><p>尾插法每次把新节点链接到链表的尾部，<strong>其创建的单链表和数据输入顺序一致</strong>。</p></blockquote><ol><li><p>初始化链表后，创建新节点，把元素1放入新节点数据域并插入到尾结点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906201103508.png" alt="image-20220906201103508"></p><ol><li>s-&gt;next&#x3D;NULL：s 节点的指针域置空。</li><li>r-&gt;next&#x3D;s：将 s 节点的地址赋值给 r 节点的指针域，即将新节点 s 插入尾节点 r 之后。</li><li>r&#x3D;s：将 s 节点的地址赋值给 r，即 r 指向新的尾节点 s。</li></ol></li><li><p>输入数据元素 2，创建新节点，把元素 2 放入新节点数据域，插入到尾节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906201742129.png" alt="image-20220906201742129"></p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CreateList_R</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//尾插法创建单链表</span><span class="token punctuation">&#123;</span><span class="token comment">//输入n个元素的值，建立带表头结点的单链表L</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>LinkList s<span class="token punctuation">,</span> r<span class="token punctuation">;</span>L<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//先建立一个带头结点的空链表</span>r<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//尾指针r指向头结点</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入元素个数n："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入n个元素："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"尾插法创建单链表..."</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>s<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span><span class="token comment">//生成新结点</span>cin<span class="token operator">>></span>s<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//输入元素值赋给新结点的数据域</span>s<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>r<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment">//将新结点s插入尾结点*r之后</span>r<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment">//r指向新的尾结点s</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取值：-1"><a href="#取值：-1" class="headerlink" title="取值："></a>取值：</h4><p>单链表的取值不像顺序表那样可以随机访问任何一个元素，单链表只有头指针，各个节点的物理地址是不连续的。</p><blockquote><p>要想找到第 i 个节点，就必须<strong>从第一个节点开始按顺序向后找</strong>，一直找到第 i 个节点。</p></blockquote><blockquote><p>注意：<strong>链表的头指针不可随意改动！</strong>一个链表是由头指针来标识的，一旦头指针改动或丢失，这个链表就不完整或找不到了。如果需要用指针移动，可定义一个指针变量进行移动。</p></blockquote><ol><li><p>先定义一个 p 指针，指向第一个元素节点，用 j 作为计数器，j&#x3D;1。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906203132220.png" alt="image-20220906203132220"></p></li><li><p>如果 p 不为空且 j&lt;i，则 p 指向 p 的下一个节点，然后 j 加 1，即：p&#x3D;p-&gt;next; j++。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906203150910.png" alt="image-20220906203150910"></p></li><li><p>直到 p 为空或者 j&#x3D;i 停止。p 为空，说明没有数到 i，链表就结束了，即不存在第 i个节点；j&#x3D;i，说明找到了第 i 个节点。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906203203024.png" alt="image-20220906203203024"></p></li><li><p>如果i值不合法，也需要进行判断。</p></li><li><p><strong>注意每一步的条件因素</strong>。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">GetElem_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token comment">//单链表的取值</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中查找第i个元素</span><span class="token comment">//用e记录L中第i个数据元素的值</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>LinkList p<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//p指向第一个结点，</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//j为计数器</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">)</span> <span class="token comment">//顺链域向后扫描，直到p指向第i个元素或p为空</span>    <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向下一个结点</span>j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//计数器j相应加1</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//i值不合法i＞n或i&lt;=0</span>e<span class="token operator">=</span>p<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//取第i个结点的数据域</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找：-1"><a href="#查找：-1" class="headerlink" title="查找："></a>查找：</h4><p>在一个单链表中查找是否存在元素 e，可以定义一个 p 指针，指向第一个元素节点，比较 p 指向节点的数据域是否等于 e。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">LocateElem_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token comment">//按值查找</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中查找值为e的元素</span>LinkList p<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>p<span class="token operator">-></span>data<span class="token operator">!=</span>e<span class="token punctuation">)</span><span class="token comment">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向下一个结点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//查找失败p为NULL</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入：-1"><a href="#插入：-1" class="headerlink" title="插入："></a>插入：</h4><p>如果要在第 i 个节点之前插入一个元素，则必须先找到第 i−1 个节点。</p><blockquote><p>单链表只有一个指针域，是向后操作的，不可以向前操作。<strong>如果直接找到第 i 个节点，就无法向前操作，把新节点插入第 i 个节点之前</strong>。</p></blockquote><p>实际上，在第 i 个节点之前插入一个元素相当于在第 i−1 个节点之后插入一个元素，因此先找到第 i−1 个节点，然后将新节点插在其后面即可。</p><ol><li><p>定义一个 p 指针，指向头节点，用 j 作为计数器，<strong>j&#x3D;0</strong>。</p></li><li><p>如果 p 不为空且 j&lt;i−1，则 p 指向 p 的下一个节点，然后 j 加 1，即：p&#x3D;p-&gt;next; j++。</p></li><li><p>直到 p 为空或 j &gt;&#x3D;i−1 停止。</p></li><li><p>p 为空，说明没有数到 i−1，链表就结束了，即 i＞n+1，i 值不合法；j &gt;i−1 说明 i＜1，此时 i 值不合法，返回 false。如果 j&#x3D;i−1，说明找到了第 i−1 个节点。</p></li><li><p>将新节点插到第 i−1 个节点之后。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906204151314.png" alt="image-20220906204151314"></p><ol><li>s-&gt;next&#x3D;p-&gt;next：将 p 节点后面的节点地址赋值给 s 节点的指针域，即 s 节点的 next 指针指向 p 后面的节点。</li><li>p-&gt;next&#x3D;s：将 s 节点的地址赋值给 p 节点的指针域，即 p 节点的 next 指针指向 s 节点。</li></ol><p>前面讲的前插法建链表，就是每次将新节点插到头节点之后，现在是将新节点插到第 i−1 个节点之后。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListInsert_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token comment">//单链表的插入</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中第i个位置插入值为e的新结点</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>LinkList p<span class="token punctuation">,</span>s<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//查找第i-1个结点，p指向该结点</span>    <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">></span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//i＞n+1或者i＜1</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>s<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span>     <span class="token comment">//生成新结点</span>s<span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>       <span class="token comment">//将新结点的数据域置为e</span>s<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//将新结点的指针域指向结点ai</span>p<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>       <span class="token comment">//将结点p的指针域指向结点s</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除：-1"><a href="#删除：-1" class="headerlink" title="删除："></a>删除：</h4><p>删除一个节点，实际上是把这个节点跳过去。根据单向链表向后操作的特性，要想跳过第 i 个节点，就<strong>必须先找到第 i−1 个节点</strong>，否则是无法跳过去的。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906204522573.png" alt="image-20220906204522573"></p><ul><li>注意保存被删节点。</li><li>注意释放空间。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListDelete_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">//单链表的删除</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中，删除第i个位置</span>LinkList p<span class="token punctuation">,</span> q<span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//查找第i?1个结点，p指向该结点</span><span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>j<span class="token operator">></span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//当i>n或i&lt;1时，删除位置不合理</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>q<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">//临时保存被删结点的地址以备释放空间</span>p<span class="token operator">-></span>next<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//改变删除结点前驱结点的指针域</span><span class="token keyword">delete</span> q<span class="token punctuation">;</span>        <span class="token comment">//释放被删除结点的空间</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双向链表："><a href="#双向链表：" class="headerlink" title="双向链表："></a>双向链表：</h3><p>单链表只能向后操作，不可以向前操作。为了向前、向后操作方便，可以给每个元素附加两个指针域，一个存储前一个元素的地址，另一个存储下一个元素的地址。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909215632955.png" alt="image-20220909215632955"></p><h4 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h4><ol><li>创建头节点，不存储数据。</li><li>令头节点前后两个指针域均为空。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DuLNode</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//结点的数据域</span><span class="token keyword">struct</span> <span class="token class-name">DuLNode</span> <span class="token operator">*</span>prior<span class="token punctuation">,</span><span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//结点的指针域</span><span class="token punctuation">&#125;</span>DuLNode<span class="token punctuation">,</span><span class="token operator">*</span>DuLinkList<span class="token punctuation">;</span> <span class="token comment">//LinkList为指向结构体LNode的指针类型</span><span class="token keyword">bool</span> <span class="token function">InitDuList_L</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//构造一个空的双向链表L</span><span class="token punctuation">&#123;</span>    L<span class="token operator">=</span><span class="token keyword">new</span> DuLNode<span class="token punctuation">;</span>     <span class="token comment">//生成新结点作为头结点，用头指针L指向头结点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token comment">//生成结点失败</span>L<span class="token operator">-></span>prior<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">//头结点的两个指针域置空</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建：-2"><a href="#创建：-2" class="headerlink" title="创建："></a>创建：</h4><h5 id="头插法：-1"><a href="#头插法：-1" class="headerlink" title="头插法："></a>头插法：</h5><ol><li><p>将新节点插入到头节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909220959282.png" alt="image-20220909220959282"></p></li><li><p>创建新节点并继续插入到头节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909221129893.png" alt="image-20220909221129893"></p><ol><li><p>s-&gt;next&#x3D;L-&gt;next：将 L 节点后面的节点（后继）地址赋值给 s 节点的指针域，即 s 节点的 next 指针指向 L 的后继节点。</p></li><li><p>L-&gt;next-&gt;prior&#x3D;s：将 s 节点的地址赋值给 L 的后继节点的 prior 指针域，即 L 的后继节点的 prior 指针指向 s 节点。<br><strong>注意这一步要先判断L-next是否为null。</strong></p></li><li><p>s-&gt;prior&#x3D;L：将 L 节点的地址赋值给 s 节点的 prior 指针域，即 s 节点的 prior 指针指向 L 节点。</p></li><li><p>L-&gt;next&#x3D;s：将 s 节点的地址赋值给 L 节点的指针域，即 L 节点的 next 指针指向 s 节点。</p><blockquote><p><strong>实际上，只需要将④语句放在最后修改即可，①②③语句顺序无要求。</strong></p></blockquote></li></ol></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CreateDuList_H</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//前插法创建双向链表</span><span class="token punctuation">&#123;</span><span class="token comment">//输入n个元素的值，建立到头结点的单链表L</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>DuLinkList s<span class="token punctuation">;</span> <span class="token comment">//定义一个指针变量</span>L<span class="token operator">=</span><span class="token keyword">new</span> DuLNode<span class="token punctuation">;</span>L<span class="token operator">-></span>prior<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//先建立一个带头结点的空链表</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入元素个数n："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入n个元素："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"前插法创建单链表..."</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>s<span class="token operator">=</span><span class="token keyword">new</span> DuLNode<span class="token punctuation">;</span> <span class="token comment">//生成新结点s</span>cin<span class="token operator">>></span>s<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//输入元素值赋给新结点的数据域</span><span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>next<span class="token punctuation">)</span>            L<span class="token operator">-></span>next<span class="token operator">-></span>prior<span class="token operator">=</span>s<span class="token punctuation">;</span>        s<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span>        s<span class="token operator">-></span>prior<span class="token operator">=</span>L<span class="token punctuation">;</span>        L<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//将新结点s插入到头结点之后</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="尾插法：-1"><a href="#尾插法：-1" class="headerlink" title="尾插法："></a>尾插法：</h5><p>尾插法建双向链表和尾插法建单链表类似，需要有一个尾指针，不再赘述。</p><h4 id="取值：-2"><a href="#取值：-2" class="headerlink" title="取值："></a>取值：</h4><p>双向链表的取值、查找和单链表的一样，此处不再赘述。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">GetElem_L</span><span class="token punctuation">(</span>DuLinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token comment">//双向链表的取值</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的双向链表L中查找第i个元素</span><span class="token comment">//用e记录L中第i个数据元素的值</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>DuLinkList p<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//p指向第一个结点，</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//j为计数器</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">)</span> <span class="token comment">//顺链域向后扫描，直到p指向第i个元素或p为空</span>    <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向下一个结点</span>j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//计数器j相应加1</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//i值不合法i＞n或i&lt;=0</span>e<span class="token operator">=</span>p<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//取第i个结点的数据域</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找：-2"><a href="#查找：-2" class="headerlink" title="查找："></a>查找：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">LocateElem_L</span><span class="token punctuation">(</span>DuLinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token comment">//按值查找</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的双向链表L中查找值为e的元素</span>DuLinkList p<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>p<span class="token operator">-></span>data<span class="token operator">!=</span>e<span class="token punctuation">)</span><span class="token comment">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向下一个结点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//查找失败p为NULL</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入：-2"><a href="#插入：-2" class="headerlink" title="插入："></a>插入：</h4><p>双向链表因为有两个指针，可以向前后两个方向操作，<strong>直接找到第 i 个节点，就可以把新节点插入第 i 个节点之前。</strong></p><blockquote><p>注意：这里假设第 i 个节点是存在的，如果第 i 个节点不存在，而第 i−1 个节点存在，还是需要找到第 i−1 个节点，将新节点插入第 i−1 个节点之后，</p></blockquote><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909223237857.png" alt="image-20220909223237857"></p><ol><li>p-&gt;prior-&gt;next&#x3D;s：s 节点的地址赋值给 p 的前驱节点的 next 指针域，即 p 的前驱的next 指针指向 s。</li><li>s-&gt;prior&#x3D;p-&gt;prior：p 的前驱的地址赋值给 s 节点的 prior 指针域，即 s 节点的 prior 指针指向 p 的前驱。</li><li>s-&gt;next&#x3D;p：p 节点的地址赋值给 s 节点的 next 指针域，即 s 节点的 next 指针指向 p 节点。</li><li>p-&gt;prior&#x3D;s：s 节点的地址赋值给 p 节点的 prior 指针域，即 p 节点的 prior 指针指向 s 节点。</li></ol><p>因为 p 的前驱无标记，<strong>一旦修改了 p 节点的 prior 指针，p 的前驱就找不到了</strong>，因此，最后修改这个指针。只需要将④语句放在最后修改即可，①②③语句顺序无要求。</p><blockquote><p><strong>原则：先修改没有指针标记的那一端。</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListInsert_L</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token comment">//双向链表的插入</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中第i个位置之前插入值为e的新结点</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>DuLinkList p<span class="token punctuation">,</span> s<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span> <span class="token comment">//查找第i个结点，p指向该结点</span>    <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token comment">//i＞n+1或者i＜1</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>s<span class="token operator">=</span><span class="token keyword">new</span> DuLNode<span class="token punctuation">;</span>     <span class="token comment">//生成新结点</span>s<span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>       <span class="token comment">//将新结点的数据域置为e</span>p<span class="token operator">-></span>prior<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>s<span class="token operator">-></span>prior<span class="token operator">=</span>p<span class="token operator">-></span>prior<span class="token punctuation">;</span>s<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>p<span class="token operator">-></span>prior<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除：-2"><a href="#删除：-2" class="headerlink" title="删除："></a>删除：</h4><p>双向链表只要直接找到第 i 个节点，然后修改指针即可：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909224117840.png" alt="image-20220909224117840"></p><ol><li><p>p-&gt;prior-&gt;next&#x3D;p-&gt;next：将 p 的后继节点的地址赋值给 p 的前驱节点的 next 指针域。即 p 的前驱节点的 next 指针指向 p 的后继节点。</p></li><li><p>p-&gt;next-&gt;prior &#x3D;p-&gt;prior：将 p 的前驱节点的地址赋值给 p 的后继节点的 prior 指针域，即 p 的后继节点的 prior 指针指向 p 的前驱节点。此项修改的前提是 p 的后继节点存在，如果不存在，则不需要此项修改。</p><blockquote><p>删除节点修改指针没有顺序，先修改哪个都可以。</p></blockquote></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListDelete_L</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">//双向链表的删除</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的双向链表L中，删除第i个位置</span>DuLinkList p<span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//查找第i个结点，p指向该结点</span><span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span><span class="token punctuation">(</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//当i>n或i&lt;1时，删除位置不合理</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token comment">//如果p的直接后继结点存在</span>        p<span class="token operator">-></span>next<span class="token operator">-></span>prior<span class="token operator">=</span>p<span class="token operator">-></span>prior<span class="token punctuation">;</span>p<span class="token operator">-></span>prior<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span>        <span class="token comment">//释放被删除结点的空间</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环链表："><a href="#循环链表：" class="headerlink" title="循环链表："></a>循环链表：</h3><p>如果从当前节点开始，无法访问该节点前面的节点，而最后一个节点的指针指向头节点，形成一个环，就可以从任何一个节点出发，访问所有的节点，这就是循环链表。</p><blockquote><p>循环链表和普通链表的区别就是最后一个节点的后继指向了头节点，还要让头节点的前驱指向最后一个节点。</p></blockquote><h3 id="链表的优点和缺点："><a href="#链表的优点和缺点：" class="headerlink" title="链表的优点和缺点："></a>链表的优点和缺点：</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>链表是动态存储，不需要预先分配最大空间；<strong>插入删除不需要移动元素</strong>。</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>每次动态分配一个节点，每个节点的地址是不连续的，需要有指针域记录下一个节点的地址，指针域需要占用一个 int 的空间，因此<strong>存储密度低</strong>（数据所占空间&#x2F;节点所占总空间）。</p><p><strong>存取元素必须从头到尾按顺序查找，属于顺序存取。</strong></p><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="合并有序顺序表："><a href="#合并有序顺序表：" class="headerlink" title="合并有序顺序表："></a>合并有序顺序表：</h3><p><strong>题目：</strong>将两个有序（非递减）顺序表 La 和 Lb 合并为一个新的有序（非递减）顺序表。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol><li>首先创建一个顺序表 Lc，其长度为 La 和 Lb 的长度之和。</li><li>然后从 La 和 Lb 中分别取数，比较其大小，将较小者放入 Lc 中，一直进行下去，直到其中一个顺序表 La 或 Lb 中的数取完为止。</li><li>把未取完的数再依次取出放入 Lc 中即可。</li></ol><h4 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h4><ol><li><p>设置 3 个工作指针：i、j、k（其实是整型数）。其中，i 和 j 分别指向 La 和 Lb 中当前待比较的元素，k 指向 Lc 中待放置元素的位置</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220910095920854.png" alt="image-20220910095920854"></p></li><li><p>比较 La.elem[i]和 Lb.elem[j]，将较小的赋值给 Lc.elem[k]，同时相应指针向后移动。如此反复，直到顺序表 La 或 Lb 中的数取完为止。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220910100100150.png" alt="image-20220910100100150"></p></li><li><p>把 La 或 Lb中未取完的数依次取出，放入 Lc 中即可</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"sqlist.h"</span><span class="token comment">//引入自定义头文件,源码目录下名为sqlist.h的文件 </span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">MergeSqlist</span><span class="token punctuation">(</span>SqList La<span class="token punctuation">,</span>SqList Lb<span class="token punctuation">,</span>SqList <span class="token operator">&amp;</span>Lc<span class="token punctuation">)</span><span class="token comment">//顺序有序表的合并</span><span class="token punctuation">&#123;</span><span class="token comment">//已知顺序有序表La和Lb的元素按值非递减排列</span><span class="token comment">//La和Lb合并得到新的顺序有序表Lc，Lc的元素也按值非递减排列</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>i<span class="token operator">=</span>j<span class="token operator">=</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Lc<span class="token punctuation">.</span>length<span class="token operator">=</span>La<span class="token punctuation">.</span>length<span class="token operator">+</span>Lb<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">//新表长度为待合并两表的长度之和</span>Lc<span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>Lc<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//为合并后的新表分配一段空间</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>La<span class="token punctuation">.</span>length<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>Lb<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//两个表都非空</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>La<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>Lb<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//依次取出两表中值较小放入到Lc表中</span>Lc<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>La<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">else</span>Lc<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>Lb<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>La<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//La有剩余，依次将La的剩余元素插入Lc表的最后</span>Lc<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>La<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>Lb<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//Lb有剩余，依次将Lb的剩余元素插入Lc表的最后</span>Lc<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>Lb<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-3"><a href="#算法复杂度分析：-3" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>合并操作需要将 La 和 Lb 中的每一个元素取出放入 Lc 中，如果 La 和 Lb 的长度分别为 m、n，那么合并操作时间复杂度为 O(m+n) 空间复杂度也为 O(m+n)</p><h3 id="合并有序链表："><a href="#合并有序链表：" class="headerlink" title="合并有序链表："></a>合并有序链表：</h3><p><strong>题目：</strong>将两个有序（非递减）单链表 La 和 Lb 合并为一个新的有序（非递减）单链表。</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>链表合并不需要再创建空间，只需要“穿针引线”，把两个单链表中的节点按非递减的顺序串联起来即可。</p><blockquote><p>注意：单链表的头指针不可以移动，一旦头指针丢失，就找不到该单链表了，因此需要辅助指针。</p></blockquote><h4 id="解题：-1"><a href="#解题：-1" class="headerlink" title="解题："></a>解题：</h4><ol><li><p>设置 3 个辅助指针 p、q、r，p 和 q 分别指向 La 和 Lb 链表的当前比较位置，新链表头指针 Lc 指向 La，当作合并后的头节点。r 指向 Lc 的当前最后一个节点，利用 r 指针“穿针引线”：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220910102955699.png" alt="image-20220910102955699"></p></li><li><p>穿针引线。比较元素大小，将较小元素用 r 指针串起来。</p></li><li><p>第 1 次比较，p-&gt;data&#x3D;4 &gt; q-&gt;data&#x3D;2，用 r 指针将 q 节点串起来。串联剩余部分，直到其中一个指针为空。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">r<span class="token operator">-></span>next<span class="token operator">=</span>q<span class="token punctuation">;</span> <span class="token comment">//把 q 节点的地址赋值给 r 的 next 指针域，即 r 的 next 指针指向 q</span>r<span class="token operator">=</span>q<span class="token punctuation">;</span> <span class="token comment">//r 指针指向 Lc 的当前尾节点</span>q<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//q 指针向后移动，等待处理下一个节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>若 p 指针不为空，用 r 指针将 p 串连起来，即 r-&gt;next&#x3D;p;。注意这里只是把这个指针连上即可，剩余的节点不需要再处理。释放 Lb 节点空间，即 delete Lb。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mergelinklist</span><span class="token punctuation">(</span>LinkList La<span class="token punctuation">,</span>LinkList Lb<span class="token punctuation">,</span>LinkList <span class="token operator">&amp;</span>Lc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">,</span>r<span class="token punctuation">;</span>    p<span class="token operator">=</span>La<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向La的第一个元素</span>    q<span class="token operator">=</span>Lb<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//q指向Lb的第一个元素</span>    Lc<span class="token operator">=</span>La<span class="token punctuation">;</span>      <span class="token comment">//Lc指向La的头结点</span>    r<span class="token operator">=</span>Lc<span class="token punctuation">;</span>       <span class="token comment">//r指向Lc的尾部</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>q<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token operator">&lt;=</span>q<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token comment">//把p指向的结点串起来</span>        <span class="token punctuation">&#123;</span>            r<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>            r<span class="token operator">=</span>p<span class="token punctuation">;</span>            p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>             <span class="token comment">//把q指向的结点串起来</span>        <span class="token punctuation">&#123;</span>            r<span class="token operator">-></span>next<span class="token operator">=</span>q<span class="token punctuation">;</span>            r<span class="token operator">=</span>q<span class="token punctuation">;</span>            q<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">?</span>p<span class="token operator">:</span>q<span class="token punctuation">;</span><span class="token comment">//相当于if(p) r->next=p; else r->next=q;</span>    <span class="token keyword">delete</span> Lb<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-4"><a href="#算法复杂度分析：-4" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>链表合并不需要再创建空间，只需要穿针引线，把两个单链表中的节点按非递减的顺序串联起来即可。因此在最坏的情况下，需要串联每一个节点，如果 La 和 Lb 的长度分别为 m、n 时间复杂度为 O(m+n) 空间复杂度为 O(1)</p><h3 id="就地逆置单链表："><a href="#就地逆置单链表：" class="headerlink" title="就地逆置单链表："></a>就地逆置单链表：</h3><p><strong>题目：</strong>将带有头节点的单链表就地逆置。即元素的顺序逆转，而辅助空间复杂度为 O(1)。</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>头插法创建单链表得到的序列正好是逆序，那么我们就利用<strong>头插法建表</strong>的思路，实现就地逆置。</p><blockquote><p>注意：在修改指针之前，一定要用一个辅助指针记录断点，否则后面这一部分就会遗失，再也找不到了。</p></blockquote><h4 id="解题：-2"><a href="#解题：-2" class="headerlink" title="解题："></a>解题：</h4><ol><li><p>首先用 p 指针指向第一个元素节点，然后将头节点的 next 域置空。</p></li><li><p>将 p 节点用头插法插入链表 L 中，插入之前用 q 指针记录断点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">q<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// q 指向 p 的下一个节点，记录断点</span>p<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//将 L 的下一个节点地址赋值给 p 的 next 域</span>L<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//将 p 节点地址赋值给 L 的 next 域</span>p<span class="token operator">=</span>q<span class="token punctuation">;</span> <span class="token comment">//p 指向 q</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>p 指针为空，算法停止，单链表就地逆置完毕。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reverselinklist</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向L的第一个元素</span>    L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//头结点的next域置空：</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//q指向p的下一个结点，记录断点；</span>        p<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//头插法，将L的下一个结点地址赋值给p的next域</span>        L<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//将p结点地址赋值给L的next域</span>        p<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token comment">//指针后移，p指向q；</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-5"><a href="#算法复杂度分析：-5" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n) 没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)</p><h3 id="查找链表的中间节点："><a href="#查找链表的中间节点：" class="headerlink" title="查找链表的中间节点："></a>查找链表的中间节点：</h3><p><strong>题目：</strong>带有头节点的单链表 L，设计一个尽可能高效的算法求 L 中的中间节点。</p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>此类题型可以使用快慢指针来解决。一个快指针，一个慢指针，快指针走两步，慢指针走一步。当快指针指向结尾的时候，慢指针刚好指向中间节点。</p><h4 id="解题：-3"><a href="#解题：-3" class="headerlink" title="解题："></a>解题：</h4><p>放置两个小青蛙，一个跳得远，一次走两块石头；一个跳得近，一次走一块石头。当快青蛙走到终点时，慢青蛙正好走到中间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LinkList <span class="token function">findmiddle</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    p<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//p为快指针，初始时指向L</span>    q<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//q为慢指针，初始时指向L</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">-></span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//p为快指针一次走两步；</span>        q<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//q为慢指针一次走一步</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token comment">//返回中间结点指针</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-6"><a href="#算法复杂度分析：-6" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n) 没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)</p><h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>如何在单链表中查找倒数第 k 个节点？</p><p>仍然可以使用快慢指针，慢指针不要动，快指针先走 <strong>k−1</strong> 步，然后<strong>两个指针一起以同样的速度走</strong>。当快指针走到终点时，慢指针正好停留在倒数第 k 个节点，为什么呢？<br><strong>因为它们之间的距离始终保持 k−1。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LinkList <span class="token function">findk</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p为快指针，初始时指向第一个数据结点</span>    q<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//q为慢指针，初始时指向第一个数据结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>k<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//k减到0时，慢指针开始走</span>            q<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//q为慢指针</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p为快指针，先走 k - 1步；</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token comment">//返回中间结点指针</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-7"><a href="#算法复杂度分析：-7" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n) 没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)</p><p>用快慢指针还可以解决很多问题，例如判断链表是否有环，判断两个链表是否相交等。</p><h3 id="删除链表中的重复元素："><a href="#删除链表中的重复元素：" class="headerlink" title="删除链表中的重复元素："></a>删除链表中的重复元素：</h3><p><strong>题目：</strong>用单链表保存 m 个整数，节点的结构为(data,next)，且|data|≤n(n 为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的节点。</p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>本题数据大小有范围限制，因此可以设置一个辅助数组记录该数据是否已出现，如果已出现，则删除；如果未出现，则标记。一趟扫描即可完成。</p><h4 id="解题：-4"><a href="#解题：-4" class="headerlink" title="解题："></a>解题：</h4><ol><li>设置一个辅助数组 flag[]，因为 n 为正整数，不包括 0，所以 0 空间不用。需要分配 n+1 个辅助空间，初始化时都为 0，表示这些数还未出现过，</li><li>设置 p 指针指向头节点，检查第一个数据元素是否已出现过。令 x&#x3D;abs(p-&gt;next-&gt;data)，如果已出现过（flag[x]&#x3D;1），则删除该节点；如果该节点数据元素未出现过，则标记 flag[x]&#x3D;1，p 指针向后移动，直到处理完毕。</li><li>abs(p-&gt;next-&gt;data)&#x3D;5，读取 flag[5]&#x3D;0，说明该节点数据元素未出现过，标记 flag[5]&#x3D;1，p 指针向后移动。</li><li>p-&gt;next 为空，算法停止。对于链表中 data 的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的节点。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Deleterep</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//删除重复元素</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>flag<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//定义flag数组，分配n+1个空间</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//初始化</span>        flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    p<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//指向头结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        x<span class="token operator">=</span><span class="token function">abs</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//未出现过</span>        <span class="token punctuation">&#123;</span>            flag<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//标记出现</span>            p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>           <span class="token comment">//指针后移</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            q<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>            p<span class="token operator">-></span>next<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//删除重复元素</span>            <span class="token keyword">delete</span> q<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>flag<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-8"><a href="#算法复杂度分析：-8" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>根据题意，单链表中保存 m 个绝对值小于等于 n 的整数，因此链表元素个数为 m，算法从头到尾扫描了一遍链表，时间复杂度为 O(m) 采用了辅助数组 flag[]，因为 n 为正整数，不包括 0，所以 0 空间不用，需要分配 n+1 个辅助空间，因此空间时间复杂度为 O(n)</p><h2 id="线性表学习技巧"><a href="#线性表学习技巧" class="headerlink" title="线性表学习技巧"></a>线性表学习技巧</h2><h3 id="顺序表和链表的比较："><a href="#顺序表和链表的比较：" class="headerlink" title="顺序表和链表的比较："></a>顺序表和链表的比较：</h3><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220910113841323.png" alt="image-20220910113841323"></p><h3 id="顺序表解题技巧："><a href="#顺序表解题技巧：" class="headerlink" title="顺序表解题技巧："></a>顺序表解题技巧：</h3><ul><li><strong>位序和下标差 1，第 i 个元素的下标为 i−1。</strong></li><li><strong>交换元素、有序合并需要借助辅助空间。</strong></li><li><strong>交换元素、有序合并需要借助辅助空间。</strong></li></ul><h3 id="链表解题技巧："><a href="#链表解题技巧：" class="headerlink" title="链表解题技巧："></a>链表解题技巧：</h3><ul><li>赋值语句两端的含义：<strong>等号的右侧是节点的地址，等号的左侧是节点的指针域</strong></li><li>修改指针的顺序：<strong>先修改没有指针标记的那一端</strong></li><li>建立链表的两种方法：<strong>头插法、尾插法。头插法是逆序建表，尾插法是正序建表</strong></li><li>链表逆置、归并不需要额外空间，<strong>属于就地操作</strong>。</li><li><strong>快慢指针法</strong>：快慢指针可以解决很多问题，如链表中间节点、倒数第 k 个节点、判断链表是否有环、环的起点、公共部分的起点等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-基础知识</title>
      <link href="/2022/09/06/shu-ju-jie-gou-ru-men-ji-chu-zhi-shi/"/>
      <url>/2022/09/06/shu-ju-jie-gou-ru-men-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构基础知识"><a href="#数据结构基础知识" class="headerlink" title="数据结构基础知识"></a>数据结构基础知识</h2><ol><li><p>数据</p><blockquote><p>数据是指所有能输入到计算机中的描述客观事物的符号，包括文本、声音、图像、符号等。</p></blockquote></li><li><p>数据元素</p><blockquote><p>数据元素是数据的基本单位，也称节点或记录：</p></blockquote><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-ji-chu-zhi-shi/image-20220906145439200.png" alt="image-20220906145439200"></p></li><li><p>数据项</p><blockquote><p>数据项表示有独立含义的数据最小单位，也称域。若干个数据项构成一个数据元素，数据项是不可分割的最小单位，如上图所示的“86”。</p></blockquote></li><li><p>数据对象</p><blockquote><p>数据对象是指相同特性的数据元素的集合，是数据的一个子集。</p></blockquote></li><li><p>数据结构</p><blockquote><p>数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。</p><p>数据结构是带“结构”的数据元素的集合，“结构”是指数据元素之间存在的关系。</p></blockquote></li><li><p>逻辑结构与存储结构</p><blockquote><p>逻辑结构是数据元素之间的关系，存储结构是数据元素及其关系在计算机中的存储方式。</p></blockquote><ul><li><p>逻辑结构：</p><p>数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题中抽象出来的数学模型。</p><ul><li><p><strong>集合</strong></p><p>数据元素间除“同属于一个集合”外，无其他关系。集合中的元素是离散、无序的。</p></li><li><p><strong>线性结构</strong></p><p>一个对一个，如线性表、栈、队列、数组、广义表。</p><p>有<strong>唯一的开始和唯一的结束</strong>，除了第一个元素外，每个元素都有唯一的直接前驱（前面那个）；除了最后一个元素外，每个元素都有唯一的直接后继（后面那个）。</p></li><li><p><strong>树形结构</strong></p><p>一个对多个，如树。</p><p>树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支，树枝和树枝之间是不相交的。</p></li><li><p><strong>图形结构</strong></p><p>多个对多个，如图、网。</p><p>图形结构就像我们经常见到的地图，任何一个节点都可能和其他节点有关系，就像一张错综复杂的网。</p></li></ul></li><li><p>存储结构：</p><p>数据元素及其关系在计算机中的存储方式。</p><ul><li><p><strong>顺序存储</strong></p><p>顺序存储是指逻辑上相邻的元素在计算机内的存储位置也是相邻的。</p><p>顺序存储采用一段连续的存储空间，将逻辑上相邻的元素存储在连续的空间内，中间不允许有空。顺序存储可以快速定位第几个元素的地址，但是插入和删除时需要移动大量元素。</p></li><li><p><strong>链式存储</strong></p><p>链式存储是指逻辑上相邻的元素在计算机内的存储位置不一定是相邻的。</p><p>每个节点除了数据域，还有一个指针域，记录下一个元素的存储地址。</p></li><li><p><strong>散列存储</strong></p><p>散列存储，又称哈希（Hash）存储，由节点的关键码值决定节点的存储地址。用散列函数确定数据元素的存储位置与关键码之间的对应关系。</p><p>散列存储可以通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。如果有冲突，则有多种处理冲突的方法。</p></li><li><p><strong>索引存储</strong></p><p>索引存储是指除建立存储节点信息外，还建立附加的索引表来标识节点的地址。索引表由若干索引项组成。如果每个节点在索引表中都有一个索引项，则该索引表称为稠密索引。若一组节点在索引表中只对应于一个索引项，则该索引表称为稀疏索引。</p></li></ul></li></ul></li><li><p>抽象数据类型</p><blockquote><p>抽象数据类型（Abstract Data Type，ADT）是将数据对象、数据对象之间的关系和数据对象的基本操作封装在一起的一种表达方式，它和工程中的应用是一致的。</p></blockquote><p>在工程项目中，开始编程之前，首先列出程序需要完成的功能任务，先不用管具体怎么实现，实现细节在项目后期完成，一开始只是抽象出有哪些基本操作。</p><ul><li><p><strong>为什么要使用抽象数据类型？</strong></p><p>抽象数据类型的主要作用是数据封装和信息隐藏，让实现与使用相分离。数据及其相关操作的结合称为数据封装。对象可以对其他对象隐藏某些操作细节，从而使这些操作不会受到其他对象的影响，这就是信息隐藏。抽象数据类型独立于运算的具体实现，使用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，实现了<strong>信息隐藏</strong>。</p></li><li><p><strong>为什么很多书中没有使用抽象数据类型？</strong></p><p>因为很多人觉得数据结构难以理解，学习起来非常吃力，因此仅仅将数据结构的基本操作作为重点，把每一个基本操作讲解清楚，使读者学会和掌握数据结构的基本操作，便完成了数据结构书的基本任务。在实际工程中，需要根据实际情况融会贯通，灵活运用，这是后续话题。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组合API</title>
      <link href="/2022/09/02/vue-zu-he-api/"/>
      <url>/2022/09/02/vue-zu-he-api/</url>
      
        <content type="html"><![CDATA[<h1 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h1><blockquote><ul><li>组件逻辑复用</li><li>逐步应用</li><li>与<code>Options API</code>共存</li></ul></blockquote><h2 id="为什么要使用Composition-API？"><a href="#为什么要使用Composition-API？" class="headerlink" title="为什么要使用Composition API？"></a>为什么要使用Composition API？</h2><p>在使用<code>Options API</code>时，我们必须反复在不同的配置项中跳跃进行代码阅读。</p><p>而使用<code>Composition API</code>后，我们可以将组件的所有代码写在一个<code>setup()</code>函数中，在其中我们可以自由地调整代码位置，让同一功能的代码放在一起。同时我们也可以抽离其中的函数放置在单独的文件中，让组件直接使用抽离出的函数，让组件代码更加简洁。</p><h2 id="Composition-API的入口——setup-函数："><a href="#Composition-API的入口——setup-函数：" class="headerlink" title="Composition API的入口——setup()函数："></a>Composition API的入口——<code>setup()</code>函数：</h2><blockquote><p>注意：<code>setup()</code>函数只是提供了响应式组件的<strong>替代</strong>方式，例如<code>data()</code>，<code>computed()</code>，<code>methods()</code>等。像静态的components，props，emits等组件配置项，还是使用原来的方式，不过之后还是会有替代的方式。</p></blockquote><p>示例：</p><p>组件MessageList.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主文件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageList</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageList <span class="token keyword">from</span> <span class="token string">"./components/MessageList.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MessageList<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何在setup-函数中定义响应式数据？"><a href="#如何在setup-函数中定义响应式数据？" class="headerlink" title="如何在setup()函数中定义响应式数据？"></a>如何在<code>setup()</code>函数中定义响应式数据？</h3><p>Vue提供了一组用于在<code>setup()</code>函数中定义响应式数据的函数，这些响应性数据也可称为<strong>状态</strong>。</p><blockquote><p>也就是说，随着用户使用，应用的响应式数据会根据事件的发生而发生变化，从而引起组件的刷新，也就是状态的改变。</p></blockquote><h4 id="ref-函数："><a href="#ref-函数：" class="headerlink" title="ref()函数："></a><code>ref()</code>函数：</h4><p><code>ref()</code>函数接收一个参数，可以是任意类型，它会把他们包装成响应式数据，作用就是<strong>替代了<code>data()</code>配置项</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>ref<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数字</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"字符串"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//字符串</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：如果传给<code>ref()</code>函数的是一个对象，那么对象的所有属性包括嵌套的属性都会转换为响应式的属性。</p></blockquote><p><strong>在<code>setup()</code>函数中，必须通过其value属性来访问其包装的响应式数据，但和原始数值不是全相等的，原理以后再说。而在模板中不需要使用value属性来访问。</strong></p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>messages = []<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>ref<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 使用ref()让其他依赖响应式数据的代码进行更新</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>messages<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="reactive-函数："><a href="#reactive-函数：" class="headerlink" title="reactive()函数："></a><code>reactive()</code>函数：</h4><blockquote><p><code>reactive()</code>函数与<code>ref()</code>函数类似，但它只接收一个<strong>对象类型</strong>的函数作为参数。这里的对象类型是广义的，包括数组。</p><p><code>reactive()</code>函数在<code>setup()</code>函数中可以直接访问，不需要使用value属性。</p><p>使用<code>ref()</code>函数时，其内部也会调用<code>reactive()</code>函数，把对象的所有属性转换为响应式数据，之后将转换后的值赋值给value属性。</p></blockquote><p>如何选择<code>ref()</code>函数和<code>reactive()</code>函数呢？</p><p>通常情况下直接使用ref()函数，因为它能直接定义基本数据，而且使用ref()函数定义的数据比较分散，所以更容易抽离成可复用的；</p><p><code>reactive()</code>函数则适用于一次性定义多个响应式数据的情况，将它们放置在一个对象中，之后通过该对象修改和访问其中的属性，适合存放组件的配置属性或表单数据。</p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; options.title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>      用户：&#123;&#123; options.user.name &#125;&#125;，活跃：&#123;&#123;        options.user.active ? "是" : "否"      &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>messages = []<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>删除全部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.title = <span class="token punctuation">'</span>这是标题<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.user.name = <span class="token punctuation">'</span>李四<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改用户<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// const messages = reactive([</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// const options = ref(&#123;</span>    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span>      <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> options <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="computed-函数："><a href="#computed-函数：" class="headerlink" title="computed()函数："></a><code>computed()</code>函数：</h4><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- v-model 可以直接绑定 ref，与 data 配置项等效 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>搜索消息<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchTerm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in searchedMessages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> computed <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> searchTerm <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> searchedMessages <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>searchTerm<span class="token punctuation">.</span>value <span class="token operator">===</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token keyword">return</span> messages<span class="token punctuation">.</span>value<span class="token punctuation">;</span>      <span class="token keyword">return</span> messages<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> msg<span class="token punctuation">.</span>content<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>searchTerm<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>searchedMessages<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> searchTerm<span class="token punctuation">,</span> searchedMessages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="watch-函数："><a href="#watch-函数：" class="headerlink" title="watch()函数："></a><code>watch()</code>函数：</h4><h5 id="监听响应式数据的变化："><a href="#监听响应式数据的变化：" class="headerlink" title="监听响应式数据的变化："></a>监听响应式数据的变化：</h5><ol><li><p>直接监听响应式数据：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">watch</span><span class="token punctuation">(</span>searchTerm<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>messages<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"搜索词："</span><span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>监听解剖后的响应式数据：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 直接监听 searchTerm 不可以</span>    <span class="token function">watch</span><span class="token punctuation">(</span>searchTerm<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"搜索词："</span><span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 需要使用一个函数</span>    <span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> searchTerm<span class="token punctuation">.</span>value<span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"搜索词："</span><span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h5 id="监听对象中基本类型的响应式属性："><a href="#监听对象中基本类型的响应式属性：" class="headerlink" title="监听对象中基本类型的响应式属性："></a>监听对象中基本类型的响应式属性：</h5><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; options.title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>      用户：&#123;&#123; options.user.name &#125;&#125;，活跃：&#123;&#123;        options.user.active ? "是" : "否"      &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.title = <span class="token punctuation">'</span>这是标题<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.user.name = <span class="token punctuation">'</span>李四<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改用户<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> reactive<span class="token punctuation">,</span> computed<span class="token punctuation">,</span> watch <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token comment">// const options = reactive(&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span>      <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 监听浅层 Object 属性</span>    <span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">,</span>      <span class="token comment">// () => options.title, // reactive</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 监听深层 Object 属性</span>    <span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">,</span>      <span class="token comment">// () => options.user.name, // reactive</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> options <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="监听对象类型的响应式属性："><a href="#监听对象类型的响应式属性：" class="headerlink" title="监听对象类型的响应式属性："></a>监听对象类型的响应式属性：</h5><blockquote><p>注意：直接监听value属性，<code>watch()</code>函数不会监听到变化。因为在监听整个对象的时候，<code>watch()</code>比较的是<strong>对象的引用</strong>，每次修改对象的属性都不会创建新的对象，而是在原对象中进行修改，所以<code>watch()</code>函数监听不到。<strong>数组同理</strong>。</p></blockquote><ol><li><p>配置<code>deep: true</code>：</p><blockquote><p>缺点：不能访问修改前的值</p></blockquote><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// with deep true，可以比对对象的属性</span>    <span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">,</span> newVal <span class="token operator">===</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相同的引用</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用扩展运算符<code>...</code>：</p><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token comment">// const options = reactive(&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span>      <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span>options<span class="token punctuation">.</span>value <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">,</span> newVal <span class="token operator">===</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相同的引用</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> options <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只使用扩展运算符，并不会监听到子对象的值，如<code>user.name</code>。即使设置了<code>deep: true</code>，监听到的对象也是相同的引用。</p><blockquote><p>因为<code>...</code>语法创建的对象是<strong>浅拷贝</strong>，只会复制顶层的属性，子对象会原封不动的把引用传给新的对象。</p></blockquote><p>可使用JSON相关的方法进行深拷贝：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对象转为字符串再转为对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h5 id="同时监听多个响应性数据："><a href="#同时监听多个响应性数据：" class="headerlink" title="同时监听多个响应性数据："></a>同时监听多个响应性数据：</h5><p><code>watch()</code>函数支持使用数组进行监听：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 同时监听多个响应性数据</span>   <span class="token function">watch</span><span class="token punctuation">(</span>     <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">(</span><span class="token parameter">newVals<span class="token punctuation">,</span> oldVals</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVals<span class="token punctuation">,</span> oldVals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 其中的数据也是数组形式</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="watchEffect-函数："><a href="#watchEffect-函数：" class="headerlink" title="watchEffect()函数："></a><code>watchEffect()</code>函数：</h4><p><code>watchEffect()</code>和 <code>watch()</code>的作用基本一样，用于监听响应式数据的变化，并根据变化做一些业务逻辑，例如请求远程服务数据。</p><p>区别：</p><ol><li><code>watchEffect()</code>函数不用明确指定标签中的响应式数据，而是会根据回调函数中的代码<strong>自动</strong>判断。如果代码中用到了响应式数据，无论多少个，<strong>只要其中的一个发生了变化，<code>watchEffect()</code>函数就会重新执行一次。</strong></li><li><code>watchEffect()</code>函数无论数据是否发生了变化，<strong>都会先执行一次回调函数</strong>。</li><li><code>watchEffect()</code><strong>不能访问修改前的值，回调函数中的响应式的值都是修改后的</strong>。</li></ol><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; options.title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>      用户：&#123;&#123; options.user.name &#125;&#125;，活跃：&#123;&#123;        options.user.active ? "是" : "否"      &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.title = <span class="token punctuation">'</span>这是标题<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.user.name = <span class="token punctuation">'</span>李四<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改用户<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watchEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token comment">// const options = reactive(&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span>      <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> options <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="watch-amp-watchEffect-清理收尾工作："><a href="#watch-amp-watchEffect-清理收尾工作：" class="headerlink" title="watch()&amp;watchEffect() 清理收尾工作："></a><code>watch()</code>&amp;<code>watchEffect()</code> 清理收尾工作：</h4><h5 id="watchEffect-函数：-1"><a href="#watchEffect-函数：-1" class="headerlink" title="watchEffect()函数："></a><code>watchEffect()</code>函数：</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">onInvalidate</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"做一些清理操作..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="watch-函数：-1"><a href="#watch-函数：-1" class="headerlink" title="watch()函数："></a><code>watch()</code>函数：</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">watch</span><span class="token punctuation">(</span>     <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">,</span>     <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">,</span> onInvalidate</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"做一些清理操作..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：<code>onInvalidate()</code>函数会在<strong>下次</strong>监听代码执行前执行</p></blockquote><h3 id="传递和访问Props属性："><a href="#传递和访问Props属性：" class="headerlink" title="传递和访问Props属性："></a>传递和访问Props属性：</h3><p>如果需要在<code>setup()</code>函数中访问Props属性，需要在<code>setup()</code>函数中设置<strong>参数</strong>：</p><p>示例：</p><p>子组件MessageList.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> toRefs <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件MessageListItem.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageListItem</span>        <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span>        <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.content<span class="token punctuation">"</span></span>      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageListItem</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> MessageListItem <span class="token keyword">from</span> <span class="token string">"./MessageListItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MessageListItem <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="转换非响应性props为响应性："><a href="#转换非响应性props为响应性：" class="headerlink" title="转换非响应性props为响应性："></a>转换非响应性props为响应性：</h3><p><code>setup()</code>函数中的props属性整体是响应性的，相当于使用<code>reactive()</code>或使用<code>ref()</code>创建的对象的value属性，故可以使用<code>watch()</code>或<code>watchEffect()</code>监听props中的属性变化。</p><p>但如果父组件传递给子组件的数据是非响应性的，如果使用解构语法拆解出来，那么是不会被监听到变化的，同样地类似computed()响应式属性也不会生效。</p><blockquote><p>须调用Vue中的<code>toRefs()</code>函数，之后再解构。</p></blockquote><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> toRefs <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> msg <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// const  msg = toRefs(props, 'msg');</span>    <span class="token function">watch</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newMsg</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ref-x2F-reactive创建的数据在Props中的响应性："><a href="#ref-x2F-reactive创建的数据在Props中的响应性：" class="headerlink" title="ref&#x2F;reactive创建的数据在Props中的响应性："></a>ref&#x2F;reactive创建的数据在Props中的响应性：</h3><blockquote><p>注意：如果父组件传递的数据类型为JavaScript基本类型，例如字符串、数字、布尔类型等，他们在通过属性传递后就会<strong>失去响应性</strong>，在子组件中需要使用<code>toRefs()</code>函数进行转换。</p></blockquote><blockquote><p>换言之，只有<strong>对象</strong>和<strong>数组</strong>类型的数据在传递的时候会保留其响应性。</p><p>使用<code>ref()</code>函数创建的数据在传递时，<strong>只会传递其value属性</strong>，在子组件中即为Proxy类型。</p></blockquote><h3 id="在setup-函数中定义methods："><a href="#在setup-函数中定义methods：" class="headerlink" title="在setup()函数中定义methods："></a>在<code>setup()</code>函数中定义methods：</h3><p>直接定义function：</p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>removeMessage(id)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>删除<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> toRefs <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 无参数</span>    <span class="token comment">// function removeMessage() &#123;</span>    <span class="token comment">//   console.log("删除消息");</span>    <span class="token comment">// &#125;</span>    <span class="token comment">// // 有参数</span>    <span class="token keyword">function</span> <span class="token function">removeMessage</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"删除消息"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> removeMessage <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Emit自定义事件："><a href="#Emit自定义事件：" class="headerlink" title="Emit自定义事件："></a>Emit自定义事件：</h3><blockquote><p>因为无法从<code>setup()</code>函数中访问<code>this</code>属性，<code>setup()</code>接收第二个参数context，其中一个属性就是emit函数。</p></blockquote><blockquote><p>context参数本身不是响应性的，所以可以<strong>直接使用解构赋值</strong>。</p></blockquote><p>示例：</p><p>子组件MessageListItem.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- &lt;button @click="removeMessage(id)">删除&lt;/button> --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>this.$emit(<span class="token punctuation">'</span>remove<span class="token punctuation">'</span>, id)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>删除<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> toRefs <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"remove"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// setup(props, &#123; emit &#125;) &#123;</span>    <span class="token comment">// 有参数</span>    <span class="token comment">// function removeMessage(id) &#123;</span>    <span class="token comment">//   emit("remove", id);</span>    <span class="token comment">// &#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// return &#123; emit &#125;;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件MessageList.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageListItem</span>        <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span>        <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.content<span class="token punctuation">"</span></span>        <span class="token attr-name">@remove</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>removeMessage<span class="token punctuation">"</span></span>      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageListItem</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> MessageListItem <span class="token keyword">from</span> <span class="token string">"./MessageListItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MessageListItem <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">removeMessage</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// console.log(id);</span>      messages<span class="token punctuation">.</span>value <span class="token operator">=</span> messages<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=></span> msg<span class="token punctuation">.</span>id <span class="token operator">!==</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> removeMessage <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="生命周期钩子："><a href="#生命周期钩子：" class="headerlink" title="生命周期钩子："></a>生命周期钩子：</h3><p>与<code>Options API</code>不同，<code>Composition API</code>中的生命周期钩子需要加上<strong>on</strong>前缀，后面对应的生命周期首字母大写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2022/09/02/vue-zu-he-api/image-20220904171819752.png" alt="image-20220904171819752"></p><p><img src="/2022/09/02/vue-zu-he-api/image-20220904172051743.png" alt="image-20220904172051743"></p><blockquote><p>没有beforeCreate和created对应生命周期钩子的原因是<code>setup()</code>函数本身就是在这两个生命周期期间执行的，所以在这两个生命周期的自定义业务逻辑，直接在<code>setup()</code>函数中编写即可。</p></blockquote><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>loading...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageListItem</span>        <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span>        <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.content<span class="token punctuation">"</span></span>      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageListItem</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> onMounted <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> MessageListItem <span class="token keyword">from</span> <span class="token string">"./MessageListItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MessageListItem <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> loading <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      loading<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        messages<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">[</span>          <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">;</span>        loading<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> loading <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Provide和Inject："><a href="#Provide和Inject：" class="headerlink" title="Provide和Inject："></a>Provide和Inject：</h3><ol><li><p>普通数据：</p><pre class="line-numbers language-none"><code class="language-none">provide(&#39;propName&#39;, value);inject(&#39;propName&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>响应式数据：</p><p>如果使用provide提供的数据本身是响应性的，那么inject接收的数据就是响应性的；</p><p>如果不是，则可以调用<code>ref()</code>，<code>reactive()</code>，<code>toRef()</code>，<code>toRefs()</code>转换为响应性数据：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- &lt;MovieItem :title="movie.title" :description="movie.description" /> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieItem</span> <span class="token attr-name">:description</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>movie.description<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieItem <span class="token keyword">from</span> <span class="token string">"./MovieItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> provide<span class="token punctuation">,</span> toRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MovieItem<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> movie <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"电影"</span><span class="token punctuation">,</span>      <span class="token literal-property property">description</span><span class="token operator">:</span> <span class="token string">"这是一段电影的描述"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">provide</span><span class="token punctuation">(</span><span class="token string">"movie"</span><span class="token punctuation">,</span> movie<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// provide("title", toRef(movie.value, "title"));</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      movie<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"电影-修改"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> movie <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="获取Template-Ref："><a href="#获取Template-Ref：" class="headerlink" title="获取Template Ref："></a>获取Template Ref：</h3><p>即相当于在<code>Options API</code>中获取DOM和Vue组件实例：</p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inputText<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inputControl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> onMounted<span class="token punctuation">,</span> ref <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> inputText <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> inputControl <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      inputControl<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> inputText<span class="token punctuation">,</span> inputControl <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取非props属性："><a href="#获取非props属性：" class="headerlink" title="获取非props属性："></a>获取非props属性：</h3><p>使用<code>attrs</code>可以获取在props中未明确定义的属性：</p><p>示例：</p><p>子组件MessageList.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageListItem</span>        <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span>        <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.content<span class="token punctuation">"</span></span>      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageListItem</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> isRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> MessageListItem <span class="token keyword">from</span> <span class="token string">"./MessageListItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MessageListItem <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> attrs <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">[</span><span class="token string">"data-title"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拆解出来，不再具有响应性</span>    <span class="token comment">// const &#123; test &#125; = attrs;</span>    <span class="token comment">// watchEffect(() => &#123;</span>    <span class="token comment">//   console.log(test, " in MessageList.vue");</span>    <span class="token comment">// &#125;);</span>    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>test<span class="token punctuation">,</span> <span class="token string">" in MessageList.vue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// console.log(attrs);</span>    <span class="token comment">// console.log(attrs.class);</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageList</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>messageList<span class="token punctuation">"</span></span> <span class="token attr-name">:test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span> <span class="token attr-name">data-title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>消息列表<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageList <span class="token keyword">from</span> <span class="token string">"./components/MessageList.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MessageList<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      test<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">"changed"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> test <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用script-setup进一步简化组件代码："><a href="#使用script-setup进一步简化组件代码：" class="headerlink" title="使用script setup进一步简化组件代码："></a>使用script setup进一步简化组件代码：</h2><p>使用配置：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script setup<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li><p>script setup中定义的函数及变量等，可以直接在模板中使用，<strong>无需手动return</strong>。</p></li><li><p>script setup可以使用import导入库或其他组件，并在模板中直接使用，无需配置。</p></li><li><p>script setup中如果需要使用props，则可以调用<code>defineProps( [ &quot;propsName&quot;] )</code>函数。</p></li><li><p>script setup中如果需要使用emits，则可以调用<code>defineEmits( [ &quot;emitsName&quot;] )</code>函数。</p></li><li><p>script setup中如果需要使用slots和attrs：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useSlots<span class="token punctuation">,</span> useAttrs<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">const</span> slots <span class="token operator">=</span> <span class="token function">useSlots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> attrs <span class="token operator">=</span> <span class="token function">useAttrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门-贪心算法</title>
      <link href="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/"/>
      <url>/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法本质"><a href="#贪心算法本质" class="headerlink" title="贪心算法本质"></a>贪心算法本质</h2><blockquote><p>一个贪心算法总是做出当前最好的选择，也就是说，它期望通过<strong>局部最优选择</strong>从而得到全局最优的解决方案。</p></blockquote><p>贪心算法在解决问题的策略上“<strong>目光短浅</strong>”，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心算法并不是从整体最优考虑，它所做出的选择只是在<strong>某种意义上的局部最优</strong>。贪心算法能得到许多问题的<strong>整体最优解或整体最优解的近似解</strong>。</p><p>所谓贪心选择性质是指原问题的整体最优解可以通过一系列局部最优的选择得到。是运用贪心策略解决的问题在程序的运行过程中<strong>无回溯</strong>过程。根据贪心策略，一步一步地得到局部最优解。最终根据贪心策略，一步一步地得到局部最优解。</p><blockquote><p>冒泡排序就使用了贪心算法，它的贪心策略就是每一次从剩下的序列中选一个最大的数，把这些选出来的数放在一起，就得到了从大到小的排序结果。</p></blockquote><h2 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h2><p>该问题要求装载的物品的数量尽可能多，而船的容量是固定的，那么优先把重量小的物品放进去，在容量固定的情况下，装的物品最多。</p><p>采用<strong>重量最轻者先装</strong>的贪心选择策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。</p><h3 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h3><ol><li>当载重量为定值c时，每件古董越小时，可装载的古董数量就越大。只要依次选择最小重量古董，直到不能再装为止。</li><li>把n个古董的重量从小到大排序，然后根据贪心策略尽可能多地选出古董，直到不能继续装为止，此时达到最优。</li></ol><p>每个古董的重量如下表所示，海盗船的载重量c为30，那么在不打碎古董又不超过载重的情况下，要装入最多的古董。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901162702223.png" alt="image-20220901162702223"></p><ol><li><p>因为贪心策略是每次选择重量最小的古董装入海盗船，因此可以按照古董重量非递减排序，排序后如下表所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901162839158.png" alt="image-20220901162839158"></p></li><li><p>按照贪心策略，每次选择重量最小的古董放入（tmp 代表古董的重量，ans 代表已装裁的古董个数）。</p><p>i&#x3D;0，选择排序后的第 1 个，装入重量 tmp&#x3D;2，不超过载重量 30，ans &#x3D;1。<br>i&#x3D;1，选择排序后的第 2 个，装入重量 tmp&#x3D;2+3&#x3D;5，不超过载重量 30，ans &#x3D;2。<br>i&#x3D;2，选择排序后的第 3 个，装入重量 tmp&#x3D;5+4&#x3D;9，不超过载重量 30，ans &#x3D;3。<br>i&#x3D;3，选择排序后的第 4 个，装入重量 tmp&#x3D;9+5&#x3D;14，不超过载重量 30，ans &#x3D;4。<br>i&#x3D;4，选择排序后的第 5 个，装入重量 tmp&#x3D;14+7&#x3D;21，不超过载重量 30，ans &#x3D;5。<br>i&#x3D;5，选择排序后的第 6 个，装入重量 tmp&#x3D;21+10&#x3D;31，超过载重量 30，算法结束。<br>即放入古董的个数为 ans&#x3D;5 个。</p></li></ol><h3 id="运行代码："><a href="#运行代码：" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1000005</span><span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">double</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//古董的重量数组</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> c<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> m<span class="token punctuation">;</span>    cin<span class="token operator">>></span>m<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>c<span class="token operator">>></span>n<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//输入每个物品重量</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 可以利用 C++中的排序函数 sort（见附录 B），对古董的重量进行从小到大（非递减）排序。要使用此函数需引入头文件：</span>        <span class="token comment">// #include &lt;algorithm></span>        <span class="token comment">// 语法描述为：</span>        <span class="token comment">// sort(begin, end)//参数 begin 和 end 表示一个范围，分别为待排序数组的首地址和尾地址</span>        <span class="token comment">// sort 函数默认为升序</span>        <span class="token comment">// 在本例中只需要调用 sort 函数对古董的重量进行从小到大排序：</span>        <span class="token function">sort</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>w<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//按古董重量升序排序</span>        <span class="token keyword">double</span> tmp<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// tmp为已装载到船上的古董重量，ans为已装载的古董个数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            tmp<span class="token operator">+=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">&lt;=</span>c<span class="token punctuation">)</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*请输入载重量 c 及古董个数 n：30 8                        //载重量 c 及古董的个数 n请输入每个古董的重量，用空格分开：4 10 7 11 3 5 14 2         //每个古董的重量，用空格隔开*/</span><span class="token comment">//输出</span><span class="token comment">//能装入的古董最大数量为 Ans=5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析："><a href="#算法解析：" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li>算法复杂度分析：<ul><li>时间复杂度：首先需要按古董重量排序，调用 sort 函数，其平均时间复杂度为 O(nlogn)，输入和贪心策略求解的两个 for 语句时间复杂度均为 O(n)，因此时间复杂度为 <strong>O(n + nlog(n))</strong></li><li>空间复杂度：程序中变量 tmp、ans 等占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为 <strong>O(1)</strong></li></ul></li><li>优化拓展：<ul><li>为什么在没有装满的情况下，仍然是最优解？因为此算法要求装入最多数量，和价值无关，所以从重量小的开始装才能装入最多的数量。</li><li>如果想知道装入哪些古董，应当如何实现？</li></ul></li></ol><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>假设山洞中有 n 种宝物，每种宝物有一定重量 w 和相应的价值 v，毛驴运载能力有限，只能运走 m 重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？</p><p>答案是选择<strong>性价比</strong>（<strong>价值&#x2F;重量</strong>）最高的宝物，如果可以达到运载重量m，那么一定能得到价值最大，即每次从剩下的宝物中选择性价比最高的宝物。</p><h3 id="算法设计：-1"><a href="#算法设计：-1" class="headerlink" title="算法设计："></a>算法设计：</h3><ol><li>将 n 种宝物的重量和价值存储在结构体 three（包含重量、价值、性价比 3 个成员）中，同时求出每种宝物的性价比也存储在对应的结构体 three 中，将其按照性价比从高到低排序。采用 sum 来存储毛驴能够运走的最大价值，初始化为 0。</li><li>根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于 m（毛驴运载能力），如果小于 m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m 减去放入宝物的重量；如果不小于 m，**则取该宝物的一部分 m * p[i]**，m&#x3D;0，程序结束。m 减少到 0，则 sum 得到最大值。</li></ol><p>有一批宝物的价值，价值和重量如表所示，毛驴的运载能力m&#x3D;30。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901172836572.png" alt="image-20220901172836572"></p><ol><li><p>按照性价比降序排序，排序后如下表所示：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901173212678.png" alt="image-20220901173212678"></p></li><li><p>每次选择性价比高的宝物放入：</p><p>第 1 次选择宝物 2，剩余容量 30−2&#x3D;28，目前装入最大价值为 8。<br>第 2 次选择宝物 10，剩余容量 28−5&#x3D;23，目前装入最大价值为 8+15&#x3D;23。<br>第 3 次选择宝物 6，剩余容量 23−8&#x3D;15，目前装入最大价值为 23+20&#x3D;43。<br>第 4 次选择宝物 3，剩余容量 15−9&#x3D;6，目前装入最大价值为 43+18&#x3D;61。</p><p>第 5 次选择宝物 5，剩余容量 6−5&#x3D;1，目前装入最大价值为 61+8&#x3D;69。<br>第 6 次选择宝物 8，发现上次处理完时剩余容量为 1，而 8 号宝物重量为 4，无法全部放入，那么可以采用部分装入的形式，装入 1 个重量单位，因为 8 号宝物的单位重量价值为1.5，因此放入价值 1×1.5&#x3D;1.5，你也可以认为装入了 8 号宝物的 1&#x2F;4，目前装入最大价值为69+1.5&#x3D;70.5，剩余容量为 0。</p></li><li><p>构造最优解：</p><p>把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了 8 号财宝的 1&#x2F;4），能够装入宝物的最大价值为 70.5。</p></li></ol><h3 id="运行代码：-1"><a href="#运行代码：-1" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-2</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> M<span class="token operator">=</span><span class="token number">1000005</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">three</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> w<span class="token punctuation">;</span><span class="token comment">//每个宝物的重量</span>    <span class="token keyword">double</span> v<span class="token punctuation">;</span><span class="token comment">//每个宝物的价值</span>    <span class="token keyword">double</span> p<span class="token punctuation">;</span><span class="token comment">//性价比</span><span class="token punctuation">&#125;</span>s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//如果不使用自定义比较函数，那么sort函数排序时不知道按哪一项的值排序，因此采用自定义比较函数的办法实现宝物性价比的降序排序。</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>three a<span class="token punctuation">,</span>three b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>p<span class="token operator">></span>b<span class="token punctuation">.</span>p<span class="token punctuation">;</span><span class="token comment">//根据宝物的单位价值从大到小排序</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token comment">//n 表示有n个宝物</span>    <span class="token keyword">double</span> m <span class="token punctuation">;</span><span class="token comment">//m 表示毛驴的承载能力</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入宝物数量n及毛驴的承载能力m ："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token operator">>></span>m<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入每个宝物的重量和价值，用空格分开： "</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token operator">>></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token operator">/</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token comment">//每个宝物单位价值</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>s<span class="token operator">+</span>n<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 前两个参数分别为待排序数组的首地址和尾地址，最后一个参数compare表示比较的类型</span>    <span class="token keyword">double</span> sum<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">;</span><span class="token comment">// sum 表示贪心记录运走宝物的价值之和</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//按照排好的顺序贪心</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> m<span class="token operator">></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token punctuation">)</span><span class="token comment">//如果宝物的重量小于毛驴剩下的承载能力</span>        <span class="token punctuation">&#123;</span>            m<span class="token operator">-=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            sum<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token comment">//如果宝物的重量大于毛驴剩下的承载能力</span>        <span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>m<span class="token operator">*</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span><span class="token comment">//部分装入，m为剩余的装载能力，即还能装多少货物，s[i].p为单位重量价值，二者相乘为总价值。</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"装入宝物的最大价值Maximum value="</span><span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//输出装入宝物的最大价值</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//輸入</span><span class="token comment">/* 6 19 //宝物数量，驴子的承载重量2 8 //第 1 个宝物的重量和价值6 1 //第 2 个宝物的重量和价值7 94 310 23 4*/</span><span class="token comment">//输出</span><span class="token comment">//Maxinum value=24.6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析：-1"><a href="#算法解析：-1" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li><p>算法复杂度分析：</p><ul><li>时间复杂度：该算法的时间主要耗费在将宝物按照性价比排序上，采用的是快速排序，算法时间复杂度为 <strong>O(nlogn)</strong></li><li>空间复杂度：空间主要耗费在存储宝物的性价比，空间复杂度为 <strong>O(n)</strong></li></ul><p>贪心策略是在每次取剩下物品里面性价比最高的物品，这样可以使得在相同重量条件下比选其他物品所得的价值更大，因此采用贪心策略能得到最优解。</p></li><li><p>优化拓展：</p><ul><li><p>如果宝物不能分割，贪心算法是否能得到最优解？</p><p>不一定。有可能出现剩余容量，没有装满的情况。这种情况下可能存在刚好达到运载能力的选择方案，因此在宝物不可分割、没法装满的情况下，贪心算法并不能得到最优解，仅仅是最优解的近似解。</p></li></ul></li></ol><h2 id="会议安排问题"><a href="#会议安排问题" class="headerlink" title="会议安排问题"></a>会议安排问题</h2><p>会议安排的目的是能在<strong>有限的时间内召开更多的会议</strong>（任何两个会议不能同时进行）。在会议安排中，每个会议 i 都有起始时间 bi 和结束时间 e i，且 bi&lt;ei，即一个会议进行的时间为半开区间[bi，ei）。如果[b i，ei）与[bj，ej）均在“有限的时间内”，且不相交，则称会议 i 与会议 j 相容的。也就是说，当 bi≥ej 或 bj≥ei 时，会议 i与会议 j 相容。会议安排问题要求在<strong>所给的会议集合中选出最大的相容活动子集</strong>，即尽可能在有限的时间内召开更多的会议。</p><p>尝试贪心策略：如果选择最早开始时间的会议，则如果会议持续时间很长，例如 8 点开始，却要持续 12 个小时，这样一天就只能安排一个会议；如果选择持续时间最短，则可能开始时间很晚，例如 19 点开始，20 点结束，这样也只能安排一个会议，所以我们最好选择那些开始时间要早，而且持续时间短的会议，即最早开始时间+持续时间最短，就是最早结束时间。</p><blockquote><p>每次从剩下的会议中选择<strong>具有最早结束时间且与已安排的会议相容</strong>的会议安排。</p></blockquote><h3 id="算法设计：-2"><a href="#算法设计：-2" class="headerlink" title="算法设计："></a>算法设计：</h3><ol><li>初始化：将 n 个会议的开始时间、结束时间存放在结构体数组中（想一想，为什么不用两个一维数组分别存储？），如果需要知道选中了哪些会议，还需要在结构体中增加会议编号，然后按结束时间从小到大排序（非递减），结束时间相等时，按开始时间从大到小排序（非递增）；</li><li>根据贪心策略就是选择第一个具有最早结束时间的会议，用 last 记录刚选中会议的结束时间；</li><li>选择第一个会议之后，依次从剩下未安排的会议中选择，如果会议 i <strong>开始时间大于等于最后一个选中的会议的结束时间</strong> last，那么会议 i 与已选中的会议相容，可以安排，更新 last 为刚选中会议的结束时间；否则，舍弃会议 i，检查下一个会议是否可以安排。</li></ol><p>原始的会议时间表：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215008673.png" alt="image-20220901215008673"></p><p>排序后的会议时间表：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215037996.png" alt="image-20220901215037996"></p><p>贪心选择过程：</p><ul><li><p>首先选择排序后的第一个会议即最早结束的会议（编号为 2），用 last 记录最后一个被选中会议的结束时间，last&#x3D;4。</p></li><li><p>检查余下的会议，找到第一个开始时间大于等于 last（last&#x3D;4）的会议，子问题转化为从该会议开始，余下的所有会议。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215159196.png" alt="image-20220901215159196"></p><p>从子问题中，选择第一个会议即最早结束的会议（编号为 3），更新 last 为刚选中会议的结束时间 last&#x3D;7。</p></li><li><p>检查余下的会议，找到第一个开始时间大于等于 last（last&#x3D;7）的会议，子问题转化为从该会议开始，余下的所有会议。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215514120.png" alt="image-20220901215514120"></p><p>从子问题中，选择第一个会议即最早结束的会议（编号为 7），更新 last 为刚选中会议的结束时间 last&#x3D;11。</p></li><li><p>检查余下的会议，找到第一个开始时间大于等于 last（last&#x3D;11）的会议，子问题转化为从该会议开始，余下的所有会议。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215546493.png" alt="image-20220901215546493"></p><p>从子问题中，选择第一个会议即最早结束的会议（编号为 10），更新 last 为刚选中会议的结束时间 last&#x3D;14；所有会议检查完毕，算法结束。</p></li><li><p>从贪心选择的结果，可以看出，被选中的会议编号为{2，3，7，10}，可以安排的会议数量最多为 4。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215640659.png" alt="image-20220901215640659"></p></li></ul><h3 id="运行代码：-2"><a href="#运行代码：-2" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-3</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Meet</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> beg<span class="token punctuation">;</span>   <span class="token comment">//会议的开始时间</span>    <span class="token keyword">int</span> end<span class="token punctuation">;</span>   <span class="token comment">//会议的结束时间</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>   <span class="token comment">//记录会议的编号</span><span class="token punctuation">&#125;</span>meet<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//会议的最大个数为1000</span><span class="token keyword">class</span> <span class="token class-name">setMeet</span><span class="token punctuation">&#123;</span>  <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>ans<span class="token punctuation">;</span> <span class="token comment">// n:会议总数 ans: 最大的安排会议总数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//读入数据</span><span class="token keyword">void</span> setMeet<span class="token double-colon punctuation">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">,</span>e<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入会议总数："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入会议的开始时间和结束时间，以空格分开:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>s<span class="token operator">>></span>e<span class="token punctuation">;</span>        meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>beg<span class="token operator">=</span>s<span class="token punctuation">;</span>        meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token operator">=</span>e<span class="token punctuation">;</span>        meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>Meet x<span class="token punctuation">,</span>Meet y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>end <span class="token operator">==</span> y<span class="token punctuation">.</span>end<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>beg <span class="token operator">></span> y<span class="token punctuation">.</span>beg<span class="token punctuation">;</span><span class="token comment">//结束时间相等时，按开始时间从大到小排序</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>end <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>end<span class="token punctuation">;</span><span class="token comment">//按结束时间从小到大排序</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> setMeet<span class="token double-colon punctuation">::</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>meet<span class="token punctuation">,</span>meet<span class="token operator">+</span>n<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//对会议按结束时间排序</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"排完序的会议时间如下:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"会议编号："</span><span class="token operator">&lt;&lt;</span><span class="token string">"  开始时间 "</span><span class="token operator">&lt;&lt;</span><span class="token string">" 结束时间"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      cout<span class="token operator">&lt;&lt;</span> <span class="token string">"   "</span> <span class="token operator">&lt;&lt;</span> meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">&lt;&lt;</span><span class="token string">"\t\t"</span><span class="token operator">&lt;&lt;</span>meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>beg <span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span> meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"-------------------------------------------------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"选择的会议的过程:"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"  选择第"</span><span class="token operator">&lt;&lt;</span> meet<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">&lt;&lt;</span><span class="token string">"个会议"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//选中了第一个会议</span>    ans<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> last <span class="token operator">=</span> meet<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">;</span>  <span class="token comment">//记录刚刚被选中会议的结束时间</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>beg<span class="token operator">>=</span>last<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//如果会议i开始时间大于等于最后一个选中的会议的结束时间</span>           ans<span class="token operator">++</span><span class="token punctuation">;</span>           last <span class="token operator">=</span> meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">;</span>           cout <span class="token operator">&lt;&lt;</span><span class="token string">"  选择第"</span><span class="token operator">&lt;&lt;</span>meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">&lt;&lt;</span><span class="token string">"个会议"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"最多可以安排"</span> <span class="token operator">&lt;&lt;</span>ans <span class="token operator">&lt;&lt;</span> <span class="token string">"个会议"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  setMeet sm<span class="token punctuation">;</span>  sm<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读入数据</span>  sm<span class="token punctuation">.</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//贪心算法求解</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*输入会议总数：10输入会议的开始时间和结束时间，以空格分开：3 61 45 72 55 93 88 116 108 1212 14*/</span><span class="token comment">//输出</span><span class="token comment">/*排完序的会议时间如下：会议编号 开始时间 结束时间2 1 44 2 51 3 63 5 76 3 85 5 98 6 107 8 119 8 1210 12 14选择的会议的过程：选择第 2 个会议选择第 3 个会议选择第 7 个会议选择第 10 个会议最多可以安排 4 个会议*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析：-2"><a href="#算法解析：-2" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li>算法复杂度分析：<ul><li>时间复杂度：在该算法中，问题的规模就是会议总个数 n。显然，执行次数随问题规模的增大而变化。首先在成员函数 setMeet::init()中，输入 n 个结构体数据。输入作为基本语句，显然，共执行 n 次。而后在调用成员函数 setMeet::solve()中进行排序，易知 sort 排序函数的平均时间复杂度为 O(nlogn)。随后进行选择会议，贡献最大的为 if(meet[i].beg&gt;&#x3D;last)语句，时间复杂度为 O(n)，总时间复杂度为 O(n +nlogn)&#x3D; <strong>O(nlogn)</strong></li><li>空间复杂度：在该算法中，meet[]结构体数组为输入数据，不计算在空间复杂度内。辅助空间有 i、n、ans 等变量，则该程序空间复杂度为常数阶，即 <strong>O(1)</strong></li></ul></li><li>优化拓展：<ul><li>有没有更好的办法，比如有更小的算法时间复杂度？</li></ul></li></ol><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>给定有向带权图 G &#x3D;（V，Ｅ），其中每条边的权是非负实数。此外，给定 V 中的一个顶点，称为源点。现在要计算从源到所有其他各顶点的最短路径长度，这里路径长度指路上各边的权之和。</p><h3 id="算法设计：-3"><a href="#算法设计：-3" class="headerlink" title="算法设计："></a>算法设计：</h3><blockquote><p>Dijkstra 算法是解决单源最短路径问题的贪心算法，它<strong>先求出长度最短的一条路径</strong>，再参照该最短路径<strong>求出长度次短的一条路径</strong>，直到求出从源点到其他各个顶点的最短路径。</p></blockquote><p>Dijkstra 算法的基本思想是首先假定源点为 u，顶点集合 V 被划分为两部分：集合 S和 V−S。初始时 S 中仅含有源点 u，其中 S 中的顶点到源点的最短路径已经确定。集合V−S 中所包含的顶点到源点的最短路径的长度待定，称从源点出发只经过 S 中的点到达V−S 中的点的路径为特殊路径，并用数组 dist[]记录当前每个顶点所对应的最短特殊路径长度。将其连接的 V−S 中的顶点加入到集合 S 中，同时更新数组 dist[]。一旦 S 包含了所有顶点，dist[]就是从源到所有其他顶点之间的最短路径长度。</p><ol><li>数据结构。设置地图的带权邻接矩阵为 map[][]，即如果从源点 u 到顶点 i 有边，就令 map[u][i]等于&lt;u，i&gt;的权值，否则 map[u][i]&#x3D;∞（无穷大）；采用一维数组 dist[i]<br>来记录从源点到 i 顶点的最短路径长度；采用一维数组 p[i]来记录最短路径上 i 顶点的前驱。</li><li>初始化。令集合 S&#x3D;{u}，对于集合 V−S 中的所有顶点 x，初始化 dist[i]&#x3D;map[u][i]，如果源点 u 到顶点 i 有边相连，初始化 p[i]&#x3D;u，否则 p[i]&#x3D; −1。</li><li>找最小。在集合 V−S 中依照贪心策略来寻找使得 dist[j]具有最小值的顶点 t，即dist[t]&#x3D;min（dist[j]|j 属于 V−S 集合），则顶点 t 就是集合 V−S 中距离源点 u 最近的顶点。</li><li>加入 S 战队。将顶点 t 加入集合 S 中，同时更新 V−S。</li><li>判结束。如果集合 V−S 为空，算法结束，否则转（6）。</li><li>借东风。在（3）中已经找到了源点到 t 的最短路径，那么对集合 V−S 中所有与顶点 t 相邻的顶点 j，都可以借助 t 走捷径。如果 dis[j]&gt;dist[t]+map[t][j]，则 dist[j]&#x3D;dist[t]+map[t][j]，记录顶点 j 的前驱为 t，有 p[j]&#x3D; t，转（3）。</li></ol><p>由此，可求得从源点 u 到图 G 的其余各个顶点的最短路径及长度，也可通过数组 p[]逆向找到最短路径上经过的城市。</p><p>算法步骤如下。</p><p>初始景点地图：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901224759504.png" alt="image-20220901224759504"></p><p>设置地图的带权邻接矩阵为 map[][]，即如果从顶点 i 到顶点 j 有边，则 map[i][j]等于&lt;i,j&gt;的权值，否则 map[i][j]&#x3D;∞（无穷大）:</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901224817141.png" alt="image-20220901224817141"></p><p>令集合 S&#x3D;{1}，V−S&#x3D;{2，3，4，5}，对于集合 V−S 中的所有顶点 x，初始化最短距离数组 dist[i]&#x3D;map[1][i]，dist[u]&#x3D;0，如图 2-12 所示。如果源点 1 到顶点 i 有边相连，初始化前驱数组 p[i]&#x3D;1，否则 p[i]&#x3D; −1，如图 2-13 所示：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225045842.png" alt="image-20220901225045842"></p><p>在集合 V−S&#x3D;{2，3，4，5}中，依照贪心策略来寻找 V−S 集合中 dist[]最小的顶点 t，如图 2-14 所示。<br>找到最小值为 2，对应的结点 t&#x3D;2。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225130199.png" alt="image-20220901225130199"></p><p>将顶点 t&#x3D;2 加入集合 S 中 S&#x3D;{1，2}，同时更新 V−S&#x3D;{3，4，5}，如图 2-15 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225251138.png" alt="image-20220901225251138"></p><p>刚刚找到了源点到 t&#x3D;2 的最短路径，那么对集合 V−S 中所有 t 的邻接点 j，都可以借助 t 走捷径。我们从图或邻接矩阵都可以看出，2 号结点的邻接点是 3 和 4 号结点，如图 2-16 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225400247.png" alt="image-20220901225400247"></p><p>先看 3 号结点能否借助 2 号走捷径：dist[2]+map[2][3]&#x3D;2+2&#x3D;4，而当前 dist[3]&#x3D;5&gt;4，因此可以走捷径即 2—3，更新 dist[3]&#x3D;4，记录顶点 3 的前驱为 2，即 p[3]&#x3D; 2。<br>再看 4 号结点能否借助 2 号走捷径：如果 dist[2]+map[2][4]&#x3D;2+6&#x3D;8，而当前 dist[4]&#x3D;∞&gt;8，因此可以走捷径即 2—4，更新 dist[4]&#x3D;8，记录顶点 4 的前驱为 2，即 p[4]&#x3D; 2。<br>更新后如图 2-17 和图 2-18 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225409864.png" alt="image-20220901225409864"></p><p>在集合 V−S&#x3D;{3，4，5}中，依照贪心策略来寻找 dist[]具有最小值的顶点 t，依照贪心策略来寻找 V−S 集合中 dist[]最小的顶点 t，如图 2-19 所示。<br>找到最小值为 4，对应的结点 t&#x3D;3。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225450417.png" alt="image-20220901225450417"></p><p>将顶点 t&#x3D;3 加入集合 S 中 S&#x3D;{1，2，3}，同时更新 V−S&#x3D;{4，5}，如图 2-20 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225518417.png" alt="image-20220901225518417"></p><p>刚刚找到了源点到 t &#x3D;3 的最短路径，那么对集合 V−S 中所有 t 的邻接点 j，都可以借助t 走捷径。我们从图或邻接矩阵可以看出，3 号结点的邻接点是 4 和 5 号结点。<br>先看 4 号结点能否借助 3 号走捷径：dist[3]+map[3][4]&#x3D;4+7&#x3D;11，而当前 dist[4]&#x3D;8&lt;11，比当前路径还长，因此不更新。<br>再看 5 号结点能否借助 3 号走捷径：dist[3]+map[3][5]&#x3D;4+1&#x3D;5，而当前 dist[5]&#x3D;∞&gt;5，因此可以走捷径即 3—5，更新 dist[5]&#x3D;5，记录顶点 5 的前驱为 3，即 p[5]&#x3D;3。<br>更新后如图 2-21 和图 2-22 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225552693.png" alt="image-20220901225552693"></p><p>在集合 V−S&#x3D;{4，5}中，依照贪心策略来寻找 V−S 集合中 dist[]最小的顶点 t，如图 2-23 所示。<br>找到最小值为 5，对应的结点 t&#x3D;5。</p><p>将顶点 t&#x3D;5 加入集合 S 中 S&#x3D;{1，2，3，5}，同时更新 V−S&#x3D;{4}，如图 2-24 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225914054.png" alt="image-20220901225914054"></p><p>刚刚找到了源点到 t &#x3D;5 的最短路径，那么对集合 V−S 中所有 t 的邻接点 j，都可以借助 t 走捷径。我们从图或邻接矩阵可以看出，5 号结点没有邻接点，因此不更新。</p><p>在集合 V−S&#x3D;{4}中，依照贪心策略来寻找 dist[]最小的顶点 t，只有一个顶点，所以很容易找到。<br>找到最小值为 8，对应的结点 t&#x3D;4。</p><p>V−S&#x3D;{ }为空时，算法停止。<br>由此，可求得从源点 u 到图 G 的其余各个顶点的最短路径及长度，也可通过前驱数组p[]逆向找到最短路径上经过的城市。</p><p>例如，p[5]&#x3D;3，即 5 的前驱是 3；p[3]&#x3D;2，即 3 的前驱是 2；p[2]&#x3D;1，即 2 的前驱是 1；p[1]&#x3D; −1，1 没有前驱，那么从源点 1 到 5 的最短路径为 1—2—3—5。</p><h3 id="运行代码：-3"><a href="#运行代码：-3" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;windows.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 城市的个数可修改</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF<span class="token operator">=</span><span class="token number">1e7</span><span class="token punctuation">;</span> <span class="token comment">// 无穷大10000000</span><span class="token keyword">int</span> map<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">;</span><span class="token comment">//n城市的个数，m为城市间路线的条数</span><span class="token keyword">bool</span> flag<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//如果s[i]等于true，说明顶点i已经加入到集合S;否则顶点i属于集合V-S</span><span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>     dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//初始化源点u到其他各个顶点的最短路径长度</span>     flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>INF<span class="token punctuation">)</span>       p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//源点u到该顶点的路径长度为无穷大，说明顶点i与源点u不相邻</span>     <span class="token keyword">else</span>       p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>u<span class="token punctuation">;</span> <span class="token comment">//说明顶点i与源点u相邻，设置顶点i的前驱p[i]=u</span>     <span class="token punctuation">&#125;</span>    dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    flag<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment">//初始时，集合S中只有一个元素：源点u</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> INF<span class="token punctuation">,</span>t <span class="token operator">=</span> u<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//在集合V-S中寻找距离源点u最近的顶点t</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>temp<span class="token punctuation">)</span>           <span class="token punctuation">&#123;</span>            t<span class="token operator">=</span>j<span class="token punctuation">;</span>            temp<span class="token operator">=</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span>u<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment">//找不到t，跳出循环</span>        flag<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//否则，将t加入集合</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//更新与t相邻接的顶点到源点u的距离</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span> map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>INF<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>               dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">;</span>               p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>t <span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">findpath</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> x<span class="token punctuation">;</span>  stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>s<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"源点为："</span><span class="token operator">&lt;&lt;</span>u<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    x<span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>      x<span class="token operator">=</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"源点到其它各顶点最短路径为："</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"--"</span><span class="token punctuation">;</span>      s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">";最短距离为："</span><span class="token operator">&lt;&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">,</span>st<span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"color 0d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市的个数："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin <span class="token operator">>></span> n<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市之间的路线的个数:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin <span class="token operator">>></span>m<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市之间的路线以及距离："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token punctuation">&#123;</span>             map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span><span class="token comment">//初始化邻接矩阵为无穷大</span>          <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin <span class="token operator">>></span> u <span class="token operator">>></span> v <span class="token operator">>></span> w<span class="token punctuation">;</span>            map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵储存，保留最小的距离</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"请输入小明所在的位置:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">;</span>        cin <span class="token operator">>></span> st<span class="token punctuation">;</span>        <span class="token function">Dijkstra</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"小明所在的位置:"</span><span class="token operator">&lt;&lt;</span>st<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>             cout <span class="token operator">&lt;&lt;</span><span class="token string">"小明:"</span><span class="token operator">&lt;&lt;</span>st<span class="token operator">&lt;&lt;</span><span class="token string">" - "</span><span class="token operator">&lt;&lt;</span><span class="token string">"要去的位置:"</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> INF<span class="token punctuation">)</span>               cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sorry,无路可达"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>             <span class="token keyword">else</span>               cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 最短距离为:"</span><span class="token operator">&lt;&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>         <span class="token function">findpath</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*请输入城市的个数：5请输入城市之间的路线的个数：11请输入城市之间的路线以及距离：1 5 125 1 81 2 162 1 295 2 322 4 134 2 271 3 153 1 213 4 74 3 19请输入小明所在的位置：5*/</span><span class="token comment">//输出</span><span class="token comment">/*小明所在的位置：5小明:5 - 要去的位置:1 最短距离为：8小明:5 - 要去的位置:2 最短距离为：24小明:5 - 要去的位置:3 最短距离为：23小明:5 - 要去的位置:4 最短距离为：30小明:5 - 要去的位置:5 最短距离为：0*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为我们在程序中使用 p[]数组记录了最短路径上每一个结点的前驱，因此除了显示最短距离外，还可以显示最短路径上经过了哪些城市，可以增加一段程序逆向找到该最短路径上的城市序列。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">findpath</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>s<span class="token punctuation">;</span><span class="token comment">//利用 C++自带的函数创建一个栈 s，需要程序头部引入#include&lt;stack></span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"源点为："</span><span class="token operator">&lt;&lt;</span>u<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        x<span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将前驱依次压入栈中</span>    x<span class="token operator">=</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"源点到其他各顶点最短路径为："</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"--"</span><span class="token punctuation">;</span><span class="token comment">//依次取栈顶元素</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出栈</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">";最短距离为："</span><span class="token operator">&lt;&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要在主函数末尾调用该函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">findpath</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//主函数中 st 为源点</span><span class="token comment">//输出结果如下</span><span class="token comment">/*源点为：5源点到其他各顶点最短路径为：5--1；最短距离为：8源点到其他各顶点最短路径为：5--1--2；最短距离为：24源点到其他各顶点最短路径为：5--1--3；最短距离为：23源点到其他各顶点最短路径为：5--1--3--4；最短距离为：30源点到其他各顶点最短路径为：5；最短距离为：0*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析：-3"><a href="#算法解析：-3" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li><p>算法复杂度分析：</p><ul><li>时间复杂度：在 Dijkstra 算法描述中，一共有 4 个 for 语句，第①个 for 语句的执行次数为 n，第②个 for 语句里面嵌套了两个 for 语句③、④，它们的执行次数均为 n，对算法的运行时间贡献最大，当外层循环标号为 1 时，③、④语句在内层循环的控制下均执行 n 次，外层循环②从 1～n。因此，该语句的执行次数为 n*n&#x3D; n²，算法的时间复杂度为 <strong>O(n²)</strong></li><li>空间复杂度：由以上算法可以得出，实现该算法所需要的辅助空间包含为数组 flag、变量 i、j、t 和 temp 所分配的空间，因此，空间复杂度为 <strong>O(n)</strong></li></ul></li><li><p>优化拓展：</p><ul><li><p>在 for 语句③中，即在集合 V−S 中寻找距离源点 u 最近的顶点 t，其时间复杂度为 O(n)，如果我们使用优先队列，则可以把时间复杂度降为 **O(log n)**那么如何使用优先队列呢？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-4-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;windows.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 城市的个数可修改</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">1e7</span><span class="token punctuation">;</span> <span class="token comment">// 无穷大</span><span class="token keyword">int</span> map<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">;</span><span class="token keyword">int</span> flag<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span>  <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span>step<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> sp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        u<span class="token operator">=</span>a<span class="token punctuation">;</span>step<span class="token operator">=</span>sp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span>  Node<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 重载 &lt;</span>        <span class="token keyword">return</span> step<span class="token operator">></span>a<span class="token punctuation">.</span>step<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> st<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    priority_queue <span class="token operator">&lt;</span>Node<span class="token operator">></span> Q<span class="token punctuation">;</span>  <span class="token comment">// 优先队列优化</span>    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Node</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化flag数组为0</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>      dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span> <span class="token comment">// 初始化所有距离为，无穷大</span>    dist<span class="token punctuation">[</span>st<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        Node it<span class="token operator">=</span>Q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//优先队列队头元素为最小值</span>        Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> t<span class="token operator">=</span>it<span class="token punctuation">.</span>u<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//说明已经找到了最短距离，该结点是队列里面的重复元素</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        flag<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>INF<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 判断与当前点有关系的点，并且自己不能到自己</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>   <span class="token comment">// 求距离当前点的每个点的最短距离,进行松弛操作</span>                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Node</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 把更新后的最短距离压入优先队列，注意：里面的元素有重复</span>                 <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">,</span>st<span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"color 0d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置背景及字体颜色</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市的个数："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span> n<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市之间的路线的个数:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span>m<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//初始化图的邻接矩阵</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token punctuation">&#123;</span>              map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span><span class="token comment">//初始化邻接矩阵为无穷大</span>          <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市之间u,v的路线以及距离w："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>u<span class="token operator">>></span>v<span class="token operator">>></span>w<span class="token punctuation">;</span>            map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵储存，保留最小的距离</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入小明所在的位置:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">;</span>        cin<span class="token operator">>></span>st<span class="token punctuation">;</span>        <span class="token function">Dijkstra</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"小明所在的位置:"</span><span class="token operator">&lt;&lt;</span>st<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>             cout <span class="token operator">&lt;&lt;</span><span class="token string">"小明:"</span><span class="token operator">&lt;&lt;</span>st<span class="token operator">&lt;&lt;</span><span class="token string">"--->"</span><span class="token operator">&lt;&lt;</span><span class="token string">"要去的位置:"</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>INF<span class="token punctuation">)</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sorry,无路可达"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>             <span class="token keyword">else</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 最短距离为:"</span><span class="token operator">&lt;&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>通常的编码方法有固定长度编码和不等长度编码两种。这是一个设计最优编码方案的问题，目的是使总码长度最短。这个问题利用字符的<strong>使用频率</strong>来编码，是不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。如果采用等长的编码方案，假设所有字符的编码都等长，则表示 n 个不同的字符需要[log n]位。例如，3 个不同的字符 a、b、c，至少需要 2 位二进制数表示，a 为 00，b 为 01，c 为 10。如果每个字符的使用频率相等，固定长度编码是空间效率最高的方法。</p><ol><li><p>编码尽可能短</p><p>我们可以让使用频率高的字符编码较短，使用频率低的编码较长，这种方法可以提高压缩率，节省空间，也能提高运算和通信速度。即<strong>频率越高，编码越短</strong>。</p></li><li><p>不能有二义性</p><p>例如，ABCD 四个字符如果编码如下。<br>A：0。B：1。C：01。D：10。<br>那么现在有一列数 0110，该怎样翻译呢？是翻译为 ABBA，ABD，CBA，还是 CD？那么如何消除二义性呢？解决的办法是：任何一个字符的编码不能是另一个字符编码的前缀，即<strong>前缀码特性</strong>。</p></li></ol><h3 id="算法设计：-4"><a href="#算法设计：-4" class="headerlink" title="算法设计："></a>算法设计：</h3><p>哈夫曼算法采取的<strong>贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树</strong>，构造一棵新树，新树根节点的权值为其左右孩子结点权值之和，将新树插入到树的集合中，求解步骤如下。</p><ol><li>确定合适的数据结构。编写程序前需要考虑的情况有：<ul><li>哈夫曼树中没有度为 1 的结点，则一棵有 n 个叶子结点的哈夫曼树共有 2n−1 个结点（n−1 次的“合并”，每次产生一个新结点），</li><li>构成哈夫曼树后，为求编码，需从叶子结点出发走一条从叶子到根的路径。</li><li>译码需要从根出发走一条从根到叶子的路径，那么我们需要知道每个结点的权值、双亲、左孩子、右孩子和结点的信息。</li></ul></li><li>初始化。构造 n 棵结点为 n 个字符的单结点树集合 T&#x3D;{t1，t2，t3，…，t n}，每棵树只有一个带权的根结点，权值为该字符的使用频率。</li><li>如果 T 中只剩下一棵树，则哈夫曼树构造成功，跳到步骤（6）。否则，从集合 T中取出没有双亲且权值最小的两棵树 t i 和 t j，将它们合并成一棵新树 zk，新树的左孩子为 t i，右孩子为 t j，zk 的权值为 t i 和 t j 的权值之和。</li><li>从集合 T 中删去 t i，t j，加入 zk。</li><li>重复以上（3）～（4）步。</li><li>约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码。算法结束。</li></ol><p>下图是一些字符和它们的使用频率：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100212471.png" alt="image-20220902100212471"></p><p>我们可以把每一个字符作为叶子，它们对应的频率作为其权值，为了比较大小方便，可以对其同时扩大 100 倍，得到 a～f 分别对应 5、32、18、7、25、13。</p><ol><li><p>初始化。构造 n 棵结点为 n 个字符的单结点树集合 T&#x3D;{a，b，c，d，e，f}，如图 2-33 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100356328.png" alt="image-20220902100356328"></p></li><li><p>从集合 T 中取出没有双亲的且权值最小的两棵树a 和 d，将它们合并成一棵新树 t1，新树的左孩子为 a，右孩子为 d，新树的权值为 a 和 d 的权值之和为 12。新树的树根 t1 加入集合 T，a 和 d 从集合T中删除，如图 2-34 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100406071.png" alt="image-20220902100406071"></p></li><li><p>从集合 T 中取出没有双亲的且权值最小的两棵树 t1 和 f，将它们合并成一棵新树 t2，新树的左孩子为 t1，右孩子为 f，新树的权值为 t1 和 f 的权值之和为 25。新树的树根 t2 加入集合 T，将 t1 和 f 从集合 T 中删除，如图 2-35 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100415960.png" alt="image-20220902100415960"></p></li><li><p>从集合 T 中取出没有双亲且权值最小的两棵树 c 和 e，将它们合并成一棵新树 t3，新树的左孩子为 c，右孩子为 e，新树的权值为 c 和 e 的权值之和为 43。新树的树根 t3 加入集合 T，将 c 和 e 从集合 T 中删除，如图 2-36 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100425130.png" alt="image-20220902100425130"></p></li><li><p>从集合 T 中取出没有双亲且权值最小的两棵树 t2和 b，将它们合并成一棵新树 t4，新树的左孩子为 t2，右孩子为 b，新树的权值为 t2 和 b 的权值之和为 57。新树的树根t4 加入集合 T，将 t2 和 b 从集合 T 中删除，如图 2-37 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100437842.png" alt="image-20220902100437842"></p></li><li><p>从集合 T 中取出没有双亲且权值最小的两棵树 t3和 t4，将它们合并成一棵新树 t5，新树的左孩子为 t4，右孩子为 t3，新树的权值为 t3 和 t4的权值之和为 100。新树的树根 t5 加入集合 T，将 t3 和 t4 从集合 T 中删除，如图 2-38所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100446844.png" alt="image-20220902100446844"></p></li><li><p>T 中只剩下一棵树，哈夫曼树构造成功。</p></li><li><p>约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码，如图 2-39 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100458042.png" alt="image-20220902100458042"></p></li></ol><h3 id="运行代码：-4"><a href="#运行代码：-4" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXBIT</span>    <span class="token expression"><span class="token number">100</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXVALUE</span>  <span class="token expression"><span class="token number">10000</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLEAF</span>   <span class="token expression"><span class="token number">30</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXNODE</span>   <span class="token expression">MAXLEAF<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> weight<span class="token punctuation">;</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>    <span class="token keyword">int</span> lchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> rchild<span class="token punctuation">;</span>    <span class="token keyword">char</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HNodeType<span class="token punctuation">;</span>        <span class="token comment">/* 结点结构体 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> bit<span class="token punctuation">[</span>MAXBIT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HCodeType<span class="token punctuation">;</span>        <span class="token comment">/* 编码结构体 */</span>HNodeType HuffNode<span class="token punctuation">[</span>MAXNODE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 定义一个结点结构体数组 */</span>HCodeType HuffCode<span class="token punctuation">[</span>MAXLEAF<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* 定义一个编码结构体数组*/</span><span class="token comment">/* 构造哈夫曼树 */</span><span class="token keyword">void</span> <span class="token function">HuffmanTree</span> <span class="token punctuation">(</span>HNodeType HuffNode<span class="token punctuation">[</span>MAXNODE<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* i、j： 循环变量，m1、m2：构造哈夫曼树不同过程中两个最小权值结点的权值，       x1、x2：构造哈夫曼树不同过程中两个最小权值结点在数组中的序号。*/</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> x2<span class="token punctuation">;</span>    <span class="token keyword">double</span> m1<span class="token punctuation">,</span>m2<span class="token punctuation">;</span>    <span class="token comment">/* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//权值</span>        HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 输入 n 个叶子结点的权值 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Please input value and weight of leaf node "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin<span class="token operator">>></span>HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token operator">>></span>HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 构造 Huffman 树 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span><span class="token comment">//执行n-1次合并</span>         m1<span class="token operator">=</span>m2<span class="token operator">=</span>MAXVALUE<span class="token punctuation">;</span>         <span class="token comment">/* m1、m2中存放两个无父结点且结点权值最小的两个结点 */</span>        x1<span class="token operator">=</span>x2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/* 找出所有结点中权值最小、无父结点的两个结点，并合并之为一棵二叉树 */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">+</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;</span>m1<span class="token operator">&amp;&amp;</span>HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                m2 <span class="token operator">=</span> m1<span class="token punctuation">;</span>                x2 <span class="token operator">=</span> x1<span class="token punctuation">;</span>                m1 <span class="token operator">=</span> HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>                x1 <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> m2 <span class="token operator">&amp;&amp;</span> HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                m2<span class="token operator">=</span>HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>                x2<span class="token operator">=</span>j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 设置找到的两个子结点 x1、x2 的父结点信息 */</span>        HuffNode<span class="token punctuation">[</span>x1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent  <span class="token operator">=</span> n<span class="token operator">+</span>i<span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent  <span class="token operator">=</span> n<span class="token operator">+</span>i<span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>n<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> m1<span class="token operator">+</span>m2<span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>n<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild <span class="token operator">=</span> x1<span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>n<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild <span class="token operator">=</span> x2<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"x1.weight and x2.weight in round "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>HuffNode<span class="token punctuation">[</span>x1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>HuffNode<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">/* 用于测试 */</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 哈夫曼树编码 */</span><span class="token keyword">void</span> <span class="token function">HuffmanCode</span><span class="token punctuation">(</span>HCodeType HuffCode<span class="token punctuation">[</span>MAXLEAF<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    HCodeType cd<span class="token punctuation">;</span>       <span class="token comment">/* 定义一个临时变量来存放求解编码时的信息 */</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cd<span class="token punctuation">.</span>start<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        c<span class="token operator">=</span>i<span class="token punctuation">;</span>        p<span class="token operator">=</span>HuffNode<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>HuffNode<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">==</span>c<span class="token punctuation">)</span>                cd<span class="token punctuation">.</span>bit<span class="token punctuation">[</span>cd<span class="token punctuation">.</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                cd<span class="token punctuation">.</span>bit<span class="token punctuation">[</span>cd<span class="token punctuation">.</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            cd<span class="token punctuation">.</span>start<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment">/*前移一位 */</span>            c<span class="token operator">=</span>p<span class="token punctuation">;</span>            p<span class="token operator">=</span>HuffNode<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>    <span class="token comment">/* 设置下一循环条件 */</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span>cd<span class="token punctuation">.</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>           HuffCode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>bit<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>cd<span class="token punctuation">.</span>bit<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        HuffCode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start<span class="token operator">=</span>cd<span class="token punctuation">.</span>start<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>n<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Please input n:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    <span class="token function">HuffmanTree</span><span class="token punctuation">(</span>HuffNode<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//构造哈夫曼树</span>    <span class="token function">HuffmanCode</span><span class="token punctuation">(</span>HuffCode<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 哈夫曼树编码</span>    <span class="token comment">//输出已保存好的所有存在编码的哈夫曼编码</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token operator">&lt;&lt;</span><span class="token string">": Huffman code is: "</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>HuffCode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            cout<span class="token operator">&lt;&lt;</span>HuffCode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>bit<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*Please input n：6Please input value and weight of leaf node 1a 0.05Please input value and weight of leaf node 2b 0.32Please input value and weight of leaf node 3c 0.18Please input value and weight of leaf node 4d 0.07Please input value and weight of leaf node 5e 0.25Please input value and weight of leaf node 6f 0.13*/</span><span class="token comment">//输出</span><span class="token comment">/*x1.weight and x2.weight in round 1 0.05 0.07x1.weight and x2.weight in round 2 0.12 0.13x1.weight and x2.weight in round 3 0.18 0.25x1.weight and x2.weight in round 4 0.25 0.32x1.weight and x2.weight in round 5 0.43 0.57a: Huffman code is: 1000b: Huffman code is: 11c: Huffman code is: 00d: Huffman code is: 1001e: Huffman code is: 01f: Huffman code is: 101*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析：-4"><a href="#算法解析：-4" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li><p>算法复杂度分析：</p><ul><li><p>时间复杂度：由程序可以看出，在函数 HuffmanTree()中，if (HuffNode[j].weight&lt;m1&amp;&amp;HuffNode[j].parent&#x3D;&#x3D;−1)为基本语句，外层 i 与 j 组成双层循环：</p><p>i&#x3D;0 时，该语句执行 n 次；<br>i&#x3D;1 时，该语句执行 n+1 次；<br>i&#x3D;2 时，该语句执行 n+2 次；<br>……<br>i&#x3D;n−2 时，该语句执行 n+n−2 次；<br>则基本语句共执行 n+（n+1）+（n+2）+…+（n+（n−2））&#x3D;（n−1）*（3n−2）&#x2F;2 次（等<br>差数列）；在函数 HuffmanCode()中，编码和输出编码时间复杂度都接近 n2；则该算法时间复<br>杂度为 <strong>O(n2)</strong></p></li><li><p>空间复杂度：所需存储空间为结点结构体数组与编码结构体数组，哈夫曼树数组HuffNode[]中的结点为 n 个，每个结点包含 bit[MAXBIT]和 start 两个域，则该算法空间复杂度为 <strong>O(n*MAXBIT)</strong></p></li></ul></li><li><p>优化拓展：</p><ol><li>函数 HuffmanTree()中找两个权值最小结点时使用优先队列，时间复杂度为 logn，执行 n−1 次，总时间复杂度为 <strong>O( n logn)</strong></li><li>函数 HuffmanCode()中，哈夫曼编码数组 HuffNode[]中可以定义一个动态分配空间的线性表来存储编码，每个线性表的长度为实际的编码长度，这样可以大大节省空间。</li></ol></li></ol><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h3><p>某学校下设 10 个学院，3 个研究所，1 个大型图书馆，4 个实验室。其中，1～10 号节点代表 10 个学院，11～13 号节点代表 3 个研究所，14 号节点代表图书馆，15～18 号节点代表 4 个实验室。该问题用无向连通图 G &#x3D;（V，E）来表示通信网络，V 表示顶点集，E 表示边集。把各个单位抽象为图中的顶点，顶点与顶点之间的边表示单位之间的通信网络，边的权值表示布线的费用。如果两个节点之间没有连线，代表这两个单位之间不能布线，费用为无穷大。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902104007203.png" alt="image-20220902104007203"></p><p>那么我们如何设计网络电缆布线，将各个单位连通起来，并且费用最少呢？</p><p>对于 n 个顶点的连通图，只需 n−1 条边就可以使这个图连通，n−1 条边要想保证图连通，就必须不含回路，所以我们只需要找出 n−1 条<strong>权值最小且无回路的边</strong>即可。</p><h4 id="算法设计：-5"><a href="#算法设计：-5" class="headerlink" title="算法设计："></a>算法设计：</h4><p>如果在一个图中深度搜索或广度搜索有没有回路，是一件繁重的工作。有一个很好的办法—<strong>避圈法</strong>。</p><p>在生成树的过程中，我们把已经在生成树中的结点看作一个集合，把剩下的结点看作另一个集合，从连接两个集合的边中选择一条权值最小的边即可。</p><p>首先任选一个结点，例如 1 号结点，把它放在集合 U 中，U&#x3D;{1}，那么剩下的结点即V−U&#x3D;{2，3，4，5，6，7}，V 是图的所有顶点集合。如图 2-60 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902104202251.png" alt="image-20220902104202251"></p><p>现在只需在连接两个集合（V 和 V−U）的边中看哪一条边权值最小，把权值最小的边关联的结点加入到集合 U。从图 2-60 可以看出，连接两个集合的 3 条边中，结点 1 到结点 2的边权值最小，选中此条边，把 2 号结点加入 U 集合 U&#x3D;{1，2}，V−U&#x3D;{3，4，5，6，7}。</p><p>再从连接两个集合（V 和 V−U）的边中选择一条权值最小的边。从图 2-61 可以看出，连接两个集合的 4 条边中，结点 2 到结点 7 的边权值最小，选中此条边，把 7 号结点加入 U集合 U&#x3D;{1，2，7}，V−U&#x3D;{3，4，5，6}。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902104251672.png" alt="image-20220902104251672"></p><p>如此下去，直到 U&#x3D;V 结束，选中的边和所有的结点组成的图就是最小生成树。这就是Prim算法。</p><ul><li><p>确定合适的数据结构。设置带权邻接矩阵 C 存储图 G，如果图 G 中存在边（u，x），令 C[u][x]等于边（u，x）上的权值，否则，C[u][x]&#x3D;∞ ；bool 数组 s[]，如果 s[i]&#x3D;true，说明顶点 i 已加入集合 U。可以通过设置两个数组来找到集合中最短的边，closest[j]表示 V−U 中的顶点 j 到集合 U 中的最邻近点，lowcost[j]表示 V−U中的顶点 j 到集合 U 中的最邻近点的边值，即边（j,closest[j]）的权值。</p><p>例如，在图 2-62 中，7 号结点到 U 集合中的最邻近点是 2，closest[7]&#x3D;2，如图 2-63 所示。7 号结点到最邻近点 2 的边值为 1，即边（2，7）的权值，记为 lowcost[7]&#x3D;1，如图 2-64所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902104743734.png" alt="image-20220902104743734"></p><p>只需要在 V−U 集合中找 lowcost[]值最小的顶点即可。</p></li><li><p>初始化。令集合 U&#x3D;{u0 }，u0∈V，并初始化数组 closest[]、lowcost[]和 s[]。</p></li><li><p>在 V−U 集合中找 lowcost 值最小的顶点 t，即 lowcost[t]&#x3D;min{lowcost[j]|j∈V−U}，满足该公式的顶点 t 就是集合 V−U 中连接集合 U 的最邻近点。</p></li><li><p>将顶点 t 加入集合 U。</p></li><li><p>如果集合 V−U，算法结束，否则，转步骤 6。</p></li><li><p>对集合 V−U 中的所有顶点 j，更新其 lowcost[]和 closest[]。更新公式：if（C[t][j]&lt;lowcost [j] ) { lowcost [j]&#x3D; C [t] [j]; closest [j] &#x3D; t; }，转步骤 3。</p></li></ul><h4 id="运行代码：-5"><a href="#运行代码：-5" class="headerlink" title="运行代码："></a>运行代码：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-6</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3fffffff</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">bool</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> closest<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> u0<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//顶点个数n、开始顶点u0、带权邻接矩阵C[n][n]</span>    <span class="token comment">//如果s[i]=true,说明顶点i已加入最小生成树</span>    <span class="token comment">//的顶点集合U；否则顶点i属于集合V-U</span>    <span class="token comment">//将最后的相关的最小权值传递到数组lowcost</span>    s<span class="token punctuation">[</span>u0<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//初始时，集合中U只有一个元素，即顶点u0</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>u0<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">[</span>u0<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            closest<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>u0<span class="token punctuation">;</span>            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//在集合中V-u中寻找距离集合U最近的顶点t</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp<span class="token operator">=</span>INF<span class="token punctuation">;</span>        <span class="token keyword">int</span> t<span class="token operator">=</span>u0<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                t<span class="token operator">=</span>j<span class="token punctuation">;</span>                temp<span class="token operator">=</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span>u0<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>       <span class="token comment">//找不到t，跳出循环</span>        s<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>     <span class="token comment">//否则，讲t加入集合U</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//更新lowcost和closest</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                closest<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>        <span class="token keyword">int</span> u0<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数n和边数m:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token operator">>></span>m<span class="token punctuation">;</span>        <span class="token keyword">int</span> sumcost<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数u,v和边值w:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>u<span class="token operator">>></span>v<span class="token operator">>></span>w<span class="token punctuation">;</span>            c<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>w<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入任一结点u0:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span> u0 <span class="token punctuation">;</span>        <span class="token comment">//计算最后的lowcos的总和，即为最后要求的最小的费用之和</span>        <span class="token function">Prim</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> u0<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"数组lowcost的内容为"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>           sumcost <span class="token operator">+=</span> lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小的花费是："</span><span class="token operator">&lt;&lt;</span>sumcost<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*输入结点数 n 和边数 m：7 12输入结点数 u，v 和边值 w：1 2 231 6 281 7 362 3 202 7 13 4 153 7 44 5 34 7 95 6 175 7 166 7 25输入任一结点 u0：1*/</span><span class="token comment">//输出</span><span class="token comment">/*数组 lowcost 的内容为：0 23 4 9 3 17 1最小的花费是：57*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法解析：-5"><a href="#算法解析：-5" class="headerlink" title="算法解析："></a>算法解析：</h4><ol><li><p>算法复杂度分析：</p><ul><li>时间复杂度：在 Prim（int n，int u0，int c[N][N]）算法中，一共有 4 个 for 语句，第①个 for 语句的执行次数为 n，第②个 for 语句里面嵌套了两个 for 语句③、④，它们的执行次数均为 n，对算法的运行时间贡献最大。当外层循环标号为 1 时，③、④语句在内层循环的控制下均执行 n 次，外层循环②从 1～n。因此，该语句的执行次数为 n*n&#x3D;n²，算法的时间复杂度为 <strong>O(n²)</strong></li><li>空间复杂度：算法所需要的辅助空间包含 i、j、lowcost 和 closest，则算法的空间复杂度是 <strong>O(n)</strong></li></ul></li><li><p>优化拓展：</p><ol><li>for 语句③找 lowcost 最小值时使用优先队列，每次出队一个最小值，时间复杂度为logn，执行 n 次，总时间复杂度为 <strong>O( n logn)</strong></li><li>for 语句④更新 lowcost 和 closest 数据时，如果图采用邻接表存储，每次只检查t的邻接边，不用从 1～n 检查，检查更新的次数为 E（边数），每次更新数据入队，入队的时间复杂度为 logn，这样更新的时间复杂度为 <strong>O( Elogn)</strong></li></ol></li></ol><h3 id="Kurskal算法："><a href="#Kurskal算法：" class="headerlink" title="Kurskal算法："></a>Kurskal算法：</h3><h4 id="算法设计：-6"><a href="#算法设计：-6" class="headerlink" title="算法设计："></a>算法设计：</h4><p>构造最小生成树还有一种算法，Kurskal 算法：设 G&#x3D;（V，E）是无向连通带权图，V&#x3D;{1，2，…，n}；设最小生成树 T&#x3D;（V，TE），该树的初始状态为只有 n 个顶点而无边的非连通图T&#x3D;（V，{}），Kruskal 算法将这 n 个顶点看成是 n 个孤立的连通分支。它首先将所有的边按权值从小到大排序，然后只要 T 中选中的边数不到 n−1，就做如下的贪心选择：在边集 E 中选取权值最小的边（i，j），如果将边（i，j）加入集合 TE 中不产生回路（圈），则将边（i，j）加入边集 TE 中，即用边（i，j）将这两个连通分支合并连接成一个连通分支；否则继续选择下一条最短边。把边（i，j）从集合 E 中删去。继续上面的贪心选择，直到 T 中所有顶点都在同一个连通分支上为止。此时，选取到的 n−1 条边恰好构成 G 的一棵最小生成树 T。</p><p>怎样判断加入某条边后图 T 会不会出现回路呢？</p><p>Kruskal 算法用了一个非常聪明的方法，就是运用<strong>集合避圈</strong>：<strong>如果所选择加入的边的起点和终点都在 T 的集合中，那么就可以断定一定会形成回路（圈）。</strong></p><h4 id="运行代码：-6"><a href="#运行代码：-6" class="headerlink" title="运行代码："></a>运行代码：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-7</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> nodeset<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">;</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">comp</span><span class="token punctuation">(</span>Edge x<span class="token punctuation">,</span> Edge y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        nodeset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> nodeset<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> q <span class="token operator">=</span> nodeset<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span>q<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//检查所有结点，把集合号是 q 的改为 p</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nodeset<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>q<span class="token punctuation">)</span>        nodeset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//a 的集合号赋值给 b 集合号</span><span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Merge</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token punctuation">,</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数n和边数m:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>        <span class="token function">Init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数u,v和边值w:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            cin<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> e<span class="token operator">+</span>m<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小的花费是："</span> <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法解析：-6"><a href="#算法解析：-6" class="headerlink" title="算法解析："></a>算法解析：</h4><ol><li><p>算法复杂度分析：</p><ul><li>时间复杂度：算法中，需要对边进行排序，若使用快速排序，执行次数为 e<em>loge，算法的时间复杂度为 O(e</em>loge)。而合并集合需要 n−1 次合并，每次为 O(n)，合并集合的时间复杂度为 <strong>O(n^2)</strong></li><li>空间复杂度：算法所需要的辅助空间包含集合号数组 nodeset[n]，则算法的空间复杂度是 <strong>O(n)</strong></li></ul></li><li><p>优化拓展：</p><ol><li><p>该算法合并集合的时间复杂度为 O(n2 )，我们可以用并查集的思想优化，使合并集合的时间复杂度降为 *<em>O(e</em>logn)**，优化后的程序如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-7-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> father<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">;</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">comp</span><span class="token punctuation">(</span>Edge x<span class="token punctuation">,</span> Edge y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>        father<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span>q<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">></span> q<span class="token punctuation">)</span>        father<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token comment">//小的赋值给大的集合号</span>    <span class="token keyword">else</span>        father<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Merge</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token punctuation">,</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数n和边数m:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>        <span class="token function">Init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数u,v和边值w:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            cin<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> e<span class="token operator">+</span>m<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小的花费是："</span> <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*输入结点数 n 和边数 m：7 12输入结点数 u，v 和边值 w：1 2 231 6 281 7 362 3 202 7 13 4 153 7 44 5 34 7 95 6 175 7 166 7 25*/</span><span class="token comment">//输出</span><span class="token comment">//最小的花费:57</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ol><p><strong>本文摘录于《趣学算法》一书，欲学习其他算法请购买正版书籍！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门-算法复杂性</title>
      <link href="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/"/>
      <url>/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="算法复杂性"><a href="#算法复杂性" class="headerlink" title="算法复杂性"></a>算法复杂性</h2><blockquote><p>算法是指对特定问题求解步骤的一种描述。</p></blockquote><p>算法具有以下特性：</p><ul><li><strong>有穷性</strong>：算法是由若干条指令组成的有穷序列，总是在执行若干次后结束，不可能永不停止。</li><li><strong>确定性</strong>：每条语句有确定的含义，无歧义。</li><li><strong>可行性</strong>：算法在当前环境条件下可以通过有限次运算实现。</li><li><strong>输入输出</strong>：有零个或多个输入，一个或多个输出。</li></ul><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><blockquote><p>算法运行需要的时间，一般将<strong>算法的执行次数</strong>作为时间复杂度的度量标准。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//算法 1-3</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//运行1次</span>total<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//运行1次</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//运行n次</span><span class="token punctuation">&#123;</span>  sum<span class="token operator">=</span>sum<span class="token operator">+</span>i<span class="token punctuation">;</span><span class="token comment">//运行n次</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//运行n*(n+1)次</span>total<span class="token operator">=</span>total<span class="token operator">+</span>i<span class="token punctuation">;</span><span class="token comment">//运行n*n次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把算法的所有语句的运行次数加起来：1+1+<em>n</em>+1+<em>n</em>+<em>n</em>×(<em>n</em>+1)+<em>n</em>×<em>n</em>，可以用一个函数T(n)表达：<br>$$<br>T(n)&#x3D;2n^2+3n+3<br>$$<br>当n足够大时,我们可以看到算法运行时间主要取决于第一项，后面的甚至可以忽略不计。<br>用极限表示为：<br>$$<br>\lim_{n\rightarrow\infty}\frac{T(n)}{f(n)}&#x3D;C≠0，C为不等于0的常数<br>$$<br>如果用<strong>时间复杂度的渐近上界</strong>表示，如图1-1所示。</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830204543034.png" alt="image-20220830204543034"></p><p>从图1-1中可以看出，当n≥n0时，T(m)≤Cf(n)，当n足够大时，T(n)和f(n)近似相等。因此，我们用O(f(n))来表示时间复杂度渐近上界，通常用这种表示法衡量算法时间复杂度。算法1-3的时间复杂度渐近上界为O(f(n))&#x3D;O(n^2)，用极限表示为：<br>$$<br>\lim_{n\rightarrow\infty}\frac{T(n)}{f(n)}&#x3D;\frac{2n^2+3n+3}{n^2}&#x3D;2≠0<br>$$<br>还有<strong>渐近下界</strong>符号Ω(T(n)≥Cf(n))，如图1-2所示。</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830205123640.png" alt="image-20220830205123640"></p><p>从图1-2可以看出，当n≥n0时，T(n)≥Cf(n)，当n足够大时，T(n)和f(n)近似相等，因此，我们用Ω(f(n))来表示时间复杂度渐近下界。<br><strong>渐近精确界</strong>符号Θ(C1f(n)≤T(n)≤C2f(n))，如图1-3所示。</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830210210688.png" alt="image-20220830210210688"></p><p>从图1-3中可以看出，当n≥n0时，C1f(n)≤T(n)≤C2f(n)，当n足够大时，T(n)和f(n)近似相等。这种两边逼近的方式，更加精确近似，因此，用<br>Θ(f(n))来表示时间复杂度渐近精确界。<br>我们通常使用<strong>时间复杂度渐近上界</strong>O(f(n))来表示时间复杂度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//算法1-4</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//运行1次</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span><span class="token comment">//可假设运行x次</span><span class="token punctuation">&#123;</span>i<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//可假设运行x次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察算法1-4，无法立即确定while及i&#x3D;i*2运行了多少次。这时可假设运行了x次，每次运算后i值为2，2^2，2^3，…，2^x，当i&#x3D;n时结束，即2^x&#x3D;n时结束，则x&#x3D;log2(n)，那么算法1-4的运算次数为1+2log2(n)，时间复杂度渐近上界为O(f(n))&#x3D;O(log2(n))。</p><blockquote><p>注意：不是每个算法都能直接计算运行次数</p></blockquote><p>有些算法，如排序、查找、插入等算法，可以分为<strong>最好</strong>、<strong>最坏</strong>和<strong>平均</strong>情况分别求算法渐近复杂度，但我们考查一个算法通常考查最坏的情况，而不是考查最好的情况，<strong>最坏情况对衡量算法的好坏具有实际的意义</strong>。</p><h3 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h3><blockquote><p>算法占用的空间大小。一般将算法的<strong>辅助空间</strong>作为衡量空间复杂度的标准。</p></blockquote><p>空间复杂度的本意是指算法在运行过程中占用了多少存储空间。算法占用的存储空间包括：</p><ol><li>输入&#x2F;输出数据</li><li>算法本身</li><li>额外需要的辅助空间</li></ol><p>输入输出数据占用的空间是必需的，算法本身占用的空间可以通过精简算法来缩减，但这个压缩的量是很小的，可以忽略不计。而在运行时使用的辅助变量所占用的空间，即辅助空间是衡量空间复杂度的关键因素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//算法1-6</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token comment">//x与y交换</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp<span class="token punctuation">;</span>temp<span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token comment">//temp为辅助空间</span>x<span class="token operator">=</span>y<span class="token punctuation">;</span>y<span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法使用了一个辅助空间temp，空间复杂度为O(1)。</p><blockquote><p>注意：递归算法中，每一次递推需要一个栈空间来保存调用记录，因此，空间复杂度需要计算递归栈的辅助空间。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//算法1-7</span><span class="token function">fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n&lt;0 data error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">fac</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="斐波那契数列："><a href="#斐波那契数列：" class="headerlink" title="斐波那契数列："></a>斐波那契数列：</h2><p>根据斐波那契数列的定义，直接设计一个递归算法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Fib1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">Fib1</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">Fib1</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，n&gt;2时要分别调用Fib1(n-1)、Fib1(n-2)和执行一次加法运算，即：</p><p>n&gt;2时，T(n) &#x3D; T(n-1) + T(n-2) + 1;</p><p>递归表达式和时间复杂度T(n)之间的关系如下：</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830214752191.png" alt="image-20220830214752191"></p><p>由此可得：T(n)≥F(n)。</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830214934155.png" alt="image-20220830214934155"></p><p>由于T(n)≥F(n)，这是一个指数阶的算法！复杂度属于爆炸增量函数，这在算法设计时应当避开的，那么我们可以改进它呢？</p><p>既然斐波那契数列中的每一项是前两项之和，如果记录前两项的值，只需要一次加法运算就可以得到当前项，时间复杂度会不会更低一些？我们用数组试试看：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Fib2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，算法的时间复杂度为O(n)。时间复杂度却从<strong>指数阶降到了多项式阶</strong>，这是算法效率的一个巨大突破！</p><p>其实我们只需要得到第n个斐波那契数，中间结果只是为了下一次使用，根本不需要记录。因此我们采用<strong>迭代法</strong>进行算法设计：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Fib3</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>s1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>s2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>s2<span class="token operator">=</span>s1<span class="token operator">+</span>s2<span class="token punctuation">;</span><span class="token comment">//辗转相加法</span>s1<span class="token operator">=</span>s2<span class="token operator">-</span>s1<span class="token punctuation">;</span><span class="token comment">//记录前一项</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> s2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进一步讨论：我们能不能继续降阶，使算法时间复杂度更低呢？</p><p><strong>本文摘录于《趣学算法》一书，欲学习其他算法请购买正版书籍！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UESTC研究生选课</title>
      <link href="/2022/08/25/uestc-yan-jiu-sheng-xuan-ke/"/>
      <url>/2022/08/25/uestc-yan-jiu-sheng-xuan-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="选课"><a href="#选课" class="headerlink" title="选课"></a>选课</h2><h3 id="学位课-目前已选17分"><a href="#学位课-目前已选17分" class="headerlink" title="学位课 目前已选17分"></a>学位课 目前已选17分</h3><p>算法设计与分析（2班）–陈佳 2学分秋</p><p>随机过程与排队论（小班研讨）–顾小丰 2学分秋</p><p>工程伦理与学术道德（9班）–谢小东 1学分春与秋</p><p>新时代中国特色社会主义理论与实践（沙河二班）–曹银忠 2学分秋</p><p>图论及应用（15班）–王也洲 3学分春</p><p>网络计算模式（1班）–丁熠 2学分春</p><p>高级计算机结构（不要选吴晓华的）或选其他学位课</p><p>硕士研究生学位英语–庞慧 3学分春与秋</p><h3 id="非学位课-目前已选10分"><a href="#非学位课-目前已选10分" class="headerlink" title="非学位课 目前已选10分"></a>非学位课 目前已选10分</h3><p>Unix&#x2F;Linux操作系统内核结构（2班）–刘玓 2学分秋</p><p>网络安全理论与技术（2班）–李树全 2学分秋</p><p>网络编程–任立勇 2学分秋</p><p>高级数字图像处理–甘涛 2学分秋</p><p>研究生论文写作指导课程（2班）–李晓瑜 1学分春</p><p>自然辩证法概论（沙河4班）–不要选郭芙蕊 1学分春</p><h3 id="教学实践环节-目前已选6分"><a href="#教学实践环节-目前已选6分" class="headerlink" title="教学实践环节 目前已选6分"></a>教学实践环节 目前已选6分</h3><p>逆向工程–何兴高 2学分春</p><p>基地实践 4学分春与秋</p><h3 id="必修环节-目前已选5-5分"><a href="#必修环节-目前已选5-5分" class="headerlink" title="必修环节 目前已选5.5分"></a>必修环节 目前已选5.5分</h3><p>学术资源的使用与分析3班–曹学艳 1学分秋</p><p>教学实践或创新创业与社会实践 1学分春与秋</p><p>论文开题报告 1学分春与秋</p><p>论文中期报告 1学分春与秋</p><p>学术活动 1学分春与秋</p><p>上学期的课：</p><p><img src="/2022/08/25/uestc-yan-jiu-sheng-xuan-ke/image-20220825220711481.png" alt="image-20220825220711481"></p><p>下学期的课：</p><p><img src="/2022/08/25/uestc-yan-jiu-sheng-xuan-ke/image-20220825220804082.png" alt="image-20220825220804082"></p><h3 id="上学期已选学分："><a href="#上学期已选学分：" class="headerlink" title="上学期已选学分："></a>上学期已选学分：</h3><p>学位课：5分</p><p>非学位课：8分</p><p>必修环节：1分</p><p>实践教学环节：0分</p><h3 id="下学期应选学分："><a href="#下学期应选学分：" class="headerlink" title="下学期应选学分："></a>下学期应选学分：</h3><p>学位课：6分（学位英语3学分，新中特2学分）</p><ul><li>网络计算模式 2学分</li><li>图论及应用 3学分</li><li>软件架构模型与设计 2学分</li></ul><p>非学位课：1分</p><ul><li>研究生论文写作指导课程 1学分</li></ul><p>必修环节：4分</p><ul><li>教学实践或创新创业与社会实践 1学分</li><li>学术活动 1学分</li><li>论文开题报告 1学分</li><li>论文中期报告 1学分</li></ul><p>实践教学环节：6分</p><ul><li>基地实践 4学分</li><li>逆向工程 2学分</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硕士生涯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Vite快速建立一个Vue项目</title>
      <link href="/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/"/>
      <url>/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h3 id="使用Vite创建Vue项目："><a href="#使用Vite创建Vue项目：" class="headerlink" title="使用Vite创建Vue项目："></a>使用Vite创建Vue项目：</h3><ol><li><p>在全局安装好node.js环境的前提下，切换到你想要创建项目的目录下，终端输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> init vite@latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Vite在安装项目时不会主动安装依赖，所以需要手动安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动项目：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="Vite3-0更新内容："><a href="#Vite3-0更新内容：" class="headerlink" title="Vite3.0更新内容："></a>Vite3.0更新内容：</h3><p>2022年7月，Vite3.0版本正式发布，有以下更新内容：</p><ol><li><p><strong>CLI的更新</strong>：</p><p>在执行 vite 命令启动项目时，终端的界面和之前会有所不同，而更重要的是，为了避免 Vite 开发服务的端口和别的应用冲突，默认的端口号从之前的 3000 变成了 <strong>5173</strong>。</p></li><li><p><strong>开箱即用的 WebSocket 连接策略</strong>：</p><p>Vite 2 中有存在一个痛点，即在存在代理的情况下(比如 Web IDE)需要我们手动配置 WebSocket 使 HMR 生效。目前 Vite 内置了一套更加完善的 WebSocket 连接策略，自动满足更多场景的 HMR 需求。</p></li><li><p><strong>服务冷启动性能提升</strong>：</p><p>Vite 3.0 在服务冷启动方面做了非常多的工作，来最大程度提升项目启动的速度。</p><p>首先我们来盘点一下 Vite 2.x 阶段服务冷启动的一些问题。</p><p>从 Vite 2.0 到 2.9 版本之前，Vite 会在服务启动之前进行依赖预构建，也就是使用 Esbuild 将项目中使用到的依赖扫描出来(Scan)，然后分别进行一次打包(Optimize)。</p><p><img src="/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/c3cfb6a684fa99a5c3041509de0efe32d14316.png"></p><p>这样会造成两个问题：</p><blockquote><ul><li>依赖预构建会阻塞 Dev Server 启动，但其实不阻塞的情况下，Dev Server 也可以正常启动。</li><li>当某些 Vite 插件手动注入了 import 语句，比如调用babel-plugin-import 添加import Button from ‘antd&#x2F;lib&#x2F;button’，就会导致 Vite 的二次预构建，因为antd&#x2F;lib&#x2F;button 的引入代码由 Vite 插件注入，属于 Dev Server 运行时发现的依赖，冷启动阶段无法扫描到。</li></ul></blockquote><p>所谓的二次预构建包含两个步骤，一是需要将所有的依赖全量预构建，二是由于依赖更新，页面需要进行 reload，加载最新的依赖代码。这样会导致 Dev Server 性能明显下降，尤其是在新增依赖较多的场景下，很容易出现浏览器卡住的情况。因此二次预构建也是需要极力避免的。当时 vite-plugin-optimize-persist就是为了解决二次预构建带来的问题，通过持久化的方式记录 Dev Server 运行时扫描到的依赖，从而让首次预构建便可以感知到，避免二次预构建的发生。</p><p>到了 2.9 版本，Vite 将预构建的逻辑做了一次整体的重构，最后的效果是下面这样的：</p><ul><li><p>Dev Server 启动后预构建(Optimize 阶段)在后台执行，也就是预构建不再阻塞 Dev Server 的启动，只需要等待 Scan 阶段完成，不过通常这个阶段的开销非常小。</p><p><img src="/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/321e2ec83707448c7ff3914fd6007c66cec4bc.png"></p></li><li><p>如果某些依赖是 Dev Server 运行时才发现的，那么 Vite 会尽可能地复用已有预构建产物，尽量不进行 page reload。</p></li></ul><p>那问题就完全解决了吗？其实并不是，在某些场景下，Vite 仍然不可避免地需要二次预构建。如下面的这个例子：</p><p><img src="/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/b8775ee25f447b0377145799ba9b0d9b29fbdd.png"></p><p>A 和 B 都是项目的第三方依赖，它们也同时依赖 C。那么当 Vite 预构建 A 的时候，将会 A 和 C 一起进行打包。但 Vite 在运行时发现了依赖 B，而 A 和 B 需要共享 C 的代码，这样 C 的代码可能就会被抽离成一个公共的 chunk，因此之前 A 的预构建产物可能就发生变化了，那么此时 Vite 必须要强制刷新页面，让浏览器使用最新的预构建产物。这仍然是一个二次预构建(所有依赖再次打包 + page reload)的过程。</p><p>总体而言，2.9 版本解决了预构建阻塞服务启动的问题，但并没有完全解决二次预构建的问题。</p><p>但在 Vite 3.0，二次预构建的问题也得到了根本的解决。那 Vite 3.0 是如何做到的呢？</p><p>核心的解决思路在于<strong>延迟处理</strong>，<strong>即把预构建的行为延迟到页面加载的最后阶段进行</strong>，此时 Vite 已经编译完了所有的源文件，可以准确地记录下所有需要预构建的依赖(包括 Vite 插件添加的一些依赖)，然后统一进行预构建，将预构建的产物响应给给浏览器即可。</p><p>因此，与 Vite 2.0 相比，Vite 3.0 在冷启动阶段所做的优化主要有两个方面：</p><blockquote><ul><li>预构建不再阻塞 Dev Server 的启动，真正做到服务秒启动的效果。</li><li>从根本上防止二次预构建的发生。</li></ul></blockquote></li><li><p><strong>import.meta.glob 语法更新</strong>：</p><ol><li><p>Vite 3.0 中重写对 import.meta.glob 的实现进行了重写，支持了更加灵活的 glob 语法，增加了如下的一些特性：</p><ul><li>多种模式匹配：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token string">"./another/*.js"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>否定模式(!)：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token string">"!**/bar.js"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>命名导入，可以更好地做到 Tree Shaking：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token keyword">import</span><span class="token operator">:</span> <span class="token string">"setup"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>自定义 query 参数：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">custom</span><span class="token operator">:</span> <span class="token string">"data"</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指定 eager 模式，替换掉原来import.meta.globEager：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">eager</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p><strong>SSR 产物默认使用 ESM 格式</strong>：</p><p>在当下的社区生态中，众多 SSR 框架已经在使用 ESM 格式作为默认的产物格式。Vite 3.0 也积极拥抱社区，支持 SSR 构建默认打包出 ESM 格式的产物。</p></li><li><p><strong>Relative Base 支持</strong>：</p><p>Vite 3.0 正式支持 Relative Base(即配置base: ‘’)，主要用于构建时无法确定 base 地址的场景。</p></li><li><p><strong>更细粒度的 base 配置</strong>：</p><p>在某些场景下，我们需要将不同的资源部署到不同的 CDN 上，比如将图片部署到单独的 CDN，和 JS&#x2F;CSS 的部署服务区分开来。但 2.x 的版本仅支持统一的部署域名，即base 配置。在 3.0 中，你可以通过 renderBuiltUrl 进行更细粒度的配置：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token literal-property property">experimental</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">renderBuiltUrl</span><span class="token operator">:</span> <span class="token punctuation">(</span>filename<span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">hostType</span><span class="token operator">:</span> <span class="token string">'js'</span> <span class="token operator">|</span> <span class="token string">'css'</span> <span class="token operator">|</span> <span class="token string">'html'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>hostType <span class="token operator">===</span> <span class="token string">'js'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">runtime</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">window.__toCdnUrl(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'https://cdn.domain.com/assets/'</span> <span class="token operator">+</span> filename      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//目前该配置项还不稳定 ，可能会在之后的 minor 版本修改。具体文档见 https://vitejs.dev/guide/build.html#advanced-base-options</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Esbuild 预构建用于生产环境</strong>：</p><p>这应该是 Vite 架构上非常大的一个改动: 将原来仅仅用于开发阶段的依赖预构建功能应用在生产环境。在 Vite 2.x 中，开发阶段使用 Esbuild 来打包依赖，而在生产环境使用 Rollup 进行打包，用 @rollupjs&#x2F;plugin-commonjs 来处理 cjs 的依赖，这样做会导致依赖处理的不一致问题，造成一些生产构建中的 bug。</p><p>但 Vite 3.0 中支持通过配置将 Esbulid 预构建同时用于开发环境和生产环境，仅添加optimizeDeps.disabled: false 的配置即可。不过这个改动确实比较大，Vite 团队不打算将此作为 v3 的正式更新内容，而是一个实验性质的功能，不会默认开启。</p><p>顺便提一句，Rollup 将在接下来的几个月发布 v3 的大版本，要知道，Rollup 2.0 发布至今已经过去 2 年多的时间了，无论是 Rollup 还是 Vite 来讲，这都是一次非常重大的变更。由于 Vite 的架构非常依赖 Rollup，在 Rollup 发布 v3 之后，Vite 也将跟随着发布 Vite 的第 4 个 major 版本。所以，Vite 4.0 的到来也不远啦：）</p></li><li><p><strong>仓库内部的变化</strong>：</p><p>除了本身功能上的演进，Vite 的仓库本身也产生了不少的变化，从中我们也能了解到社区的一些动向:</p><ul><li>不再支持 Nodejs 12，需要 Node.js 14.18+ 的版本。</li><li>单元测试和 E2E 测试从 Jest 完全迁移到 Vitest，一方面 Vitest 更快、体验更好，另一方面也能在 Vite 这样大型的仓库完善 Vitest 的生态，进一步提升 Vitest 稳定性。</li><li>VitePress 文档部分也参与 CI 流程。</li><li>包管理器 pnpm 迁移至 v7。</li><li>不管是Vite 本身的包还是 E2E 中测试的项目，都在 package.json 中声明type: “module”，即 Pure ESM 包，对外提供 ESM 格式的产物，将社区 Pure ESM 的趋势又推动了一步。</li><li>官方所有的 Vite 插件都采用unbuild(新一代库构建工具) 进行构建，pluin-vue-jsx 和plugin-legacy 均迁移到了 TS 上。</li><li>包体积优化。3.0 进一步优化 Vite 本身的产物和 node_modules 体积，将terser 和node-forge 的依赖移除，让用户进行按需安装(node-forge 的功能是实现 https 证书生成，可用@vitejs&#x2F;plugin-basic-ssl 插件替代)，效果如下：</li></ul><table><thead><tr><th></th><th>Publish Size</th><th>Install Size</th></tr></thead><tbody><tr><td>Vite 2.9.14</td><td>4.38MB</td><td>19.1MB</td></tr><tr><td>Vite 3.0.0</td><td>3.05MB</td><td>17.8MB</td></tr><tr><td>Reduction</td><td>-30%</td><td>-7%</td></tr></tbody></table><p>不得不说在自身包体积的优化方面， Vite 对于还是做的很细致的，这也是很多库开发者忽视的一点，有时候加个插件就得安装动辄上百 MB 的依赖，导致项目的 node_modules 最后变得非常臃肿，此时不妨学习一下 Vite 是怎么优化自身体积的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Vue中的组件知识</title>
      <link href="/2022/08/19/guan-yu-vue-zhong-de-zu-jian-zhi-shi/"/>
      <url>/2022/08/19/guan-yu-vue-zhong-de-zu-jian-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="创建组件的注意事项："><a href="#创建组件的注意事项：" class="headerlink" title="创建组件的注意事项："></a>创建组件的注意事项：</h3><blockquote><p>在HTML模板中使用组件时，首字母大写的形式只能在template配置项中的HTML代码中使用，或者在单文件组件的HTML中使用。</p><p>如果在像index.html这种纯html文件中使用组件时，必须使用<strong>小写单词+短横线</strong>的形式。</p><p>定义名字的时候尽量使用两个或以上的单词，避免和原生的HTML标签名冲突。</p><p>组件数据的流向设计：<strong>属性向下，事件向上</strong>，即父组件只能向子组件传递数据，子组件不能修改父组件的属性，父组件也不能访问子组件中的属性，子组件可通过事件触发父组件中的事件。</p></blockquote><h3 id="props："><a href="#props：" class="headerlink" title="props："></a>props：</h3><blockquote><p>组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。父组件的数据需要通过 prop 才能下发到子组件中。也就是<code>props</code>是<strong>子组件访问父组件数据的唯一接口</strong>。</p><ul><li>单向数据流</li><li>父组件属性变化，子组件自动刷新</li><li>子组件不能直接修改父组件属性</li></ul></blockquote><p>你可以基于对象的语法使用以下选项：</p><ul><li><code>type</code>: 可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的<a href="vue/guide/components-props.html#Prop-%E7%B1%BB%E5%9E%8B">更多信息在此</a>。</li><li><code>default</code>: <code>any</code><br>为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。</li><li><code>required</code>: <code>Boolean</code><br>定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。</li><li><code>validator</code>: <code>Function</code><br>自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在<a href="vue/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81">这里</a>查阅更多 prop 验证的相关信息。</li></ul><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"sender"</span><span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"time"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>     <span class="token literal-property property">isStudent</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>         <span class="token literal-property property">type</span><span class="token operator">:</span>Boolean<span class="token punctuation">,</span>         <span class="token keyword">default</span><span class="token operator">:</span><span class="token boolean">true</span> <span class="token comment">// 可声明默认值</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 不同类型的数据，注意默认值的返回类型</span><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">type</span><span class="token operator">:</span> Object<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">"abc"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">followers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">type</span><span class="token operator">:</span> Array<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 即使是空数组，也需要从函数中返回</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">handleClick</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">type</span><span class="token operator">:</span> Function<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"点击事件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>   <span class="token literal-property property">time</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>     <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>     <span class="token comment">// 可以在props中校验数据</span>     <span class="token function">validator</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> value <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token literal-property property">sender</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>     <span class="token literal-property property">type</span><span class="token operator">:</span> String<span class="token punctuation">,</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>     <span class="token literal-property property">type</span><span class="token operator">:</span> String<span class="token punctuation">,</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父组件中，首先需要引入组件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageItem <span class="token keyword">from</span> <span class="token string">"./components/MessageItem.vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    MessageItem  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>向子组件传值：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> <span class="token comment">&lt;!-- 使用v-bind才可以传送数据本身的属性值 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageItem</span>  <span class="token attr-name">:user</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>&#123;haha:222&#125;</span> <span class="token attr-name">:time</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>2022</span> <span class="token attr-name">sender</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>q<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageItem</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="emit："><a href="#emit：" class="headerlink" title="emit："></a>emit：</h3><blockquote><p>子组件可以使用 $emit <strong>触发父组件的自定义事件</strong>。</p><p>Vue虽然也支持通过props向父组件传递数据，但如此做子组件就会<strong>依赖</strong>父组件，即如果父组件没有传递参数，且子组件的事件处理函数也没有默认值，那么子组件调用事件处理函数就会报出异常；而使用emit事件传递则没有这个问题，如果父组件不处理子组件的事件也没有任何问题，因为子组件不依赖父组件的事件监听。</p></blockquote><ul><li><p>参数</p><ul><li><code>&#123;string&#125; eventName</code></li><li><code>[...args]</code></li></ul><p>触发当前实例上的事件。附加参数都会传给监听器回调。</p></li><li><p>示例</p><p>在子组件中，定义emits数组以及触发事件，可添加多个参数：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"deletePosts"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>deletePosts<span class="token punctuation">'</span>, 5)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可自定义方法，例如：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPosts(5)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token function">selectPosts</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"deletePosts"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// selectPosts事件触发后，自动触发deletePosts事件</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父组件中，首先需要引入组件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageItem <span class="token keyword">from</span> <span class="token string">"./components/MessageItem.vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    MessageItem  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件触发方法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageItem</span>  <span class="token attr-name">@deletePosts</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>handleDeletePosts<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageItem</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageItem <span class="token keyword">from</span> <span class="token string">"./components/MessageItem.vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    MessageItem  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token function">handleDeletePosts</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="provide和inject："><a href="#provide和inject：" class="headerlink" title="provide和inject："></a>provide和inject：</h3><blockquote><p>在实际开发中，可能需要传递数据到更深层次的组件，例如子组件的子组件，即使中间的组件没有用到这个属性也要层层传递。</p></blockquote><p>Vue中提供了<code>provide</code>配置项来向<strong>所有下层组件</strong>传递数据，而用到数据的组件可以使用<code>inject</code>配置项来获取数据：</p><ul><li><strong>类型</strong>：<ul><li><strong>provide</strong>：<code>Object | () =&gt; Object</code></li><li><strong>inject</strong>：<code>Array&lt;string&gt; | &#123; [key: string]: string | Symbol | Object &#125;</code></li></ul></li></ul><p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</p><p><code>provide</code> 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 <code>Symbol</code> 和 <code>Reflect.ownKeys</code> 的环境下可工作。</p><p><code>inject</code> 选项应该是：</p><ul><li>一个字符串数组，或</li><li>一个对象，对象的 key 是本地的绑定名，value 是：<ul><li>在可用的注入内容中搜索用的 key (字符串或 Symbol)，或</li><li>一个对象，该对象的：<ul><li><code>from</code> 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)</li><li><code>default</code> 属性是降级情况下使用的 value</li></ul></li></ul></li></ul><blockquote><p>注意：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote><ul><li><p>示例：</p><p>MovieCard.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieItem</span>      <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>movie.title<span class="token punctuation">"</span></span>      <span class="token attr-name">:description</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>movie.description<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieItem <span class="token keyword">from</span> <span class="token string">"./MovieItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MovieItem<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">movie</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"电影"</span><span class="token punctuation">,</span>        <span class="token literal-property property">description</span><span class="token operator">:</span> <span class="token string">"这是一段电影的描述"</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.card</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MovieItem.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieTitle</span> <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    &#123;&#123; description &#125;&#125;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieTitle <span class="token keyword">from</span> <span class="token string">"./MovieTitle.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MovieTitle <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"title"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.description</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 10%<span class="token punctuation">,</span> 88%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MovieTitle.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"title"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">h2</span> <span class="token punctuation">&#123;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出组件的层级关系，中间组件尽管没有使用到title属性，但仍需要将其加入到props配置项中，向下传递到MovieTitle.vue文件中。若使用<code>provide</code>和<code>inject</code>配置项，则简洁很多：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- &lt;MovieItem :title="movie.title" :description="movie.description" /> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieItem</span> <span class="token attr-name">:description</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>movie.description<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieItem <span class="token keyword">from</span> <span class="token string">"./MovieItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MovieItem<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">movie</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"电影"</span><span class="token punctuation">,</span>        <span class="token literal-property property">description</span><span class="token operator">:</span> <span class="token string">"这是一段电影的描述"</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">provide</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"测试电影"</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.card</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- &lt;MovieTitle :title="title" /> --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieTitle</span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    &#123;&#123; description &#125;&#125;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieTitle <span class="token keyword">from</span> <span class="token string">"./MovieTitle.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MovieTitle <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// props: ["title", "description"],</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"description"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.description</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 10%<span class="token punctuation">,</span> 88%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// props: ["title"],</span>  <span class="token literal-property property">inject</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"title"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">h2</span> <span class="token punctuation">&#123;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但如此做<code>provide</code>中的title属性没有与data中的title属性相对应，若修改为以下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">provide</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>movie<span class="token punctuation">.</span>title<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则会报错：</p><p><img src="/2022/08/19/guan-yu-vue-zhong-de-zu-jian-zhi-shi/image-20220819210345147.png" alt="image-20220819210345147"></p><p>原因是如果需要<code>provide</code>提供data中的属性，则需要将<code>provide</code>写为一个函数，类似data中的形式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>movie<span class="token punctuation">.</span>title<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="如何修改子组件中的样式："><a href="#如何修改子组件中的样式：" class="headerlink" title="如何修改子组件中的样式："></a>如何修改子组件中的样式：</h3><p>对于子组件中的根元素，可通过普通CSS样式书写格式进行修改，若想为子组件中除根元素以外的元素，则需要使用<code>deep</code>选择器：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.text :deep(a)</span> <span class="token punctuation">&#123;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>0deg<span class="token punctuation">,</span> 80%<span class="token punctuation">,</span> 70%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ref："><a href="#ref：" class="headerlink" title="ref："></a>ref：</h3><p>Vue提供了一种机制，可以获取到组件的实例并访问其中的属性，即为<code>ref</code>。使用<code>ref</code>可以访问到原生的HTML的DOM实例，也可以获取Vue组件的实例，但会破坏数据的流向，所以万不得已的时候最好不要使用。</p><p>在子组件中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inputText<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inputControl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">inputText</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inputControl<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inputControl<span class="token punctuation">.</span><span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">input</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 8px 14px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 30%<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父组件中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AutoFocus</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>autofocus<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> AutoFocus <span class="token keyword">from</span> <span class="token string">"./components/AutoFocus.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    AutoFocus<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>autofocus<span class="token punctuation">.</span>inputText<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>autofocus<span class="token punctuation">.</span><span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> <span class="token string">"PingFang SC"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Yahei"</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">body</span> <span class="token punctuation">&#123;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #0f141c<span class="token punctuation">;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">radial-gradient</span><span class="token punctuation">(</span>    #212943 0.6000000000000001px<span class="token punctuation">,</span>    #0f141c 0.6000000000000001px  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-size</span><span class="token punctuation">:</span> 12px 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#app</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="让组件支持v-model指令："><a href="#让组件支持v-model指令：" class="headerlink" title="让组件支持v-model指令："></a>让组件支持v-model指令：</h3><p>示例：</p><p>子组件SearchInput.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>搜索：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">input</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 8px 14px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 30%<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SearchInput</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchTerm<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>&#123;&#123;searchTerm&#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> SearchInput <span class="token keyword">from</span> <span class="token string">"./components/SearchInput.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    SearchInput<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">SearchTerm</span><span class="token operator">:</span> <span class="token string">""</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> <span class="token string">"PingFang SC"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Yahei"</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">body</span> <span class="token punctuation">&#123;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #0f141c<span class="token punctuation">;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">radial-gradient</span><span class="token punctuation">(</span>    #212943 0.6000000000000001px<span class="token punctuation">,</span>    #0f141c 0.6000000000000001px  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-size</span><span class="token punctuation">:</span> 12px 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#app</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">p</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时v-model并不能生效，需要在子组件中添加属性：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span>    <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>搜索：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span>    <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>      <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>      <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>modelValue<span class="token punctuation">"</span></span>      <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>update:modelValue<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"modelValue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"update:modelValue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">input</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 8px 14px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 30%<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若需要多个v-model，添加更多属性，并加以区分：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span>    <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>搜索：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span>    <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>      <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>      <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchTerm<span class="token punctuation">"</span></span>      <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>update:searchTerm<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>类别：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span>      <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span>      <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>update:category<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>    <span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>default<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>默认<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fontend<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>backend<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>后端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fullstack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>全栈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"searchTerm"</span><span class="token punctuation">,</span> <span class="token string">"category"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"update:searchTerm"</span><span class="token punctuation">,</span> <span class="token string">"update:category"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">label</span> <span class="token punctuation">&#123;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">input</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 8px 14px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 30%<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">select</span> <span class="token punctuation">&#123;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 6px<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!-- v-model 后面的参数必须和子组件接收的属性名相同，例如 searchTerm --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SearchInput</span>        <span class="token attr-name"><span class="token namespace">v-model:</span>searchTerm</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchTerm<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">v-model:</span>category</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span>      <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>splitLine<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>搜索词：&#123;&#123; searchTerm &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>类别：&#123;&#123; category &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> SearchInput <span class="token keyword">from</span> <span class="token string">"./components/SearchInput.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    SearchInput<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 名字无需和 SearchInput 中的属性名相同</span>      <span class="token comment">// 例如这里可以叫 searchQuery，</span>      <span class="token literal-property property">searchTerm</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>      <span class="token literal-property property">category</span><span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> <span class="token string">"PingFang SC"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Yahei"</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">body</span> <span class="token punctuation">&#123;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #0f141c<span class="token punctuation">;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">radial-gradient</span><span class="token punctuation">(</span>    #212943 0.6000000000000001px<span class="token punctuation">,</span>    #0f141c 0.6000000000000001px  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-size</span><span class="token punctuation">:</span> 12px 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#app</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.splitLine</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 1px<span class="token punctuation">;</span>  <span class="token property">border-bottom</span><span class="token punctuation">:</span> 1px dashed <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">p</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>50deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用动态组件渲染不同的HTML标签："><a href="#使用动态组件渲染不同的HTML标签：" class="headerlink" title="使用动态组件渲染不同的HTML标签："></a>使用动态组件渲染不同的HTML标签：</h3><blockquote><p>使用<code>:is</code>+HTML标签（可能需要用到计算属性）</p></blockquote><p>父组件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!-- 动态 HTML 元素  --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>三级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>四级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>五级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>六级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> TextHeading <span class="token keyword">from</span> <span class="token string">"./components/TextHeading.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    TextHeading<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>子组件TextHeading.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>heading<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Component</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"level"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">heading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">h</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>level<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">h1</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 3em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h2</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 2.4em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h3</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 1.8em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h4</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 1.4em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h5</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 1.2em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h6</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 1em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用动态组件渲染不同的Vue组件："><a href="#使用动态组件渲染不同的Vue组件：" class="headerlink" title="使用动态组件渲染不同的Vue组件："></a>使用动态组件渲染不同的Vue组件：</h3><blockquote><p>使用<code>:is</code>+组件名称</p></blockquote><p>例如此功能实现两个表单组件的切换：</p><p>登录表单文件ProfileForm.vue：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">@submit.prevent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>昵称：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>生日：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>date<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>地址：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">::-webkit-calendar-picker-indicator</span> <span class="token punctuation">&#123;</span>  <span class="token property">filter</span><span class="token punctuation">:</span> <span class="token function">invert</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注册表单文件RegisterForm.vue：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">@submit.prevent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>手机号：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span>      <span class="token punctuation">></span></span>验证码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sendSMSCodeBtn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        发送验证码      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span>    <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.sendSMSCodeBtn</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 24px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>buttons<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span>          <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm === <span class="token punctuation">'</span>RegisterForm<span class="token punctuation">'</span><span class="token punctuation">"</span></span>          <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm = <span class="token punctuation">'</span>ProfileForm<span class="token punctuation">'</span><span class="token punctuation">"</span></span>        <span class="token punctuation">></span></span>          下一步        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm === <span class="token punctuation">'</span>ProfileForm<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm = <span class="token punctuation">'</span>RegisterForm<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            上一步          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>完成<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> RegisterForm <span class="token keyword">from</span> <span class="token string">"./components/RegisterForm.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> ProfileForm <span class="token keyword">from</span> <span class="token string">"./components/ProfileForm.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    RegisterForm<span class="token punctuation">,</span>    ProfileForm<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">currentForm</span><span class="token operator">:</span> <span class="token string">"RegisterForm"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，如果仅使用这种方法切换表单，会导致表单数据缺失，原因是因为使用动态组件每次切换组件时，都会创建新的组件实例。</p></blockquote><p>改进：</p><blockquote><p>在<code>Component</code>标签外绑定<code>KeepAlive</code>标签</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 动态组件默认每次渲染都会重新创建，数据会丢失，使用 &lt;KeepAlive>&lt;/KeepAlive> 组件可以缓存组件，避免数据丢失 --></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>KeepAlive</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>KeepAlive</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组件传送"><a href="#组件传送" class="headerlink" title="组件传送"></a>组件传送</h3><h4 id="在其他DOM元素挂载组件："><a href="#在其他DOM元素挂载组件：" class="headerlink" title="在其他DOM元素挂载组件："></a>在其他DOM元素挂载组件：</h4><blockquote><p>某些组件可能在逻辑上不属于任何父组件，例如页面边缘的提示框，它们会根据<code>body</code>元素进行绝对定位。如果我们将它们放在某个父组件中，那么它们的位置就会限制于父组件容器内。</p></blockquote><blockquote><p>Vue提供了<code>teleport</code>属性，可以让子组件挂载在其他页面元素上。</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Teleport</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>body<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>show<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alertBox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>closeIcon<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>show = false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>X<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span>消息提示框组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Teleport</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多次传送组件："><a href="#多次传送组件：" class="headerlink" title="多次传送组件："></a>多次传送组件：</h4><p>如果一个组件多次传送到相同的页面下，那么传送的顺序会追加到页面中，例如要弹出多个消息提示框：</p><p>在index.html文件中添加：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>icon<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/favicon.ico<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Vite App<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!-- 添加messages --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>messages<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/src/main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父组件App.vue文件中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msgs.push(`这是一段消息$&#123;msgs.length + 1&#125;`)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        添加消息      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AlertBox</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in msgs<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AlertBox</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> AlertBox <span class="token keyword">from</span> <span class="token string">"./components/AlertBox.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    AlertBox<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">msgs</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> <span class="token string">"PingFang SC"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Yahei"</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">body</span> <span class="token punctuation">&#123;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #0f141c<span class="token punctuation">;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">radial-gradient</span><span class="token punctuation">(</span>    #212943 0.6000000000000001px<span class="token punctuation">,</span>    #0f141c 0.6000000000000001px  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-size</span><span class="token punctuation">:</span> 12px 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#app</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">button</span> <span class="token punctuation">&#123;</span>  <span class="token property">border</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>    90deg<span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 12px 18px<span class="token punctuation">;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.container</span> <span class="token punctuation">&#123;</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token comment">/* border: 1px solid hsl(280deg, 100%, 50%); */</span><span class="token punctuation">&#125;</span><span class="token comment">/*注意此处布局*/</span><span class="token selector">#messages</span> <span class="token punctuation">&#123;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column-reverse<span class="token punctuation">;</span>  <span class="token property">gap</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>   <span class="token comment">&lt;!-- 此处改为#messages --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Teleport</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#messages<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>show<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alertBox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>closeIcon<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>show = false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>X<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span>消息提示框组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Teleport</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//可添加计时器，3s后关闭提示框</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.alertBox</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 350px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 80px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 24px<span class="token punctuation">;</span>  <span class="token comment">/* position: absolute;  right: 12px;  bottom: 12px; */</span>  <span class="token comment">/*改为相对定位，因为关闭按钮在其中*/</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.content</span> <span class="token punctuation">&#123;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.closeIcon</span> <span class="token punctuation">&#123;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">font-weight</span><span class="token punctuation">:</span> 900<span class="token punctuation">;</span>  <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Mixins："><a href="#Mixins：" class="headerlink" title="Mixins："></a>Mixins：</h3><h4 id="组件配置的复用："><a href="#组件配置的复用：" class="headerlink" title="组件配置的复用："></a>组件配置的复用：</h4><blockquote><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。（现在不推荐使用此种方法进行组件复用）</p></blockquote><p>例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义一个混入对象</span><span class="token keyword">var</span> myMixin <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">hello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello from mixin!'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义一个使用混入对象的组件</span><span class="token keyword">var</span> Component <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span>myMixin<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">var</span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// => "hello from mixin!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="共同属性的覆盖与合并："><a href="#共同属性的覆盖与合并：" class="headerlink" title="共同属性的覆盖与合并："></a>共同属性的覆盖与合并：</h4><ul><li><code>data</code>函数：Mixins中的<code>data</code>属性会与组件中的data属性进行<strong>合并</strong>，<strong>如果有同名的属性，组件自身的属性会覆盖Mixins中的属性</strong>。</li><li><code>computed</code>，<code>methods</code>，<code>components</code>，<code>props</code>等这些值为数组或对象，同data函数中的合并覆盖规则。</li><li>如果是<strong>生命周期钩子</strong>，Mixins和组件中的<strong>都会执行</strong>，<strong>Mixins中的先执行</strong>，<strong>组件中的后执行</strong>。</li></ul><h4 id="全局注册："><a href="#全局注册：" class="headerlink" title="全局注册："></a>全局注册：</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createApp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">"./App.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> PaginationMixin <span class="token keyword">from</span> <span class="token string">"./mixins/PaginationMixin"</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span>PaginationMixin<span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">siteTitle</span><span class="token operator">:</span> <span class="token string">"我的 Vue 应用"</span><span class="token punctuation">,</span>  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">siteTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>siteTitle<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>        &#123;&#123; siteTitle &#125;&#125;      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PaginationComponent</span>        <span class="token attr-name">:totalPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>totalPage<span class="token punctuation">"</span></span>        <span class="token attr-name">:defaultCurrentPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentPage<span class="token punctuation">"</span></span>      <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PaginationComponent2</span>        <span class="token attr-name">:totalPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>totalPage<span class="token punctuation">"</span></span>        <span class="token attr-name">:defaultCurrentPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentPage<span class="token punctuation">"</span></span>      <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BaseButton</span> <span class="token attr-name">:defaultCurrentPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentPage<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> BaseButton <span class="token keyword">from</span> <span class="token string">"./components/BaseButton.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> PaginationComponent <span class="token keyword">from</span> <span class="token string">"./components/PaginationComponent.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> PaginationComponent2 <span class="token keyword">from</span> <span class="token string">"./components/PaginationComponent2.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">siteTitle</span><span class="token operator">:</span> <span class="token string">"Mixin 全局注册"</span><span class="token punctuation">,</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    PaginationComponent<span class="token punctuation">,</span>    PaginationComponent2<span class="token punctuation">,</span>    BaseButton<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">totalPage</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>      <span class="token literal-property property">currentPage</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Mixins也存在局限性，例如命名易冲突，各代码之间的逻辑功能也不能复用。</p></blockquote><h3 id="异步组件加载："><a href="#异步组件加载：" class="headerlink" title="异步组件加载："></a>异步组件加载：</h3><p>对于大型项目，一次性加载所有组件会影响页面的首次打开速度。正确方法应该是根据用户的操作与导航，加载相应的组件。</p><blockquote><p><code>defineAsyncComponent</code>：接收一个回调函数作为参数，可用于异步加载组件。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> defineAsyncComponent <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> ProductPage <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"./components/ProductPage.vue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组件错误处理："><a href="#组件错误处理：" class="headerlink" title="组件错误处理："></a>组件错误处理：</h3><h4 id="全局错误处理："><a href="#全局错误处理：" class="headerlink" title="全局错误处理："></a>全局错误处理：</h4><p><code>errorHandler</code>：</p><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>默认值</strong>：<code>undefined</code></p></li><li><p><strong>用法</strong>：</p><pre class="line-numbers language-none"><code class="language-none">Vue.config.errorHandler &#x3D; function (err, vm, info) &#123;  &#x2F;&#x2F; handle error  &#x2F;&#x2F; &#96;info&#96; 是 Vue 特定的错误信息，比如错误所在的生命周期钩子  &#x2F;&#x2F; 只在 2.2.0+ 可用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p><blockquote><p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p></blockquote><blockquote><p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p></blockquote><blockquote><p>从 2.6.0 起，这个钩子也会捕获 <code>v-on</code> DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。</p></blockquote><blockquote><p>错误追踪服务 <a href="https://sentry.io/">Sentry</a> 和 <a href="https://docs.bugsnag.com/platforms/browsers/vue/">Bugsnag</a> 都通过此选项提供了官方支持。</p></blockquote></li></ul><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createApp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">"./App.vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">errorHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="错误边界："><a href="#错误边界：" class="headerlink" title="错误边界："></a>错误边界：</h4><blockquote><p>如果某个Vue组件提供了错误处理能力，那么它就被称为错误边界。Vue组件会以事件冒泡方式向父组件传递错误信息，只有当父组件处理了错误并手动停止了错误的传播，错误才不会继续向上传递，这样这个子组件所有的子组件发生的错误都会交给他进行处理。</p></blockquote><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>error<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>啊哦，我是错误的顶级组件了！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!-- &lt;AppList v-else :data="data" /> --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AppList</span> <span class="token attr-name">:data</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>data<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AppButton</span><span class="token punctuation">></span></span>测试按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AppButton</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> AppList <span class="token keyword">from</span> <span class="token string">"./components/AppList.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> AppButton <span class="token keyword">from</span> <span class="token string">"./components/AppButton.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    AppList<span class="token punctuation">,</span>    AppButton<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token literal-property property">error</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">errorCaptured</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">// 停止错误向上传播</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费利用云资源训练模型教程</title>
      <link href="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/"/>
      <url>/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="谷歌在线训练模型的流程："><a href="#谷歌在线训练模型的流程：" class="headerlink" title="谷歌在线训练模型的流程："></a>谷歌在线训练模型的流程：</h3><blockquote><p>如果本地训练模型，会长时间占用自己显卡的显存，而且显卡的显存大小很大程度上影响训练的时间，谷歌提供免费的云端GPU，有足足16G的显存可以用来训练数据集。</p><p>由于是免费资源，所以训练的持续时间不能太长从而占用公共资源，如果是需要训练几天的大型数据，本教程不再适用。</p></blockquote><h4 id="1-注册Google-Drive云盘"><a href="#1-注册Google-Drive云盘" class="headerlink" title="1.注册Google Drive云盘"></a>1.注册Google Drive云盘</h4><blockquote><p>目的是为了之后将云盘中的文件挂载到Colaboratory上，防止文件丢失。</p><p>官网地址：<a href="https://drive.google.com/">https://drive.google.com</a></p></blockquote><p>新建一个文件夹，将训练所需的准备文件放置在此文件夹中。</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726103637723.png" alt="image-20220726103637723"></p><h4 id="2-从云盘连接到Colaboratory"><a href="#2-从云盘连接到Colaboratory" class="headerlink" title="2.从云盘连接到Colaboratory"></a>2.从云盘连接到Colaboratory</h4><p>点击右上角新建一个Google Colaboratory，如果没有该选项，则需要点击<strong>连接更多应用程式</strong>进行安装：</p><img src="image-20220726104004419.png" alt="image-20220726104004419" style="zoom:50%;" /><p>创建好后，进入下面的页面：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726104147163.png" alt="image-20220726104147163"></p><p>默认是使用CPU的资源，需要更改为使用GPU的资源。点击菜单栏中的<strong>修改</strong>按钮，再点击<strong>笔记本设置</strong>，更改为使用GPU资源：</p><img src="image-20220726104256034.png" alt="image-20220726104256034" style="zoom:50%;" /><p>点击右上角<strong>连接</strong>按钮，选择<strong>连接到托管代码执行程序</strong>，这样就连接上云盘了：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726104410455.png" alt="image-20220726104410455"></p><h4 id="3-准备工作："><a href="#3-准备工作：" class="headerlink" title="3.准备工作："></a>3.准备工作：</h4><p>查看当前GPU情况，16G的显存，已经算很好的配置了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span>nvidia-smi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220526204800113.png" alt="image-20220526204800113"></p><p>脚本定义挂载网盘并执行代码，需要点击链接输入验证码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">from</span> google<span class="token punctuation">.</span>colab <span class="token keyword">import</span> drivedrive<span class="token punctuation">.</span>mount<span class="token punctuation">(</span><span class="token string">'/content/drive'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726110413026.png" alt="image-20220726110413026"></p><p>进入到挂载的文件夹中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">%cd /content/drive <span class="token comment"># /content/drive</span>%cd My<span class="token punctuation">\</span> Drive/colab <span class="token comment"># /content/drive/My Drive/colab</span><span class="token operator">!</span>git clone https://github.com/ultralytics/yolov5.git <span class="token comment"># 克隆yolov5的代码到文件夹中</span>%cd yolov5/ <span class="token comment"># /content/drive/MyDrive/colab/yolov5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>回到Dirve云盘中，此时文件夹结构应该如下图，一个是yolov5官方的文件夹，一个是自己的数据集文件夹：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726110943526.png" alt="image-20220726110943526"></p><p>开始训练前，还需要修改下yolov5的文件。找到yolov5文件夹中的models文件夹，根据所需打开.yaml文件，这里以yolov5s.yaml为例：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726111130283.png" alt="image-20220726111130283"></p><p>修改其中的nc值，根据你自己数据集所需进行修改，修改完后点击右上角的<strong>Save to Drive</strong>按钮：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726111403630.png" alt="image-20220726111403630"></p><h4 id="4-开始训练："><a href="#4-开始训练：" class="headerlink" title="4.开始训练："></a>4.开始训练：</h4><p>进入yolov5文件夹：</p><pre class="line-numbers language-none"><code class="language-none">%cd yolov5&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 执行训练命令，注意自己的训练集位置输入是否正确：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span>python train.py --data <span class="token punctuation">..</span>/Lion/data.yaml --cfg models/yolov5s.yaml --weights <span class="token string">''</span> --batch-size <span class="token number">32</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220526205304830.png" alt="image-20220526205304830"></p><p>训练结束后，将训练好的权重中最好的权重best.pt下载到本地，其余检测操作同本地检测图片操作相同。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像识别 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全速下载百度网盘的教程</title>
      <link href="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/"/>
      <url>/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载Microsoft-Edge浏览器"><a href="#1-下载Microsoft-Edge浏览器" class="headerlink" title="1.下载Microsoft  Edge浏览器"></a>1.下载Microsoft  Edge浏览器</h3><h3 id="2-添加油猴插件："><a href="#2-添加油猴插件：" class="headerlink" title="2.添加油猴插件："></a>2.添加油猴插件：</h3><p>点开浏览器右上角三个点，点击<strong>拓展</strong>选项，再点击<strong>管理扩展</strong>选项：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722112815950.png" alt="image-20220722112815950"></p><p>点击<strong>获取 Microsoft Edage 扩展</strong>，在商店中搜索<strong>Tampermonkey</strong>，下载绿色的：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722113257104.png" alt="image-20220722113257104"></p><h3 id="3-添加百度网盘直链下载助手："><a href="#3-添加百度网盘直链下载助手：" class="headerlink" title="3.添加百度网盘直链下载助手："></a>3.添加百度网盘直链下载助手：</h3><p>点开浏览器右上角的扩展选项，点击<strong>Tampermonkey</strong>，选择<strong>获取新脚本</strong>：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722113540704.png" alt="image-20220722113540704"></p><p>搜索用户脚本，<strong>百度网盘简易下载助手（直链下载复活版）</strong></p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722113712560.png" alt="image-20220722113712560"></p><p>最好是访问<a href="https://greasyfork.org/zh-CN/scripts/418182-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%AE%80%E6%98%93%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B-%E7%9B%B4%E9%93%BE%E4%B8%8B%E8%BD%BD%E5%A4%8D%E6%B4%BB%E7%89%88">百度网盘简易下载助手（直链下载复活版） (greasyfork.org)</a>，只要跳转到这个界面就算成功，注意版本是1.5.5，然后安装此脚本：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114026073.png" alt="image-20220722114026073"></p><h3 id="4-安装Aria2："><a href="#4-安装Aria2：" class="headerlink" title="4.安装Aria2："></a>4.安装Aria2：</h3><p>在上个页面往下拉，下载Aria2：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114202084.png" alt="image-20220722114202084"></p><h3 id="5-如何全速下载："><a href="#5-如何全速下载：" class="headerlink" title="5.如何全速下载："></a>5.如何全速下载：</h3><p>进入下载好的Aria2文件夹，双击打开<strong>aria2.exe</strong>文件，<strong>保持在后台运行</strong>；如果你需要查看下载页面，在打开aria2.exe后，再点击AriaNg启动器.exe文件，跳转到浏览器查看下载进度：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114825906.png" alt="image-20220722114825906"></p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114908574.png" alt="image-20220722114908574"></p><p>点击要下载资源的百度网盘链接，<strong>将其保存到自己网盘后</strong>，<strong>在网页端进入自己的网盘</strong>：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220908085628498.png" alt="image-20220908085628498"></p><p>右上角会出现<strong>简易下载助手</strong>，选择你要下载的资源，点击简易下载助手：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114939150.png" alt="image-20220722114939150"></p><p>点击<strong>点击获取直链地址</strong>，关注公众号获取验证码：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722115036698.png" alt="image-20220722115036698"></p><p>获取后，<strong>修改保存路径</strong>，点击<strong>发送至Aria2</strong>按钮：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722115535291.png" alt="image-20220722115535291"></p><p>回到Aria或者回到AriaNg启动器.exe打开的浏览器页面，就能看到下载进度：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722120052380.png" alt="image-20220722120052380"></p><p>速度非常快，和你的网速一致，全速下载！</p><blockquote><p>注意：只能下载单个文件，<strong>无法直接下载文件夹</strong>！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学入门--光</title>
      <link href="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/"/>
      <url>/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/</url>
      
        <content type="html"><![CDATA[<h3 id="WebGL入门："><a href="#WebGL入门：" class="headerlink" title="WebGL入门："></a>WebGL入门：</h3><h3 id="1-画布："><a href="#1-画布：" class="headerlink" title="1.画布："></a>1.画布：</h3><h4 id="1-坐标系："><a href="#1-坐标系：" class="headerlink" title="1.坐标系："></a>1.坐标系：</h4><p>对于大多数计算机屏幕，坐标原点位于屏幕左上角，x轴向右侧延伸，y轴向左侧延伸：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143143556.png" alt="image-20220620143143556"></p><p>但对于3D图形程序员来说，更倾向使用另一种坐标系：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143216979.png" alt="image-20220620143216979"></p><h4 id="2-颜色模型："><a href="#2-颜色模型：" class="headerlink" title="2.颜色模型："></a>2.颜色模型：</h4><h5 id="1-减法色模型："><a href="#1-减法色模型：" class="headerlink" title="1.减法色模型："></a>1.减法色模型：</h5><p>从包含所有波长的光开始，减去一部分数量的颜色，从而创建任何其他颜色：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143348156.png" alt="image-20220620143348156"></p><p>但这种模型不完全正确，实际原色是青色、平红色和黄色。而且混合这三种模型会产生一种稍暗的颜色，但不是纯黑色，因此需要添加黑色作为第四种“原色”，黑色用K表示，因此我们得出CMYK模型，如下图：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143819653.png" alt="image-20220620143819653"></p><h5 id="2-加法色模型："><a href="#2-加法色模型：" class="headerlink" title="2.加法色模型："></a>2.加法色模型：</h5><p>屏幕与纸张相反，屏幕本身是黑色的，还会发出光，因此我们从没有光开始，然后添加我们想要的波长的光。大多数颜色可以通过在黑色表面添加不同“数量”的红色、绿色、蓝色来创建，这就是RGB颜色模型，是一种加法色模型，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143826817.png" alt="image-20220620143826817"></p><h4 id="3-颜色深度："><a href="#3-颜色深度：" class="headerlink" title="3.颜色深度："></a>3.颜色深度：</h4><p>大多数图像都是使用8位二进制数来表示一种原色，这里称原色为颜色通道，每个通道使用8位二进制的话，一个像素由三个通道组成就是24位二进制数，共有2^24种不同颜色，这种格式成为R8G8B8格式，是常用格式，颜色深度认为是24位。</p><h4 id="4-颜色表示："><a href="#4-颜色表示：" class="headerlink" title="4.颜色表示："></a>4.颜色表示：</h4><p>使用三个字节来表示一种颜色，每个字节保存从0到255的8位颜色通道的值，我们将颜色表示为(R,G,B)。</p><h4 id="5-颜色的处理方式："><a href="#5-颜色的处理方式：" class="headerlink" title="5.颜色的处理方式："></a>5.颜色的处理方式：</h4><p>我们可以通过将每个颜色通道值乘一个常量来修改颜色的强度，可以通过将每个颜色通道值分别相加来将两个颜色相加。这些运算可能产生无效值，我们将<strong>任何超过255的值视为255，任何低于0的值视为0</strong>，我们把这称为将值范围限制[0,255]，类似生活中使用相机曝光不足或过度曝光的情况。</p><h4 id="6-场景："><a href="#6-场景：" class="headerlink" title="6.场景："></a>6.场景：</h4><p>场景需要坐标轴来讨论其中的为题，不能使用与画布相同的坐标系，因为画布为2D，场景是3D，如图是场景使用的坐标系：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620144636553.png" alt="image-20220620144636553"></p><p>场景的单位取决于我们的场景代表什么，不同场景单位不同。</p><h3 id="2-基础光线追踪知识："><a href="#2-基础光线追踪知识：" class="headerlink" title="2.基础光线追踪知识："></a>2.基础光线追踪知识：</h3><h4 id="1-渲染图片："><a href="#1-渲染图片：" class="headerlink" title="1.渲染图片："></a>1.渲染图片：</h4><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620152206227.png" alt="image-20220620152206227"></p><p>如何让计算机渲染这张图片？我们用一个固定的视角和一个窗口来观察风景，将图像分成很多“格子”，在每一个格子涂上相应的颜色，最终绘制的图像如图：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620152351610.png" alt="image-20220620152351610"></p><p>绘画过程可以是这样的：</p><ul><li>将眼睛和框架搭建好</li><li>扫描画布上每一个区域</li><li>对应画布和图像上的区域</li><li>识别图像上每一个区域所看到的的颜色</li><li>将每个区域的颜色画出来</li></ul><h4 id="2-基本假设："><a href="#2-基本假设：" class="headerlink" title="2.基本假设："></a>2.基本假设：</h4><p>首先我们需要一个固定的观察位置，也就是相机位置，用O表示，假设相机位置O&#x3D;(0,0,0)；假设有一个固定的相机方位，相机方位决定了相机指向哪里，我们假设相机指向z轴正方向，并且y轴正方向是向上的，x轴正方向是向右的，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620153152123.png" alt="image-20220620153152123"></p><p>再假设一个“窗口”，假设位于相机正前方，垂直于z轴，中心在z轴上，平行于x轴与y轴，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620153300698.png" alt="image-20220620153300698"></p><p>图中的矩形作为我们观察世界的窗口，我们称之为视口。本质上，我们将在画布上绘制我们通过视口看到的任何内容。注意视口大小和视口到相机距离决定了从相机可以观察的角度，称为<strong>视野</strong>。</p><h4 id="3-画布空间到视口空间："><a href="#3-画布空间到视口空间：" class="headerlink" title="3.画布空间到视口空间："></a>3.画布空间到视口空间：</h4><p>视口是以世界空间的单位衡量的，而画布是以像素衡量的，所以从画布到空间坐标<strong>只是比例的改变</strong>。</p><h4 id="4-追踪光线："><a href="#4-追踪光线：" class="headerlink" title="4.追踪光线："></a>4.追踪光线：</h4><blockquote><p>现实世界中，光线是经过反射后到我们的眼睛中，我们可以尝试模拟场景光源中光子离开光源的路径，但这非常耗时，而且光子数量惊人，并且只有一小部分光子在通过视口后会刚好到达。这种技术称为光子追踪或光子映射。</p></blockquote><p>相反我们考虑，反向光线：从相机发出射线，穿过视口中的某个点，并跟踪射线的路径，直到他“击中”场景中的某个物体，这个物体就是相机通过视口那个点看到的物体。因此我们只需将<strong>该物体的颜色</strong>作为“通过该点的光的颜色”，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620155153656.png" alt="image-20220620155153656"></p><h3 id="3-光："><a href="#3-光：" class="headerlink" title="3.光："></a>3.光：</h3><p>将介绍3种类型的光源，点光，方向光和环境光。</p><h4 id="1-简单假设："><a href="#1-简单假设：" class="headerlink" title="1.简单假设："></a>1.简单假设：</h4><p>用单个实数i来表征任何光，i源于光的强度，使用白光从而保证事情简单。其次将忽视空气，因为在现实生活中，光源离得越远，看起来就越暗，因为空气中漂浮的粒子会在光线穿过它们时吸收部分光。</p><h3 id="2-光源："><a href="#2-光源：" class="headerlink" title="2.光源："></a>2.光源：</h3><h5 id="1-点光："><a href="#1-点光：" class="headerlink" title="1.点光："></a>1.点光：</h5><p>从3D空间中的一个固定的点发射光，这个点被称为点光源的位置，点光源向每个方向均匀的发射光，这就是它被称为全向光的原因。因此，点光可以完全用位置和强度来描述。</p><p>定义向量L作为从场景中的点P到光源Q的方向，我们可以计算这个向量，称其为光向量，即Q-P。需要注意，Q是固定的，P可以是场景中的任何点，因此L对于场景中的每个点都是不同的，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620162555479.png" alt="image-20220620162555479"></p><h5 id="2-方向光："><a href="#2-方向光：" class="headerlink" title="2.方向光："></a>2.方向光：</h5><p>和点光一样，方向光也有强度，但没有位置，相反它有一个固定的方向。在方向光的情况下，L是给定的，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620163037954.png" alt="image-20220620163037954"></p><h5 id="3-环境光："><a href="#3-环境光：" class="headerlink" title="3.环境光："></a>3.环境光：</h5><p>不希望每个物体被直接照亮或者完全黑暗，为了突破这一限制，定义第三种光源，称之为环境光。它只以其强度为特征。我们将声明环境光为场景中的每个点贡献一些光，不管它在哪里。</p><p>一般来说，一个场景会有单个环境光（因为环境光只有一个强度值，任何数量的环境光都可以简单地组合成一个环境光）和任何数量的点光及方向光。</p><h5 id="4-单点光照："><a href="#4-单点光照：" class="headerlink" title="4.单点光照："></a>4.单点光照：</h5><p>为了计算单个点的光照，我们将计算每个光源奉献的光，并将它们加在一起，得到一个代表该点接收到的光的总量的数字。然后我们可以用这个总量乘物体表面在该点的颜色，从而获得该点的着色颜色，用以代表该点接收了多少光。</p><p>我们可以根据物体反射的方式直观地将物体分为两大类：“哑光“和”闪光“物体。</p><h5 id="5-漫反射："><a href="#5-漫反射：" class="headerlink" title="5.漫反射："></a>5.漫反射：</h5><p>当一束光线照射到一个哑光物体上时，光线会沿着每个方向均匀地散射回场景中，这个过程叫做漫反射，这是使哑光物体看起来无光泽的原因。另一方面，反射的光的数量取决于光线和物体表面之间的角度，这是因为光线所携带的能量必须根据角度分散在更小或更大的区域上，所以单位面积上反射到场景的能量分别更高或更低，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620164823915.png" alt="image-20220620164823915"></p><h5 id="6-镜面反射："><a href="#6-镜面反射：" class="headerlink" title="6.镜面反射："></a>6.镜面反射：</h5><p>与哑光物体不同，感知这些闪亮物体表面的方式实际上取决于你的视角。不规则物体表面是这样反射的：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620165117294.png" alt="image-20220620165117294"></p><p>但如果表面是相对光滑的呢？如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620165209598.png" alt="image-20220620165209598"></p><p>注意在计算机图形学中，除非特殊说明，光源方向都是从场景中任意一点指向光源的方向，与物理中入射光的方向相反，是为了方便后续光照模型中的计算。</p><p>但并非每一个物体是完全光滑的，所以总有一部分光线会沿着接近R的方向被反射，越是接近R，该方向反射的光线越多，物体的光泽度决定反射光线衰减的程度：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620165525865.png" alt="image-20220620165525865"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端必看的书籍【进阶】</title>
      <link href="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/"/>
      <url>/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-白银前端："><a href="#1-白银前端：" class="headerlink" title="1.白银前端："></a>1.白银前端：</h3><blockquote><p>可以熟练的进行平时的业务开发，但是对于JS高阶，源码，浏览器原理，数据结构与算法，设计模式，网络，前端工程之类的东西很迷茫，只知道大致概念。</p></blockquote><ul><li><p>《剖析Vue.js内部运行机制》，对于Vue内部的基础原理的理解，适合新手初次接触Vue。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/160fdc404b36a1a0_tplv-t2oaga2asx-zoom-1.webp" alt="img"></p></li><li><p>《深入浅出Vue.js》，从原生demo一步步转换成框架的样子，循序渐进。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s31471882.webp" alt="img"></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/"> Vue.js 技术揭秘 (ustbhuangyi.github.io)</a>，源码解析，更进一步的对于源码的理解。</p></li><li><p><a href="https://github.com/HcySunYang/vue-design/tree/elegant">Vue全面解析</a>，非常详细，逐行分析源码。</p></li><li><p>《图解http》，比较入门，满足日常基本使用。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s27283822.webp" alt="img"></p></li><li><p>《图解TCP&#x2F;IP》，入门级别，同上一起使用。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s26676928.webp" alt="img"></p></li><li><p>《TCP&#x2F;IP详解 卷1》，非常详细和深入地讲解tcp和ip协议。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s28845534.webp" alt="img"></p></li></ul><h3 id="2-黄金前端："><a href="#2-黄金前端：" class="headerlink" title="2.黄金前端："></a>2.黄金前端：</h3><blockquote><p>有需要对大型项目的架构的把控，项目管理，资源分配能力的需求，专注于整体的把握，不再拘泥于具体技术。</p></blockquote><ul><li><p>《JavaScript设计模式与开发实践》</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s28065006.webp" alt="img"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Node.js实现图像识别接口调用</title>
      <link href="/2022/07/16/ji-yu-node-js-shi-xian-tu-xiang-shi-bie-jie-kou-diao-yong/"/>
      <url>/2022/07/16/ji-yu-node-js-shi-xian-tu-xiang-shi-bie-jie-kou-diao-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="1-比较各类商业图像识别接口："><a href="#1-比较各类商业图像识别接口：" class="headerlink" title="1.比较各类商业图像识别接口："></a>1.比较各类商业图像识别接口：</h3><p>1.火山引擎：对于人体、人像的识别功能较多，对于动物几乎没有，分类较少只有两三个，而且识别精度较差，往往识别不出图像中的实体。</p><p>2.谷歌引擎：识别精度、细节相当高，但没有分类，识别元素过多，且在国外，调试和支付不太方便。</p><p>3.百度引擎：识别精度优秀，分类较多，有明确的动物识别分类，且能衍生出百科知识，返回的标签为中文标签。</p><p>4.阿里云引擎：识别分类没有动物分类，但是在阿里云市场有其他公司的接口，相当于外包。</p><h3 id="2-选用接口："><a href="#2-选用接口：" class="headerlink" title="2.选用接口："></a>2.选用接口：</h3><p>综合考虑使用百度动物识别，使用语言为node.js。但其官方示例没有node.js的语言示例，需要自己琢磨开发。</p><h4 id="1-调用百度获取token的接口："><a href="#1-调用百度获取token的接口：" class="headerlink" title="1.调用百度获取token的接口："></a>1.调用百度获取token的接口：</h4><p>一开始的想法是将这个过程作为中间件，但发现作为中间件使用后，原接口就不能再发起请求了，原因不得而知，只能将其封装在方法中：</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">async function getToken() &#123;  const param &#x3D; qs.stringify(&#123;    grant_type: &quot;client_credentials&quot;,    client_id: &quot;your client_id&quot;,    client_secret: &quot;your client_secret&quot;,  &#125;);  &#x2F;&#x2F;通过秘钥获取token相关属性  try &#123;    &#x2F;&#x2F;但这个方法需要考虑到异步问题    &#x2F;&#x2F; axios(&#123;    &#x2F;&#x2F;   method: &quot;get&quot;,    &#x2F;&#x2F;   baseURL: &quot;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;&quot;,    &#x2F;&#x2F;   &#x2F;&#x2F;两种url写法均可以请求到    &#x2F;&#x2F;   &#x2F;&#x2F; url: &#96;oauth&#x2F;2.0&#x2F;token?grant_type&#x3D;client_credentials&amp;client_id&#x3D;$&#123;client_id&#125;&amp;client_secret&#x3D;$&#123;client_secret&#125;&#96;,    &#x2F;&#x2F;   url: &quot;oauth&#x2F;2.0&#x2F;token?&quot; + param,    &#x2F;&#x2F; &#125;).then((res) &#x3D;&gt; &#123;    &#x2F;&#x2F;   &#x2F;&#x2F; var stream &#x3D; res.data.pipe(fs.createWriteStream(&quot;.&#x2F;baidu-token.json&quot;));    &#x2F;&#x2F;   &#x2F;&#x2F; stream.on(&quot;finish&quot;, () &#x3D;&gt; &#123;    &#x2F;&#x2F;   &#x2F;&#x2F;   console.log(&quot;传输完成！&quot;);    &#x2F;&#x2F;   &#x2F;&#x2F; &#125;);    &#x2F;&#x2F;   return axios.get(&quot;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token?&quot; + param);    &#x2F;&#x2F; &#125;);    return axios.get(&quot;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token?&quot; + param);  &#125; catch (error) &#123;    console.log(error);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之前考虑过将获取到的token存放在文件中，这样不太会占用内存，但使用fs.createWriteStream(“.&#x2F;baidu-token.json”)浏览器会报同源跨域错误，虽然没什么影响，但如果不想看见报错还是不要使用这种优雅的写法了。</p><h4 id="2-将图像转换为base64格式："><a href="#2-将图像转换为base64格式：" class="headerlink" title="2.将图像转换为base64格式："></a>2.将图像转换为base64格式：</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> image2base64 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"image-to-base64"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> imageBase64 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">image2base64</span><span class="token punctuation">(</span>      <span class="token comment">// "http://localhost:4000/" + req.file.filename</span>      imageUrl    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里的imageUrl直接使用的是阿里云存储OSS返回的url，比较方便</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-调用动物识别接口："><a href="#3-调用动物识别接口：" class="headerlink" title="3.调用动物识别接口："></a>3.调用动物识别接口：</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getAnimal</span><span class="token punctuation">(</span><span class="token parameter">imageUrl<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> token <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> imageBase64 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">image2base64</span><span class="token punctuation">(</span>      <span class="token comment">// "http://localhost:4000/" + req.file.filename</span>      imageUrl    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> bodyFormData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bodyFormData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"image"</span><span class="token punctuation">,</span> imageBase64<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">"post"</span><span class="token punctuation">,</span>      <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://aip.baidubce.com/rest/2.0/image-classify/v1/animal?access_token=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>token<span class="token punctuation">.</span>data<span class="token punctuation">.</span>access_token<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>      <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"content-type"</span><span class="token operator">:</span> <span class="token string">"application/x-www-form-urlencoded"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token literal-property property">data</span><span class="token operator">:</span> bodyFormData<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    response<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里一定要将imageBase64添加到bodyFormData，官方文档中没有说，是一个坑。</p><h3 id="3-识别结果："><a href="#3-识别结果：" class="headerlink" title="3.识别结果："></a>3.识别结果：</h3><p><img src="/2022/07/16/ji-yu-node-js-shi-xian-tu-xiang-shi-bie-jie-kou-diao-yong/image-20220716192722021.png" alt="image-20220716192722021"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 图像识别 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端必看的书籍【入门】</title>
      <link href="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/"/>
      <url>/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="1-黑铁前端："><a href="#1-黑铁前端：" class="headerlink" title="1.黑铁前端："></a>1.黑铁前端：</h3><blockquote><p>没有接触过前端，对于前端没有概念。</p></blockquote><p>推荐书籍：</p><ul><li><p>《Head First HTML与CSS（第2版）》，看完会对html和css有基本概念。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716182659269.png" alt="image-20220716182659269"></p></li><li><p>《JavaScript DOM编程艺术》，最好的JS入门书籍，其中还介绍了最符合标准的编程理念。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716182900459.png" alt="image-20220716182900459"></p></li><li><p>《JavaScript高级程序设计（第4版）》，带你入门基础的JavaScript语法，DOM环境和事件，本地存储和跨域等等，是一本非常全面的书籍。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716183058434.png" alt="image-20220716183058434"></p></li></ul><h3 id="2-青铜前端："><a href="#2-青铜前端：" class="headerlink" title="2.青铜前端："></a>2.青铜前端：</h3><blockquote><p>可以使用html，css，JavaScript编写简单的页面，但还不会使用库。</p></blockquote><ul><li><p>《JavaScript高级程序设计（第4版）》，没错，继续攻读一遍，会有新的收获。</p></li><li><p>Vue，这时候可以尝试接触库和框架了，直接看官方文档，养成看官方文档的好习惯。</p></li><li><p>《ES6标准入门 第3版 》，了解ES6用法基础。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716183639881.png" alt="image-20220716183639881"></p></li></ul><h3 id="3-白银前端："><a href="#3-白银前端：" class="headerlink" title="3.白银前端："></a>3.白银前端：</h3><blockquote><p>会使用库，例如可以用vue，jquery完成普通业务的开发，比如说一些活动落地页和后台管理页面</p></blockquote><ul><li><p>《JavaScript高级程序设计（第4版）》，没错，再看一遍会有新的成长。</p></li><li><p>《正则表达式必知必会(修订版)》，书很薄，但是正则表达式是前端开发者必须要会的一项技能。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716183927650.png" alt="image-20220716183927650"></p></li><li><p>《你不知道的JavaScript 上卷》，内容为作用域和闭包以及对象原型，很重要。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716184057259.png" alt="image-20220716184057259"></p></li><li><p>《你不知道的JavaScript 中卷》，内容为类型、语法、异步和性能。异步推荐看《ES6标准入门》，性能部分不推荐看</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716184230506.png" alt="image-20220716184230506"></p></li><li><p>《你不知道的JavaScript 下卷》，内容为JavaScript入门知识和未来发展趋势的展望，对前两本书的总结，ES6部分不推荐看。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716184550929.png" alt="image-20220716184550929"></p><ul><li><p>《深入理解ES6》，在了解ES6基础上的一本进阶书籍。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716184902235.png" alt="image-20220716184902235"></p></li></ul></li><li><p>《JavaScript 忍者秘籍》，很有深度的一本书，对于JS的核心部分剖析的很详细。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716185140322.png" alt="image-20220716185140322"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最简单的提升网站的性能的方法</title>
      <link href="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/"/>
      <url>/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CDN加速"><a href="#1-CDN加速" class="headerlink" title="1.CDN加速"></a>1.CDN加速</h3><ul><li><p>什么是CDN？</p><p>CDN英文全称content delivery network，翻译过来就是内容分发网络，是一种在地理位置上分散的服务器组，这些服务器组一起工作来加速互联网内容快速传播，这些内容包括HTML页面，css、javascript文件，图像、视频等媒体文件。</p><p>通俗来讲，就是CDN服务公司通过在全球各地建立很多服务器，然后当你加入他们的网络后 ，他们会缓存你的网站内容到各地服务器上，这样当访问你的网站时，他们就会从最近的缓存服务器上读取你的网站，而不需要直接访问你网站所在的服务器地址。</p></li><li><p>为什么强烈建议启用CDN？</p><p>研究表明，如果你的网站打开速度超过2s以上，那么你的客户很有可能离你而去，这一点对于商业化网站尤其重要，打开速度慢，那么将造成不可估量的损失。</p><p>以本博客为例，仓库放在Github上，国内加载速度很慢，因此需要CDN加速来优化网站打开速度。</p></li></ul><h4 id="Cloudflare-CDN"><a href="#Cloudflare-CDN" class="headerlink" title="Cloudflare CDN"></a>Cloudflare CDN</h4><p>Cloudflare是全球最大的一家主营CDN和网络安全的公司，而且配置也非常简单。</p><h5 id="第一步：在Cloudflare添加你的网站"><a href="#第一步：在Cloudflare添加你的网站" class="headerlink" title="第一步：在Cloudflare添加你的网站"></a>第一步：在Cloudflare添加你的网站</h5><p>点击左侧导航栏中的<strong>网站</strong>选项，再点击右上角的<strong>添加站点</strong>按钮，输入你的域名，Cloudflare会开始扫描查询你的网站DNS配置。</p><p><img src="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/image-20220715144412879.webp" alt="image-20220715144412879"></p><p>查询DNS完毕之后，会复制你的DNS记录到Cloudflare，然后点击继续按钮；接下来页面会要求你把原来的域名服务器更改为Cloudflare自己的，不改域名服务器，上面的DNS并不会生效。</p><p><img src="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/image-20220715144840060.webp" alt="image-20220715144840060"></p><p>以腾讯云为例，登录<strong>腾讯云域名注册管理控制台</strong>，进入“我的域名”页面，选择待修改的DNS域名，点击<strong>管理</strong>选项：</p><p><img src="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/image-20220715145234006.webp" alt="image-20220715145234006"></p><p>将DNS服务器修改为Cloudflare提供的两个：</p><p><img src="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/image-20220715145503131.webp" alt="image-20220715145503131"></p><p>至此，你的域名就可以在Cloudflare上管理了，在24小时域名服务器更新完成后，用户也可以通过你自己的域名访问到网站了。</p><h5 id="第二步：优化性能"><a href="#第二步：优化性能" class="headerlink" title="第二步：优化性能"></a>第二步：优化性能</h5><p>在Cloudflare进入主页，点击配置好的网站，选择免费套餐，勾选以下设置：</p><ul><li><p>提高安全性</p></li><li><ul><li>自动 HTTPS 重写</li><li>始终使用 HTTPS</li></ul></li><li><p>优化性能</p></li><li><ul><li>Auto Minify， 勾选html、css、js，保存</li><li>Brotli，打开，保存</li></ul></li></ul><p>点击左侧导航栏中的<strong>速度</strong>按钮：</p><ul><li><p>优化</p></li><li><ul><li>Auto Minify 自动最小化 – JavaScript、CSS、HTML 全部勾选，其实这在入门设置的时候就已经勾选了，可以不需要改动</li><li>Brotli – 开启， 同上</li><li>Rocket Loader – 开启，可缩短包含 JavaScript 的页面的绘制时间。</li><li>Railgun – 加入你得主机商在你的主机商安装了此软件，比如<a href="https://link.zhihu.com/?target=https://www.qingsongb2c.com/goto/chemicloud-hosting/">Chemicloud</a>，可以开启，</li><li>AMP（Accelerated Mobile Pages即加速移动端网页的加载速度） 真实 URL – 可开启</li></ul></li><li><p>Browser Insights（现功能在其他地方设置，有操作指导教程，跟着走就行）</p></li><li><ul><li>配置 – Browser Insights开启</li></ul></li></ul><h3 id="2-图片格式与压缩技术："><a href="#2-图片格式与压缩技术：" class="headerlink" title="2.图片格式与压缩技术："></a>2.图片格式与压缩技术：</h3><ol><li><p>将你网站中的文件换为.webp格式，webp是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自图像编码格式VP8 。是由Google购买On2 Technologies后发展出来的格式，以BSD授权条款发布。webp可让网页图档有效进行压缩，同时又不影响图片格式兼容与实际清晰度，进而让整体网页下载速度加快。</p><p>推荐一个转换格式网站：<a href="https://cdkm.com/cn/jpg-to-webp">JPG转WEBP - 免费在线将JPG文件转换成WEBP (cdkm.com)</a></p></li><li><p>无损压缩各类格式图片的网站：<a href="https://tinypng.com/">TinyPNG – Compress WebP, PNG and JPEG images intelligently</a></p></li></ol><p>本文仅介绍了两种最简单的加速个人网站的技巧，还有许多优化技巧，例如压缩字体，URL优化，SEO优化等，以后会更新教程。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用yolo5进行数据训练</title>
      <link href="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/"/>
      <url>/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载数据集并进行本地训练的标准流程"><a href="#1-下载数据集并进行本地训练的标准流程" class="headerlink" title="1.下载数据集并进行本地训练的标准流程"></a>1.下载数据集并进行本地训练的标准流程</h3><ol><li><p>克隆github项目</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/theAIGuysCode/OIDv4_ToolKit pip <span class="token function">install</span> -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下载数据集</p><p>数据集网站为<a href="https://storage.googleapis.com/openimages/web/index.html">https://storage.googleapis.com/openimages/web/index.html</a></p><p>搜索对应的类别，这里以Lion为例，下载训练集200张：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python main.py downloader --classes Lion --type_csv train --limit <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>注意：若某个类别有两个单词组成，单词间使用下划线代替：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python main.py downloader --classes Bell_pepper --type_csv train --limit <span class="token number">400</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>注意：若想同时训练多个类别，可通过如下代码将多个类别移动至同一类别：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python main.py downloader --classes Aircraft Weapon --type_csv <span class="token builtin class-name">test</span> --limit <span class="token number">100</span> --multiclasses <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>数据预处理</p><p>下载后的数据存储在OID&#x2F;Dataset&#x2F;train&#x2F;，每个类别的文件包括对应的image和label，对应的label为txt文件，打开后为：</p><pre class="line-numbers language-none"><code class="language-none">Lion 48.0 268.23846499999996 972.8 561.4438100000001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>的label为txt文件，打开后为：</p><pre class="line-numbers language-none"><code class="language-none">Lion 48.0 268.23846499999996 972.8 561.4438100000001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但目前的label格式并不能直接拿来放在yolov5中训练，需要转换成yolov5接受的格式</p><ol><li><p>打开classes.txt，将里面的内容改为需要转换的类别：</p><p>在本例中，修改为：Lion</p></li><li><p>运行指令<code>python convert_annotations.py</code>,转换label格式。<br>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token keyword">import</span> argparse<span class="token keyword">import</span> fileinput<span class="token comment"># function that turns XMin, YMin, XMax, YMax coordinates to normalized yolo format</span><span class="token keyword">def</span> <span class="token function">convert</span><span class="token punctuation">(</span>filename_str<span class="token punctuation">,</span> coords<span class="token punctuation">)</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span>    image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>filename_str <span class="token operator">+</span> <span class="token string">".jpg"</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-=</span> coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    coords<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-=</span> coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    x_diff <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    y_diff <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>x_diff    coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>y_diff    coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">"Label"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> coordsROOT_DIR <span class="token operator">=</span> os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># create dict to map class names to numbers for yolo</span>classes <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"classes.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myFile<span class="token punctuation">:</span>    <span class="token keyword">for</span> num<span class="token punctuation">,</span> line <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>myFile<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        line <span class="token operator">=</span> line<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>        classes<span class="token punctuation">[</span>line<span class="token punctuation">]</span> <span class="token operator">=</span> num    myFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># step into dataset directory</span>os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"OID"</span><span class="token punctuation">,</span> <span class="token string">"Dataset"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>DIRS <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># for all train, validation and test folders</span><span class="token keyword">for</span> DIR <span class="token keyword">in</span> DIRS<span class="token punctuation">:</span>    <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>DIR<span class="token punctuation">)</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span>DIR<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Currently in subdirectory:"</span><span class="token punctuation">,</span> DIR<span class="token punctuation">)</span>                CLASS_DIRS <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># for all class folders step into directory to change annotations</span>        <span class="token keyword">for</span> CLASS_DIR <span class="token keyword">in</span> CLASS_DIRS<span class="token punctuation">:</span>            <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>CLASS_DIR<span class="token punctuation">)</span><span class="token punctuation">:</span>                os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span>CLASS_DIR<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Converting annotations for class: "</span><span class="token punctuation">,</span> CLASS_DIR<span class="token punctuation">)</span>                                <span class="token comment"># Step into Label folder where annotations are generated</span>                os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">"Label"</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> filename <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    filename_str <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    <span class="token keyword">if</span> filename<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">".txt"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        annotations <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>                            <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>                                <span class="token keyword">for</span> class_type <span class="token keyword">in</span> classes<span class="token punctuation">:</span>                                    line <span class="token operator">=</span> line<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>class_type<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>classes<span class="token punctuation">.</span>get<span class="token punctuation">(</span>class_type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                labels <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>                                coords <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                coords <span class="token operator">=</span> convert<span class="token punctuation">(</span>filename_str<span class="token punctuation">,</span> coords<span class="token punctuation">)</span>                                labels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> labels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> labels<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> labels<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> coords<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>                                newline <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                line <span class="token operator">=</span> line<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>line<span class="token punctuation">,</span> newline<span class="token punctuation">)</span>                                annotations<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">)</span>                            f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                        os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span>                        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> outfile<span class="token punctuation">:</span>                            <span class="token keyword">for</span> line <span class="token keyword">in</span> annotations<span class="token punctuation">:</span>                                outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>                                outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>                            outfile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                        os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">"Label"</span><span class="token punctuation">)</span>                os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span>                os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span>        os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>移动标签位置</p><p>数据预处理后，txt和jpg文件是放在一个文件夹下的，仍然不是yolov5要求的文件格式，即label，image文件夹分开存放。首先删除Label文件夹中的文件，但不要删除Label文件夹；</p><p>运行代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> glob<span class="token keyword">import</span> shutil<span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Pathp <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">r"E:\opencv_learning\OIDv4_ToolKit-master\OID\Dataset\validation\Lion"</span><span class="token punctuation">)</span>  <span class="token comment">#  需要统计的文件夹路径，这里我们统计的是桌面上的test文件夹，可以随便改名</span>q <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">r"E:\opencv_learning\Lion\valid\Label"</span><span class="token punctuation">)</span> <span class="token comment">#  将提取出的所有txt放到test2文件夹下，如果没有需要先创建一个，可以随便改名</span>FileList <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"**/*.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 找出这个文件夹下的所有txt格式的文件，可以自行换成flac、mp4、mp3，全都可以！</span><span class="token keyword">for</span> <span class="token builtin">file</span> <span class="token keyword">in</span> FileList<span class="token punctuation">:</span>       <span class="token comment"># 这个的意思是，遍历所有找出的txt文件，并复制到另一个文件夹中</span>    shutil<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span>q<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时将Lion文件夹下的txt文件复制到Label文件夹下，将Label文件夹重命名为label，复制出来到与yolov5项目同一目录级别的文件夹下；接着同上处理img文件，复制出来放在与label文件夹同一级别的目录中，最终目录格式：</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525105312819.webp"></p><ul><li><p>注意：如果使用shutil的move()剪切方法会报错，具体原因据说是shutil的源码bug，目前仍然没有修复，所以只能用这种比较麻烦的方法构成所需目录。</p></li><li><p>注意，要在train同一目录下创建data.yaml文件，内容参考其他data.yaml文件。</p></li><li><p>注意：如果要得到正确的训练结果，还需要下载同类别的validation文件，张数约为训练集的百分之20，用以上方法整理到与train文件夹同一目录下，test文件同理，最终目录结构：</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525105701317.webp"></p></li></ul><p>lion_detect是我自己创建放几张网上找的图片用来测试的。</p></li><li><p>开始训练</p><p>打开yolov5 6.1项目，设置训练参数：</p></li></ol><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525105912373.webp"></p><p>​点击train.py文件运行，开始训练，训练完成后打开detect.py文件，设置参数：</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525110031198.webp"></p><p>​其中best.pt是训练后最好的权重，用以检测。</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525110313235.webp"></p><p>​我们对比一下官方自带的训练集的检测结果：</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525110334725.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像识别 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebGL着色器入门</title>
      <link href="/2022/07/13/webgl-zhao-se-qi-ru-men/"/>
      <url>/2022/07/13/webgl-zhao-se-qi-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="1-着色器是什么？"><a href="#1-着色器是什么？" class="headerlink" title="1.着色器是什么？"></a>1.着色器是什么？</h3><p>WebGL需要两种着色器：<br><strong>顶点着色器(Vertex shader)</strong>:顶点着色器是用来描述顶点特性（如位置、颜色等)的程序。顶点(vertex)是指二维或三维空间中的一个点，比如二维或三维图形的端点或交点。</p><p><strong>片元着色器(Vertex shader)</strong>:进行逐片元处理过程如光照的程序。片元(fragment)是一个WebGL术语，你可以将其理解为像素（图像的单元）。</p><p>下图是浏览器显示图像的流程：</p><p><img src="/2022/07/13/webgl-zhao-se-qi-ru-men/image-20220713214157458.webp"></p><p>图的左侧是两个浏览器窗口。它们是同一个窗口，上面一个是执行JavaScript程序之前的窗口，下面一个是执行之后的。程序执行的流程大概是：首先运行JavaScript程序，调用了WbGL的相关方法，然后顶点着色器和片元着色器就会执行，在颜色缓冲区内进行绘制，这时就清空了绘图区；最后，颜色缓冲区中的内容会自动在浏览器的画布上显示出来。</p><h3 id="2-着色器代码示例："><a href="#2-着色器代码示例：" class="headerlink" title="2.着色器代码示例："></a>2.着色器代码示例：</h3><p>因为着色器程序代码必须预先处理成单个字符串的形式，所以我们用+号将多行字符串连成一个长字符串。每一行以\n结束，这是由于当着色器内部出错时，就能获取出错的行号，这对于检查源代码中的错误很有帮助。但是，\n并不是必须的，你自己编写着色器时，也可以不用它。</p><p><img src="/2022/07/13/webgl-zhao-se-qi-ru-men/image-20220713214259031.webp"></p><h3 id="3-初始化着色器："><a href="#3-初始化着色器：" class="headerlink" title="3.初始化着色器："></a>3.初始化着色器：</h3><p>大部分WebGL程序都遵循这样的流程：</p><p><img src="/2022/07/13/webgl-zhao-se-qi-ru-men/image-20220713214315749.webp"></p><p>目前最重要的是，你必须知道，<strong>WebGL程序包括运行在浏览器中的JavaScript和运行在WebGL系统的着色器程序这两个部分</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
