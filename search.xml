<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Node.js中的模块化</title>
      <link href="/2023/06/30/node.js-zhong-de-mo-kuai-hua/"/>
      <url>/2023/06/30/node.js-zhong-de-mo-kuai-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js-模块化"><a href="#Node-js-模块化" class="headerlink" title="Node.js 模块化"></a>Node.js 模块化</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是模块化与模块"><a href="#什么是模块化与模块" class="headerlink" title="什么是模块化与模块 ?"></a>什么是模块化与模块 ?</h3><blockquote><p>将一个复杂的程序文件依据一定规则（规范）拆分成多个文件的过程称之为 <code>模块化</code></p></blockquote><p>其中拆分出的 <span style="color:red">每个文件就是一个模块</span>，模块的内部数据是私有的，不过模块可以暴露内部数据以便其他模块使用</p><h3 id="什么是模块化项目"><a href="#什么是模块化项目" class="headerlink" title="什么是模块化项目 ?"></a>什么是模块化项目 ?</h3><blockquote><p>编码时是按照模块一个一个编码的， 整个项目就是一个模块化的项目</p></blockquote><h3 id="模块化好处"><a href="#模块化好处" class="headerlink" title="模块化好处"></a>模块化好处</h3><p>下面是模块化的一些好处：</p><ol><li><p>防止命名冲突</p></li><li><p>高复用性</p></li><li><p>高维护性</p></li></ol><h2 id="模块暴露数据"><a href="#模块暴露数据" class="headerlink" title="模块暴露数据"></a>模块暴露数据</h2><h3 id="模块初体验"><a href="#模块初体验" class="headerlink" title="模块初体验"></a>模块初体验</h3><p>可以通过下面的操作步骤，快速体验模块化</p><ol><li><p>创建 me.js</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//声明函数</span><span class="token keyword">function</span> <span class="token function">tiemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'贴膜....'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//暴露数据</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> tiemo<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建 index.js</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//导入模块</span><span class="token keyword">const</span> tiemo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./me.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用函数</span><span class="token function">tiemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//=> 贴膜....</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="暴露数据"><a href="#暴露数据" class="headerlink" title="暴露数据"></a>暴露数据</h3><p>模块暴露数据的方式有两种：</p><ol><li><p><code>module.exports</code> &#x3D; value</p></li><li><p><code>exports.name</code> &#x3D; value</p></li></ol><blockquote><p>使用时有几点注意：</p><ul><li><code>module.exports</code> 可以暴露 <span style="color:red">任意</span> 数据</li><li>不能使用 <code>exports = value</code> 的形式暴露数据，模块内部 module 与 exports 的隐式关系<br><code>exports = module.exports = &#123;&#125;</code> ，require 返回的是目标模块中 <code>module.exports</code> 的值</li></ul></blockquote><p><img src="/2023/06/30/node.js-zhong-de-mo-kuai-hua/a40a41f72dee15ee4d3e3cabd91ec9c2df2fa090.jpg" alt="05_NodeJS模块化"></p><h2 id="导入（引入）模块"><a href="#导入（引入）模块" class="headerlink" title="导入（引入）模块"></a>导入（引入）模块</h2><p>在模块中使用 require 传入文件路径即可引入文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./me.js'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>require 使用的一些注意事项：</p><ol><li><p>对于自己创建的模块，导入时路径建议写 <span style="color:red">相对路径</span>，且不能省略 <code>./</code> 和 <code>../</code></p></li><li><p><code>js</code> 和 <code>json</code> 文件导入时可以不用写后缀，c&#x2F;c++编写的 <code>node</code> 扩展文件也可以不写后缀，但是一般用不到，直接使用 <strong>node</strong> 的 <code>require()</code> 方法即可将 JSON 文件转换成 JS 对象</p></li><li><p>如果导入其他类型的文件，会以 <code>js</code> 文件进行处理</p></li><li><p>如果导入的路径是个文件夹，则会 <span style="color:red">首先</span> 检测该文件夹下 <code>package.json</code> 文件中 <code>main</code> 属性对应的文件，</p><p>如果存在则导入，反之如果文件不存在会报错。</p><p>如果 main 属性不存在，或者 package.json 不存在，则会尝试导入文件夹下的 <code>index.js</code> 和<br><code>index.json</code>，</p><p>如果还是没找到，就会报错</p></li><li><p>导入 node.js 内置模块时，直接 require 模块的名字即可，无需加 <code>./</code> 和 <code>../</code></p></li></ol><h2 id="导入模块的基本流程"><a href="#导入模块的基本流程" class="headerlink" title="导入模块的基本流程"></a>导入模块的基本流程</h2><p>这里我们介绍一下 <code>require</code> 导入 <span style="color:red">自定义模块</span> 的基本流程</p><ol><li>将相对路径转为绝对路径，定位目标文件</li><li>缓存检测</li><li>读取目标文件代码</li><li>包裹为一个函数并执行（自执行函数）。通过 <code>arguments.callee.toString()</code> 查看自执行函数</li><li>缓存模块的值</li><li>返回 <code>module.exports</code> 的值</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/** * 伪代码 */</span><span class="token keyword">function</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token parameter">file</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//1. 将相对路径转为绝对路径，定位目标文件</span>  <span class="token keyword">let</span> absolutePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2. 缓存检测</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>caches<span class="token punctuation">[</span>absolutePath<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> caches<span class="token punctuation">[</span>absolutePath<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//3. 读取文件的代码</span>  <span class="token keyword">let</span> code <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>absolutePath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//4. 包裹为一个函数 然后执行</span>  <span class="token keyword">let</span> module <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> exports <span class="token operator">=</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'尚硅谷'</span>    <span class="token punctuation">&#125;</span>      module<span class="token punctuation">.</span>exports <span class="token operator">=</span> test<span class="token punctuation">;</span>      <span class="token comment">//输出</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>callee<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname<span class="token punctuation">)</span>  <span class="token comment">//5. 缓存结果</span>  caches<span class="token punctuation">[</span>absolutePath<span class="token punctuation">]</span> <span class="token operator">=</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>  <span class="token comment">//6. 返回 module.exports 的值</span>  <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/06/30/node.js-zhong-de-mo-kuai-hua/5b1f2533d8071dd34751737864e20362539418d1.jpg" alt="05_NodeJS模块化"></p><h2 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h2><p><code>module.exports</code> 、<code>exports</code> 以及 <code>require</code> 这些都是 <code>CommonJS</code> 模块化规范中的内容。</p><p>而 Node.js 是实现了 CommonJS 模块化规范，二者关系有点像 JavaScript 与 ECMAScript</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中的浮动与定位</title>
      <link href="/2023/06/28/css-zhong-de-fu-dong-yu-ding-wei/"/>
      <url>/2023/06/28/css-zhong-de-fu-dong-yu-ding-wei/</url>
      
        <content type="html"><![CDATA[<h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><h2 id="元素浮动后的特点"><a href="#元素浮动后的特点" class="headerlink" title="元素浮动后的特点"></a>元素浮动后的特点</h2><ol><li>🤢脱离文档流。</li><li>😊不管浮动前是什么元素，浮动后：默认宽与高都是被内容<strong>撑开</strong>（尽可能小），而且可以设置宽高。</li><li>😊不会独占一行，可以与其他元素共用一行。</li><li>😊不会 <code>margin</code> 合并，也不会 <code>margin</code> 塌陷，能够完美的设置四个方向的 <code>margin</code> 和 <code>padding</code> 。</li><li>😊不会像行内块一样被当做文本处理（没有行内块的空白问题）。</li></ol><h2 id="浮动产生的影响及解决方案"><a href="#浮动产生的影响及解决方案" class="headerlink" title="浮动产生的影响及解决方案"></a>浮动产生的影响及解决方案</h2><h3 id="产生影响"><a href="#产生影响" class="headerlink" title="产生影响"></a>产生影响</h3><p>对兄弟元素的影响： 后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟<br>无影响。<br>对父元素的影响： 不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽度依然束缚浮动的元<br>素。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>方案一： 给父元素指定高度。</p></li><li><p>方案二： 给父元素也设置浮动，带来其他影响。</p></li><li><p>方案三： 给父元素设置 <code>overflow: hidden</code> 。</p></li><li><p>方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 <code>clear: both</code> 。</p></li><li><p>方案五： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;&#x3D;&#x3D;&gt; 推荐使用</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">.parent::after &#123;content: &quot;&quot;;display: block;clear:both;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>布局中的一个原则：设置浮动的时候，<strong>兄弟元素要么全都浮动，要么全都不浮动。</strong></p></blockquote><h2 id="浮动相关属性"><a href="#浮动相关属性" class="headerlink" title="浮动相关属性"></a>浮动相关属性</h2><table><thead><tr><th>CSS 属性</th><th>功能</th><th>属性值</th></tr></thead><tbody><tr><td><code>float</code></td><td>设置浮动</td><td><code>left</code> : 设置左浮动<br/><code>right</code> : 设置右浮动<br/><code>none</code> ：不浮动，默认值</td></tr><tr><td><code>clear</code></td><td>清除浮动<br/>清除前面兄弟元素浮动元素的响应</td><td><code>left</code> ：清除前面左浮动的影响<br/><code>right</code> ：清除前面右浮动的影响<br/><code>both</code> ：清除前面左右浮动的影响</td></tr></tbody></table><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><h3 id="如何设置相对定位"><a href="#如何设置相对定位" class="headerlink" title="如何设置相对定位"></a>如何设置相对定位</h3><ul><li>给元素设置 <code>position: relative</code> 即可实现相对定位。</li><li>可以使用 <code>left</code> 、 <code>right</code> 、 <code>top</code> 、 <code>bottom</code> 四个属性调整位置。</li></ul><h3 id="相对定位的参考点"><a href="#相对定位的参考点" class="headerlink" title="相对定位的参考点"></a>相对定位的参考点</h3><ul><li>相对自己原来的位置</li></ul><h3 id="相对定位元素的特点"><a href="#相对定位元素的特点" class="headerlink" title="相对定位元素的特点"></a>相对定位元素的特点</h3><ol><li><strong>不会脱离文档流</strong>，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。</li><li>定位元素的显示<strong>层级</strong>比普通元素高，无论什么定位，显示层级都是一样的。</li><li>默认规则是：<ul><li>定位的元素会盖在普通元素之上。</li><li>都发生定位的两个元素，后写的元素会盖在先写的元素之上。</li></ul></li><li><code>left</code> 不能和 <code>right</code> 一起设置， <code>top</code> 和 <code>bottom</code> 不能一起设置（通常情况下）。</li><li>相对定位的元素，也能继续浮动，但不推荐这样做。</li><li>相对行为的元素，也能通过 <code>margin</code> 调整位置，但不推荐这样做。</li></ol><blockquote><p>注意：绝大多数情况下，相对定位，会与绝对定位配合使用。</p></blockquote><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><h3 id="如何设置绝对定位"><a href="#如何设置绝对定位" class="headerlink" title="如何设置绝对定位"></a>如何设置绝对定位</h3><ul><li>给元素设置 <code>position: absolute</code> 即可实现绝对定位。</li><li>可以使用 <code>left</code> 、 <code>right</code> 、 <code>top</code> 、 <code>bottom</code> 四个属性调整位置。</li></ul><h3 id="绝对定位的参考点"><a href="#绝对定位的参考点" class="headerlink" title="绝对定位的参考点"></a>绝对定位的参考点</h3><ul><li><p>参考它的包含块。</p><blockquote><p>什么是包含块？</p><ol><li>对于没有脱离文档流的元素：包含块就是父元素；</li><li>对于脱离文档流的元素：包含块是第一个拥有定位属性的祖先元素（如果所有祖先都没定位，那包含块就是整个页面）。</li></ol></blockquote></li></ul><h3 id="绝对定位元素的特点"><a href="#绝对定位元素的特点" class="headerlink" title="绝对定位元素的特点"></a>绝对定位元素的特点</h3><ol><li><p><strong>脱离文档流</strong>，会对后面的兄弟元素、父元素有影响。</p></li><li><p><code>left</code> 不能和 <code>right</code> 一起设置， <code>top</code> 和 <code>bottom</code> 不能一起设置（通常情况下）。</p></li><li><p>绝对定位、浮动不能同时设置，如果同时设置，浮动失效，以定位为主。</p></li><li><p>绝对定位的元素，也能通过 <code>margin</code> 调整位置，但不推荐这样做。</p></li><li><p>无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了定位元素。</p><blockquote><p>何为定位元素？ —— <strong>默认宽、高都被<u>内容</u>所撑开，且能自由设置宽高。</strong></p></blockquote></li></ol><h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><h3 id="如何设置固定定位"><a href="#如何设置固定定位" class="headerlink" title="如何设置固定定位"></a>如何设置固定定位</h3><ul><li>给元素设置 <code>position: fixed</code> 即可实现固定定位。</li><li>可以使用 <code>left</code> 、 <code>right</code> 、 <code>top</code> 、 <code>bottom</code> 四个属性调整位置。</li></ul><h3 id="固定定位的参考点"><a href="#固定定位的参考点" class="headerlink" title="固定定位的参考点"></a>固定定位的参考点</h3><ul><li><p>参考它的视口</p><blockquote><p>什么是视口？—— 对于 PC 浏览器来说，视口就是我们看网页的那扇“窗户”。</p></blockquote></li></ul><h3 id="固定定位元素的特点"><a href="#固定定位元素的特点" class="headerlink" title="固定定位元素的特点"></a>固定定位元素的特点</h3><ol><li><strong>脱离文档流</strong>，会对后面的兄弟元素、父元素有影响。</li><li><code>left</code> 不能和 <code>right</code> 一起设置， <code>top</code> 和 <code>bottom</code> 不能一起设置。</li><li>固定定位和浮动不能同时设置，如果同时设置，浮动失效，以固定定位为主。</li><li>固定定位的元素，也能通过 <code>margin</code> 调整位置，但不推荐这样做。</li><li>无论是什么元素（行内、行内块、块级）设置为固定定位之后，都变成了定位元素。</li></ol><h2 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h2><h3 id="如何设置粘性定位"><a href="#如何设置粘性定位" class="headerlink" title="如何设置粘性定位"></a>如何设置粘性定位</h3><ul><li>给元素设置 <code>position: sticky</code> 即可实现粘性定位。</li><li>可以使用 <code>left</code> 、 <code>right</code> 、 <code>top</code> 、 <code>bottom</code> 四个属性调整位置，不过最常用的是 <code>top</code> 值。</li></ul><h3 id="粘性定位的参考点"><a href="#粘性定位的参考点" class="headerlink" title="粘性定位的参考点"></a>粘性定位的参考点</h3><ul><li>离它最近的一个拥有“滚动机制”的祖先元素，即便这个祖先不是最近的真实可滚动祖先。</li></ul><h3 id="粘性定位元素的特点"><a href="#粘性定位元素的特点" class="headerlink" title="粘性定位元素的特点"></a>粘性定位元素的特点</h3><ul><li><strong>不会脱离文档流</strong>，它是一种专门用于<strong>窗口滚动时</strong>的新的定位方式。</li><li>最常用的值是 <code>top</code> 值。</li><li>粘性定位和浮动可以同时设置，但不推荐这样做。</li><li>粘性定位的元素，也能通过 <code>margin</code> 调整位置，但不推荐这样做。</li></ul><blockquote><p>粘性定位和相对定位的特点基本一致，不同的是：粘性定位可以在元素到达某个位置时将其固定。</p></blockquote><h2 id="定位层级"><a href="#定位层级" class="headerlink" title="定位层级"></a>定位层级</h2><ol><li>定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。</li><li>如果位置发生重叠，默认情况是：后面的元素，会显示在前面元素之上。</li><li>可以通过 CSS 属性  <code>z-index</code> 调整元素的显示层级。</li><li>z-index 的属性值是数字，没有单位，值越大显示层级越高。</li><li>只有定位的元素设置 <code>z-index</code> 才有效。</li><li><strong>如果 <code>z-index</code> 值大的元素，依然没有覆盖掉 <code>z-index</code> 值小的元素，那么请检查其包含块的层级。</strong></li></ol><h2 id="定位的特殊应用"><a href="#定位的特殊应用" class="headerlink" title="定位的特殊应用"></a>定位的特殊应用</h2><blockquote><p>注意：</p><ol><li>发生固定定位、绝对定位后，元素都变成了定位元素，默认宽高被内容撑开，且依然可以设置宽高。</li><li>发生相对定位后，元素依然是之前的显示模式。</li><li>以下所说的特殊应用，只针对 <strong>绝对定位</strong> 和 <strong>固定定位</strong> 的元素，不包括相对定位的元素。</li></ol></blockquote><h3 id="让定位元素的宽充满包含块"><a href="#让定位元素的宽充满包含块" class="headerlink" title="让定位元素的宽充满包含块"></a>让定位元素的宽充满包含块</h3><ol><li>块宽想与包含块一致，可以给定位元素同时设置 <code>left</code> 和 <code>right</code> 为 <code>0</code> 。</li><li>高度想与包含块一致， <code>top</code> 和 <code>bottom</code> 设置为 <code>0</code> 。</li></ol><h3 id="让定位元素在包含块中居中"><a href="#让定位元素在包含块中居中" class="headerlink" title="让定位元素在包含块中居中"></a>让定位元素在包含块中居中</h3><ul><li><p>方案一</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">left</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token property">right</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token property">top</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token property">bottom</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span>auto<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方案二（不推荐，因为不太方便之后的计算）</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">left: 50%;top: 50%;margin-left: 负的宽度一半;margin-top: 负的高度一半;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>注意：<strong>该定位的元素必须设置宽高！</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js常用模块详解</title>
      <link href="/2023/06/27/node.js-chang-yong-mo-kuai-xiang-jie/"/>
      <url>/2023/06/27/node.js-chang-yong-mo-kuai-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Buffer（缓冲器）"><a href="#Buffer（缓冲器）" class="headerlink" title="Buffer（缓冲器）"></a>Buffer（缓冲器）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Buffer 是一个类似于数组的 <code>对象</code> ，用于表示固定长度的字节序列</p><p>Buffer 本质是一段内存空间，专门用来处理 <code>二进制数据</code> 。</p><p><img src="/2023/06/27/node.js-chang-yong-mo-kuai-xiang-jie/e63bd2526bce2f0bbc003f3d0e122915459d9f2b.png" alt="image-20230320173023659"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>Buffer 大小固定且无法调整</li><li>Buffer 性能较好，可以直接对计算机内存进行操作</li><li>每个元素的大小为 1 字节（byte）</li></ol><p><img src="/2023/06/27/node.js-chang-yong-mo-kuai-xiang-jie/1f67ed9e1b8884786dafcc4deb804f96234af9f4.png" alt="image-20230320173043532"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="创建Buffer"><a href="#创建Buffer" class="headerlink" title="创建Buffer"></a>创建Buffer</h4><p>Node.js 中创建 Buffer 的方式主要如下几种：</p><ol><li><p><code>Buffer.alloc</code></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 创建了一个长度为 10 字节的 Buffer，相当于申请了 10 字节的内存空间，每个字节的值为 0let buf_1 &#x3D; Buffer.alloc(10) &#x2F;&#x2F;&#x3D;&gt;结果为&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>Buffer.allocUnsafe</code></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 创建了一个长度为 10 字节的 Buffer，buffer 中可能存在旧数据，可能会影响执行结果，所以叫 unsafe ，但是效率比 alloc 高let buf_2 &#x3D; Buffer.allocUnsafe(10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>Buffer.from</code></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 通过字符串创建 Bufferlet buf_3 &#x3D; Buffer.from(&#39;hello&#39;)&#x2F;&#x2F; 通过数组创建 Bufferlet buf_4 &#x3D; Buffer.from([105, 108, 111, 118, 101, 121, 111, 117])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="Buffer与字符串的转化"><a href="#Buffer与字符串的转化" class="headerlink" title="Buffer与字符串的转化"></a>Buffer与字符串的转化</h4><blockquote><p>我们可以借助 <code>toString</code> 方法将 Buffer 转为字符串</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let buf_4 &#x3D; Buffer.from([105, 108, 111, 118, 101, 121, 111, 117])console.log(buf_4.toString()) &#x2F;&#x2F;&#x3D;&gt;iloveyou<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>**注意: **<code>toString</code> 默认是按照 <code>utf-8</code> 编码方式进行转换的</p><h4 id="Buffer-的读写"><a href="#Buffer-的读写" class="headerlink" title="Buffer 的读写"></a>Buffer 的读写</h4><blockquote><p>Buffer 可以直接通过 <code>[]</code> 的方式对数据进行处理。</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let buf_3 &#x3D; Buffer.from(&#39;hello&#39;)&#x2F;&#x2F; 读取console.log(buf_3[1]) &#x2F;&#x2F;&#x3D;&gt;101&#x2F;&#x2F; 修改buf_3[1] &#x3D; 97&#x2F;&#x2F;查看字符串结果console.log(buf_3.toString()) &#x2F;&#x2F;&#x3D;&gt;hallo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意:</strong></p><ol><li>如果修改的数值超过 <code>255</code> ，则超过 <code>8</code> 位数据会被舍弃</li><li>一个 <code>utf-8</code> 的字符 一般 占3个字节</li></ol></blockquote><h2 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h2><blockquote><p>fs 全称为 <code>file system</code> ，称之为 <code>文件系统</code> ，是 Node.js 中的 <code>内置模块</code> ，可以对计算机中的磁盘进行操作。</p></blockquote><p>本章节会介绍如下几个操作：</p><ol><li>文件写入</li><li>文件读取</li><li>文件移动与重命名</li><li>文件删除</li><li>文件夹操作</li><li>查看资源状态</li></ol><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><blockquote><p>文件写入就是将 数据 保存到 文件 中，我们可以使用如下几个方法来实现该效果</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>writeFile</td><td>异步写入</td></tr><tr><td>writeFileSync</td><td>同步写入</td></tr><tr><td>appendFile &#x2F; appendFileSync</td><td>追加写入</td></tr><tr><td>createWriteStream</td><td>流式写入</td></tr></tbody></table><h4 id="writeFile-异步写入"><a href="#writeFile-异步写入" class="headerlink" title="writeFile 异步写入"></a>writeFile 异步写入</h4><p><strong>语法</strong>： <code>fs.writeFile(file, data[, options], callback)</code></p><p><strong>参数说明</strong>：</p><ul><li>file 文件名</li><li>data 待写入的数据</li><li>options 选项设置 <code>（可选）</code></li><li>callback 写入回调</li></ul><p><strong>返回值</strong>： <code>undefined</code></p><p><strong>代码示例</strong>：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; require 是 Node.js 环境中的 &#39;全局&#39; 变量，用来导入模块const fs &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F; 将 [三人行，必有我师焉。] 写入到当前文件夹下的 [座右铭.txt] 文件中fs.writeFile(&#39;.&#x2F;座右铭.txt&#39;, &#39;三人行，必有我师焉。&#39;, err &#x3D;&gt;&#123;    &#x2F;&#x2F; 如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null    if(err)&#123;        console.log(err)        return    &#125;    console.log(&#39;写入成功&#39;)  &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="writeFileSync-同步写入"><a href="#writeFileSync-同步写入" class="headerlink" title="writeFileSync 同步写入"></a>writeFileSync 同步写入</h4><p><strong>语法:</strong> <code>fs.writeFileSync(file, data[, options])</code></p><p>参数与 <code>fs.writeFile</code> 大体一致，只是没有 callback 参数</p><p><strong>返回值：</strong><code>undefined</code></p><p>代码示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">try&#123;    fs.writeFileSync(&#39;.&#x2F;座右铭.txt&#39;, &#39;三人行，必有我师焉。&#39;)&#125;catch(e)&#123;    console.log(e)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Node.js 中的磁盘操作是由其他 <code>线程</code> 完成的，结果的处理有两种模式:</p><ul><li>同步处理 JavaScript 主线程 <code>会等待</code> 其线程的执行结果，然后再继续执行主线程的代码，<code>效率较低</code></li><li>异步处理 JavaScript 主线程 <code>不会等待</code> 其线程的执行结果，直接执行后续的主线程代码，<code>效率较好</code></li></ul></blockquote><h4 id="appendFile-x2F-appendFileSync-追加写入"><a href="#appendFile-x2F-appendFileSync-追加写入" class="headerlink" title="appendFile &#x2F; appendFileSync 追加写入"></a>appendFile &#x2F; appendFileSync 追加写入</h4><blockquote><p><code>appendFile</code> 作用是在文件尾部追加内容，<code>appendFile</code> 语法与 <code>writeFile</code> 语法完全相同</p></blockquote><p><strong>语法</strong>:</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.appendFile(file, data[, options], callback)fs.appendFileSync(file, data[, options])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>返回值</strong>：二者都为 <code>undefined</code></p><p>实例代码：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.append(&#39;.&#x2F;座右铭.txt&#39;, &#39;则其善者而从之，其不善者而改之。&#39;, err &#x3D;&gt;&#123;    if(err) throw err    console.log(&#39;追加成功&#39;)&#125;)fs.appendFileSync(&#39;.&#x2F;座右铭.txt&#39;,&#39;\r\n温故而知新，可以为师矣&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="createWriteStream-流式写入"><a href="#createWriteStream-流式写入" class="headerlink" title="createWriteStream 流式写入"></a>createWriteStream 流式写入</h4><p><strong>语法</strong>：<code>fs.createWriteStream(path[, options])</code></p><p><strong>参数说明</strong>：</p><ul><li><code>path</code> 文件路径</li><li><code>options</code> 选项配置（ <code>可选</code> ）</li></ul><p>**返回值: **<code>Object</code></p><p>代码示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let ws &#x3D; fs.createWriteStream(&#39;.&#x2F;观书有感.txt&#39;)&#x2F;&#x2F;写入数据到流ws.write(&#39;半亩方塘一鉴开\r\n&#39;)ws.write(&#39;天光云影共徘徊\r\n&#39;)ws.write(&#39;问渠那得清如许\r\n&#39;)ws.write(&#39;为有源头活水来\r\n&#39;)&#x2F;&#x2F;关闭写入流，表明已没有数据要被写入可写流ws.end()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数。</p><p>流式写入方式适用于 大文件写入或者频繁写入的场景，<code>writeFile</code>适合于写入频率较低的场景</p></blockquote><h4 id="写入文件的场景"><a href="#写入文件的场景" class="headerlink" title="写入文件的场景"></a>写入文件的场景</h4><p><code>文件写入</code> 在计算机中是一个非常常见的操作，下面的场景都用到了文件写入</p><ul><li>下载文件</li><li>安装软件</li><li>保存程序日志，如 Git</li><li>编辑器保存文件</li><li>视频录制</li></ul><blockquote><p>当 需要持久化保存数据 的时候，应该想到 <code>文件写入</code></p></blockquote><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><blockquote><p>文件读取顾名思义，就是通过程序从文件中取出其中的数据，我们可以使用如下几种方式：</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>readFile</td><td>异步读取</td></tr><tr><td>readFileSync</td><td>同步读取</td></tr><tr><td>createReadStream</td><td>流式读取</td></tr></tbody></table><h4 id="readFile-异步读取"><a href="#readFile-异步读取" class="headerlink" title="readFile 异步读取"></a>readFile 异步读取</h4><p><strong>语法</strong>: <code>fs.readFile(path[, options], callback)</code></p><p><strong>参数说明</strong>：</p><ul><li>path 文件路径</li><li>options 选项配置</li><li>callback 回调函数</li></ul><p><strong>返 回 值 ：</strong> <code>undefined</code></p><p>代码示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 导入 fs 模块fs.readFile(&#39;.&#x2F;座右铭.txt&#39;, (error,data) &#x3D;&gt;&#123;    if(err) throw err    console.log(data)&#125;)fs.readFile(&#39;.&#x2F;座右铭.txt&#39;, &#39;uft-8&#39;, (error,data) &#x3D;&gt;&#123;    if(err) throw err    console.log(data)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="readFileSync-同步读取"><a href="#readFileSync-同步读取" class="headerlink" title="readFileSync 同步读取"></a>readFileSync 同步读取</h4><p><strong>语法：</strong><code>fs.readFileSync(path[, options])</code></p><p><strong>参数说明：</strong></p><ul><li>path 文件路径</li><li>options 选项配置</li></ul><p><strong>返 回 值 ：</strong><code>string | Buffer</code></p><p>代码示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let data &#x3D; fs.readFileSync(&#39;.&#x2F;座右铭.txt&#39;)let data &#x3D; fs.readFileSync(&#39;.&#x2F;座右铭.txt&#39;, &#39;utf-8&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="createReadStream-流式读取"><a href="#createReadStream-流式读取" class="headerlink" title="createReadStream 流式读取"></a>createReadStream 流式读取</h4><p><strong>语法：</strong><code>fs.createReadStream(path[, options])</code></p><p><strong>参数说明：</strong></p><ul><li>path 文件路径</li><li>options 选项配置（ <code>可选</code> ）</li></ul><p><strong>返回值：</strong><code>Object</code></p><p>代码示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 创建读取流对象let rs &#x3D; fs.createReadStream(&#39;.&#x2F;观书有感.txt&#39;)&#x2F;&#x2F; 每次取出 64k 数据后执行一次 data 回调&#x2F;&#x2F; 绑定一个 data 事件  chunk 块儿  大块儿re.on(&#39;data&#39;, chunk &#x3D;&gt;&#123;    console.log(chunk)    console.log(chunk.length)&#125;)&#x2F;&#x2F; 读取完毕后，执行 end 回调 (可选事件)re.on(&#39;end&#39;, () &#x3D;&gt;&#123;    console.log(&#39;读取完毕&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件移动与重命名"><a href="#文件移动与重命名" class="headerlink" title="文件移动与重命名"></a>文件移动与重命名</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>rename</code> 或 <code>renameSync</code> 来移动或重命名 <code>文件或文件夹</code></p></blockquote><p><strong>语法：</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.rename(oldPath, newPath, callback)fs.renameSync(oldPath, newPath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数说明：</strong></p><ul><li>oldPath 文件当前的路径</li><li>newPath 文件新的路径</li><li>callback 操作后的回调</li></ul><p>代码示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.rename(&#39;.&#x2F;观书有感.txt&#39;, &#39;.&#x2F;论语&#x2F;观书有感.txt&#39;, err &#x3D;&gt;&#123;if(err) throw err    console.log(&#39;移动完成&#39;)&#125;)fs.renameSync(&#39;.&#x2F;座右铭.txt&#39;, &#39;.&#x2F;论语&#x2F;.我的座右铭.txt&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注</strong>: 如果还是移动到当前路径，但是修改了名字，就是重命名了</p><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>unlink</code> 或 <code>unlinkSync</code> 来删除文件</p></blockquote><p><strong>语法:</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.unlink(path, callback)fs.unlinkSync(path)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数说明</strong>：</p><ul><li>path 文件路径</li><li>callback 操作后的回调</li></ul><p>代码示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const fs &#x3D; require(&#39;fs&#39;)fs.unlink(&#39;.&#x2F;test.txt&#39;, err &#x3D;&gt;&#123;    if(err) throw err    console.log(&#39;删除成功&#39;)&#125;)fs.unlinkSync(&#39;.&#x2F;test2.txt&#39;)&#x2F;&#x2F; 调用 rm 方法  14.4   同步 rmSyncfs.rm(&#39;.&#x2F;论语.txt&#39;, err &#x3D;&gt; &#123;  if (err) &#123;    console.log(&#39;删除失败&#39;)    return  &#125;  console.log(&#39;删除成功&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><blockquote><p>借助 Node.js 的能力，我们可以对文件夹进行 <code>创建</code> 、<code>读取</code> 、<code>删除</code> 等操作</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>mkdir &#x2F; mkdirSync</td><td>创建文件夹</td></tr><tr><td>readdir &#x2F; readdirSync</td><td>读取文件夹</td></tr><tr><td>rmdir &#x2F; rmdirSync</td><td>删除文件夹</td></tr></tbody></table><h3 id="mkdir-创建文件夹"><a href="#mkdir-创建文件夹" class="headerlink" title="mkdir 创建文件夹"></a>mkdir 创建文件夹</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>mkdir</code> 或 <code>mkdirSync</code> 来创建文件夹</p></blockquote><p><strong>语法</strong>:</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.mkdir(path[, options], callback)fs.mkdirSync(path[, options])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数说明</strong>：</p><ul><li>path 文件夹路径</li><li>options 选项配置（ <code>可选</code> ）</li><li>callback 操作后的回调</li></ul><p>示例代码：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 异步创建文件夹  mk  make  制作   dir  directory  文件夹fs.mkdir(&#39;.&#x2F;page&#39;, err &#x3D;&gt;&#123;    if(err) throw err    console.log(&#39;创建成功&#39;)&#125;)&#x2F;&#x2F; 递归异步创建fs.mkdir(&#39;.&#x2F;1&#x2F;2&#x2F;3&#39;, &#123;recursive: true&#125;, err &#x3D;&gt;&#123;    if(err) throw err    console.log(&#39;递归创建成功&#39;)&#125;)&#x2F;&#x2F; 递归同步创建文件夹fs.mkdirSync(&#39;.&#x2F;x&#x2F;y&#x2F;z&#39;, &#123;recursive: true&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="readdir-读取文件夹"><a href="#readdir-读取文件夹" class="headerlink" title="readdir 读取文件夹"></a>readdir 读取文件夹</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>readdir</code> 或 <code>readdirSync</code> 来读取文件夹</p></blockquote><p><strong>语法：</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.readdir(path[, options], callback)fs.readdirSync(path[, options])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数说明：</strong></p><ul><li>path 文件夹路径</li><li>options 选项配置（ <code>可选</code> ）</li><li>callback 操作后的回调</li></ul><p>示例代码：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 异步读取fs.readdir(&#39;.&#x2F;论语&#39;, (err, data) &#x3D;&gt; &#123;if(err) throw err    console.log(data)&#125;)&#x2F;&#x2F; 同步读取 let data &#x3D; fs.readdirSync(&#39;.&#x2F;论语&#39;)console.log(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="rmdir-删除文件夹"><a href="#rmdir-删除文件夹" class="headerlink" title="rmdir 删除文件夹"></a>rmdir 删除文件夹</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>rmdir</code> 或 <code>rmdirSync</code> 来删除文件夹</p></blockquote><p><strong>语法</strong>：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.rmdir(path[, options], callback)fs.redirSync(path[, options])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数说明</strong>：</p><ul><li>path 文件夹路径</li><li>options 选项配置（ 可选 ）</li><li>callback 操作后的回调</li></ul><p>示例代码：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 异步删除文件夹  rm  remove 移除fs.rmdir(&#39;.&#x2F;page&#39;, err &#x3D;&gt; &#123;    if(err) throw err    console.log(&#39;删除成功&#39;)&#125;)&#x2F;&#x2F;异步递归删除文件夹  不推荐&#x2F;&#x2F;&#x3D;&gt;DeprecationWarning: In future versions of Node.js, fs.rmdir(path, &#123; recursive: true &#125;) will be removed. Use fs.rm(path, &#123; recursive: true &#125;) insteadfs.rmdirSync(&#39;.&#x2F;1&#39;, &#123;recursive: true&#125;, err &#x3D;&gt; &#123;    if(err)&#123;     console.log(err)        return    &#125;    console.log(&#39;递归删除&#39;)&#125;)&#x2F;&#x2F;同步递归删除文件夹fs.rmdirSync(&#39;.&#x2F;x&#39;, &#123;recursive: true&#125;)&#x2F;&#x2F; 建议使用fs.rm(&#39;.&#x2F;a&#39;, &#123; recursive: true &#125;, err &#x3D;&gt; &#123;  if (err) &#123;    console.log(err)    return  &#125;  console.log(&#39;删除成功&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看资源状态"><a href="#查看资源状态" class="headerlink" title="查看资源状态"></a>查看资源状态</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>stat</code> 或 <code>statSync</code> 来查看资源的详细信息</p></blockquote><p><strong>语法</strong>：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fs.stat(path[, options], callback)fs.statSync(path[, options])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数说明</strong>：</p><ul><li>path 文件夹路径</li><li>options 选项配置（ 可选 ）</li><li>callback 操作后的回调</li></ul><p>示例代码：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 异步获取状态&#x2F;&#x2F; stat  方法  status 缩写 状态fs.stat(&#39;&#x2F;data.txt&#39;, (err, data) &#x3D;&gt;&#123;    if(err) throw err    console.log(data)&#125;)&#x2F;&#x2F; 同步获取状态let data &#x3D; fs.statSync(&#39;.&#x2F;data.txt&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果值对象结构</strong>：</p><ul><li>size 文件体积</li><li>birthtime 创建时间</li><li>mtime 最后修改时间</li><li>isFile 检测是否为文件</li><li>isDirectory 检测是否为文件夹</li><li>….</li></ul><h3 id="相对路径问题"><a href="#相对路径问题" class="headerlink" title="相对路径问题"></a>相对路径问题</h3><p>fs 模块对资源进行操作时，路径的写法有两种：</p><ul><li>相对路径<ul><li><code>./座右铭.txt</code> 当前目录下的 座右铭.txt</li><li><code>座右铭.txt</code> 等效于上面的写法</li><li><code>../座右铭.txt</code> 当前目录的上一级目录中的 座右铭.txt</li></ul></li><li>绝对路径<ul><li><code>D:/Program Files</code> windows 系统下的绝对路径</li><li><code>/user/bin</code> Linux 系统下的绝对路径</li></ul></li></ul><blockquote><p>相对路径中所谓的 <code>当前目录</code> ，指的是 <code>命名行的工作目录</code> ，而并非是文件的所在目录</p><p>所以当命名行的工作目录与文件所在目录不一致时，会出现一些 Bug</p></blockquote><h3 id="dirname"><a href="#dirname" class="headerlink" title="_dirname"></a>_dirname</h3><p><code>__dirname</code> 与 <code>require</code> 类似，都是 Node.js 环境中的 ‘全局’ 变量</p><p><code>__dirname</code> 保存着 当前文件夹所在目录的绝对路径，可以使用 <code>__dirname</code> 与文件名拼接成绝对路径</p><p>代码示例:</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F;&#x3D;&gt;__dirname + &#39;&#x2F;data.txt&#39;  &#x3D;&#x3D;&#x3D; &#39;D:\\Desktop\\Node\\code\\03-fs模块&#x2F;data.txt&#39;let data &#x3D; fs.readFileSync(__dirname + &#39;&#x2F;data.txt&#39;)console.log(data) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>使用 fs 模块的时候，尽量使用 <code>__dirname</code> 路径转换为绝对路径，这样可以避免相对路径产生的 Bug</strong></p></blockquote><h2 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h2><blockquote><p><code>path</code> 模块提供了 <code>操作路径</code> 的功能，我们将介绍如下几个较为常用的几个 API：</p></blockquote><table><thead><tr><th><strong>API</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>path.resolve</td><td>拼接规范的绝对路径 <code>常用</code></td></tr><tr><td>path.sep</td><td>获取操作系统的路径分隔符</td></tr><tr><td>path.parse</td><td>解析路径并返回对象</td></tr><tr><td>path.basename</td><td>获取路径的基础名称</td></tr><tr><td>path.dirname</td><td>获取路径的目录名</td></tr><tr><td>path.extname</td><td>获得路径的扩展名</td></tr></tbody></table><p>代码示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 导入 fs 模块const fs &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F; 导入 path 模块const path &#x3D; require(&#39;path&#39;)&#x2F;&#x2F; 写入文件&#x2F;&#x2F; fs.writeFileSync(__dirname + &#39;&#x2F;index.html&#39;, &#39;love&#39;)console.log(__dirname + &#39;&#x2F;index.html&#39;) &#x2F;&#x2F;&#x3D;&gt;D:\Desktop\Node\code\04-path&#x2F;index.html&#x2F;&#x2F; resolve 解决问题  拼接绝对路径console.log(path.resolve(__dirname, &#39;.&#x2F;index.html&#39;)) &#x2F;&#x2F;&#x3D;&gt;D:\Desktop\Node\code\04-path\index.htmlconsole.log(path.resolve(__dirname, &#39;index.html&#39;)) &#x2F;&#x2F;&#x3D;&gt;D:\Desktop\Node\code\04-path\index.htmlconsole.log(path.resolve(__dirname, &#39;&#x2F;index.html&#39;, &#39;.&#x2F;test&#39;)) &#x2F;&#x2F;&#x3D;&gt;D:\index.html\test&#x2F;&#x2F; sep 获取路径分隔符console.log(path.sep) &#x2F;&#x2F;&#x3D;&gt; window \  linux &#x2F;&#x2F;&#x2F; parse 方法  __filename  &#39;全局变量&#39;console.log(__filename) &#x2F;&#x2F;&#x3D;&gt;文件的绝对路径 &#x2F;&#x2F;&#x3D;&gt;D:\Desktop\Node\code\04-path\01-path.js&#x2F;&#x2F; 解析路径let str &#x3D; &#39;D:\\Desktop\\Node\\code\\04-path\\01-path.js&#39;console.log(path.parse(str))&#x2F;&#x2F; 获取路径基础名称console.log(path.basename(pathname))&#x2F;&#x2F; 获取路径的目录名console.log(path.dirname(pathname))&#x2F;&#x2F; 获取路径的拓展名console.log(path.extname(pathname))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><h3 id="创建-HTTP-服务"><a href="#创建-HTTP-服务" class="headerlink" title="创建 HTTP 服务"></a>创建 <strong>HTTP</strong> 服务</h3><p>使用 nodejs 创建 HTTP 服务</p><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//1. 导入 http 模块</span><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 创建服务对象 create 创建 server 服务</span><span class="token comment">// request 意为请求. 是对请求报文的封装对象, 通过 request 对象可以获得请求报文的数据</span><span class="token comment">// response 意为响应. 是对响应报文的封装对象, 通过 response 对象可以设置响应报文</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 设置响应体</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello HTTP server'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//=>返回结果是一个对象</span><span class="token comment">//3. 监听端口, 启动服务</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">9000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务已经启动, 端口 9000 监听中...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>http.createServer</code> 里的回调函数的执行时机： <span style="color:red">当接收到 HTTP 请求的时候，就会执行</span></p></blockquote><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p>命令行 <code>ctrl + c</code> 停止服务</p></li><li><p>当服务启动后，更新代码 <span style="color:red">必须重启服务才能生效</span></p></li><li><p>响应内容中文乱码的解决办法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 设置响应头</span>response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'content-type'</span><span class="token punctuation">,</span><span class="token string">'text/html;charset=utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>端口号被占用</p><p><code>Error: listen EADDRINUSE: address already in use :::9000</code></p><p>1）关闭当前正在运行监听端口的服务 （ <span style="color:red">使用较多</span> ）</p><p>2）修改其他端口号</p></li><li><p><code>HTTP</code> 协议<span style="color:red">默认端口</span>是 <code>80</code> 。<code>HTTPS</code> 协议的<span style="color:red">默认端口</span>是 <code>443</code>, HTTP 服务开发常用端口有 <code>3000</code>，<code>8080</code>，<code>8090</code>，<code>9000</code> 等</p></li></ol><blockquote><p>如果端口被其他程序占用，可以使用 <span style="color:red">资源监视器</span> 找到占用端口的程序，然后使用 <span style="color:red">任务管理器</span> 关闭对应的程序</p></blockquote><h3 id="获取-HTTP-请求报文"><a href="#获取-HTTP-请求报文" class="headerlink" title="获取 HTTP 请求报文"></a>获取 HTTP 请求报文</h3><table><thead><tr><th align="left">含义</th><th align="left">语法</th><th align="left">重点掌握</th></tr></thead><tbody><tr><td align="left">请求方法</td><td align="left"><code>request.method</code></td><td align="left">*****</td></tr><tr><td align="left">请求版本</td><td align="left"><code>request.httpVersion</code></td><td align="left"></td></tr><tr><td align="left">请求路径</td><td align="left"><code>request.url</code></td><td align="left">*****</td></tr><tr><td align="left">URL 路径</td><td align="left"><code>require(&#39;url&#39;).parse(request.url).pathname</code></td><td align="left">*****</td></tr><tr><td align="left">URL 查询字符串</td><td align="left"><code>require(&#39;url&#39;).parse(request.url,  true).query</code></td><td align="left">*****</td></tr><tr><td align="left">请求头</td><td align="left"><code>request.headers</code></td><td align="left">*****</td></tr><tr><td align="left">请求体</td><td align="left">request.on(‘data’, function(chunk){})<br>request.on(‘end’, function(){})</td><td align="left"></td></tr></tbody></table><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 1. 导入 http 模块const http &#x3D; require(&#39;http&#39;)&#x2F;&#x2F; 2. 创建服务对象const server &#x3D; http.createServer((request, response) &#x3D;&gt; &#123;  &#x2F;&#x2F; 获取请求的方法  console.log(request.method)  &#x2F;&#x2F;&#x3D;&gt;GET  &#x2F;&#x2F; 获取请求的 url  console.log(request.url)  &#x2F;&#x2F; 只包含 url 中的 路径 与查询字符串  &#x2F;&#x2F; 获取 http 协议的版本号  console.log(request.httpVersion)  &#x2F;&#x2F;&#x3D;&gt; 1.1  &#x2F;&#x2F; 获取 http 的请求头  console.log(request.headers) &#x2F;&#x2F;&#x3D;&gt;结果是一个对象  response.end(&#39;http&#39;) &#x2F;&#x2F;&#x3D;&gt;设置响应体&#125;)&#x2F;&#x2F; 3. 监听端口，启动服务server.listen(9000, () &#x3D;&gt; &#123;  console.log(&#39;服务已经启动...&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项：</strong> </p><ol><li><code>request.url</code> 只能获取路径以及查询字符串，无法获取 URL 中的域名以及协议的内容</li><li><code>request.headers</code> 将请求信息转化成一个对象，并将属性名都转化成了『小写』</li><li>关于路径：如果访问网站的时候，只填写了 IP 地址或者是域名信息，此时请求的路径为『 <code>/</code> 』</li><li>关于 <code>favicon.ico</code>：这个请求是属于浏览器自动发送的请求</li></ol><h4 id="提取-http-报文中-url的路径-与-查询字符串"><a href="#提取-http-报文中-url的路径-与-查询字符串" class="headerlink" title="提取 http 报文中 url的路径 与 查询字符串"></a>提取 http 报文中 url的路径 与 查询字符串</h4><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 导入 http 模块const http &#x3D; require(&#39;http&#39;)&#x2F;&#x2F; 创建服务对象const server &#x3D; http.createServer((request, response) &#x3D;&gt; &#123;  &#x2F;&#x2F; 实例化 url 对象  &#x2F;&#x2F; let url &#x3D; new URL(&#39;&#x2F;search?a&#x3D;100&amp;b&#x3D;200&#39;,&#39;http:&#x2F;&#x2F;127.0.0.1:9000&#39;)  let url &#x3D; new URL(request.url, &#39;http:&#x2F;&#x2F;127.0.0.1&#39;)  console.log(url)  &#x2F;&#x2F;&#x3D;&gt;如图所示，为一个对象  &#x2F;&#x2F; 输出路径  console.log(url.pathname)  &#x2F;&#x2F;&#x3D;&gt;&#x2F;search  &#x2F;&#x2F; 输出 keyword 查询字符串  console.log(url.searchParams.get(&#39;a&#39;))  &#x2F;&#x2F;&#x3D;&gt; 100  response.end(&#39;url new&#39;)&#125;)&#x2F;&#x2F; 监听端口，启动服务server.listen(9000, () &#x3D;&gt; &#123;  console.log(&#39;服务已经启动...&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/06/27/node.js-chang-yong-mo-kuai-xiang-jie/image-20230630230206865.png" alt="image-20230630230206865"></p><h3 id="设置-HTTP-响应报文"><a href="#设置-HTTP-响应报文" class="headerlink" title="设置 HTTP 响应报文"></a>设置 <strong>HTTP</strong> 响应报文</h3><h2 id=""><a href="#" class="headerlink" title=""></a></h2><table><thead><tr><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>设置响应状态码</td><td>response.statusCode</td></tr><tr><td>设置响应状态描述</td><td>response.statusMessage （ 用的非常少 ）</td></tr><tr><td>设置响应头信息</td><td>response.setHeader(‘头名’, ‘头值’)  (<code>可以自定义</code>)</td></tr><tr><td>设置响应体</td><td>response.write(‘xx’)<br/>response.end(‘xxx’)</td></tr></tbody></table><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 1. 设置响应状态码response.statusCode &#x3D; 203&#x2F;&#x2F; 2. 响应状态的描述response.statusMessage &#x3D; &#39;i love you&#39;&#x2F;&#x2F; 3. 响应头response.setHeader(&#39;content-type&#39;, &#39;text&#x2F;html;charset&#x3D;utf-8&#39;)&#x2F;&#x2F; 自定义响应头response.setHeader(&#39;myHeader&#39;, &#39;test test&#39;)&#x2F;&#x2F; 设置多个同名的响应头response.setHeader(&#39;test&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; write 和 end 的两种使用情况：&#x2F;&#x2F; 1. write 和 end 的结合使用 响应体相对分散response.write(&#39;xx&#39;);response.write(&#39;xx&#39;);response.write(&#39;xx&#39;);response.end(); &#x2F;&#x2F;每一个请求，在处理的时候必须要执行 end 方法的&#x2F;&#x2F;2. 单独使用 end 方法 响应体相对集中response.end(&#39;xxx&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网页中的-URL"><a href="#网页中的-URL" class="headerlink" title="网页中的 URL"></a>网页中的 <strong>URL</strong></h3><p>网页中的 URL 主要分为两大类：<code>相对路径</code> 与 <code>绝对路径</code></p><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p>绝对路径可靠性强，而且相对容易理解，在项目中运用较多</p><table><thead><tr><th>形式</th><th>特点</th></tr></thead><tbody><tr><td><a href="http://atguigu.com/web">http://atguigu.com/w eb</a></td><td>直接向目标资源发送请求，容易理解。网站的外链会用到此形式</td></tr><tr><td>&#x2F;&#x2F;atguigu.com&#x2F;web</td><td>与页面 URL 的协议拼接形成完整 URL 再发送请求。大型网站用的比较多</td></tr><tr><td>&#x2F;web</td><td>与页面 URL 的协议、主机名、端口拼接形成完整 URL 再发送请求。中小型网站</td></tr></tbody></table><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p>相对路径在发送请求时，需要与当前页面 URL 路径进行 <code>计算</code> ，得到完整 URL 后，再发送请求，学习阶段用的较多</p><p>例如当前网页 url 为 <a href="http://www.atguigu.com/course/h5.html">http://www.atguigu.com/course/h5.html</a></p><table><thead><tr><th>形式</th><th>最终的 <strong>URL</strong></th></tr></thead><tbody><tr><td>.&#x2F;css&#x2F;app.css</td><td><a href="http://www.atguigu.com/course/css/app.css">http://www.atguigu.com/course/css/app.css</a></td></tr><tr><td>js&#x2F;app.js</td><td><a href="http://www.atguigu.com/course/js/app.js">http://www.atguigu.com/course/js/app.js</a></td></tr><tr><td>..&#x2F;img&#x2F;logo.png</td><td><a href="http://www.atguigu.com/img/logo.png">http://www.atguigu.com/img/logo.png</a></td></tr><tr><td>..&#x2F;..&#x2F;mp4&#x2F;show.mp4</td><td><a href="http://www.atguigu.com/mp4/show.mp4">http://www.atguigu.com/mp4/show.mp4</a></td></tr></tbody></table><h4 id="网页中使用-URL-的场景小结"><a href="#网页中使用-URL-的场景小结" class="headerlink" title="网页中使用 URL 的场景小结"></a>网页中使用 <strong>URL</strong> 的场景小结</h4><p>包括但不限于如下场景：</p><ul><li>a 标签 href</li><li>link 标签 href</li><li>script 标签 src </li><li>img 标签 src</li><li>video audio 标签 src</li><li>form 中的 action</li><li>AJAX 请求中的 URL</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>志愿填报</title>
      <link href="/2023/06/26/zhi-yuan-tian-bao/"/>
      <url>/2023/06/26/zhi-yuan-tian-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="南京工业职业技术大学（建议冲一下）"><a href="#南京工业职业技术大学（建议冲一下）" class="headerlink" title="南京工业职业技术大学（建议冲一下）"></a>南京工业职业技术大学（建议冲一下）</h2><p>优势：</p><ol><li>相比其他二本，国家支持大</li><li>学校条件好一些，位置很好</li><li>适合你的分数，可以冲一冲</li></ol><p>劣势：</p><ol><li>专转本不久，有些措施还不太完善。</li><li>分数可能达不到要求，专业可能不太好选。</li><li>图书馆和宿舍比较小，不过在新建宿舍。</li></ol><h2 id="电子科技大学成都学院（不建议）"><a href="#电子科技大学成都学院（不建议）" class="headerlink" title="电子科技大学成都学院（不建议）"></a>电子科技大学成都学院（不建议）</h2><p>优势：</p><ol><li>地理位置优越</li></ol><p>劣势：</p><ol><li>学费高，尤其是计算机专业，一年大概学费2w左右</li><li>设施差，官僚主义严重，硬件设施烂</li><li>商业化严重</li></ol><h2 id="成都锦城学院（建议）"><a href="#成都锦城学院（建议）" class="headerlink" title="成都锦城学院（建议）"></a>成都锦城学院（建议）</h2><p>优势：</p><ol><li>设施好，环境好</li><li>寝室环境好，离电子科技大学很近</li><li>学习氛围不错</li><li>很年轻很有态度的学校，在独立学院里是很不错的。</li></ol><p>劣势：</p><ol><li>交通略不方便</li><li>地方小</li><li>学费贵</li></ol><h2 id="长沙理工大学城南学院（建议）"><a href="#长沙理工大学城南学院（建议）" class="headerlink" title="长沙理工大学城南学院（建议）"></a>长沙理工大学城南学院（建议）</h2><p>优势：</p><ol><li>最便宜的民办本科</li><li>师资水平和本部共享</li><li>校园较大，宿舍环境好，食堂好</li></ol><p>劣势：</p><ol><li>在湖南本地是三本</li><li>长沙it行业不是很厉害</li></ol><h2 id="西安交通工程学院（不建议）"><a href="#西安交通工程学院（不建议）" class="headerlink" title="西安交通工程学院（不建议）"></a>西安交通工程学院（不建议）</h2><p>优势：</p><p>劣势：</p><ol><li>无热水洗澡，6人间</li><li>位置偏</li><li>王牌专业轨道交通</li><li>三本</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 硕士生涯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中的盒子模型</title>
      <link href="/2023/06/26/css-zhong-de-he-zi-mo-xing/"/>
      <url>/2023/06/26/css-zhong-de-he-zi-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS2"><a href="#CSS2" class="headerlink" title="CSS2"></a>CSS2</h1><p>具体参数请查询：<a href="https://developer.mozilla.org/zh-CN/">MDN Web Docs (mozilla.org)</a>，本文不多做赘述。</p><h2 id="盒子模型的组成"><a href="#盒子模型的组成" class="headerlink" title="盒子模型的组成"></a>盒子模型的组成</h2><ol><li><code>margin</code>（外边距）： 盒子与外界的距离。</li><li><code>border</code>（边框）： 盒子的边框。</li><li><code>padding</code>（内边距）： 紧贴内容的补白区域。</li><li><code>content</code>（内容）：元素中的文本或后代元素都是它的内容。</li></ol><img src="image-20230626155140768.png" alt="image-20230626155140768" style="zoom:50%;" /><p>盒子的大小 &#x3D; <code>content</code> + <strong>左右</strong> <code>padding</code> + <strong>左右</strong> <code>border</code> 。</p><blockquote><p>注意：外边距 margin 不会影响盒子的大小，但会影响盒子的位置。</p></blockquote><h3 id="盒子内容区（content）"><a href="#盒子内容区（content）" class="headerlink" title="盒子内容区（content）"></a>盒子内容区（content）</h3><blockquote><p>注意：</p><ol><li><code>max-width</code> 、 <code>min-width</code> 一般不与 <code>width</code> 一起使用。</li><li><code>max-height</code> 、 <code>min-height</code> 一般不与 <code>height</code> 一起使用。</li></ol></blockquote><h4 id="默认宽度"><a href="#默认宽度" class="headerlink" title="默认宽度"></a>默认宽度</h4><p>所谓的默认宽度，就是<span style="color: red"><strong>不设置 <code>width</code> 属性</strong></span>时，元素所呈现出来的宽度。<br><strong>总宽度</strong> &#x3D; 父的 <code>content</code> — 自身的左右 <code>margin</code> 。<br><strong>内容区的宽度</strong> &#x3D; 父的 <code>content</code> — 自身的左右 <code>margin</code> — 自身的左右 <code>border</code> — 自身的左右<br><code>padding</code> 。</p><h3 id="盒子内边距（padding）"><a href="#盒子内边距（padding）" class="headerlink" title="盒子内边距（padding）"></a>盒子内边距（padding）</h3><blockquote><p>注意：</p><ol><li><code>padding</code>的值不能是负数。</li><li><strong>行内元素</strong>的左右内边距是没有问题的，上下边距不能完美的设置。</li><li><strong>块级元素</strong>、<strong>行内块元素</strong>，四个方向的<strong>内边距</strong>都可以完美设置。</li></ol></blockquote><h3 id="盒子边框（border）"><a href="#盒子边框（border）" class="headerlink" title="盒子边框（border）"></a>盒子边框（border）</h3><blockquote><p>注意：</p><ol><li>边框相关属性共20个</li><li><code>border-style</code>、<code>border-width</code>、<code>border-color</code>其实也是复合属性</li></ol></blockquote><h3 id="盒子外边距（margin）"><a href="#盒子外边距（margin）" class="headerlink" title="盒子外边距（margin）"></a>盒子外边距（margin）</h3><blockquote><p>注意：</p><ol><li>子元素的<code>margin</code>，是参考父元素的<code>content</code>计算的。（因为是父亲的<code>content</code>中承装着子元素）</li><li>上<code>margin</code>、左<code>margin</code>：影响<strong>自己</strong>的位置；下<code>margin</code>、右<code>margin</code>：影响后面<strong>兄弟元素</strong>的位置。</li><li>块级元素、行内块元素，均可以完美地设置四个方向的<code>margin</code>；但行内元素，左右<code>margin</code>可以完美设置，上下<code>margin</code>设置无效。</li><li><code>margin</code>的值可以是<code>auto</code>，如果给一个块级元素设置左右<code>margin</code>都为<code>auto</code>，该块级元素会在父元素中水平居中。</li><li><code>margin</code>的值可以是负值。（详见<a href="https://qt-7274.github.io/2023/03/19/css-jin-jie-fu-margin-ji-zhu/">CSS进阶–负margin技术 | QT-7274 </a>)</li></ol></blockquote><h4 id="margin塌陷"><a href="#margin塌陷" class="headerlink" title="margin塌陷"></a><code>margin</code>塌陷</h4><p>情形参考文章：<a href="http://localhost:4000/2023/03/19/css-jin-jie-wai-bian-ju-die-jia/">CSS进阶–外边距叠加 | QT-7274</a></p><p><strong>如何解决<code>margin</code>塌陷？</strong></p><ul><li>给父元素设置不为0的<code>padding</code>。</li><li>给父元素设置宽度不为0的<code>border</code>。</li><li>给父元素设置CSS样式：<code>overflow:hidden</code>。</li></ul><h4 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a><code>margin</code>合并</h4><p>情形参考文章：<a href="https://qt7274.co/2023/03/19/css-jin-jie-wai-bian-ju-die-jia/">CSS进阶–外边距叠加 | QT-7274 (qt7274.co)</a></p><p><strong>如何解决<code>margin</code>合并？</strong></p><p>无需解决，布局的时候上下的兄弟元素，只给一个设置上下外边距即可。</p><h3 id="处理内容溢出"><a href="#处理内容溢出" class="headerlink" title="处理内容溢出"></a>处理内容溢出</h3><blockquote><p>注意：</p><ol><li><code>overflow-x</code>、<code>overflow-y</code> 不能一个是<code>hidden</code>，一个是<code>visible</code>，是实验性属性，不建议使用。</li><li><code>overflow</code>常用的值是<code>hidden</code>和<code>auto</code>，除了能处理溢出的显示方式，还可以解决很多其他问题。</li></ol></blockquote><h3 id="隐藏元素的方式"><a href="#隐藏元素的方式" class="headerlink" title="隐藏元素的方式"></a>隐藏元素的方式</h3><h4 id="visibility属性"><a href="#visibility属性" class="headerlink" title="visibility属性"></a><code>visibility</code>属性</h4><p><code>visibility</code>属性默认值是<code>show</code>，如果设置为<code>hidden</code>，元素会隐藏。</p><p>但元素仍占据原有位置。</p><h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a><code>display</code>属性</h4><p>设置<code>display:none</code>，就可以让元素隐藏。</p><p>彻底隐藏，无法被看见，也不占用任何位置，没有大小宽高。</p><h3 id="布局技巧"><a href="#布局技巧" class="headerlink" title="布局技巧"></a>布局技巧</h3><ol><li><p>行内元素、行内块元素，可以被父元素当作文本处理。</p><blockquote><p>可以像处理文本对齐一样，去处理：行内、行内块元素在父元素中的对齐。<code>text-align</code>、<code>line-height</code>、<code>text-indent</code>等。</p></blockquote></li><li><p>子元素在父元素中的<strong>水平居中</strong>：</p><ul><li>若子元素为<strong>块元素</strong>，给父元素加上：<code>margin: 0 auto;</code>。</li><li>若子元素为<strong>行内元素</strong>、<strong>行内块元素</strong>，给父元素加上：<code>text-align: center;</code>。</li></ul></li><li><p>子元素在父元素中的<strong>垂直居中</strong>：</p><ul><li><p>若子元素为<strong>块元素</strong>，给子元素加上： <code>margin-top</code>，值为（父元素<code>content</code> - 子元素盒子总高）<code>/</code> 2。</p></li><li><p>若子元素为<strong>行内元素</strong>、<strong>行内块元素</strong>：</p><p>让父元素的<code>height</code> &#x3D; <code>line-height</code>，每个子元素都加上：<code>vertical-align : middle;</code>。</p><p>若想绝对垂直居中，父元素<code>font-size</code>设置为<code>0</code>。</p></li></ul></li><li><p>使用负margin技术也可实现水平垂直居中，详见：<a href="https://qt-7274.github.io/2023/03/19/css-jin-jie-fu-margin-ji-zhu/">CSS进阶–负margin技术 | QT-7274</a></p></li></ol><h3 id="元素之间的空白问题"><a href="#元素之间的空白问题" class="headerlink" title="元素之间的空白问题"></a>元素之间的空白问题</h3><p>产生的原因：</p><p>行内元素、行内块元素，彼此之间的换行会被浏览器解析为一个空白字符。</p><p>解决方案：</p><ol><li><strong>方案一</strong>：去掉换行和空格（不推荐）。</li><li><strong>方案二</strong>：给父元素设置<code>font-size: 0</code>，再给需要显示文字的元素，单独设置字体大小（推荐）。</li></ol><h3 id="行内块的幽灵空白问题"><a href="#行内块的幽灵空白问题" class="headerlink" title="行内块的幽灵空白问题"></a>行内块的幽灵空白问题</h3><p>产生原因：</p><p>行内块元素与文本的基线对齐，而文本的基线与文本最底端之间是有一定距离的。</p><p>解决方案：</p><ol><li><strong>方案一</strong>：给行行内块设置<code>vertical</code>，值不为<code>baseline</code>即可，设置为<code>middel</code>、<code>bottom</code>、<code>top</code>即可。</li><li><strong>方案二</strong>：若父元素中只有一张图片，设置图片为<code>display: block</code>。</li><li><strong>方案三</strong>：给父元素设置<code>font-size: 0</code>。如果该行内块内部还有文本，则需单独设置<code>font-size</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精读《深入理解现代JavaScript》</title>
      <link href="/2023/06/24/jing-du-shen-ru-li-jie-xian-dai-javascript/"/>
      <url>/2023/06/24/jing-du-shen-ru-li-jie-xian-dai-javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章：块级作用域声明：-let-和-const"><a href="#第二章：块级作用域声明：-let-和-const" class="headerlink" title="第二章：块级作用域声明： let 和 const"></a>第二章：块级作用域声明： let 和 const</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>对于现在的 <code>JavaScript</code> 来说，声明变量的方式一共有三种：</p><blockquote><ul><li><code>var</code>：变量，会跳出块级作用域</li><li><code>let</code>：变量，不会跳出块级作用域</li><li><code>const</code>：常量，不会跳出块级作用域</li></ul></blockquote><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>什么是块级作用域？</p><blockquote><p>所谓块级作用域指的是 <strong>两个大括号中间的内容</strong>，比如 <code>for 循环、if、函数</code> 只要存在 <code>&#123;&#125;</code> 那么都会生成块级作用域。</p></blockquote><p>除了块级作用域之外，<code>var</code> 和 <code>let、const</code> 在特性上也有一些区别。这个区别主要体现在两个方面 <strong>变量提升、暂时性死区（<code>TDZ</code>）</strong></p><h3 id="变量提升与暂时性死区"><a href="#变量提升与暂时性死区" class="headerlink" title="变量提升与暂时性死区"></a>变量提升与暂时性死区</h3><p>咱们先来看变量提升。对于 <code>var</code> 声明的变量而言，会存在变量提升的概念，也就是可以 <strong>先使用、后定义</strong>，咱么来看这段代码：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(msg) &#x2F;&#x2F; undefined （并不会报错）var msg &#x3D; &#39;hello world&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这段代码中，<code>msg</code> 变量先被使用，后声明。虽然打印了 <code>undefined</code>，但是它并不会报错。</p><p>原因是因为，以上代码会被编译为以下形式：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var msgconsole.log(msg) &#x2F;&#x2F; undefinedmsg &#x3D; &#39;hello world&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>即 <strong>msg 变量的定义会被提升到最前面</strong>。而这种形式就叫做 <strong>变量提升</strong>。</p><p>但是如果我们使用 <code>let 或 const</code> 来代替 <code>var</code> 的话，因为 <code>let、const</code> 不具备变量提升，所以就会抛出对应的错误：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(msg2); &#x2F;&#x2F; Uncaught ReferenceError: Cannot access &#39;msg2&#39; before initializationlet msg2 &#x3D; &#39;hello word&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而这样的错误，就被叫做 <strong>暂时性死区（ temporal dead zone，简称TDZ ）。</strong></p><h3 id="旧习换新"><a href="#旧习换新" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>这里的旧习换新主要包含两点：</p><ul><li>第一点是 **不要使用 <code>var</code>，改用 <code>let</code> 和 <code>const</code>**：因为无论是 <strong>跳出块级作用域也好，还是变量提升也好</strong>，在标准图灵完备的编程语言中，都不是一个应该具备的特性。</li><li>第二点是 <strong>缩小变量的作用域，从而提升可维护性</strong>：想要理解这句话，可能需要具备一定的编程经验。如果大家不是很理解的话，那么可以想象一下 <strong>一万行代码的文件和一百行代码的文件</strong> 哪个更好维护？我们始终需要谨记 <strong>代码越少，越容易维护</strong>。所以 <strong>缩小你的作用域空间，减少逻辑的复杂度。</strong></li></ul><h2 id="第三章：函数的新特性"><a href="#第三章：函数的新特性" class="headerlink" title="第三章：函数的新特性"></a>第三章：函数的新特性</h2><p>函数作为 <code>JavaScript 世界</code> 的 <strong>一等公民</strong>，是我们在实际项目开发中，无时无刻不在使用的东西。</p><p>在这一章中，咱们主要从 <strong>参数、this 指向、构造函数</strong> 这三个方面来去说明函数的新特性。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>函数的参数分为两种 <strong>形参、实参</strong>。所谓形参指的是 <strong>定义函数时指定的形式参数</strong>。所谓实参指的是 <strong>调用函数时，传递的实际参数。</strong></p><p>而在定义形参时，我们可以通过 <strong>赋值符 &#x3D;</strong> 的形式，为形参指定 <strong>默认值</strong>。这表示 <strong>如果没有传递对应的实参，则该形参默认为该值</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function fn(name &#x3D; &#39;张三&#39;) &#123;  console.log(name); &#x2F;&#x2F; 张三&#125;fn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个默认值可以为 <strong>任意的单一表达式</strong>，比如我们可以指定一个 <strong>立即执行的箭头函数</strong>，那么此时默认值会为该函数的值：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 箭头函数：() &#x3D;&gt; &#39;李四&#39;&#x2F;&#x2F; (() &#x3D;&gt; &#39;李四&#39;)() 表示立即执行的箭头函数function fn(name &#x3D; (() &#x3D;&gt; &#39;李四&#39;)()) &#123;  console.log(name);&#125;fn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>JavaScript</code> 中，函数的实参和形参并不要求是一一对应的。也就是说 <strong>实参的数量可以超过形参的数量</strong>。那么在这种情况下，如果我们想要获取到 <strong>多余的实参</strong>，一共有两种方式：</p><ul><li><p>第一种是传统的 <code>arguments </code>，但是它并不是通用的，<strong>在箭头函数中无法使用</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function fn(name) &#123;  console.log(arguments); &#x2F;&#x2F; [&#39;张三&#39;, 30, &#39;男&#39;, callee: ƒ, Symbol(Symbol.iterator): ƒ]&#125;const fn &#x3D; (name) &#x3D;&gt; &#123;  console.log(arguments); &#x2F;&#x2F; Uncaught ReferenceError: arguments is not defined&#125;fn(&#39;张三&#39;, 30, &#39;男&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第二种是 <code>ES6 之后</code> 新增的 <strong>“rest” 参数</strong>，它是通用的，表示 <strong>接收所有的剩余参数</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function fn(name, ...args) &#123;  console.log(args); &#x2F;&#x2F; [30, &#39;男&#39;]&#125;const fn &#x3D; (name, ...args) &#x3D;&gt; &#123;  console.log(args); &#x2F;&#x2F; [30, &#39;男&#39;]&#125;fn(&#39;张三&#39;, 30, &#39;男&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>针对 <code>this</code> 指向，指的是 <strong>普通函数和箭头函数</strong> 下的 <code>this</code> 指向问题。</p><p>这应该是一个 <strong>面试</strong> 时的高频问点。当大家遇到这样的问题时，大多数时候只需要从三个方面进行回答即可：</p><ul><li><p>首先第一个方面是 <strong>普通函数的 this 指向</strong>：针对于普通函数而言，<code>this</code> 指向<span style="color: red">调用方</span></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function fn() &#123;  console.log(this); &#x2F;&#x2F; window&#125;fn() &#x2F;&#x2F; window.fn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后是箭头函数：针对于箭头函数而言，不会修改 <code>this</code> 指向，即 <strong>this 指向上层作用域中的 this</strong> </p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;  name: &#39;张三&#39;,  fn() &#123;    console.log(this); &#x2F;&#x2F; person    const subFn &#x3D; () &#x3D;&gt; &#123;      console.log(this); &#x2F;&#x2F; 指向上层作用域（fn）中的 this    &#125;    subFn()  &#125;&#125;person.fn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最后是 <code>call、apply、bind</code> 这三个 <code>API</code>：它们都可以在 <strong>普通函数</strong> 中修改 <code>this</code> 指向，<code>this</code> 指向它们的第一个参数</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;  name: &#39;张三&#39;&#125;const fn &#x3D; () &#x3D;&gt; &#123;  console.log(this); &#x2F;&#x2F; window  箭头函数永远不会修改 this 指向&#125;function fn2() &#123;  console.log(this); &#x2F;&#x2F; person&#125;fn.apply(person)fn2.call(person)fn.bind(person)()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数通常指 <strong>首字母大写的普通函数</strong> 。也就是说：<span style="color: red"><strong>箭头函数永远不可以作为构造函数使用</strong></span></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Person(name) &#123;  &#x2F;&#x2F; this 指向实例对象  this.name &#x3D; name&#125;const p &#x3D; new Person(&#39;张三&#39;)console.log(p); &#x2F;&#x2F; Person &#123;name: &#39;张三&#39;&#125;const Person2 &#x3D; (name) &#x3D;&gt; &#123;  &#x2F;&#x2F; this 指向 window  this.name &#x3D; name&#125;const p2 &#x3D; new Person2(&#39;张三&#39;)console.log(p2); &#x2F;&#x2F; Uncaught TypeError: Person2 is not a constructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旧习换新-1"><a href="#旧习换新-1" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>这一章的旧习换新主要包含四点内容，也是对本章重点内容的总结：</p><ul><li>首选是关于箭头函数和普通函数的使用场景： <strong>不想修改 this 指向时，使用箭头函数。需要改变 this 的指向时，使用普通函数</strong></li><li>其次是关于参数默认值：<strong>使用参数默认值，而不要使用代码为参数赋初始值</strong></li><li>第三是关于剩余参数： <strong>使用 rest 参数替代 arguments 关键字</strong> 来获取剩余参数</li></ul><h2 id="第四章：类"><a href="#第四章：类" class="headerlink" title="第四章：类"></a>第四章：类</h2><p>针对于第四章而言，从名字到内容都非常的纯粹，一个字 <strong>类</strong>。</p><p>那么对于这一章的内容，让我们从一个问题开始：我们常说 <strong>JavaScript 实际上没有类，只是用原型来模拟了类？是这样的吗？</strong></p><p>答案是 <strong>当然不是</strong>。其实从 <code>ES2015</code> 之后，<code>ECMAScript</code> 标准为 <code>JavaScript</code> 提供了 <strong>类</strong> 的概念。它并不是原型的模拟，只是 <strong>可以用原型来模拟类而已</strong>。</p><p>那么下面咱们就来看看 <code>ES2015</code> 之后的 <strong>类语法</strong></p><h3 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h3><p>类语法分为 <strong>创建</strong> 和 <strong>使用</strong> 两部分。</p><p>咱们先来看类的创建：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const fnName &#x3D; &#39;fn&#39; + Math.floor(Math.random() * 1000)class Color &#123;  &#x2F;&#x2F; 一个《构造函数》  constructor(r &#x3D; 0, g &#x3D; 0, b &#x3D; 0) &#123;    &#x2F;&#x2F; 三个《数据属性》    this.r &#x3D; r    this.g &#x3D; g    this.b &#x3D; b  &#125;  &#x2F;&#x2F; 一个《访问器属性》  get rgb() &#123;    &#x2F;&#x2F; 可通过 实例.rgb 访问    return &#96;rgb($&#123;this.r&#125;, $&#123;this.g&#125;, $&#123;this.b&#125;)&#96;  &#125;  set rgb(val) &#123;    &#x2F;&#x2F; 为 r、g、b 赋值    &#x2F;&#x2F; 可通过 实例.rgb &#x3D; xx 访问  &#125;  &#x2F;&#x2F; 一个《原型方法》  toString() &#123;    return &#96;重写的原型方法：$&#123;this.rgb&#125;&#96;  &#125;  &#x2F;&#x2F; 一个静态方法  static fromCss(r, g, b) &#123;    &#x2F;&#x2F; 利用 new this 可以直接得到 Color 实例    return new this(r, g, b)  &#125;  &#x2F;&#x2F; 动态方法名  [fnName]() &#123;    return &#96;动态方法名为：$&#123;fnName&#125;&#96;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，我们通过类语法 <code>class</code> 创建了一个类 <code>Color</code>，这里大家注意，根据规范 <strong>类名首字母应该大写</strong>。这里的代码我已经写好了注释，大家可以在这里暂停来查看下对应的代码内容。</p><p>而如果想要使用类的话，那么必须要通过 <code>new</code> 关键字来进行使用：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const c &#x3D; new Color(30, 144, 255)console.log(c[fnName]()); &#x2F;&#x2F; 动态方法名为：fn275console.log(c.toString()); &#x2F;&#x2F; 重写的原型方法：rgb(30, 144, 255)console.log(c.rgb); &#x2F;&#x2F; rgb(30, 144, 255)console.log(Color.fromCss(255, 255, 255)); &#x2F;&#x2F; Color &#123;r: 255, g: 255, b: 255&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><p>继承在编程语言中是一个非常常见的概念，在 <code>ES6</code> 之前想要完成继承，那么多数情况下需要使用 <strong>原型继承</strong> 的方式。而原型继承有很多种，比如：<strong>组合式继承、原型式继承、寄生式继承、寄生式组合继承 ……</strong> 很多种方式。</p><p>但是在实际开发中，如果我们直接使用类语法的话，那么想要实现继承就非常容易了。只需要使用到一个关键字 <code>extends</code></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class SubColor extends Color &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>而除了 <code>extends</code> 之外，类继承的时候还有另外一个关键字 <code>super</code>。 <code>super</code> 关键字可以用来 <strong>处理与父类相关的事情</strong>。</p><p>它的使用场景主要有两个：</p><h4 id="作为函数使用"><a href="#作为函数使用" class="headerlink" title="作为函数使用"></a>作为函数使用</h4><p><code>super</code> 关键字可以直接作为函数进行使用。比如：在构造函数中使用时，<code>super</code> 可以直接调用父类的构造函数，在通常情况下 <span style='color: red'><strong>这是一个必须的操作</strong></span></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class SubColor extends Color &#123;  constructor(r &#x3D; 0, g &#x3D; 0, b &#x3D; 0, a &#x3D; 1) &#123;    &#x2F;&#x2F; 触发父类的构造函数    super(r, g, b)    this.a &#x3D; a  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="作为属性查询使用"><a href="#作为属性查询使用" class="headerlink" title="作为属性查询使用"></a>作为属性查询使用</h4><p><code>super</code> 关键字可以用来 <strong>访问一个对象字面或类的 [[Prototype]] 的方法和属性</strong>。比如：我们可以在静态方法中利用 <code>super</code> 访问父类的静态方法</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class SubColor extends Color &#123;  static fromCss(r, g, b, a &#x3D; 1) &#123;    &#x2F;&#x2F; 通过 super 调用父类的静态方法    const result &#x3D; super.fromCss(r, g, b)    &#x2F;&#x2F;  code....    return new this(r, g, b, a)  &#125;&#125;&#x2F;&#x2F; 子类重写的 formCss。result &#x3D; &#123;color: red&#125; + &#123;fontSize: 20px&#125;console.log(Color.fromCss(255, 255, 255));console.log(SubColor.fromCss(255, 255, 255, 1)); &#x2F;&#x2F; SubColor &#123;r: 255, g: 255, b: 255, a: 1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>对于类而言，最后一个需要大家关注的概念就是 <code>new.target</code>。</p><p><strong><code>new.target</code></strong> 属性允许你 <strong>检测函数或构造方法是否是通过 new 运算符被调用的，并且可以返回一个指向构造方法或函数的引用</strong>。</p><p>我们可以利用它来判断 <strong>当前触发构造函数时是通过哪个类来触发的</strong> ，这在 <strong>多层继承判断来源时会非常有用</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class Color &#123;  constructor() &#123;    console.log(&#96;new.target.name: $&#123;new.target.name&#125;&#96;);  &#125;&#125;class SubColor extends Color &#123;  constructor() &#123;    super()  &#125;&#125;new Color() &#x2F;&#x2F; new.target: 指向 Colornew SubColor() &#x2F;&#x2F; new.target: 指向 SubColor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旧习换新-2"><a href="#旧习换新-2" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>这里的旧习换新环节，就比较简单了，只有一点： <strong>实际开发中，通过 <code>class</code> 来完成类的构建和继承。</strong></p><h2 id="第五章：对象的新特性"><a href="#第五章：对象的新特性" class="headerlink" title="第五章：对象的新特性"></a>第五章：对象的新特性</h2><p>接下来我们来看对象在 <code>ES6</code> 之后的新特性。</p><p>对象在我们日常开发中使用的场景是非常多的，所以这一章中的很多新特性大家或多或少的应该都有一些了解。我挑选了几个日常开发中最常用的语法，来给大家进行下分享。</p><p>首先是  <strong>可计算的属性名</strong>。</p><p>有些时候，我们可能希望 <strong>对象的 <code>key</code> 是一个不确定的唯一值。</strong> 比如：世界上每一个人都是唯一的，所以 <code>person</code> 对象应该具备一个唯一的 <code>“特性”</code> ，那么我们就可以通过这种方式来进行表示</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const key &#x3D; Symbol(&#39;key&#39;)const person &#x3D; &#123;  name: &#39;张三&#39;,  &#x2F;&#x2F; 可计算的属性名  [key]: key&#125;console.log(person); &#x2F;&#x2F; &#123;name: &#39;张三&#39;, Symbol(key): Symbol(key)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，我们利用 <code>Symbol</code> 构建了一个 <code>key</code>，然后利用 <code>[key]</code> 作为 <code>person</code> 的<code>唯一 key 名</code>。</p><p>同时，为了方便对象字面量的编写，<code>ES6</code> 之后提供了 <strong>属性简写</strong> 的语法： <strong>当 key 和 value 拥有同样的变量名时，那么可以进行简写</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const name &#x3D; &#39;张三&#39;const person &#x3D; &#123;  &#x2F;&#x2F; name: name  name&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>属性简写</strong> 是我们在日常开发中非常常用的一种方式。</p><p>除了属性简写之后，还有另外一个新特性也是我们在日常开发中非常常见的，那就是 <strong>展开运算符</strong>。</p><p>展开运算符以 <code>...</code> 的形式进行表示，可以用在对象的展开和合并的多个场景中：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const names &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]&#x2F;&#x2F; 展开console.log(...names); &#x2F;&#x2F; 张三 李四 王五&#x2F;&#x2F; 合并console.log([&#39;赵六&#39;, ...names]); &#x2F;&#x2F;[&#39;赵六&#39;, &#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旧习换新-3"><a href="#旧习换新-3" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>最后是对象的旧习换新环节，这个环节的内容比较多，主要有 5 个：</p><ol><li>当你需要一个动态的 <code>key</code> 时，可以通过可计算的属性名直接创建该对象</li><li>多使用属性的简写，以此来简化对象构建的过程</li><li>是 <code>Object.assign</code> 方法，这是一个 <code>ES6</code> 新增的方法。可以 <strong>将一个对象的可枚举属性复制到另一个对象上</strong> 。但是要注意，这是一个浅拷贝的</li><li><code>Symbol</code> 可以构建一个唯一值。 使用 <code>Symbol</code> 作为 <code>key</code> 名，可以避免属性名冲突</li><li>最后是关于实例的原型，之前访问实例的原型时多通过 <code>__proto__</code> 访问。现在可以通过 <code>Object.setPrototypeOf、Object.getPrototypeOf</code> 来直接访问原型</li></ol><h2 id="第六章：可迭代对象、迭代器、生成器"><a href="#第六章：可迭代对象、迭代器、生成器" class="headerlink" title="第六章：可迭代对象、迭代器、生成器"></a>第六章：可迭代对象、迭代器、生成器</h2><p>从这一章的名字就可以看出来，这一章中主要讲了三个东西 <code>可迭代对象、迭代器、生成器</code>。本章的内容在我们日常的业务项目开发中其实用的不是特别多，并且很多时候有更习惯的替代方案。但是在面试中，确有可能经常被问到，所以不妨一听。</p><h3 id="可迭代对象、迭代器"><a href="#可迭代对象、迭代器" class="headerlink" title="可迭代对象、迭代器"></a>可迭代对象、迭代器</h3><p>首先咱们先来看可迭代对象、迭代器。想要了解这两个东西，咱们需要先搞清楚他们的概念：</p><blockquote><p>迭代器：所谓迭代器指的是 <strong>一个具有 next 方法的对象</strong>。也就是说，从 <strong>理论上</strong>，只要一个对象具备 <code>next</code> 方法，那么它就是迭代器。这里大家注意：<strong>迭代器可以应用在数组中，却 不可以 应用在普通对象中</strong></p><p>可迭代对象：而可迭代对象指的是 <strong>可以通过标准方法获取迭代器，以遍历其内容的对象</strong>。</p><p>所以说 <strong>可迭代对象、迭代器</strong> 通常是配合来进行说明的。</p></blockquote><p>而对于迭代器而言，分为 <strong>隐式迭代器 和 显示迭代器</strong> 两种。</p><p>咱们先来看隐式迭代器 <code>for of</code>，它拥有 <strong>隐式</strong> 的 <code>next</code> 方法：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const names &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]for (const iterator of names) &#123;  console.log(iterator); &#x2F;&#x2F; 张三、李四、王五&#125;const person &#x3D; &#123;  name: &#39;张三&#39;,  age: 30&#125;&#x2F;&#x2F; Uncaught TypeError: person is not iterable&#x2F;&#x2F; 普通对象默认不可迭代for (const iterator of person) &#123;  console.log(iterator);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而显示迭代器被叫做 <code>Symbol.iterator</code>，每个数组都包含一个 <code>Symbol.iterator</code> 的属性，可以利用该属性获取显示迭代器，它拥有 <strong>显示</strong> 的 <code>next</code> 方法：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const names &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]const it &#x3D; names[Symbol.iterator]()console.log(it); &#x2F;&#x2F; Array Iterator &#123;&#125;console.log(it.next()); &#x2F;&#x2F; &#123;value: &#39;张三&#39;, done: false&#125;console.log(it.next()); &#x2F;&#x2F; &#123;value: &#39;李四&#39;, done: false&#125;console.log(it.next()); &#x2F;&#x2F; &#123;value: &#39;王五&#39;, done: false&#125;console.log(it.next()); &#x2F;&#x2F; &#123;value: undefined, done: true&#125;&#x2F;&#x2F; const person &#x3D; &#123;&#x2F;&#x2F;   name: &#39;张三&#39;,&#x2F;&#x2F;   age: 30&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#x2F;&#x2F; Uncaught TypeError: person is not iterable&#x2F;&#x2F; &#x2F;&#x2F; 普通对象默认不可迭代&#x2F;&#x2F; for (const iterator of person) &#123;&#x2F;&#x2F;   console.log(iterator);&#x2F;&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而针对于对象而言，咱们也说过 <strong>普通对象默认不可迭代</strong>。不可迭代的原因其实是因为 <strong>缺少 Symbol.iterator 属性</strong>。所以如果我们希望让普通对象可迭代的话，那么可以通过以下两步来完成：</p><ul><li>为对象添加 <code>Symbol.iterator</code> 属性，返回 <code>iterator</code> 迭代器对象</li><li><code>iterator</code> 迭代器对象中包含 <code>next</code> 方法</li></ul><p>因为在实际开发中使用场景不多，所以其中具体的代码咱们就不在这里说了。</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>虽然迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。生成器函数提供了一个强大的选择：<strong>它允许你定义一个包含自有迭代算法的函数，同时它可以自动维护自己的状态</strong>。所以我们可以 <strong>利用生成器得到一个迭代器对象（<code>Generator</code> 符合 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE">可迭代协议</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">迭代器协议</a>），同时该迭代器对象同样会拥有 <code>next</code> 方法</strong>。</p><p>那么咱们搞明白 <strong>生成器与迭代器</strong> 的关系之后，下面咱们来看下 <strong>生成器</strong> 的语法。</p><p>想要创建并使用生成器的话，一共分为三步：</p><ol><li><p>生成器被称为 <strong>生成器函数</strong>，所以想要构建一个生成器，那么必须要构建一个函数：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 通过在 function 后面增加一个 * 来标记当前函数为生成器函数function* simple() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>生成器内部包含 <strong>暂停迭代</strong> 的功能，这个暂停是配合 <code>next</code> 方法进行使用的</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function* simple() &#123;  for (let i &#x3D; 0; i &lt; 3; i++) &#123;    &#x2F;&#x2F; 使用 yield 控制暂停迭代    yield console.log(i);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>调用生成器函数，可以得到一个迭代器对象，通过 <code>next</code> 方法控制 <strong>迭代过程</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const s &#x3D; simple()s.next() &#x2F;&#x2F; 0s.next() &#x2F;&#x2F; 1s.next() &#x2F;&#x2F; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>同时对于生成器而言，它还可以 <strong>传递参数（消费值）</strong>，咱们来看这个例子：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function* add() &#123;  console.log(&#39;开始&#39;);  &#x2F;&#x2F; yield 后面的内容被叫做 value，并且 yield 包含返回值  const value1 &#x3D; yield &quot;请输入第一次的值&quot;  console.log(&#96;第一次的值为：$&#123;value1&#125;&#96;);  const value2 &#x3D; yield &quot;请输入第二次的值&quot;  console.log(&#96;第二次的值为：$&#123;value2&#125;&#96;);  return value1 + value2&#125;let resultconst gen &#x3D; add()&#x2F;&#x2F; 开始result &#x3D; gen.next()console.log(result);&#x2F;&#x2F; 第一次输入值result &#x3D; gen.next(35)console.log(result);&#x2F;&#x2F; 第二次输入值result &#x3D; gen.next(7)console.log(result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="image-20230625185609320.png" alt="image-20230625185609320" style="zoom:50%;" /><h3 id="旧习换新-4"><a href="#旧习换新-4" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>就像我们开始所说的一样，在实际企业开发中生成器与自定义迭代器其实使用率并不高，所以这里的旧习换新只有一个：</p><ul><li><strong>利用 DOM 的可迭代特性，通过 for….of… 进行循环</strong>。比如在通过 <code>querySelectAll</code> 获取 <code>DOM</code> 的伪数组之后，伪数组虽然没有办法直接 <code>forEach</code>，但是可以利用隐式迭代器 <code>for of</code> 完成循环操作</li></ul><h2 id="第七章：解构"><a href="#第七章：解构" class="headerlink" title="第七章：解构"></a>第七章：解构</h2><p>关于对象相关的最后一部分就是 <strong>解构</strong> 了。解构应该是日常开发中非常常用的语法。其目的是为了 <strong>从数据结构中快速提取对应的内容</strong></p><p>解构分为两部分：对象解构 和 数组解构。</p><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>当对对象进行解构时，需要 <strong>配合 大括号 完成，大括号中放入需要提取的字段名，同时该字段名会作为新的变量名被创建</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;  name: &#39;张三&#39;,  age: 30&#125;&#x2F;&#x2F; 以大括号的形式来结构对象&#x2F;&#x2F; 以 key 的形式，获取指定属性const &#123; name &#125; &#x3D; person &#x2F;&#x2F; const name &#x3D; person.nameconsole.log(name); &#x2F;&#x2F; 张三<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而当 <strong>对象呈嵌套形式时</strong>，同样可以利用 <strong>嵌套解构</strong> 的形式进行结构：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;  name: &#39;曹操&#39;,  age: 58,  children: [    &#123;      name: &#39;曹丕&#39;,      age: 35    &#125;,    &#123;      name: &#39;曹植&#39;,      age: 28    &#125;  ]&#125;&#x2F;&#x2F; &#123; children &#125; 表示获取 person 的 children&#x2F;&#x2F; &#123; children: [caoPi] &#125; 表示从 children 中获取第一个元素，命名为 caoPiconst &#123; children: [caoPi] &#125; &#x3D; personconsole.log(caoPi); &#x2F;&#x2F; &#123;name: &#39;曹丕&#39;, age: 35&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>而对于数组的解构，需要 <strong>配合 中括号 完成，</strong>中括号中 <strong>按照下标的顺序，依次写入新的变量名</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#x2F;&#x2F; 以中括号的形式来结构对象&#x2F;&#x2F; 中括号定义变量名const [v1, v2, v3] &#x3D; arr &#x2F;&#x2F; const v1 &#x3D; arr[0], v2 &#x3D; arr[1], v3 &#x3D; arr[2]console.log(v1, v2, v3); &#x2F;&#x2F; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，对于数组解构而言，也可以通过 <code>“rest” 语法</code> 直接获取 <strong>剩余元素，剩余元素会被赋值给新的数组</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#x2F;&#x2F; 以中括号的形式来结构对象&#x2F;&#x2F; 中括号定义变量名&#x2F;&#x2F; “rest” 语法... 表示剩余所有组成新数组const [v1, ...v2] &#x3D; arr &#x2F;&#x2F; const v1 &#x3D; arr[0], v2 &#x3D; [arr[1], arr[2]]console.log(v1, v2); &#x2F;&#x2F; &#39;a&#39;,  [&#39;b&#39;, &#39;c&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旧习换新-5"><a href="#旧习换新-5" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>解构是日常开发中常用的语法，但是本身比较简单。只要大家在以后的开发中多使用解构语法，就会发现它本质上是一个非常简单的东西。</p><h2 id="第八章：Promise"><a href="#第八章：Promise" class="headerlink" title="第八章：Promise"></a>第八章：Promise</h2><p>接下来咱们来看第八章、第九章关于异步处理的部分。</p><p>说道异步，肯定有很多小伙伴直接想到的就是 <code>Promise</code>。 没有 <code>Promise</code> 是 <code>ES6</code> 之后专门用来处理异步的解决方案。但是要注意：</p><blockquote><p> <code>Promise</code> <strong>本身并不执行任何操作，它只是一种观察异步操作结果的方案</strong>。</p></blockquote><p>在 <code>Promise</code> 内部对整个异步的操作分为 <strong>三种状态</strong>，对应 <strong>三种结果</strong>。而语法分为 <strong>定义</strong> 和 <strong>使用</strong> 两部分。其中三种状态发生在定义阶段，三种结果发生在使用阶段。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function reload(b) &#123;  &#x2F;&#x2F; 创建 promise 实例  return new Promise((resolve, reject) &#x3D;&gt; &#123;    console.log(&#39;代码进入 pending 状态&#39;);    setTimeout(() &#x3D;&gt; &#123;      if (b) &#123;        resolve(&#39;代码进入 已成功 状态&#39;)      &#125; else &#123;        reject(&#39;代码进入 已拒绝 状态&#39;)      &#125;    &#125;, 500);  &#125;)&#125;const p1 &#x3D; reload(true)p1.then((data) &#x3D;&gt; &#123;  console.log(data); &#x2F;&#x2F; 代码进入 已成功 状态&#125;).finally(() &#x3D;&gt; &#123;  console.log(&#39;p1 已敲定&#39;);&#125;)const p2 &#x3D; reload(false)p2.then((data) &#x3D;&gt; &#123;  console.log(data); &#x2F;&#x2F; 代码进入 已拒绝 状态&#125;).finally(() &#x3D;&gt; &#123;  console.log(&#39;p2已敲定&#39;);&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，对于 <code>Promise</code> 而言，它支持链式调用的方式。只要在 <code>.then</code> 中 <code>return</code> 了内容，那么 <code>return</code> 的内容就会被封装为 <code>Promise.resolve</code> ，从而可以继续 <code>.then</code>:</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const p1 &#x3D; reload(true)p1.then((data) &#x3D;&gt; &#123;  console.log(data); &#x2F;&#x2F; 代码进入 已成功 状态  return &#39;进入第二次 Promise&#39;&#125;).then(data &#x3D;&gt; &#123;  console.log(data);  return &#39;进入第三次 Promise&#39;&#125;).then(data &#x3D;&gt; &#123;  console.log(data);  console.log(&#39;三次结束&#39;);&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旧习换新-6"><a href="#旧习换新-6" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>对于 <code>Promise</code> 来说，现在在开发中的使用已经非常普遍了。所以当大家以后遇到异步问题时，应该首先考虑 <code>Promise</code></p><h2 id="第九章：异步函数、迭代器、生成器"><a href="#第九章：异步函数、迭代器、生成器" class="headerlink" title="第九章：异步函数、迭代器、生成器"></a>第九章：异步函数、迭代器、生成器</h2><p><code>Promise</code> 可以帮助我们处理异步操作，但是从上面的代码我们可以看出，在 <code>Promise</code> 的 <strong>使用</strong> 阶段，代码的复杂度其实并不低。</p><p>所以在 <code>ES7</code> 之后，<code>TC39</code> 推出了 <strong>异步函数</strong> 的概念，以解决 <code>Promise</code> 使用的复杂度问题。</p><p>想要定义异步函数，那么需要通过 <code>async</code> 关键字来进行定义，在异步函数中，可以通过 <code>await</code> 关键字来 <strong>让异步操作，变为同步的写法</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function reload1() &#123;  &#x2F;&#x2F; 创建 promise 实例  return new Promise((resolve, reject) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#39;reload1 进入 已成功 状态&#39;)    &#125;, 500);  &#125;)&#125;function reload2() &#123;  &#x2F;&#x2F; 创建 promise 实例  return new Promise((resolve, reject) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#39;reload2 进入 已成功 状态&#39;)    &#125;, 500);  &#125;)&#125;function reload3() &#123;  &#x2F;&#x2F; 创建 promise 实例  return new Promise((resolve, reject) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#39;reload3 进入 已成功 状态&#39;)    &#125;, 500);  &#125;)&#125;&#x2F;&#x2F; async 和 await 必须同时出现&#x2F;&#x2F; async 标记指定方法为《异步方法》,该方法会返回一个 Promise&#x2F;&#x2F; await 只能在《异步方法》中使用async function start() &#123;  &#x2F;&#x2F; 该操作同样为异步操作，只不过拥有了同步的写法  const result1 &#x3D; await reload1()  console.log(result1);  const result2 &#x3D; await reload2()  console.log(result2);  const result3 &#x3D; await reload3()  console.log(result3);  return &#39;start 返回值&#39;&#125;const p &#x3D; start()console.log(p); &#x2F;&#x2F; promise<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用 <code>async/await</code> 时，默认情况下返回值是 <code>.then</code> 的内容，如果想要捕获异常，那么需要通过 <code>try...catch...</code> 来完成。</p><p>同时对于异步函数来说，也可以配合生成器进行使用，得到 <strong>异步生成器函数</strong>。这种异步生成器，在需要 <strong>手动控制多个异步请求的顺序以及结果的时候，会有些用处</strong>，如果大家没有这方面的需求，只需要有个印象就可以了。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; async 函数必然返回 promiseasync function* fetchInSeries([...urls]) &#123;  for (const url of urls) &#123;    const res &#x3D; await fetch(url)    &#x2F;&#x2F; g.next().value 得到 res.json()    yield res.json()  &#125;&#125;async function getData() &#123;  const g &#x3D; fetchInSeries([&#39;1.json&#39;, &#39;2.json&#39;, &#39;3.json&#39;])  &#x2F;*    let result &#x3D; await g.next()    while (!result.done) &#123;      console.log(result.value);      result &#x3D; await g.next()    &#125;  *&#x2F;  let result  while (!(result &#x3D; await g.next()).done) &#123;    console.log(result.value);  &#125;&#125;getData()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码的 <code>getData()</code> 方法中，我们通过 <code>fetchInSeries</code> 方法得到了一个迭代器 <code>g</code> ，然后利用 <code>while</code> 循环的方式进行了迭代。</p><p>而整个迭代的过程可以进一步的简写，利用 <code>for await of</code> 语法，会更加轻松</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">async function getData() &#123;  &#x2F;&#x2F; for await of：利用迭代器的特性配合 await 解析生成器  for await (const value of fetchInSeries([&#39;1.json&#39;, &#39;2.json&#39;, &#39;3.json&#39;])) &#123;    console.log(value);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旧习换新-7"><a href="#旧习换新-7" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>使用 <code>async、await</code> 配合 <code>promise</code> 处理异步请求，是在当前阶段开发中非常常见的一种场景。当大家遇到异步请求时，那么首先应该想到的就是 <code>Promise + async\await</code>。</p><h2 id="第十章：模板字面量、标签函数和新的字符串特性"><a href="#第十章：模板字面量、标签函数和新的字符串特性" class="headerlink" title="第十章：模板字面量、标签函数和新的字符串特性"></a>第十章：模板字面量、标签函数和新的字符串特性</h2><p>从第十章开始，到第十四章为止，这五个章节主要是对传统技术的升级。</p><p>以第十章为例，传统技术下，想要拼接字符串与变量，那么一般需要通过 <strong>+ 运算符</strong> 进行隐式转换。而 <code>ES6</code> 之后，提供了 <strong>模板字符串</strong> 的概念：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const msg &#x3D; &#39;world&#39;console.log(&#96;hello $&#123;msg&#125;&#96;); &#x2F;&#x2F; hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>处理之外，还提供了一些新的字符串方法。</p><p>以及通过 <code>for of</code> 隐式迭代器对字符串进行迭代操作。</p><h3 id="旧习换新-8"><a href="#旧习换新-8" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>这一章的内容中，对我们日常开发和面试有用的内容其实比较少，里面还包含一些对我们没有什么用处的东西，比如 <code>Unicode 的改进</code>，这些我就略过了，如果大家对 <code>Unicode</code> 感兴趣的话，可以去看一下书中的内容。</p><h2 id="第十一章：新数组特性、类型化数组"><a href="#第十一章：新数组特性、类型化数组" class="headerlink" title="第十一章：新数组特性、类型化数组"></a>第十一章：新数组特性、类型化数组</h2><p>对于第十一章来说，和第十章其实非常的类似。第十一章主要讲解的是 <code>Array 数组的改进</code>。内容主要就是两部分。</p><p>第一部分是对于 <code>Array</code> 数组的新增方法。</p><p>第二部分是 <strong>类型化数组</strong>。</p><p>对于很多小伙伴来说，类型化数组的概念大家可能是第一次听到。但是大家应该知道 <strong>JavaScript 中传统的 “数组” 并不是真正的数组，而是一个对象。</strong> 所以在 <code>ES6</code> 之后，<code>TC39</code> 提出了一个新的概念就是 <strong>类型化数组</strong>，不同的类型化数组可以存储不同的值，但是在日常的使用中，我们可能很少会主动使用这个东西。</p><h3 id="旧习换新-9"><a href="#旧习换新-9" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>数组的新增方法，在日常开发中是非常有用的。所以以上我们所列举出来的方法大家一定去 <code>MDN</code> 上看一下，至少做到有个印象。</p><h2 id="第十二章：Map-和-Set"><a href="#第十二章：Map-和-Set" class="headerlink" title="第十二章：Map 和 Set"></a>第十二章：Map 和 Set</h2><p>上面两章的内容相对都比较简单。但是接下来的 <code>Map</code> 和 <code>Set</code> 可能对于很多小伙伴来说是 <strong>“盲区”</strong>。</p><p>这一章一共讲到了 <code>4个</code> 新的接口：<code>Map、Set、WeakMap、WeakSet</code>。</p><p>咱么先来看 <code>Map</code>。<code>Map</code> 是 <strong>以 键\值对 的形式存储数据的对象，其中键值对可以是任何值</strong>。乍一看可能和 <strong>普通对象</strong> 没有什么区别，但是大家需要注意的是 <strong>普通对象的 key 只能是 字符串</strong>。 而 <strong>Map 对象的 key 可以是任意值</strong>。</p><p>也就是说虽然存储方式相同，但是可存储的内容确实大大不同的。</p><p>除此之外，在 <code>API</code> 上，<code>Map</code> 和 <code>&#123;&#125;</code> 也有较大的区别。我们可以来看下关于 <code>Map</code> 对象的基本语法：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 创建const m &#x3D; new Map()&#x2F;&#x2F; 增m.set(&#39;name&#39;, &#39;张三&#39;)m.set(&#39;age&#39;, &#39;30&#39;)&#x2F;&#x2F; 改m.set(&#39;name&#39;, &#39;李四&#39;)&#x2F;&#x2F; 查m.get(&#39;name&#39;)&#x2F;&#x2F; 删m.delete(&#39;name&#39;)&#x2F;&#x2F; 获取长度console.log(m.size);&#x2F;&#x2F; 迭代for (const [key, value] of m) &#123;  console.log(key, value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对于 <code>Set</code> 而言，它与数组有些类似，但是不同的地方在于 <strong><code>Set</code> 存储唯一值，也就是元素不可以重复。</strong></p><p>同样它的语法和传统的 <code>Array</code> 也有较大的区别：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 创建const s &#x3D; new Set()&#x2F;&#x2F; 增s.add(&#39;张三&#39;).add(&#39;李四&#39;)&#x2F;&#x2F; 是否包含s.has(&#39;张三&#39;)&#x2F;&#x2F; 删s.delete(&#39;张三&#39;)&#x2F;&#x2F; 清空s.clear()&#x2F;&#x2F; 获取长度console.log(s.size);&#x2F;&#x2F; 迭代for (const value of s) &#123;  console.log(value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对于 <code>Map</code> 和 <code>Set</code> 来说，都提供了一个 <code>Weak</code> 版，叫做 <code>WeakMap</code> 和 <code>WeakSet</code>。</p><p> <code>WeakMap</code> 和 <code>WeakSet</code>与 <code>Map</code> 和 <code>Set</code> 的区别主要体现在三个地方：</p><ul><li>首先第一个地方是 <strong>值为弱引用</strong> ，这意味着它并不会影响垃圾回收。</li><li>同时因为是弱引用，所以 <strong>值不会保存在内存中</strong>，这个就比较好理解了。</li><li>最后就是 <strong>不可迭代</strong>。</li></ul><h3 id="旧习换新-10"><a href="#旧习换新-10" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>最后就是旧习换新。</p><ul><li>首先：如果你要以键值对的形式保存数据，同时 <code>Key</code> 非字符串，那么此时可以考虑使用 <code>Map</code></li><li>其次：<code>Set</code> 对象可以存储唯一值，这在数组去重的场景下会非常有用</li><li>最后：如果你希望 <code>key</code> 跟随变量的销毁而被回收时，那么可以使用 <code>WeakMap</code> 或 <code>WeakSet</code></li></ul><h2 id="第十三章：模块"><a href="#第十三章：模块" class="headerlink" title="第十三章：模块"></a>第十三章：模块</h2><p>第十三章主要讲解的就是模块化的概念。任何的模块化都会被分成两部分 <strong>导入</strong> 和 <strong>导出</strong>。</p><p>而目前在前端领域，主要的模块化方式有两个 <code>ESM</code> 和 <code>CJS</code> 。</p><p>所以说咱们在这一章中要学习的就是：</p><ul><li><code>ESM</code> 的导入、导出</li><li><code>CJS</code> 的导入、导出</li></ul><p>一个四个环节。</p><p>那么首先我们先来看 <code>ESM</code>。所谓 <code>ESM</code> 指的是 <strong>ES2015 之后新增的标准模块化方案 <code>ES Module</code><strong>。它相对复杂一点，分为 <strong>直接导出</strong>、</strong>按需导出</strong>、<strong>直接导入</strong>、<strong>按需导入</strong> 一共四部分。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">直达链接</a>。</p><p>除了这标准的四部分之后，有时候在 <code>EMS</code> 中可能还会涉及到 <strong>导入同时导出</strong> 的场景，如果想要导入并导出，那么可以通过 <code>export &#123;xx&#125; from &#39;./xx&#39;</code> 的方式进行。</p><p>第二个是 <code>CJS</code>。<code>CJS</code> 的逻辑与 <code>ESM</code> 相同，甚至更加简单。只是语法上会稍有不同。<code>CJS</code> 不存在按需的概念，所以只有导入和导出两部分。<a href="https://nodejs.org/docs/latest/api/modules.html">文档直达链接</a></p><p>除了 <code>CJS</code> 和 <code>EMS</code> 之外，还有一些其他的模块化方案，比如 <code>UMD</code>，<code>AMD</code>、<code>CMD</code> 等等。这些模块化方案在应用层开发中很少见，所以咱们不做讨论。</p><h3 id="旧习换新-11"><a href="#旧习换新-11" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>最后就是旧习换新环节。</p><p>其实对于模块化的问题，在现在的企业开发中已经是非常常见的了。无论是 <code>EMS</code> 还是 <code>CJS</code> 都已经得到了广泛的应用。所以这一章的内容，对于大多数小伙伴来说，应该都没有太大的难度才对。</p><h2 id="第十四章：反射和代理"><a href="#第十四章：反射和代理" class="headerlink" title="第十四章：反射和代理"></a>第十四章：反射和代理</h2><p>看完模块化之后，下面咱们来看下反射和代理的概念。其中反射代表的是 <code>Reflect</code>，代理代表的是 <code>Proxy</code>。我第一次接触它们两个是在 <code>Vue 3</code> 中接触到的。</p><p>这两个 <code>API</code> 多数情况下应该是配合使用的，任意一个单独拿出来，在复杂场景中都意义不大。</p><p>所以说我们在介绍这两个 <code>API</code> 的时候会先介绍它们两个的作用，然后再把它们两个合起来去说。</p><p>那么咱们先来看 <code>反射对象（Reflect）</code> 。它 <strong>提供了《对象基本操作的各种方法，比如：获取和设置属性值、获取和设置对象的原型、从对象中删除属性…》</strong> 等等……</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;  name: &#39;张三&#39;&#125;console.log(person.name) &#x2F;&#x2F; 张三console.log(Reflect.get(person, &#39;name&#39;)) &#x2F;&#x2F; 张三<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，我们可以利用 <code>Reflect.get(person, &#39;name&#39;)</code> 方法，获取到 <code>person</code> 对象下 <code>name</code> 属性的值。</p><p>但是肯定有很多小伙伴看到这就说了 <strong>这有啥用啊？</strong> 我们完全可以通过 <code>person.name</code> 来获取啊。</p><p>所以 <code>Reflect</code> 的真正有意义的使用，就需要配合 <code>Proxy</code> 进行了。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;name: &#39;张三&#39;,age: 30&#125;const p &#x3D; new Proxy(person, &#123;&#x2F;** * 代理 person 的 setter 行为 * @param &#123;*&#125; target person 被代理对象 * @param &#123;*&#125; key 修改时的 key * @param &#123;*&#125; value 修改的 value * @param &#123;*&#125; receiver proxy 实例 p，被代理对象 *&#x2F;set(target, key, value, receiver) &#123;console.log(target, key, value, receiver)&#x2F;&#x2F; 修改被代理对象target[key] &#x3D; value&#x2F;&#x2F; 标记修改成功return true&#125;,&#x2F;** * 代理 person 的 getter 行为 * @param &#123;*&#125; target person 被代理对象 * @param &#123;*&#125; key 修改时的 key * @param &#123;*&#125; receiver proxy 实例 p，被代理对象 * @returns *&#x2F;get(target, key, receiver) &#123;return target[key]&#125;&#125;)p.name &#x3D; &#39;李四&#39; &#x2F;&#x2F; 触发 set。注意：只有修改 proxy 实例才会触发 setconsole.log(p.name) &#x2F;&#x2F; 触发 get。注意：只有通过 proxy 实例才会触发 get<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，我们通过 <code>Proxy</code> 代理了 <code>person</code> 的 <code>getter</code> 行为和 <code>setter</code> 行为。从而可以监听到 <code>person</code> 的赋值操作和输出操作。</p><p>那么下面我们来看 <code>Proxy</code> 配合 <code>Reflect</code> 的场景，这个场景可能稍微有一些复杂，需要大家在搞明白 <code>Proxy</code> 和 <code>Reflect</code> 之后再查看：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;lastName: &#39;张&#39;,firstName: &#39;三&#39;,&#x2F;&#x2F; 通过 get 标识符标记，可以让方法的调用像属性的调用一样get fullName() &#123;return this.lastName + this.firstName&#125;&#125;const proxy &#x3D; new Proxy(person, &#123;get(target, key, receiver) &#123;console.log(&#39;触发了 getter&#39;)&#x2F;&#x2F; getter 行为本应触发三次，但是只触发了一次。这是因为 fullName 中的 this 指向了 target(person)，而不是 proxy 实例&#x2F;&#x2F; return target[key]&#x2F;&#x2F; 正常触发三次return Reflect.get(target, key, receiver)&#125;&#125;)console.log(proxy.fullName)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的这段代码中，我们为 <code>person</code> 提供了一个 <code>get fullName() </code> 的属性方法，当 <code>fullName</code> 被触发时，它应该存在 <strong>三次 <code>getter</code> 行为</strong>，即： <strong>fullName、lastName、firstName</strong>。</p><p>但是如果我们在 <code>get</code> 监听中，使用 <code>target[key]</code> 的方式，那么这三次的 <code>getter</code> 行为只会被监听一次。原因是因为 <code>fullName</code> 中的 <code>this</code> 指向 <code>person</code>，而不会指向 <code>proxy 实例</code>。</p><p>所以我们需要通过 <code>Reflect.get</code> 来完成这个行为。 <code>Reflect.get</code> 的第三个参数可以控制 <code>fullName</code> 的 <code>this</code> 指向，使其指向 <code>receiver</code>，也就是  <code>proxy 实例</code>。</p><h3 id="旧习换新-12"><a href="#旧习换新-12" class="headerlink" title="旧习换新"></a>旧习换新</h3><p>如果大家从事业务开发，那么 <code>Proxy</code> 和 <code>Reflect</code> 使用的场景应该并不多。而如果有一天，你需要监听某个对象的 <code>getter</code> 或者 <code>setter</code> 动作了，那么可以直接通过 <code>Proxy</code> 来完成。</p><h2 id="第十五章：正则表达式"><a href="#第十五章：正则表达式" class="headerlink" title="第十五章：正则表达式"></a>第十五章：正则表达式</h2><p>基本上每一本 <code>JavaScript</code> 的书籍都会包含一个 <strong>正则表达式</strong> 的环节，但是讲道理在日常的开发中 <strong>正则表达式</strong> 的使用不足以让我们花费大量的时间，同时书中的那些内容也不足以支撑复杂场景的 <strong>正则表达式</strong> 使用。</p><p>在本书的第十五章中，我摘抄出了 <strong>3 个新增的正则标记符</strong>，为大家提供参考。</p><h2 id="第十六章：共享内存"><a href="#第十六章：共享内存" class="headerlink" title="第十六章：共享内存"></a>第十六章：共享内存</h2><p>作者在书中说道： <strong>绝大多数的开发者并不需要在线程之间共享内存。</strong>  作者说的很对，所以我们这里不会花费篇章来说这个问题。如果你需要，那么可以看下书中讲解的内容。</p><h2 id="第十七章：其他特性"><a href="#第十七章：其他特性" class="headerlink" title="第十七章：其他特性"></a>第十七章：其他特性</h2><p>第十七章的其他特性，主要呈现了一些单一、不成系统的特性。这些特性虽然大多都比较简单，但是有些在日常开发中还是比较有用的。</p><p>我从中抽出来了对我们日常开发有价值的新特性，咱们一起来看一下：</p><ul><li><p><strong>BigInt</strong>：<code>BigInt</code> 主要用来处理大数字问题：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; BigInt：处理大数字（大于 2^53 - 1 的整数）问题const bigNum &#x3D; 900719925474099596console.log(bigNum); &#x2F;&#x2F; 9867273627366328000  数值错误&#x2F;&#x2F; const bigIntObj &#x3D; BigInt(900719925474099596n)const bigIntObj &#x3D; 900719925474099596n &#x2F;&#x2F; 加上 n 表示 bigintconsole.log(bigIntObj.toString()); &#x2F;&#x2F; 900719925474099596<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>新的整数字面量语法（二进制、八进制）</strong>：主要针对二进制、八进制</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 二进制 0b 开头console.log(0b1000); &#x2F;&#x2F; 8&#x2F;&#x2F; 八进制 0o 开头console.log(0o17); &#x2F;&#x2F; 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>省略 catch 绑定的异常</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 省略 catch 绑定的异常try &#123;  JSON.parse(&#39;abc&#39;)&#125; catch &#123;  console.log(&#39;不需要为 catch(err) &#123;...&#125;&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>新的 Math 方法</strong></p><p><img src="/2023/06/24/jing-du-shen-ru-li-jie-xian-dai-javascript/image-20230627142003717.png" alt="image-20230627142003717"></p></li><li><p><strong>取幂运算符</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 取幂运算符 **console.log(2 ** 3); &#x2F;&#x2F; 2 * 2 * 2 &#x3D; 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>空值合并</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 空值合并 ??const num &#x3D; 0 &#x2F;&#x2F; 0 是一个正常的数值，但是在 JavaScript 中 0 参与逻辑运算会被当做 “假”&#x2F;&#x2F; 利用逻辑或的逻辑中断特性console.log(num || 300); &#x2F;&#x2F; 300&#x2F;&#x2F; 但是在程序中，有些时候 0 会被作为一个有意义的值，所以上面案例，我们去期望得到的是 0&#x2F;&#x2F; 利用空值合并：?? 前面的值只有为 null 或者 undefined 才会被认为 “假”console.log(num ?? 300); &#x2F;&#x2F; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>可选链</strong></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 可选链 xx?.xx  const person &#x3D; &#123;  name: &#39;张三&#39;&#125;&#x2F;&#x2F; console.log(person.child.name); &#x2F;&#x2F; child 为 undefined，所以报错 Cannot read properties of undefined (reading &#39;name&#39;)&#x2F;&#x2F; 利用可选链，如果 ? 前面为 null 或者 undefined ，则逻辑短路console.log(person.child?.name); &#x2F;&#x2F; undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="第十八章：即将推出的类特性"><a href="#第十八章：即将推出的类特性" class="headerlink" title="第十八章：即将推出的类特性"></a>第十八章：即将推出的类特性</h2><h2 id="第十九章：展望未来"><a href="#第十九章：展望未来" class="headerlink" title="第十九章：展望未来"></a>第十九章：展望未来</h2><p>最后的十八和十九章，对我们现在而言意义就不大了。里面很多的特性现在并不支持，在实际开发中使用的场景也非常有限。</p><p>如果你对这些东西比较感兴趣的话，那么可以看一下。否则意义不大。</p><blockquote><p>视频出处：【一小时读完《深入理解现代 JavaScript》，彻底掌握 ES6 之后 JavaScript 新特性！】 <a href="https://www.bilibili.com/video/BV1qD4y1G7YK/?share_source=copy_web&amp;vd_source=a9f0fd4630ebe41da19ca2c83eb295e6">https://www.bilibili.com/video/BV1qD4y1G7YK/?share_source=copy_web&amp;vd_source=a9f0fd4630ebe41da19ca2c83eb295e6</a></p><p>作者：LGD_Sunday</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器权重计算</title>
      <link href="/2023/06/24/css-xuan-ze-qi-quan-chong-ji-suan/"/>
      <url>/2023/06/24/css-xuan-ze-qi-quan-chong-ji-suan/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ol><li><a href="https://qt-7274.github.io/2023/02/27/html5-xin-zeng-yuan-su/">CSS特性与优先级 | QT-7274</a></li><li><a href="https://qt-7274.github.io/2023/06/23/qian-tan-css-zhong-de-xuan-ze-qi/">浅谈CSS中的选择器 | QT-7274</a></li></ol><h1 id="CSS选择器权重计算"><a href="#CSS选择器权重计算" class="headerlink" title="CSS选择器权重计算"></a>CSS选择器权重计算</h1><p>通过不同的选择器，选中相同的元素，并且为相同的样式名设置不同的值时，就发生了样式的冲突。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><blockquote><p><code>!important</code> &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配选择器</p></blockquote><h2 id="权值计算"><a href="#权值计算" class="headerlink" title="权值计算"></a>权值计算</h2><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>每个选择器，都可以计算出一组权重，格式为：<code>(a, b, c)</code></p><blockquote><ul><li><code>a</code>: ID选择器的个数。</li><li><code>b</code>: <strong>类、伪类、属性</strong>选择器的个数。</li><li><code>c</code>: <strong>元素、伪</strong>选择器的个数</li></ul></blockquote><table><thead><tr><th>选择器</th><th>权重</th></tr></thead><tbody><tr><td><code>ul&gt;li</code></td><td><code>(0,0,2)</code></td></tr><tr><td><code>div ul&gt;li p a span</code></td><td><code>(0,0,6)</code></td></tr><tr><td><code>#qt7274</code> <code>.slogan</code></td><td><code>(1,1,0)</code></td></tr><tr><td><code>#qt7274</code> <code>.slogan</code> <code>a</code></td><td><code>(1,1,1)</code></td></tr></tbody></table><h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><p>按照 <span style="color: red;">从左到右</span>的顺序，依次比较大小，当前位胜出后，后面的不再对比，例如：</p><blockquote><ul><li><code>(1,0,0)</code> &gt; <code>(0,2,2)</code></li><li><code>(1,1,0)</code> &gt; <code>(1,0,3)</code></li><li><code>(1,1,3)</code> &gt; <code>(1,1,2)</code></li></ul></blockquote><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2023/06/24/css-xuan-ze-qi-quan-chong-ji-suan/image-20230624193751875.png" alt="image-20230624193751875"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈CSS中的选择器</title>
      <link href="/2023/06/23/qian-tan-css-zhong-de-xuan-ze-qi/"/>
      <url>/2023/06/23/qian-tan-css-zhong-de-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ol><li><a href="https://qt-7274.github.io/2023/02/27/html5-xin-zeng-yuan-su/">CSS特性与优先级</a></li><li><a href="https://qt-7274.github.io/2023/06/24/css-xuan-ze-qi-quan-chong-ji-suan/">CSS选择器权重计算 | QT-7274 (qt7274.co)</a></li></ol><h2 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h2><p>使用场景：选中<strong>同时满足</strong>条件的所有选择器。</p><p>代码示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p.red</span> <span class="token punctuation">&#123;</span>  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li>标签要写在选择器的开头，例如<code>p</code>元素。</li><li>选择器之间<strong>没有空格</strong>。</li><li>id选择器理论上可以作为交集的条件，但没有意义。</li><li>交集选择器中不可能出现两个元素选择器。</li><li>元素选择器配合类名选择器使用频率较多。</li></ol></blockquote><h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><p>使用场景：同时选择<strong>满足其中任意一个</strong>选择器条件的元素。<br>代码示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">h1, h2</span> <span class="token punctuation">&#123;</span>  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意；</p><ol><li>多个选择器通过**<code>,</code>**连接，此处<code>,</code>的含义就是或。</li><li>需要注意的是，<strong>并集选择器中的选择器顺序不影响选择结果</strong>。无论选择器的顺序如何，只要满足其中任意一个选择器的条件，元素就会被选中。</li><li>一般竖着写。</li><li>任何形式的选择器都可以作为并集选择器的一部分。</li><li>并集选择器通常用于集体声明，可以缩小样式表体积。</li></ol></blockquote><h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>使用场景：选中指定元素中，<strong>符合要求的后代元素</strong>。</p><p>代码示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">ul li</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li>选择器之间，以<strong>空格</strong>隔开。</li><li>后代选择器，最终选择的是后代，不选中祖先。</li><li>儿子、孙子、重孙子都算是后代。</li><li>结构一定要符合HTML的嵌套要求。</li></ol></blockquote><h2 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h2><p>使用场景：选择指定元素中，符合要求的子元素（<strong>儿子元素</strong>）。</p><p>代码示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div>a</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li>选择器之间以**<code>&gt;</code>**隔开。</li><li>子代选择器，最终选择的是子代，不是父级。</li><li>注意子元素和后代元素的区别。</li></ol></blockquote><h2 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h2><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>使用场景：选中指定元素后，符合条件的<strong>相邻兄弟</strong>元素。</p><blockquote><p>相邻：紧挨着当前元素的下一个元素。</p></blockquote><p>代码示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div+p</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li>选择器之间以**<code>+</code>**连接。</li></ol></blockquote><h3 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h3><p>使用场景：选中指定元素后，符合条件的<strong>所有兄弟</strong>元素。</p><p>代码示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div~p</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li>选择器之间以**<code>~</code>**连接。</li></ol></blockquote><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>使用场景：选中属性值<strong>符合一定要求</strong>的元素。</p><p>代码示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 选中具有title属性的元素 */</span><span class="token selector">div[title]</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 选中title属性值为qt7274的元素 */</span><span class="token selector">div[title="qt7274"]</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 选中title属性值以a开头的元素 */</span><span class="token selector">div[title^="a"]</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 选中title属性值以u结尾的元素 */</span><span class="token selector">div[title$="u"]</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 选中title属性值包含g的元素 */</span><span class="token selector">div[title*="g"]</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li><code>[属性名]</code> 选中<strong>具有</strong>某个属性的元素。</li><li><code>[属性名=&quot;值&quot;]</code> 选中包含某个属性，且属性值<strong>等于</strong>指定值的元素。</li><li><code>[属性名^=&quot;值&quot;]</code> 选中包含某个属性，且属性值以指定的值<strong>开头</strong>的元素。</li><li><code>[属性名$=&quot;值&quot;]</code> 选中包含某个属性，且属性值以指定的值<strong>结尾</strong>的元素。</li><li><code>[属性名*=“值”]</code> 选择包含某个属性，属性值<strong>包含</strong>指定值的元素。</li></ol></blockquote><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>使用场景：选中特殊状态的元素。</p><blockquote><p>伪——虚假的，不是真实存在的。</p><p>伪类——像类(<code>class</code>)，但不是类，是元素的一种特殊状态。</p></blockquote><h3 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h3><ol><li><p><code>:link</code> 超链接<strong>未被访问</strong>的状态。</p></li><li><p><code>:visited</code> 超链接<strong>访问过</strong>的状态。</p></li><li><p><code>:hover</code> 鼠标<strong>悬停</strong>在元素上的状态。</p></li><li><p><code>:active</code> 元素<strong>激活</strong>的状态。</p><blockquote><p>在CSS中，元素的激活状态（Active State）是指当用户与元素进行交互并触发其激活行为时的状态。通常，元素的激活状态与用户的操作有关，例如点击、按下鼠标按钮或按下键盘按键等。</p><p>一旦用户释放鼠标按钮或松开键盘按键，元素就会恢复到正常状态。</p></blockquote></li><li><p><code>:focus</code>获取<strong>焦点</strong>的元素。</p><blockquote><p>表单类元素才能使用<code>:focus</code>伪类。</p><p>当用户：点击元素、触摸元素、或通过键盘的“tab”键等方式选择元素时，就是获得焦点。</p></blockquote></li></ol><h3 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h3><h4 id="常用结构伪类"><a href="#常用结构伪类" class="headerlink" title="常用结构伪类"></a>常用结构伪类</h4><ol><li><code>:first-child</code> 所有兄弟元素中的<strong>第一个</strong>。</li><li><code>:last-child</code> 所有兄弟元素中的<strong>最后一个</strong>。</li><li><code>:nth-child(n)</code> 所有兄弟元素中的<strong>第 n 个</strong>。</li><li><code>:first-of-type</code> 所有<strong>同类型</strong>兄弟元素中的<strong>第一个</strong>。</li><li><code>:last-of-type</code> 所有<strong>同类型</strong>兄弟元素中的<strong>最后一个</strong>。</li><li><code>:nth-of-type(n)</code> 所有<strong>同类型</strong>兄弟元素中的 <strong>第n个</strong> 。</li></ol><p>关于n的值：</p><blockquote><ol><li><code>0</code> 或 <code>不写</code> ：什么都选不中 —— 几乎不用。</li><li><code>n</code> ：选中所有子元素 —— 几乎不用。</li><li><code>1~正无穷的整数</code> ：选中对应序号的子元素。</li><li><code>2n</code> 或 <code>even</code> ：选中序号为偶数的子元素。</li><li><code>2n+1</code> 或 <code>odd</code> ：选中序号为奇数的子元素。</li><li><code>-n+3</code> ：选中的是前 3 个。</li></ol></blockquote><h4 id="不常用结构伪类"><a href="#不常用结构伪类" class="headerlink" title="不常用结构伪类"></a>不常用结构伪类</h4><ol><li><code>:nth-last-child(n) </code>所有兄弟元素中的<strong>倒数第 n 个</strong>。</li><li><code>:nth-last-of-type(n)</code> 所有<strong>同类型</strong>兄弟元素中的 <strong>倒数第n个</strong> 。</li><li><code>:only-child</code> 选择没有兄弟的元素（独生子女）。</li><li><code>:only-of-type</code> 选择没有<strong>同类型</strong>兄弟的元素。</li><li><code>:root </code>根元素。</li><li><code>:empty</code> 内容为空元素（空格也算内容）。</li></ol><h3 id="否定伪类"><a href="#否定伪类" class="headerlink" title="否定伪类"></a>否定伪类</h3><p><code>:not(选择器)</code> 排除满足括号中条件的元素。</p><h3 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h3><ol><li><code>:checked</code> 被选中的复选框或单选按钮。</li><li><code>:enable</code> 可用的表单元素（没有 <code>disabled</code> 属性）。</li><li><code>:disabled</code> 不可用的表单元素（有 <code>disabled</code> 属性）。</li></ol><h3 id="目标伪类"><a href="#目标伪类" class="headerlink" title="目标伪类"></a>目标伪类</h3><p><code>:target</code> 选中锚点指向的元素。</p><h3 id="语言伪类"><a href="#语言伪类" class="headerlink" title="语言伪类"></a>语言伪类</h3><p><code>:lang()</code> 根据指定的语言选择元素（本质是看 <code>lang</code> 属性的值）</p><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p>使用场景：选中元素中的一些特殊位置</p><p>常用伪元素：</p><ul><li><code>::first-letter</code> 选中元素中的<strong>第一个文字</strong>。</li><li><code>::first-line</code> 选中元素中的<strong>第一行文字</strong>。</li><li><code>::selection</code> 选中<strong>被鼠标选中</strong>的内容。</li><li><code>::placeholder</code> 选中输入框的<strong>提示文字</strong>。</li><li><code>::before</code> 在元素<strong>最开始</strong>的位置，创建一个子元素（必须用 <code>content</code> 属性指定内容）。</li><li><code>::after</code> 在元素<strong>最后</strong>的位置，创建一个子元素（必须用 <code>content</code> 属性指定内容）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5表单验证细节</title>
      <link href="/2023/06/14/html5-biao-dan-yan-zheng-xi-jie/"/>
      <url>/2023/06/14/html5-biao-dan-yan-zheng-xi-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a><code>label</code>标签</h2><p><code>label</code>元素的作用是为控件提供可点击的文本标签，当用户点击标签时，相关的控件会获得焦点或执行相应的操作。</p><ol><li><p>通过将<code>label</code>元素的<code>for</code>属性设置为相关控件的<code>id</code>，可以将<code>label</code>与控件进行关联。这种方式允许用户<strong>通过点击标签来聚焦或选择相应的控件</strong>。示例代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>将控件直接放在<code>label</code>元素内部，不需要使用<code>for</code>属性。这种方式不需要额外指定<code>id</code>属性，标签与控件之间的关联通过嵌套关系建立。示例代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>用户名：  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="约束验证"><a href="#约束验证" class="headerlink" title="约束验证"></a>约束验证</h2><h3 id="validity属性"><a href="#validity属性" class="headerlink" title="validity属性"></a>validity属性</h3><p>在HTML5中，<code>validity</code>（有效性）是一个用于验证表单字段的属性。它是在浏览器中内置的验证功能，用于检查用户输入的有效性并提供相应的反馈。</p><p>每个HTML5表单字段都具有一个<code>validity</code>属性，该属性包含一组布尔值，表示与字段的有效性相关的不同条件。这些条件包括以下几个方面：</p><ol><li><p><code>valueMissing</code>（值缺失）：如果字段是必填字段且没有提供值，则此属性为true。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>typeMismatch</code>（类型不匹配）：如果字段的值与字段的预期类型不匹配（例如，邮箱字段中输入的不是有效的电子邮件地址），则此属性为true。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>patternMismatch</code>（模式不匹配）：如果字段的值与通过正则表达式定义的模式不匹配，则此属性为true。模式可以使用<code>pattern</code>属性进行指定。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>tooShort</code>（长度过短）：如果字段的值长度小于通过<code>minLength</code>属性指定的最小长度，则此属性为true。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">minlength</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>6<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>tooLong</code>（长度过长）：如果字段的值长度大于通过<code>maxLength</code>属性指定的最大长度，则此属性为true。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">maxlength</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>rangeUnderflow</code>（范围过低）：如果字段的值小于通过<code>min</code>属性指定的最小值，则此属性为true。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token attr-name">min</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>rangeOverflow</code>（范围过高）：如果字段的值大于通过<code>max</code>属性指定的最大值，则此属性为true。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token attr-name">max</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>stepMismatch</code>（步骤不匹配）：如果字段的值不符合通过<code>step</code>属性指定的步长要求，则此属性为true。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token attr-name">step</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="setCustomValidity方法"><a href="#setCustomValidity方法" class="headerlink" title="setCustomValidity方法"></a><code>setCustomValidity</code>方法</h3><p>在HTML5中，<code>setCustomValidity</code>是一个用于设置自定义验证消息的方法。它可以用于覆盖浏览器默认的验证消息，并根据自定义逻辑设置验证字段的有效性。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Submit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">const</span> usernameInput <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    usernameInput<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>usernameInput<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      usernameInput<span class="token punctuation">.</span><span class="token function">setCustomValidity</span><span class="token punctuation">(</span><span class="token string">'Username must be at least 6 characters long.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      usernameInput<span class="token punctuation">.</span><span class="token function">setCustomValidity</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法也可结合validity属性使用，可用validity属性中的字段的布尔值作为校验依据。</p><h2 id="表单美化"><a href="#表单美化" class="headerlink" title="表单美化"></a>表单美化</h2><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><ol><li><p><code>:required</code>和<code>:optional</code>是CSS伪类选择器，用于选择表单元素（如input、select、textarea等）中的必填和可选项。</p><p><code>:required</code>伪类选择器选择需要填写的表单元素，即具有<code>required</code>属性的表单元素。这些元素在提交表单之前必须包含值，否则会触发HTML5验证，并阻止表单的提交。</p><p>示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">cssCopy codeinput:required</span> <span class="token punctuation">&#123;</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述CSS规则将选择所有带有<code>required</code>属性的输入元素，并将其边框颜色设置为红色。</p><p><code>:optional</code>伪类选择器选择可选的表单元素，即没有<code>required</code>属性的表单元素。这些元素可以包含值，也可以为空。</p><p>示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">cssCopy codeinput:optional</span> <span class="token punctuation">&#123;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 0.5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述CSS规则将选择所有没有<code>required</code>属性的输入元素，并将其透明度设置为0.5。</p><p>这些伪类选择器可以帮助我们根据表单元素的必填和可选状态来应用不同的样式或行为。</p></li><li><p>在css中设置label后的名称以及选中边框样式</p><p>示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">input:optional</span><span class="token punctuation">&#123;</span><span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"(选填)"</span><span class="token punctuation">;</span>    <span class="token property">outline</span><span class="token punctuation">:</span> 0<span class="token punctuation">&#125;</span><span class="token selector">input:required</span><span class="token punctuation">&#123;</span><span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"(必填)"</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> 0 0 3px 1px #aa0088<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>:valid</code> 和 <code>:invalid</code> 是 CSS 伪类选择器，用于选择表单元素的验证状态。</p><p><code>:valid</code> 伪类选择器匹配符合验证规则的表单元素，即通过验证的元素。这些元素可以包含有效的值，并满足其所定义的验证条件。</p><p>示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">cssCopy codeinput:valid</span> <span class="token punctuation">&#123;</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述 CSS 规则将选择所有通过验证的输入元素，并将其边框颜色设置为绿色。</p><p><code>:invalid</code> 伪类选择器匹配不符合验证规则的表单元素，即未通过验证的元素。这些元素包含无效的值或不满足其所定义的验证条件。</p><p>示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">cssCopy codeinput:invalid</span> <span class="token punctuation">&#123;</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述 CSS 规则将选择所有未通过验证的输入元素，并将其边框颜色设置为红色。</p><p>这些伪类选择器可以帮助我们根据表单元素的验证状态来应用不同的样式或行为。它们通常与 HTML5 的表单验证机制一起使用，可以基于浏览器自动验证的结果来进行样式调整或其他交互。</p></li></ol><h3 id="事件优化"><a href="#事件优化" class="headerlink" title="事件优化"></a>事件优化</h3><ol><li><p>使用<code>oninput</code>和<code>oninvalid</code>设置验证结果</p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tel<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tel<span class="token punctuation">"</span></span> <span class="token attr-name">autofocus</span> <span class="token attr-name">required</span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Enter your name<span class="token punctuation">"</span></span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>^[0-9]&#123;5&#125;$<span class="token punctuation">"</span></span> <span class="token attr-name">oninput</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>this.setCustomValidity(<span class="token punctuation">'</span><span class="token punctuation">'</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">oninvalid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>this.setCustomValidity(<span class="token punctuation">'</span>请输入正确的手机号码<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用JavaScript判断两次密码输入是否一致</p><p>示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function checkPassword()&#123;        var password &#x3D; document.getElementById(&#39;password&#39;).value;        var RepeatPassword &#x3D; document.getElementById(&#39;Repeat password&#39;).value;        if(password !&#x3D; RepeatPassword)&#123;            RepeatPassword.setCustomValidity(&#39;两次输入的密码不一致&#39;);        &#125;        else&#123;            RepeatPassword.setCustomValidity(&#39;&#39;);        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>去除默认起泡样式</p><p>示例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 用于替换表单的默认无效样式的函数function replaceInvalidityUi(form) &#123;  &#x2F;&#x2F; 为表单添加 &#39;invalid&#39; 事件监听器  form.addEventListener(&#39;invalid&#39;, function(event) &#123;    event.preventDefault(); &#x2F;&#x2F; 阻止默认的无效表单提交行为  &#125;, true);  &#x2F;&#x2F; 为表单添加 &#39;submit&#39; 事件监听器  form.addEventListener(&#39;submit&#39;, function(event) &#123;    if (!this.checkValidity()) &#123; &#x2F;&#x2F; 检查表单是否有效      event.preventDefault(); &#x2F;&#x2F; 阻止表单提交    &#125;  &#125;, true);  &#x2F;&#x2F; 在表单中找到提交按钮  var submitButton &#x3D; form.querySelector(&#39;input[type&#x3D;&quot;submit&quot;]&#39;);  &#x2F;&#x2F; 为提交按钮添加 &#39;click&#39; 事件监听器  submitButton.addEventListener(&#39;click&#39;, function(event) &#123;    &#x2F;&#x2F; 在表单中找到所有无效字段    var invalidFields &#x3D; form.querySelectorAll(&#39;:invalid&#39;);    &#x2F;&#x2F; 在表单中找到所有错误消息元素    var errorMessages &#x3D; form.querySelectorAll(&#39;.error-message&#39;);    &#x2F;&#x2F; 从DOM中删除现有的错误消息    for (var i &#x3D; 0; i &lt; errorMessages.length; i++) &#123;      errorMessages[i].parentNode.removeChild(errorMessages[i]);    &#125;    &#x2F;&#x2F; 为每个无效字段添加错误消息    for (var i &#x3D; 0; i &lt; invalidFields.length; i++) &#123;      var invalidField &#x3D; invalidFields[i];      invalidField.insertAdjacentHTML(&#39;afterend&#39;, &#39;&lt;div class&#x3D;&quot;error-message&quot;&gt;&#39; + invalidField.validationMessage + &#39;&lt;&#x2F;div&gt;&#39;);    &#125;    &#x2F;&#x2F; 如果存在无效字段，则将焦点设置在第一个无效字段上    if (invalidFields.length &gt; 0) &#123;      invalidFields[0].focus();    &#125;  &#125;);&#125;&#x2F;&#x2F; 获取具有ID &#39;form&#39; 的表单元素var form &#x3D; document.getElementById(&#39;form&#39;);&#x2F;&#x2F; 调用 replaceInvalidityUi 函数，为表单替换无效样式replaceInvalidityUi(form);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精读《Vue.js设计与实现》</title>
      <link href="/2023/06/12/jing-du-vue-js-she-ji-yu-shi-xian/"/>
      <url>/2023/06/12/jing-du-vue-js-she-ji-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《Vue.js 设计与实现》：它不同于市场上纯粹的 “源码分析” 类的书籍。而是 <strong>从高层的设计角度，探讨框架需要关注的问题（-尤雨溪序）</strong>，以 <strong>提出问题 - 分析思路 - 解决问题</strong> 的方式，来讲解 <code>vue 3</code> 的核心设计。其内部，没有读一行 <code>vue3</code> 的源码，但却可以让我们对整个 <code>vue 3</code> 的核心，拥有一个非常清楚的认知。</p><h2 id="第一篇：框架设计概览"><a href="#第一篇：框架设计概览" class="headerlink" title="第一篇：框架设计概览"></a>第一篇：框架设计概览</h2><h3 id="第一章：权衡的艺术"><a href="#第一章：权衡的艺术" class="headerlink" title="第一章：权衡的艺术"></a>第一章：权衡的艺术</h3><h4 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h4><p>首先第一个方面就是：<strong>命令式和声明式</strong> 的概念。</p><p>所谓 <strong>命令式</strong> 指的就是：<strong>关注过程</strong> 的范式。</p><p><img src="/%E7%B2%BE%E8%AF%BB%E3%80%8AVue-js%E3%80%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230612192529928.png" alt="image-20230612192529928"></p><p>而 <strong>声明式</strong> 指的就是： <strong>关注结果</strong> 的范式。</p><p><img src="/%E7%B2%BE%E8%AF%BB%E3%80%8AVue-js%E3%80%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230612192601767.png" alt="image-20230612192601767"></p><p>那么这里大家来想一下，<code>vue</code> 是声明式的？还是命令式的？</p><p>对于 <code>vue</code> 而言，它的内部实现一定是 <strong>命令式</strong> 的，而我们在使用 <code>vue</code> 的时候，则是通过 <strong>声明式</strong> 来使用的。</p><p>也就是说： <strong>vue 封装了命令式的过程，对外暴露出了声明式的结果</strong></p><h4 id="性能与可维护性的权衡"><a href="#性能与可维护性的权衡" class="headerlink" title="性能与可维护性的权衡"></a>性能与可维护性的权衡</h4><p>在明确好了命令式和声明式的概念之后。接下来咱们来看下从 <strong>性能</strong> 层面，<code>vue</code> 所体现出来的一种权衡的方式。</p><p>针对于性能的分析，主要从两个方面去说。</p><p>首先第一个方面：大家觉得 <strong>是命令式的性能更强，还是声明式的性能更强呢？</strong></p><p>答案是：<strong>命令式的性能 &gt; 声明式的性能</strong>。</p><p>其实原因非常简单，对于 <strong>命令式</strong> 的代码而言，它直接通过 <strong>原生的 <code>JavaScript</code> 进行实现</strong>，这是最简单的代码，没有比这个更简单的了，我们把它的性能比作 <code>1</code>。</p><p>而声明式，无论内部做了什么，它想要实现同样的功能，内部必然要实现同样的命令式代码。所以它的性能消耗一定是 <code>1 + N</code> 的。</p><p>那么既然如此，<code>vue</code> 为什么还要对外暴露出声明式的接口呢？</p><p>这其实是因为：<strong>声明式的可维护性，要远远大于命令式的可维护性</strong>。</p><p>当性能与可维护性产生冲突时，那么舍鱼而取熊掌者也。（注意：在 <code>vue</code> 的性能优化之下，它并不会比纯命令式的性能差太多）</p><p>而这样的一种权衡，在 <code>template</code> 模板中，更是体现的淋漓尽致。</p><p>在前端领域，想要使用 <code>JavaScript</code> 修改 <code>html</code> 的方式，主要有三种：**<code>原生 JavaScript、innerHTML、虚拟 DOM</code>**</p><p>很多小伙伴都会认为 <code>虚拟 DOM</code> 的性能是最高的，其实不是。</p><img src="精读《Vue-js》设计与实现/image-20230612192855594.png" alt="image-20230612192855594" style="zoom:50%;" /><p>从这个对比我们可以发现，<code>虚拟 DOM</code> 的性能，并不是最高的。</p><p>但是它的 <strong>心智负担（书写难度）最小</strong>， 从而带来了 <strong>可维护性最高</strong>。所以哪怕它的性能并不是最高的。<code>vue</code> 依然选择了 <code>虚拟 DOM</code> 来进行了渲染层的构建。</p><p>这个也是一种性能与可维护性的权衡。</p><h4 id="运行时和编译时"><a href="#运行时和编译时" class="headerlink" title="运行时和编译时"></a>运行时和编译时</h4><p>第一章的最后一部分，主要讲解的就是 <strong>运行时和编译时</strong>。</p><p>这两个名词，各位小伙伴在日常开发中，应该是经常听到的。</p><p>它们两个都是框架设计的一种方式，可单独出现，也可组合使用。</p><p>那么下面咱们就分别来介绍一下它们。</p><p>首先是 **运行时：<code>runtime</code>**。</p><blockquote><p>它指的是：<strong>利用 render 函数，直接把 虚拟 <code>DOM</code>  转化为 真实 <code>DOM</code> 元素</strong> 的一种方式。</p><p>在整个过程中，不包含编译的过程，所以无法分析用户提供的内容。</p></blockquote><p>其次是 <strong>编译时：compiler</strong>：</p><blockquote><p>它指的是：<strong>直接把 <code>template</code> 模板中的内容，转化为 真实 <code>DOM</code> 元素</strong>。</p><p>因为存在编译的过程，所以可以分析用户提供的内容。</p><p>同时，没有运行时理论上性能会更好。</p><p>目前该方式，有具体的实现库，那就是现在也非常火的 <code>Svelte</code></p><p>但是这里要注意： <strong>它的真实性能，没有办法达到理论数据。</strong></p></blockquote><p>最后是 <strong>运行时 + 编译时</strong>：</p><blockquote><p>它的过程被分为两步：</p><ol><li>先把 <code>template</code> 模板转化为 <code>render</code> 函数。也就是 <strong>编译时</strong></li><li>再利用 <code>render</code> 函数，把 虚拟 <code>DOM</code> 转化为 真实 <code>DOM</code>。也就是 <strong>运行时</strong></li></ol><p>两者的结合，可以：</p><p>在 编译时，分析用户提供的内容<br>在 运行时，提供足够的灵活性</p><p>这也是 <code>vue</code> 的主要实现方式。</p></blockquote><h3 id="第二章：框架设计的核心要素"><a href="#第二章：框架设计的核心要素" class="headerlink" title="第二章：框架设计的核心要素"></a>第二章：框架设计的核心要素</h3><ol><li>通过 环境变量 和 <code>TreeShanking</code> 控制打包之后的体积</li><li>构建不同的打包产物，以应用不同的场景</li><li>提供了 <code>callWithErrorHandling</code> 接口函数，来对错误进行统一处理</li><li>源码通过 <code>TypeScript</code> 开发，以保证可维护性。</li><li>内部添加了大量的类型判断和其他工作，以保证开发者使用时的良好体验。</li></ol><h3 id="第三章：Vue-js-3-的设计思路"><a href="#第三章：Vue-js-3-的设计思路" class="headerlink" title="第三章：Vue.js 3 的设计思路"></a>第三章：Vue.js 3 的设计思路</h3><p>在这一章中，作者站在一个高层的角度，以 <strong><code>UI</code> 形式、渲染器、组件、编辑器</strong> 为逻辑主线进行的讲解。</p><p>下面咱们就来捋一捋这条线。</p><p>在 <code>Vue</code> 中 <code>UI</code> 形式主要分为两种：</p><ul><li>声明式的模板描述<br>![image-20230208170232727](..&#x2F;..&#x2F;..&#x2F;书籍&#x2F;一小时读完系列&#x2F;book_read_quickly-master&#x2F;Vue.js 设计与实现&#x2F;Vue.js 设计与实现.assets&#x2F;image-20230208170232727.png)</li><li>命令式的 render 函数<br><img src="/%E7%B2%BE%E8%AF%BB%E3%80%8AVue-js%E3%80%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230208170236795.png" alt="image-20230208170236795"></li></ul><p>而针对于 <strong>声明式的模板描述</strong> 而言，本质上就是咱们常用的 <code>tempalte</code> 模板。它会被 <strong>编辑器</strong> 编译，得到 <strong>渲染函数 <code>render</code></strong> 。</p><p>渲染器与渲染函数，并 <strong>不是</strong> 一个东西。</p><p>渲染器是 **函数 <code>createRenderer</code> 的返回值，是一个对象。被叫做 <code>renderer</code>**。 <strong><code>renderer</code> 对象中有一个方法 <code>render</code><strong>，这个 <code>render</code> ，就是我们常说的</strong>渲染函数</strong>。</p><p>渲染函数接收两个参数 <code>VNode</code> 和 <code>container</code>。</p><p>其中 <code>VNode</code> 表示 <strong>虚拟 DOM</strong>，本质上是一个 <code>JS</code> 对象。<code>container</code> 是一个容器，表示被挂载的位置。而 <code>render</code> 函数的作用，就是： <strong>把 <code>vnode</code> 挂载到 <code>container</code> 上</strong>。</p><p>同时，因为 <code>Vue</code> 以组件代表最小颗粒度，所以 <code>vue</code> 内部的渲染，本质上是：<strong>大量的组件渲染</strong>。</p><p>而组件本质上是一组 <code>DOM</code> 的集合，所以渲染一个一个的组件，本质上就是在渲染一组这一组的 <code>DOM</code>。也就是说，<code>Vue</code> 本质上是： <strong>以组件作为介质，来完成针对于一组、一组的 <code>DOM</code> 渲染。</strong></p><h2 id="第二篇：响应式系统"><a href="#第二篇：响应式系统" class="headerlink" title="第二篇：响应式系统"></a>第二篇：响应式系统</h2><h3 id="第四章：响应系统的作用与实现"><a href="#第四章：响应系统的作用与实现" class="headerlink" title="第四章：响应系统的作用与实现"></a>第四章：响应系统的作用与实现</h3><p>在这一章中，作者从 <strong>响应式数据的概念开始，讲解了响应式系统的实现。</strong> 然后针对于 <strong>计算属性与 <code>watch</code>  的实现原理，进行了分析。</strong> 在分析的过程中，也对其所设计到的 <strong><code>调度系统（scheduler）</code> 和  <code>惰性执行（lazy）</code> 的原理进行了明确。</strong> 最后讲解了在 <strong>竞态问题下，关于过期的副作用的处理逻辑。</strong> </p><h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><p>那么首先咱们先来看基本概念 <strong>副作用函数 与 响应式数据</strong>。</p><p>所谓 <strong>副作用函数</strong> 指的是 <strong>会产生副作用的函数</strong>，这样的函数非常的多。比如</p><p><img src="/%E7%B2%BE%E8%AF%BB%E3%80%8AVue-js%E3%80%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230612193528677.png" alt="image-20230612193528677"></p><p>在这段代码中， <code>effect</code> 的触发会导致全局变化 <code>val</code> 发生变化，那么 <code>effect</code> 就可以被叫做<strong>副作用函数</strong>。而如果 <code>val</code> 这个数据的变化，导致了视图的变化，那么 <code>val</code> 就被叫做 <strong>响应式数据</strong>。</p><p>那么如果想要实现响应式数据的话，那么它的核心逻辑，必然要依赖两个行为：</p><ul><li>第一个是 <code>getter</code> 行为，也就是 <strong>数据读取</strong></li><li>第二个是 <code>setter</code> 行为，也就是 <strong>数据修改</strong></li></ul><p>在 <code>vue 2</code> 中，这样的两个行为通过 <code>Object.defineProperty</code> 进行的实现。</p><p>在 <code>vue 3</code> 中，这样的两个行为通过 <code>Proxy</code> 进行的实现。</p><p>那么具体的实现逻辑是什么呢？咱们来看下面的图示：</p><p>首先是 <code>getter</code> 形式：</p><img src="精读《Vue-js》设计与实现/image-20230208191120105.png" alt="image-20230208191120105" style="zoom:20%;" /><p>在该函数中，存在一个 <code>effect</code> 方法，方法内部触发了 <code>getter</code> 行为。一旦 <code>getter</code> 行为被触发，则把对应的 <code>effect</code> 方法保存到一个 “桶（数据对象）” 中</p><p>当触发 <code>setter</code> 行为时：</p><img src="精读《Vue-js》设计与实现/image-20230208191257788.png" alt="image-20230208191257788" style="zoom:23%;" /><p>则会从 “桶” 中取出 <code>effect</code> 方法，并执行。</p><p>那么此时因为 <code>obj.text</code> 的值发生了变化，所以 <code>effect</code> 被执行时 <code>document.body.innerText</code> 会被赋上新的值。从而导致视图发生变化。</p><h4 id="调度系统（scheduler）"><a href="#调度系统（scheduler）" class="headerlink" title="调度系统（scheduler）"></a>调度系统（scheduler）</h4><p>那么说完了基本的响应性之后，接下来咱们来看 <strong>调度系统（<code>scheduler</code>）</strong></p><p>所谓调度系统，指的就是 <strong>响应性的可调度性</strong>。</p><p>而所谓的可调度，指的就是 <strong>当数据更新的动作，触发副作用函数重新执行时，有能力决定：副作用函数（effect）执行的时机、次数以及方式</strong></p><p>比如，在这段打印中，决定打印的顺序</p><p><img src="/%E7%B2%BE%E8%AF%BB%E3%80%8AVue-js%E3%80%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230612193750814.png" alt="image-20230612193750814"></p><p>而想要实现一个调度系统，则需要依赖 <strong><code>异步：Promise</code> 和 <code>队列：jobQueue</code></strong> 来进行实现。咱们需要 <strong>基于 <code>Set</code> 构建出一个基本的队列数组 <code>jobQueue</code>，利用 <code>Promise</code> 的异步特性，来控制执行的顺序</strong></p><h4 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a>计算属性（computed）</h4><p>当我们可以控制了执行顺序之后，那么就可以利用这个特性来完成 <strong>计算属性（computed）</strong> 的实现了。</p><p>计算属性本质上是： <strong>一个属性值，当依赖的响应式数据发生变化时，重新计算</strong></p><p>那么它的实现就需要彻底依赖于 <strong>调度系统（scheduler）</strong> 来进行实现。</p><h4 id="惰性执行（lazy）"><a href="#惰性执行（lazy）" class="headerlink" title="惰性执行（lazy）"></a>惰性执行（lazy）</h4><p>说完计算属性，那么下面我们来看下 <code>watch</code> 监听器。</p><p><code>watch</code> 监听器本质上是 <strong>观测一个响应式数据，当数据发生变化时，通知并执行相应的回调函数</strong></p><p>这也就意味着，<code>watch</code> 很多时候并不需要立刻执行。</p><p>那么此时，就需要使用到 <strong>惰性执行（<code>lazy</code>）</strong> 来进行控制。</p><p>惰性执行的实现要比调度系统简单。它本质上 <strong>是一个 <code>boolean</code> 型的值，可以被添加到 <code>effect</code> 函数中，用来控制副作用的执行</strong>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 执行副作用函数</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="过期的副作用"><a href="#过期的副作用" class="headerlink" title="过期的副作用"></a>过期的副作用</h4><p><code>watch</code> 监听器的实现非常广泛，有时候我们甚至可以在 <strong><code>watch</code> 中完成一些异步操作。</strong></p><p>但是大量的异步操作，极有可能会导致 <strong>竞态问题</strong>。</p><p>所谓的竞态问题，指的是 <strong>在描述一个系统或者进程的输出，依赖于不受控制的事件出现顺序或者出现时机</strong>。比如咱们来看这段代码</p><p><img src="/%E7%B2%BE%E8%AF%BB%E3%80%8AVue-js%E3%80%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230612193927515.png" alt="image-20230612193927515"></p><blockquote><p>这段代码完成的是一个异步操作。</p><p>如果 <code>obj</code> 连续被修改了两次，那么就会发起两个请求。我们最终的期望应该是 <code>data</code> 被赋值为 请求B 的结果。</p><p>但是，因为异步的返回结果我们无法预计。所以，如果 请求 B 先返回，那么最终 <code>data</code> 的值就会变为 请求 A 的返回值。</p><p>这个咱们的期望是不一样的。</p><p>那么这样的问题，就是 <strong>竞态问题</strong></p></blockquote><p>而如果想要解决这问题，那么就需要使用到 <code>watch</code> 回调函数的第三个参数 <code>onInvalidate</code>，它本身也是一个回调函数。并且 <strong>该回调函数（<code>onInvalidate</code>）会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求</strong></p><p>而 <code>onInvalidate</code> 的实现原理也非常简单，只需要 <strong>在副作用函数（effct）重新执行前，先触发 <code>onInvalidate</code></strong> 即可。</p><h3 id="第五章：非原始值（对象）的响应性方案"><a href="#第五章：非原始值（对象）的响应性方案" class="headerlink" title="第五章：非原始值（对象）的响应性方案"></a>第五章：非原始值（对象）的响应性方案</h3><p>书中的第五章整体而言非常简单，主要就介绍了两个接口，<code>Proxy</code> 和 <code>Reflect</code>。</p><p>这两个接口通常会一起进行使用，其中：</p><ul><li><code>Proxy</code> 可以 <strong>代理一个对象（被代理对象）的 getter 和 setter 行为，得到一个 proxy 实例（代理对象）</strong></li><li><code>Reflect</code> 可以 <strong>在 Proxy 中使用 this 时，保证 this 指向 proxy，从而正确执行次数的副作用</strong></li></ul><h3 id="第六章：原始值（非对象）的响应性方案"><a href="#第六章：原始值（非对象）的响应性方案" class="headerlink" title="第六章：原始值（非对象）的响应性方案"></a>第六章：原始值（非对象）的响应性方案</h3><p>如果大家熟悉 <code>proxy</code> 的话，那么可以知道，针对于 <code>proxy</code> 而言，它只能代理复杂数据类型。这就意味着，简单数据类型无法具备响应性。</p><p>但是，在 <code>vue</code> 中，我们可以通过 <code>ref</code> 构建简单数据类型的响应。</p><p>那么 <code>ref</code> 是如何进行实现的呢？</p><p>这里大家要注意：<strong>针对于最新的 vue 3.2 而言，书中在 《6.1 引入 ref 的概念》中所讲解的 ref 实现原理存在 “落后性”。 vue 3.2 已经修改了 ref 的实现，这得益于 @basvanmeurs 的贡献</strong></p><p>在最新的 <code>vue 3.2</code> 代码中，<code>vue</code> 通过 <strong><code>get</code> 、<code>set</code>  函数标记符，让函数以属性调用的形式被触发。</strong>这两个修饰符，可以让我们 <strong>像调用属性一样，调用方法</strong>。 所以当我们平时 <strong>访问 ref.value 属性时，本质上是  value() 函数的执行</strong>。</p><h2 id="第三篇：渲染器"><a href="#第三篇：渲染器" class="headerlink" title="第三篇：渲染器"></a>第三篇：渲染器</h2><h3 id="第七章：渲染器的设计"><a href="#第七章：渲染器的设计" class="headerlink" title="第七章：渲染器的设计"></a>第七章：渲染器的设计</h3><p>在之前咱们说过 <strong>渲染器与渲染函数不是一个东西</strong></p><ul><li><strong>渲染器</strong> 是 <code>createRenderer</code> 的返回值，是一个对象。</li><li><strong>渲染函数</strong> 是渲染器对象中的 <code>render</code> 方法</li></ul><p>在 <code>vue 3.2.37</code> 的源码内部，<code>createRenderer</code> 函数的具体实现是通过 <code>baseCreateRenderer</code> 进行的。它的代码量非常庞大，涉及到了 <code>2000</code> 多行的代码。</p><p>总体可以被分为两部分：</p><ol><li><strong>在浏览器端渲染时，利用 <code>DOM API</code> 完成 <code>DOM</code> 操作</strong>：比如，如果渲染 <code>DOM</code> 那么就使用 <code>createElement</code>，如果要删除 <code>DOM</code> 那么就使用 <code>removeChild</code>。</li><li><strong>渲染器不能与宿主环境（浏览器）产生强耦合</strong>：因为 <code>vue</code> 不光有浏览器渲染，还包括了 <code>服务端</code> 渲染，所以如果在渲染器中绑定了宿主环境，那么就不好实现服务端渲染了。</li></ol><p>所谓 <code>vnode</code> 本身是 <strong>一个普通的 JavaScript 对象，代表了渲染的内容</strong>。对象中通过 <code>type</code> 表示渲染的 <code>DOM</code>。比如 <code>type === div</code>：则表示 <code>div</code> 标签、<code>type === Framgnet</code> 则表示渲染片段（vue 3 新增）、<code>type === Text</code> 则表示渲染文本节点。</p><h3 id="第八章：挂载与更新"><a href="#第八章：挂载与更新" class="headerlink" title="第八章：挂载与更新"></a>第八章：挂载与更新</h3><p>对于渲染器而言，它做的最核心的事情就是 <strong>对节点进行挂载、更新的操作</strong>。作者在第八章中，详细的介绍了对应的逻辑。</p><p>整个第八章分为两部分来讲解了这个事情：</p><ol><li><code>DOM</code> 节点操作</li><li>属性节点操作</li></ol><h4 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a><code>DOM</code> 节点操作</h4><p>首先先来看 <code>DOM</code> 节点操作。<code>DOM</code> 节点的操作可以分为三部分：</p><ul><li><strong>挂载</strong>：所谓挂载表示节点的初次渲染。比如，可以直接通过 <code>createElement</code> 方法新建一个 <code>DOM</code> 节点，再利用 <code>parentEl.insertBefore </code> 方法插入节点。</li><li><strong>更新</strong>：当响应性数据发生变化时，可能会涉及到 <code>DOM</code> 的更新。此时的更新本质上是属于 <strong>属性的更新</strong>。咱们等到属性节点操作那里再去说。</li><li><strong>卸载</strong>：所谓卸载表示旧节点不在被需要了。那么此时就需要删除旧节点，比如可以通过 <code>parentEl.removeChild</code> 进行。</li></ul><p>以上三种类型，是 <code>vue</code> 在进行 <code>DOM</code> 操作时的常见逻辑。基本上覆盖了 <code>DOM</code> 操作 <code>90% 以上</code> 的常见场景</p><h4 id="属性节点操作"><a href="#属性节点操作" class="headerlink" title="属性节点操作"></a>属性节点操作</h4><p>看完了 <code>DOM</code> 操作之后，接下来咱们来看属性节点操作。</p><p>针对于属性而言，大体可以分为两类：</p><ol><li><strong>属性</strong>：比如 <code>class</code>、<code>id</code>、<code>value</code>、<code>src</code>…</li><li><strong>事件</strong>：比如 <code>click</code>、<code>input</code>….</li></ol><p>那么咱们就先来看 <strong>非事件的属性部分</strong>。</p><p>想要了解 <code>vue</code> 中对于属性的处理，那么首先咱们需要先搞明白一个很重要的问题。那就是 <strong>浏览器中的属性分类</strong>。</p><p>在浏览器中 <code>DOM</code> 属性其实被分为了两类：</p><ul><li>第一类叫做 <code>HTML Attributes</code>：直接定义在 <code>HTML 标签</code> 上的属性，都属于这一类。</li><li>第二类叫做 <code>DOM Properties</code>：它是拿到 <code>DOM</code> 对象后定义的属性。咱们接下来主要要说的就是它。</li></ul><p> <code>HTML Attributes</code> 的定义相对而言比较简单和直观，但是问题在于 <strong>它只能在 <code>html</code> 中进行操作</strong>。</p><p>而如果想要在 <code>JS</code> 中操作 <code>DOM</code> 属性，就必须要通过  <code>DOM Properties</code> 来进行实现。但是因为 <code>JS</code> 本身特性的问题，会导致某些 <code>DOM Properties</code> 的设置存在特殊性。比如 <code>class、type、value</code> 这三个。</p><p>所以为了保证 <code>DOM Properties</code> 的成功设置，那么我们就必须要知道 **不同属性的 <code>DOM Properties</code> 定义方式 **。</p><p>下面咱们来看一下。</p><p><code>DOM Properties</code> 的设置一共被分为两种：</p><ol><li><code>el.setAttribute(&#39;属性名&#39;, &#39;属性值&#39;)</code></li><li><code> . 属性赋值</code> ： <code>el.属性名 = 属性值</code> 或者 <code>el[属性名] = 属性值</code> 都属于 <code>.属性赋值</code></li></ol><p>我们来看这段代码：</p><img src="精读《Vue-js设计与实现》/image-20230209093545078.png" alt="image-20230209093545078" style="zoom:50%;" /><blockquote><p>在这段代码中，我们为 <code>textarea</code> 利用 <code>DOM Properties</code> 的方式设置了三个不同的属性：</p><ul><li>首先是 <code>class</code>： <code>class</code> 在属性操作中是一个非常特殊的存在。它有两个名字 <code>class</code> 和 <code>className</code>。如果我们直接通过 <code>el.setAttribute</code> 的话，那么必须要用 <code>class</code> 才可以成功，而如果是通过 <code>. 属性</code> 的形式，那么必须要使用 <code>className</code> 才可以成功。</li><li>第二个是 <code>type</code>： <code>type</code> 仅支持 <code>el.setAttribute</code>  的方式，不支持 <code>.属性的方式</code></li><li>第三个是 <code>value</code>：<code>value</code> 不支持直接使用 <code>el.setAttribute</code>  设置，但是支持 <code>.属性</code> 的设置方式</li></ul></blockquote><p>除了这三个属性之外，其实还有一些其他的属性也需要进行特殊处理，咱们这里就不再一一赘述了。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>接下来，咱们来看 <code>vue</code> 对事件的处理操作。</p><p>事件的处理和属性、<code>DOM</code> 一样，也是分为 <strong>添加、删除、更新</strong> 三类。</p><ul><li>添加：添加比较简单，主要利用 <code>el.addEventListener</code> 进行实现即可。</li><li>删除：主要利用 <code>el.removeEventListener</code> 进行处理。</li><li>更新：但是对于更新来说，就比较有意思了。下面咱们主要来看的就是这个更新操作。</li></ul><p>通常情况下，我们所认知的事件更新应该是 <strong>删除旧事件、添加新事件</strong> 的过程。但是如果利用 <code>el.addEventListener</code> 和 <code>el.removeEventListener</code> 来完成这件事情，是一件非常消耗性能的事。</p><p>那么怎么能够节省性能，同时完成事件的更新呢？</p><p>这时，<code>vue</code> 对事件的更新提出了一个叫做 <code>vei</code> 的概念，这个概念的意思是： <strong>为 <code>addEventListener</code> 回调函数，设置了一个 <code>value</code> 的属性方法，在回调函数中触发这个方法。通过更新该属性方法的形式，达到更新事件的目的。</strong></p><p>这个代码比较多，大家如果想要查看具体代码的话，可以 <a href="https://github.com/lgd8981289/vue-next-mini">在 github 搜索 vue-next-mini</a>，进入到 <code>packages/runtime-dom/src/modules/events.ts</code> 路径下查看。</p><h3 id="第九、十、十一章：Diff-算法"><a href="#第九、十、十一章：Diff-算法" class="headerlink" title="第九、十、十一章：Diff 算法"></a>第九、十、十一章：Diff 算法</h3><p>整个渲染器最后的三个章节全部都用来讲解了 <code>diff</code> 算法。</p><p>针对于 <code>diff</code> 而言，它的本质其实就是一个对比的方法，其描述的核心就是： <strong>“旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。</strong></p><p>目前针对于 <code>vue 3.2.37</code> 的版本来说，整个的 <code>diff</code> 算法被分为 5 步（<strong>这 5 步不跟大家读了，因为咱们没头没尾的读一遍，其实对大家也没有什么帮助</strong>）：</p><ol><li><code>sync from start</code>：自前向后的对比</li><li><code>sync from end</code>：自后向前的对比</li><li><code> common sequence + mount</code>：新节点多于旧节点，需要挂载</li><li><code>common sequence + unmount</code>：旧节点多于新节点，需要卸载</li><li><code>unknown sequence</code>：乱序</li></ol><p>而，针对于书中的这三章来说，本质上是按照 <strong>简单 diff 算法、双端 diff 算法、快速 diff 算法</strong> 的顺序把整个 <code>diff</code> 的前世今生基本上都说了一遍。里面涉及到了非常多的代码。</p><h2 id="第四篇：组件化"><a href="#第四篇：组件化" class="headerlink" title="第四篇：组件化"></a>第四篇：组件化</h2><h3 id="第十二章：组件的实现原理"><a href="#第十二章：组件的实现原理" class="headerlink" title="第十二章：组件的实现原理"></a>第十二章：组件的实现原理</h3><p>想要了解 <code>vue</code> 中组件的实现，那么首先我们需要知道什么是组件。</p><p>组件本质上就是一个 <code>JavaScript</code> 对象，比如，以下对象就是一个基本的组件</p><img src="精读《Vue-js设计与实现》/image-20230209105953064.png" alt="image-20230209105953064" style="zoom:33%;" /><p>而对于组件而言，同样需要使用 <code>vnode</code> 来进行表示，当 <code>vnode</code> 的 <code>type</code> 属性是一个 <strong>自定义对象</strong> 时，那么这个 <code>vnode</code> 就表示组件的 <code>vnode</code></p><img src="精读《Vue-js设计与实现》/image-20230209110548502.png" alt="image-20230209110548502" style="zoom:33%;" /><p>而组件的渲染，本质上是 <strong>组件包含的 <code>DOM</code> 的渲染。</strong> 对于组件而言，必然会包含一个 <code>render</code> 渲染函数。如果没有 <code>render</code> 函数，那么 <code>vue</code> 会把 <code>template</code> 模板编译为 <code>render</code> 函数。而组件渲染的内容，其实就是 <code>render</code> 函数返回的 <code>vnode</code>。具体的渲染逻辑，全部都通过渲染器执行。</p><img src="精读《Vue-js设计与实现》/image-20230613164740214.png" alt="image-20230613164740214" style="zoom:50%;" /><p><code>vue 3</code> 之后提出了 <code>composition API</code>，<code>composition API</code> 包含一个入口函数，也就是 <code>setup</code> 函数。 <code>setup</code> 函数包含两种类型的返回值：</p><ol><li><strong>返回一个函数</strong>：当 <code>setup</code> 返回一个函数时，那么该函数会被作为 <code>render</code> 函数直接渲染。</li><li><strong>返回一个对象</strong>：当 <code>setup</code> 返回一个对象时，那么 <code>vue</code> 会直接把该对象的属性，作为 <code>render</code> 渲染时的依赖数据</li></ol><p>同时，对于组件来说还有一个 <strong>插槽</strong> 的概念。插槽的实现并不神奇。插槽本质上 <strong>是一段 <code>innerHTML</code> 的内容，在 <code>vnode</code> 中以 <code>children</code> 属性进行呈现</strong>。当插槽被渲染时，只需要渲染 <code>children</code> 即可。</p><p>对于组件来说，除了咱们常用的 <strong>对象组件</strong> 之外，<code>vue</code> 还提供了额外的两种组件，也就是 <strong>异步组件与函数式组件</strong>。</p><h3 id="第十三章：异步组件与函数式组件"><a href="#第十三章：异步组件与函数式组件" class="headerlink" title="第十三章：异步组件与函数式组件"></a>第十三章：异步组件与函数式组件</h3><p>所谓异步组件，指的是： <strong>异步加载的组件</strong> 。</p><p>比如服务端返回一个组件对象，那么我们也可以拿到该对象，直接进行渲染。</p><p>异步组件在 <strong>优化页面性能、拆包、服务端下发组件</strong> 时，会比较有用。</p><p>而对于 <strong>函数式组件</strong> 来说，相对就比较冷僻了。函数式组件指的是 <strong>没有状态的组件。本质上是一个函数，可以通过静态属性的形式添加 <code>props</code> 属性</strong> 。在实际开发中，并不常见。</p><h3 id="第十四章：内建组件和模块"><a href="#第十四章：内建组件和模块" class="headerlink" title="第十四章：内建组件和模块"></a>第十四章：内建组件和模块</h3><p>这一章中，主要描述了 <code>vue</code> 的三个内置组件。</p><h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>首先第一个是 <code>KeepAlive</code>。</p><p>这是我们在日常开发中，非常常用的内置组件。它可以 <strong>缓存一个组件，避免该组件不断地销毁和创建</strong>。</p><p>看起来比较神奇，但是它的实现原理其实并不复杂，主要围绕着 <strong>组件卸载</strong> 和 <strong>组件挂载</strong> 两个方面：</p><ul><li><strong>组件卸载</strong>：当一个组件被卸载时，它并不被真正销毁，而是把组件保存在一个容器中</li><li><strong>组件挂载</strong>：因为组件被保存了。所以当这个组件需要被挂载时，就不需要在重新创建，而是直接从容器中获取即可。</li></ul><h4 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h4><p><code>Teleport</code> 是 <code>vue 3</code> 新增的组件，作用是 <strong>将 <code>Teleport</code> 插槽的内容渲染到其他的位置</strong>。比如我们可以把 <code>dialog</code> 渲染到 <code>body</code> 根标签之下。</p><p>它的实现原理，主要也是分为两部分：</p><ol><li>把 Teleport 组件的渲染逻辑，从渲染器中抽离</li><li>在指定的位置进行独立渲染</li></ol><h4 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h4><p><code>Transition</code> 是咱们常用的动画组件，作用是 <strong>实现动画逻辑</strong>。</p><p>其核心原理同样被总结为两点：</p><ol><li><code>DOM</code> 元素被挂载时，将动效附加到该 <code>DOM</code> 元素上</li><li><code>DOM</code> 元素被卸载时，等在 <code>DOM</code> 元素动效执行完成后，执行卸载 <code>DOM</code> 操作</li></ol><h2 id="第五篇：编译器"><a href="#第五篇：编译器" class="headerlink" title="第五篇：编译器"></a>第五篇：编译器</h2><h3 id="第十五章：编译器核心技术概述"><a href="#第十五章：编译器核心技术概述" class="headerlink" title="第十五章：编译器核心技术概述"></a>第十五章：编译器核心技术概述</h3><p>在编译器核心技术概述，主要包含两个核心内容：</p><ol><li>模板 <code>DSL</code> 的编译器</li><li><code>Vue</code> 编译流程三大步</li></ol><h4 id="模板-DSL-的编译器"><a href="#模板-DSL-的编译器" class="headerlink" title="模板 DSL 的编译器"></a>模板 <code>DSL</code> 的编译器</h4><p>在任何一个编程语言中，都存在编译器的概念。 <code>vue</code> 的编译器是在 <strong>一种领域下，特定语言的编译器</strong> ，那么这种编译器被叫做 <code>DSL</code> 编译器。</p><p>而编译器的本质是 <strong>通过一段程序，可以把 A 语言翻译成 B 语言</strong>。在 <code>vue</code> 中的体现就是 <strong>把 <code>tempalte</code> 模板，编译成 <code>render</code> 渲染函数</strong></p><p>一个完整的编译器，一个分为 <strong>两个阶段、六个流程</strong>：</p><ul><li>编译前端：<ul><li>词法分析</li><li>语法分析</li><li>语义分析</li></ul></li><li>编译后端：<ul><li>中间代码生成</li><li>优化</li><li>目标代码生成</li></ul></li></ul><p><img src="/%E7%B2%BE%E8%AF%BB%E3%80%8AVue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/image-20230209113241592.png" alt="image-20230209113241592"></p><p>而对于 <code>vue</code> 的编译器而言，因为它是一个特定领域下的编译器，所以流程会进行一些优化，一共分为三大步</p><p><img src="/%E7%B2%BE%E8%AF%BB%E3%80%8AVue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/image-20230209113421705.png" alt="image-20230209113421705"></p><ol><li><code>parse</code>：通过 <code>parse</code> 函数，把模板编译成 <code>AST</code> 对象</li><li><code>transform</code>：通过 <code>transform</code> 函数，把 <code>AST</code> 转化为 <code>JavaScript AST</code></li><li><code>generate</code>：通过 <code>generate</code> 函数，把 <code>JavaScript AST</code> 转化为 渲染函数（<code>render</code>）</li></ol><h3 id="第十六章：解析器（parse）"><a href="#第十六章：解析器（parse）" class="headerlink" title="第十六章：解析器（parse）"></a>第十六章：解析器（parse）</h3><p>这一章，主要详细讲解了 <strong>parse 解析逻辑</strong>。是在三大步中的 <code>parse</code> 逻辑的基础上，进行了一个加强。</p><p>所以这里咱们也按下不表</p><h3 id="第十七章：编译优化"><a href="#第十七章：编译优化" class="headerlink" title="第十七章：编译优化"></a>第十七章：编译优化</h3><p>最后就是编译优化。</p><p>编译优化也是一个非常大的概念，其核心就是 <strong>通过编译的手段提取关键信息，并以此知道生成最优代码的过程</strong>。</p><p>它的核心优化逻辑，主要是 <strong>把节点分为两类</strong>：</p><ul><li>第一类是 <strong>动态节点</strong>：也就是会 <strong>受数据变化影响</strong> 的节点</li><li>第二类是 <strong>静态节点</strong>：也就是 <strong>不受数据变化影响</strong> 的节点</li></ul><p>优化主要的点，就是 <strong>动态节点</strong>。</p><p>优化的方式主要是通过 <code>Block 树</code> 进行优化。</p><p><code>Block 树</code> 本质上就是一个 <strong>虚拟节点数对象</strong>，内部包含一个 <code>dynamicChildren</code> 属性，用来 <strong>收集所有的动态子节点</strong>，以达到提取关键点进行优化的目的。</p><p>除此之外，还有一些小的优化手段，比如：</p><ul><li>静态提升</li><li>预字符串化</li><li>缓存内联事件处理函数</li><li><code>v-once</code> 指令</li><li>…</li></ul><h2 id="第六篇：服务端渲染"><a href="#第六篇：服务端渲染" class="headerlink" title="第六篇：服务端渲染"></a>第六篇：服务端渲染</h2><p>最后一篇只有一个章节，就是 <strong>同构渲染</strong>。</p><p>想要了解同构渲染，那么需要先搞明白 <code>CSR、SSR</code> 的概念。</p><ul><li><code>CSR</code>：所谓 <code>CSR</code> 指的是 <strong>客户端渲染</strong>。<ul><li>浏览器向服务器发起请求</li><li>服务器查询数据库，返回数据</li><li>浏览器得到数据，进行页面构建</li></ul></li><li><code>SSR</code>：表示 <strong>服务端渲染</strong><ul><li>览器向服务器发起请求</li><li>服务器查询数据库，根据数据，生成 <code>HTML</code> ，并进行返回</li><li>浏览器直接渲染 <code>HTML</code></li></ul></li></ul><p>两种方式各有利弊，所以同构渲染，指的就是 <strong>把 <code>CSR</code> 和 <code>SSR</code> 进行合并</strong>。既可以单独 <code>CSR</code> ，也可以单独 <code>SSR</code>，同时还可以 **结合两者，在首次渲染时，通过 <code>SSR</code>，在非首次渲染时，通过 <code>CSR</code>**。</p><p>以下是三者的对比图</p><img src="精读《Vue-js设计与实现》/image-20230209121227934.png" alt="image-20230209121227934" style="zoom:50%;" /><p>而针对 <code>vue</code> 的服务端渲染来说，它是 <strong>将虚拟 <code>DOM</code>  渲染为 <code>HTML</code> 字符串</strong>，本质上是 <strong>解析的 <code>vnode</code> 对象，然后进行的 <code>html</code> 的字符串拼接</strong></p><p>最后又讲解了客户端激活的原理，大致分为两步：</p><ol><li>为页面中的 <code>DOM</code> 元素与虚拟节点对象之间建立联系</li><li>为页面中的 <code>DOM</code> 元素添加事件绑定</li></ol><p>这两步主要是通过 <code>renderer.hydrate()</code> 方法进行实现了。</p><blockquote><p>视频出处：【一小时读完《Vue.js 设计与实现》】 <a href="https://www.bilibili.com/video/BV1K24y1q7eJ/?share_source=copy_web&amp;vd_source=a9f0fd4630ebe41da19ca2c83eb295e6">https://www.bilibili.com/video/BV1K24y1q7eJ/?share_source=copy_web&amp;vd_source=a9f0fd4630ebe41da19ca2c83eb295e6</a></p><p>视频文档出处：<a href="https://juejin.cn/post/7197980894363156540">https://juejin.cn/post/7197980894363156540</a></p><p>作者：LGD_Sunday</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精读《JavaScript权威指南》</title>
      <link href="/2023/06/12/jing-du-javascript-quan-wei-zhi-nan/"/>
      <url>/2023/06/12/jing-du-javascript-quan-wei-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="第2章词法结构"><a href="#第2章词法结构" class="headerlink" title="第2章词法结构"></a>第2章词法结构</h2><p>所谓词法结构指的是： <strong>如何使用这门语言编写程序</strong> 的方式。</p><p><code>JavaScript</code> 的词法结构主要包含了 5 个部分：</p><ol><li>注释</li><li>字面量</li><li>标识符和保留字</li><li><code>Unicode</code></li><li>分号</li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>JavaScript</code> 的注释分为两大类，一共有三种写法：</p><img src="image-20230612191101753.png" alt="image-20230612191101753" style="zoom:50%;" /><p>上图的第一种为 <strong>单行注释</strong>，剩下的两种为 <strong>多行注释</strong>。</p><p>这里有一个小点大家注意，第三种注释方式配合 <code>VS Code</code> 可以让我们在使用 <code>js</code> 函数获得对应的注释提示：</p><img src="image-20230612191150938.png" alt="image-20230612191150938" style="zoom:50%;" /><h3 id="可选的分号"><a href="#可选的分号" class="headerlink" title="可选的分号"></a>可选的分号</h3><p>我们知道在 <code>JS</code> 中分号并不是一个强制必须要有的东西，并且根据现在企业开发的标准，很多时候是 <strong>不允许</strong> 写结尾分号的。</p><p>这种不允许在某些情况下，可能会导致一些错误。比如：</p><img src="image-20230612172032215.png" alt="image-20230612172032215" style="zoom:50%;" /><p>这样的代码，一旦我们通过格式化处理，那么就会被合并被一行：</p><img src="image-20230612172044225.png" alt="image-20230612172044225" style="zoom:50%;" /><p>所以，此时我们就增加一些 <strong>“防御性”</strong> 的分号，避免这种情况出现：</p><img src="image-20230612172058260.png" alt="image-20230612172058260" style="zoom:50%;" /><p>另外有一个小的细节点需要注意，那就是 <strong>一定不能在return、break或continue等关键字后加入《换行符》</strong>，这里作者给我们列举了实例：</p><img src="image-20230612172119386.png" alt="image-20230612172119386" style="zoom:50%;" /><h2 id="第3章-类型、值和变量"><a href="#第3章-类型、值和变量" class="headerlink" title="第3章 类型、值和变量"></a>第3章 类型、值和变量</h2><p>在 <code>JS</code> 中类型一般被分为两大类：</p><ol><li>简单数据类型：作者称其为 <strong>原始类型</strong></li><li>复杂数据类型：作者称其为 <strong>特殊类型</strong></li></ol><p>整个第三章中，所讲解的主要就是这两大类型的内容。</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>首先咱们先来看原始类型，整个原始类型包含了 7 种类型的值： <code>number、string、boolean、null、undefined、symbol、bigint</code>。</p><p>这 7 种数据类型我们不会一个一个都去讲，我们主要来看其中 5 个。</p><ol><li>首先是 <code>number</code>：在 <code>JS</code> 中，无论是整数还是小数都被称为 <code>number</code> 类型。但是大家要注意的是：**<code>JS</code> 中无法精确表示浮点数**。比如：<code>0.3 - 0.2</code> 是不等于 <code>0.1</code> 的。所以说 <code>JS</code> 无法进行精确地浮点数表示。</li><li>接下来是 <code>null</code> 和 <code>undefined</code>：这两个值在 <code>JS</code> 中都被称为是 <strong>假性值</strong>。但是它们也有不太一样的地方。<code>null</code> 是一个特殊值，通常被用来表示 <strong>某个值不存在</strong>，它是一个 <code>object</code> 类型，我们可以使用 <code>typeof null === &#39;object&#39;</code>  来进行测试。</li><li>而 <code>undefined</code> 它表示一个 “更深层次的不存在”，当我们定义一个变量但不进行赋值时，那么这个变量默认是 <code>undefined</code>。<code>undefined</code> 是一个单独的类型，我们可以使用 <code>typeof undefined === &#39;undefined&#39;</code> 来进行测试。</li><li>最后是 <code>symbol</code> 和 <code>bigint</code>：这两个都是 <code>ES6</code> 之后新增的数据类型。其中 <code>symbol</code> 表示 <strong>唯一的值</strong>。我们可以通过 <code>symbol</code> 得到一个<strong>永远都不会重复</strong>的结果 <code>Symbol(&#39;a&#39;) === Symbol(&#39;a&#39;) // false</code> 。 </li><li>而 <code>bigint</code> 表示的是 <strong>大数字</strong>。默认情况下 <code>JS</code> 中的 <code>number</code> 类型只能表示 <code>-2^53 -- 2^53</code> 之间，超过这个范围就无法精准表示了。所以 <code>ES</code> 推出了 <code>bigint</code> 来表示大数字。使用 <code>bigint</code> 非常简单，只需要在 **大数字后面加上 n ** 就可以了，同时需要注意 <code>bigint</code> 只能是 <strong>整数</strong>，另外 <code>bigint</code> 不能与 <code>number</code> 进行算术运算。</li></ol><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><p>接下来我们来看特殊类型。 <code>JS</code> 中的特殊类型只有一个，那就是 <code>object</code>。或者说：在 <code>JS</code> 所有不属于原始类型的都是特殊类型。</p><p>比如：<code>Array</code>、<code>Object</code>、<code>Function</code>、<code>Set</code> 等等</p><p>这些特殊类型我们会在 <code>第六章 - 第九章</code> 再去进行详细讲解。</p><h2 id="第4章-表达式与操作符"><a href="#第4章-表达式与操作符" class="headerlink" title="第4章 表达式与操作符"></a>第4章 表达式与操作符</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><blockquote><p> <strong>在 JS 中你的每一行语句，都可以被称为是一个表达式。</strong></p></blockquote><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="条件式调用"><a href="#条件式调用" class="headerlink" title="条件式调用"></a>条件式调用</h4><p>首先是 <strong>条件式调用</strong>：在我们的日常开发中，如果一个对象为 <strong>假性值</strong>，那么当我们获取这个对象的属性时，会得到一个错误：</p><img src="image-20230612172916349.png" alt="image-20230612172916349" style="zoom:50%;" /><p>为了解决这样的问题，在 <code>ES2020</code> 中提供了一个新的语法 <strong>条件式调用</strong>，可以让我们避免这种错误：</p><img src="image-20230612172928143.png" alt="image-20230612172928143" style="zoom:50%;" /><p>在 <code>obj</code> 后面加上一个 <code>?</code>，如果 <code>obj</code> 为假性值，则会得到一个 <code>undefined</code>。而不会抛出异常。</p><h4 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h4><p><code>in</code> 操作符用来判断 <strong>左侧值是否是右侧对象的属性名</strong>，返回一个 <code>boolean</code> 类型的值。</p><h4 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h4><p><code>instanceof</code> 操作符用来判断 <strong>左侧值是否是右侧类的实例</strong>，返回一个 <code>boolean</code> 类型的值。</p><h4 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h4><p><code>typeof 操作符</code> 我们在前面使用过，它可以用来 <strong>判断一个值的类型</strong>。它可以判断的所有类型如下表所示：</p><img src="image-20230612173011302.png" alt="image-20230612173011302" style="zoom:50%;" /><h4 id="delete-操作符"><a href="#delete-操作符" class="headerlink" title="delete 操作符"></a>delete 操作符</h4><p><code>delete</code> 操作符可以用来 <strong>删除一个对象或数组的指定属性或元素</strong>：</p><img src="image-20230612173034357.png" alt="image-20230612173034357" style="zoom:50%;" /><h4 id="eval-函数（操作符）"><a href="#eval-函数（操作符）" class="headerlink" title="eval() 函数（操作符）"></a>eval() 函数（操作符）</h4><p><code>eval() </code> 是一个函数，但是在这里作者把它作为操作符来进行讲解。</p><p><code>eval() </code> 可以接收一个 <strong>字符串</strong>，这个字符串应该是一段表达式。然后 <code>JS引擎</code> 会把这段字符串当做 <code>JavaScript</code> 代码来进行执行。</p><h4 id="先定义操作符"><a href="#先定义操作符" class="headerlink" title="?? 先定义操作符"></a>?? 先定义操作符</h4><p><code>?? 先定义操作符</code> 有点类似于  <code>|| 操作符</code>。但是不同的地方在于 <code>|| 操作符</code>  中 <code>数字 0</code> 会被作为假性值判断为假，但是在 <code>?? 先定义操作符</code> 中 <code>数字 0 </code> 会被作为真来进行处理。</p><h2 id="第5章-语句"><a href="#第5章-语句" class="headerlink" title="第5章 语句"></a>第5章 语句</h2><p>循环语句</p><blockquote><p>循环语句指的是 <strong>包含循环的语句</strong>。在 <code>JS</code> 中可以产生循环功能的语法非常多，比如：<code>while、do/while、for</code> 这三个都是基本的循环语法，这里咱们不去详细说。</p><p>除此之外，还有一些 <code>ES6</code> 之后新增的循环方式：</p><p>首先是 <code>for/of</code> 循环： <code>for/of</code> 循环，<strong>不可以循环对象，只能循环非对象</strong>，比如 <code>Array、Map</code> 都可以利用 <code>for/of</code> 进行循环操作。当数组使用 <code>for/of</code> 进行循环时，每个循环对象表示数组的 <code>item</code>。当 <code>Map</code> 进行循环时，每个循环对象是一个 <strong>数组</strong>，我们可以通过 <code>[] 解构</code> 的方式，拿到对应 <code>item</code> 的 <code>key 和 value</code>。</p><p>其次是 <code>for/in</code> 循环： <code>for/in</code> 循环比较简单，<strong>它既可以循环对象，也可以循环数组</strong>。</p><p>最后是 <code>for/await与异步迭代</code> 循环：这一块涉及到了迭代器和异步的部分，咱们把它放到 <code>第12章 迭代器与生成器 和 第13章 异步JavaScript</code> 中在进行讲解。</p></blockquote><p>跳转语句</p><blockquote><p>所谓跳转语句指的是：<strong>会修改代码执行顺序的语句</strong>。</p><p><code>JS</code> 中的跳转语句一共分为 <code>7</code> 类：<code>break、continue、return、yield、throw、try/catch/finally</code>，咱们一个一个来说。</p><p>首先是 <code>break</code>：它通常配合循环或者 <code>switch</code> 进行使用，表示退出当前循环或 <code>switch</code> 条件判断。</p><p><code>continue</code>：通常配合循环使用，它表示 <strong>跳出当前循环，继续进行下一次循环</strong>。</p><p><code>return</code>：<code>return</code> 语句只能出现在函数体内，表示返回值，并终止函数执行。</p><p><code>yield</code>： 主要配合生成器函数来进行使用，这个咱们等到 <code>第12章 迭代器与生成器</code> 时再进行说明。</p><p><code>throw</code>：表示抛出一个异常，通常情况下，这会终止程序的执行。</p><p><code>try/catch/finally</code>：可以捕获异常。当 <code>try</code> 中的代码块出现异常时，代码会进入 <code>catch</code> 执行，最终无论结果如何都会执行 <code>finally</code>。</p></blockquote><h2 id="第6章-对象"><a href="#第6章-对象" class="headerlink" title="第6章 对象"></a>第6章 对象</h2><p>在 <code>JS</code> 中，对象是一个属性的 <strong>无序集合</strong>，所有用 <code>&#123;&#125; </code> 包裹，并且包含 <code>key:value</code> 结构的值都是一个对象。</p><p>想要创建一个对象的话，一共有三种方式：</p><ul><li>对象字面量：这是最常用的一种方式 <code>const obj = &#123; name: &#39;张三&#39; &#125;</code></li><li>new 创建：利用 <code>Object</code> 构造函数，配合 <code>new</code> 关键字，创建对象实例 <code>const obj = new Object</code></li><li>原型创建：通过 <code>Object.create</code> 方法创建对象实例</li></ul><p>而想要创建对象属性的话，那么一共有两种方式：</p><ul><li>. 操作符：<code>obj.key</code></li><li><code>[key]</code>：<code>obj[key]</code></li></ul><p>想要删除对象中的某个属性，可以利用咱们前面提到的 <code>delete</code> 关键字。</p><p>在 <code>JS</code> 中，如果想要测试某个属性是否属于指定对象，那么一共有三种方式：</p><ul><li>in 操作符：咱们之前有提到过这个操作符，这里就不再多说了。</li><li><code>hasOwnProperty</code> 方法：当前方法可以 <strong>测试指定属性是否为对象的自有属性</strong>。</li><li><code>propertyIsEnumerable 方法</code>：当前方法可以 <strong>测试指定属性是否为对象的可枚举属性</strong>。</li></ul><p>而如果想要 <strong>依赖现有对象，扩展出其他对象的话</strong>，那么有两种方式：</p><ul><li><code>Object.assign()</code>：该方法可以将所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>（<code>Object.propertyIsEnumerable()</code> 返回 true）的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">自有</a>（<code>Object.hasOwnProperty()</code> 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象。</li><li><code>扩展操作符...</code>：利用 <code>ES6</code> 提供的 <code>扩展操作符</code>，可以把多个对象合并成一个新的对象。</li></ul><p>除此之外，<code>JS</code> 还提供了序列化的方法，所谓的序列化指的是 <strong>把对象的状态转换为字符串的过程，之后可以从中恢复对象的状态</strong> 。在 JS 中，可以通过 <code>JSON.parse</code> 和 <code>JSON.stringify</code> 来完成对象的序列化过程。</p><p>最后就是 <strong>对象字面量扩展语法</strong>，这些扩展方法有些可能比较冷僻，但是有的确实在日常开发中存在一些价值，所以我们这里需要拿出来一些时间来说一下。</p><ul><li><p>首先是 <strong>简写属性</strong>：这种语法是开发中非常常见的语法，<strong>当 <code>key 和 value</code> 为相同的名称时，可以简写</strong>。</p><img src="image-20230612173658238.png" alt="image-20230612173658238" style="zoom:50%;" /></li><li><p>其次是 <strong>计算的属性名</strong>：有些时候我们可能期望使用变量来作为对象的<code>key</code>，此时就需要用到这种计算的属性名。</p><img src="image-20230612173711768.png" alt="image-20230612173711768" style="zoom:50%;" /></li><li><p>然后是 <strong>简写方法</strong>：这个也是非常常见的一种写法。常见到很多同学都不认为这是一种简写的写法。</p><img src="image-20230612173721850.png" alt="image-20230612173721850" style="zoom:50%;" /></li><li><p>最后是 <strong>属性的获取方法与设置方法</strong>：我们可以通过 <code>set</code> 和 <code>get</code> 表示来标记一个对象的方法，这样这个方法就可以像调用属性一样进行调用了。<code>vue3</code> 中的 <code>ref</code> 就是通过这种方式实现的响应性。</p><img src="image-20230612173734002.png" alt="image-20230612173734002" style="zoom:50%;" /></li></ul><h2 id="第7章-数组"><a href="#第7章-数组" class="headerlink" title="第7章 数组"></a>第7章 数组</h2><p><code>JS</code> 提供了两个 <strong>工厂方法</strong> 来创建数组：</p><ul><li><p>第一个是 <code>Array.of()</code>：可以通过 <strong>可变数量的参数</strong> 创建一个新的 <code>Array</code> 实例，而不需要考虑参数的数量或类型。</p><img src="image-20230612174333706.png" alt="image-20230612174333706" style="zoom:50%;" /></li><li><p>第二个是 <code>Array.from()</code>：这个方法的主要价值是可以把 <strong>把类数组转化为真实数组</strong>。关于类数组我们会在下面讲解到</p><img src="image-20230612174345691.png" alt="image-20230612174345691" style="zoom:50%;" /></li></ul><p>想要添加或者删除数组元素的话，这里咱们各列举三种方式：</p><ul><li>添加<ul><li><code>Array.prototype.push()</code>：把指定元素添加对数组的最后</li><li><code>Array.prototype.unshift()</code>：把指定元素添加到数组的最前</li><li><code>arr[1] = &#39;xx&#39;</code>：把指定元素添加到数组的指定位置</li></ul></li><li>删除<ul><li><code>Array.prototype.pop()</code>：从数组的最后删除元素</li><li><code>Array.prototype.shift()</code>：从数组的最前删除元素</li><li><code>delete 操作符</code>：删除数组指定位置元素</li></ul></li></ul><p>对于数组迭代的话，我们日常开发中常用的其实只有两种：</p><ul><li>传统 <code>for</code> 循环：<img src="image-20230612174446241.png" alt="image-20230612174446241" style="zoom:50%;" /></li><li><code>forEach</code> 循环：<br><img src="/2023/06/12/jing-du-javascript-quan-wei-zhi-nan/image-20230612174455484.png" alt="image-20230612174455484"></li></ul><p>在 <code>JS</code> 中存在一个特殊的数组概念，叫做 <strong>类数组对象</strong>。在 <code>JS</code> 中，所有的数组都拥有如下四个特性：</p><ul><li>① 数组的<code>length</code>属性会在新元素加入时自动更新</li><li>② 设置<code>length</code>为更小的值会截断数组</li><li>③ 数组从<code>Array.prototype</code>继承有用的方法</li><li>④ <code>Array.isArray()</code>对数组返回<code>true</code></li></ul><p>而类数组，虽然也具备 <code>length</code> 属性，但是却没有以上这四个特性。比如：<code>arguments</code>。如果想要把类数组对象转化为数组对象，可以使用我们之前提到的 <code>Array.from()</code> 方法</p><h2 id="第8章函数"><a href="#第8章函数" class="headerlink" title="第8章函数"></a>第8章函数</h2><p>函数包含参数的概念，参数分为 <strong>形参</strong> 和 <strong>实参</strong> 。其中 <strong>形参</strong> 表示 <strong>定义函数时指定的参数</strong>。 <strong>实参</strong> 表示 <strong>调用函数时传递的参数</strong>。在 <code>JS</code> 中实参和形参并 <strong>不需要</strong> 是一一对应的，同时函数调用也不对传入的实参进行任何类型检查。那么这样的一个动态的形式，在 <code>JS</code> 中就被分为了 <code>5</code> 个概念：</p><ul><li><p>可选形参与默认值：这样的代码表示，如果没有传入 <code>a</code> 形参，那么 <code>a</code> 默认为 <code>[]</code></p><img src="image-20230612175022888.png" alt="image-20230612175022888" style="zoom:50%;" /></li><li><p>剩余形参与可变长度实参列表：可以通过 <code>...</code> 的形式来获取所有的剩余实参。在这里 <code>rest = [10, 100, 2, 3, 1000, 4, 5, 6]</code></p><img src="image-20230612175044195.png" alt="image-20230612175044195" style="zoom:50%;" /></li><li><p><code>Arguments</code> 对象：表示或许所有的实参，它是一个伪数组，可以通过 <code>Array.from</code> 方法转化为真实数组</p><p><img src="/2023/06/12/jing-du-javascript-quan-wei-zhi-nan/image-20230612175102465.png" alt="image-20230612175102465"></p></li><li><p>在函数调用中使用扩展操作符：在实参中可以使用扩展运算符，这表示把数组所有的元素作为一个一个的实参单独传入</p><img src="image-20230612175122564.png" alt="image-20230612175122564" style="zoom:50%;" /></li><li><p>把函数实参解构为形参：函数的形参可以直接进行解构</p><img src="image-20230612175136561.png" alt="image-20230612175136561" style="zoom:50%;" /></li></ul><p>函数内部可以嵌套函数，如果 <strong>一个函数访问了其它函数作用域中才有的变量</strong>，那么这个函数可以叫做 <strong>闭包函数</strong>。闭包是在面试时的一个常见概念，需要大家能够掌握。</p><p><img src="/2023/06/12/jing-du-javascript-quan-wei-zhi-nan/image-20230612175235324.png" alt="image-20230612175235324"></p><p>对于函数而言，它除了可以被调用之外，还拥有自己的 <strong>属性</strong> 和 <strong>方法</strong>。</p><ul><li><p>属性：函数的属性有很多，咱们这里主要说三个</p><ul><li><code>length</code> 属性：形参的个数</li><li><code>name</code> 属性：定义函数时使用的名字</li><li><code>prototype</code> 属性：获取原型对象</li></ul></li><li><p>方法</p><ul><li><p><code>call()、apply()</code>：这两个是函数的典型方法。<code>call()</code>和<code>apply()</code>允许间接调用一个函数，就像这个函数是某个其他 <strong>对象</strong> 的方法一样，同时会把该函数中的 <code>this</code> 修改为当前对象。</p><img src="image-20230612190335748.png" alt="image-20230612190335748" style="zoom:50%;" /></li><li><p><code>bind()</code>：在函数 <code>f</code> 上调用 <code>bind()</code> 方法并传入对象 <code>o</code>，则这个方法会返回一个新函数。同时它也会修改函数 <code>f</code> 中的 <code>this</code> 指向</p><img src="image-20230612190346634.png" alt="image-20230612190346634" style="zoom:50%;" /></li><li><p><code>toString()</code> 方法：返回一个符合函数声明语句的字符串</p></li><li><p><code>Function()</code> 构造函数：使用 Function() 构造函数可以用来 创建新函数</p><img src="image-20230612190355559.png" alt="image-20230612190355559" style="zoom:50%;" /></li></ul><p>最后如果一个函数 <strong>接收一个函数参数，并返回一个新函数</strong> 的话，那么这个函数可以被叫做 <strong>高阶函数</strong></p><img src="image-20230612190407357.png" alt="image-20230612190407357" style="zoom:50%;" /></li></ul><h2 id="第9章-类"><a href="#第9章-类" class="headerlink" title="第9章 类"></a>第9章 类</h2><p>首先 <code>JS</code> 中把 <strong>可以让一组对象在同一个原型对象中继承属性</strong> 的东西称之为 <strong>类</strong>。比如，我们可以简单的通过 <code>Object.create() 创建实例</code> ，那此时 <code>Object</code> 其实就可以被称为一个类。</p><p>在 <code>ES6</code> 之前，类以构造函数的形式进行呈现，所谓构造函数其实就是一个 <strong>首字母大写的普通函数</strong>：</p><img src="image-20230612190420015.png" alt="image-20230612190420015" style="zoom:50%;" /><p>因为它是一个普通函数，所以它既可以通过 <strong>构造函数</strong> 的形式，配合 <code>new</code> 进行使用。也可以直接调用使用。如果我们想要判断当前的函数是否是通过 <code>new</code> 关键字使用的，那么可以通过 <code>new.target</code> 来进行判定“：</p><img src="image-20230612190431804.png" alt="image-20230612190431804" style="zoom:50%;" /><p>通过构造函数得到的实例，可以利用 <code>instanceof</code> 关键字进行判定</p><img src="image-20230612190441808.png" alt="image-20230612190441808" style="zoom:50%;" /><p>在 <code>ES6</code> 之后，<code>ES</code> 推出了  <code>class</code> 的语法，利用 <code>class</code> 语法可以直接创建类，而不需要在像之前通过构造函数进行创建了。我们可以使用 <code>class</code> 重写 <code>Range</code> 类：</p><img src="image-20230612190450512.png" alt="image-20230612190450512" style="zoom:50%;" /><p>有了 <code>class</code> 之后，如果想要实现继承，那么就非常简单了，可以直接通过 <code>extends 实现继承</code>：</p><img src="image-20230612190459918.png" alt="image-20230612190459918" style="zoom:50%;" /><p>利用 <code>static</code> 关键字，可以为类设置静态方法：静态方法是作为构造函数而非原型对象的属性定义的。 </p><p><img src="/2023/06/12/jing-du-javascript-quan-wei-zhi-nan/image-20230612190507402.png" alt="image-20230612190507402"></p><p>以上代码通过：<code>Range.parse()</code> 调用</p><p>因为 <code>class</code> 本质上依然是 <strong>原型继承</strong> 的机制，所以我们可以通过 <code>prototype</code> 属性来为已有的类添加方法：</p><img src="image-20230612180421423.png" alt="image-20230612180421423" style="zoom:50%;" /><blockquote><p>视频出处：【(旧)一小时读完《JavaScript权威指南（第7版）》上】 <a href="https://www.bilibili.com/video/BV1Ts4y1N7S2/?share_source=copy_web&amp;vd_source=a9f0fd4630ebe41da19ca2c83eb295e6">https://www.bilibili.com/video/BV1Ts4y1N7S2/?share_source=copy_web&amp;vd_source=a9f0fd4630ebe41da19ca2c83eb295e6</a></p><p>视频文档出处：<a href="https://juejin.cn/post/7211422882252947515">https://juejin.cn/post/7211422882252947515</a></p><p>作者：LGD_Sunday</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局——媒体查询</title>
      <link href="/2023/05/25/xiang-ying-shi-bu-ju-mei-ti-cha-xun/"/>
      <url>/2023/05/25/xiang-ying-shi-bu-ju-mei-ti-cha-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><p>CSS中的媒体查询是一种技术，用于根据不同的设备和屏幕尺寸应用不同的样式。通过使用媒体查询，可以为不同的设备和屏幕尺寸提供不同的样式，从而优化用户体验。</p><h2 id="媒体查询的引入方法"><a href="#媒体查询的引入方法" class="headerlink" title="媒体查询的引入方法"></a>媒体查询的引入方法</h2><ol><li><p>使用@media属性进行媒体查询：</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">@media mediatype and (condition) &#123;  &#x2F;* CSS rules go here *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，mediatype 表示媒体类型，可以是 all（所有媒体设备）、print（打印设备）、screen（计算机屏幕）等等。condition 表示条件，可以是设备宽度、高度、方向、分辨率等等。</p><p>此外，媒体查询可以嵌套，以便为不同的屏幕尺寸和设备类型提供更加精细的样式：</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">@media screen and (max-width: 480px) &#123;  &#x2F;* CSS rules for small screens go here *&#x2F;  @media (orientation: portrait) &#123;    &#x2F;* CSS rules for portrait orientation go here *&#x2F;  &#125;  @media (orientation: landscape) &#123;    &#x2F;* CSS rules for landscape orientation go here *&#x2F;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在<code>&lt;style&gt;</code>标签中使用媒体查询：</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">&lt;style media&#x3D;&quot;mediatype and (condition)&quot;&gt;  &#x2F;* 样式规则 *&#x2F;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在HTML文档中使用标签进行媒体查询：</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">&lt;link rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;(max-width: 768px)&quot; href&#x3D;&quot;small-screen.css&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，在屏幕宽度小于等于768px时，就会加载small-screen.css样式表，从而应用相应的样式规则。</p></li><li><p>使用@import规则引入带有媒体查询的样式表：</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">@import url(&quot;small-screen.css&quot;) screen and (max-width: 768px);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript进阶题目</title>
      <link href="/2023/05/09/javascript-jin-jie-ti-mu/"/>
      <url>/2023/05/09/javascript-jin-jie-ti-mu/</url>
      
        <content type="html"><![CDATA[<ol><li><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function sayHi() &#123;  console.log(name);  console.log(age);  var name &#x3D; &#39;Lydia&#39;;  let age &#x3D; 21;&#125;sayHi();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>Lydia</code> and <code>undefined</code></li><li>B: <code>Lydia</code> and <code>ReferenceError</code></li><li>C: <code>ReferenceError</code> and <code>21</code></li><li>D: <code>undefined</code> and <code>ReferenceError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: D</strong></p><p>在函数中，我们使用了 <code>var</code> 关键词来声明<code>name</code> 变量，这导致变量被提升（内存空间在创建阶段设置），默认值为<code>undefined</code>，直到该变量被定义的那一行。</p><p>而带有 <code>let</code>关键字 (和 <code>const</code>)的变量会被提升，但和 <code>var</code>不同的是，它不会被初始化。在我们初始化它们之前，它们是不可访问的，这被称为“时间死区”。</p><p>当我们尝试在声明变量之前访问变量时，JavaScript 会抛出  <code>ReferenceError</code>。  </p></li><li><h3 id="异步函数的执行"><a href="#异步函数的执行" class="headerlink" title="异步函数的执行"></a>异步函数的执行</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>0 1 2</code> and <code>0 1 2</code></li><li>B: <code>0 1 2</code> and <code>3 3 3</code></li><li>C: <code>3 3 3</code> and <code>0 1 2</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>在JavaScript中，由于事件队列的存在，<code>setTimeout</code>回调函数在循环执行后才被调用。在第一个循环中，变量<code>i</code>使用<code>var</code>关键字声明，因此该值是全局的。在循环期间，我们每次使用一元运算符<code>++</code>将<code>i</code>的值增加<code>1</code>。因此，在循环中使用<code>var</code>声明变量时，每次循环都会覆盖上一次循环中的变量值，最终导致所有的变量都共享同一个值。当<code>setTimeout</code>回调函数被调用时，第一个示例中的i等于3。</p><p>在第二个循环中，变量<code>i</code>使用<code>let</code>关键字声明：使用<code>let</code>（和<code>const</code>）关键字声明的变量是块作用域的（块是<code>&#123; &#125;</code>之间的任何内容）。在每次迭代期间，i将具有新值，并且每个值都在循环内部作用域。</p></li><li><h3 id="this作用域"><a href="#this作用域" class="headerlink" title="this作用域"></a>this作用域</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const shape &#x3D; &#123;  radius: 10,  diameter() &#123;    return this.radius * 2;  &#125;,  perimeter: () &#x3D;&gt; 2 * Math.PI * this.radius,&#125;;console.log(shape.diameter());console.log(shape.perimeter());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>20</code> and <code>62.83185307179586</code></li><li>B: <code>20</code> and <code>NaN</code></li><li>C: <code>20</code> and <code>63</code></li><li>D: <code>NaN</code> and <code>63</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>请注意，<code>diameter</code>的值是一个正则函数，而<code>perimeter</code>的值是一个箭头函数。对于箭头函数，<code>this</code>关键字指的是它当前周围的作用域，这与常规函数不同！这意味着当我们调用 <code>perimeter</code> 时，它不是指形状对象，而是指它周围的范围（例如窗口）。<br>该对象没有值<code>radius</code>，返回 <code>NaN</code>。</p></li><li><h3 id="一元加号运算符"><a href="#一元加号运算符" class="headerlink" title="一元加号运算符"></a>一元加号运算符</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">+true;!&#39;Lydia&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>A: <code>1</code> and <code>false</code></li><li>B: <code>false</code> and <code>NaN</code></li><li>C: <code>false</code> and <code>false</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>一元加号运算符（unary plus）会尝试将操作数转换为数字。在JavaScript中，<code>true</code>被转换为<code>1</code>，<code>false</code>被转换为<code>0</code>。</p><p>字符串<code>&#39;Lydia&#39;</code>，它是一个真值（truthy value），也就是说它在布尔上下文中会被视为true。因此，我们实际上在问“这个真值是否为假值？”这个表达式的结果是<code>false</code>，因为“Lydia”是一个真值，不是假值。</p></li><li><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const bird &#x3D; &#123;  size: &#39;small&#39;,&#125;;const mouse &#x3D; &#123;  name: &#39;Mickey&#39;,  small: true,&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>mouse.bird.size</code> is not valid</li><li>B: <code>mouse[bird.size]</code> is not valid</li><li>C: <code>mouse[bird[&quot;size&quot;]]</code> is not valid</li><li>D: All of them are valid</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>在 JavaScript 中，所有对象键都是字符串（除非它是 <code>Symbol</code>）。尽管我们可能不会将它们输入为字符串，但它们总是会在底层转换为字符串。 当使用方括号表示法时，JavaScript会进行解释（或解包）语句。它看到第一个开放的方括号<code>[</code>，然后继续查找直到找到闭合的方括号<code>]</code>。只有在找到闭合的方括号后，它才会评估语句。</p><p>在这个例子中，<code>mouse[bird.size]</code>首先评估<code>bird.size</code>，它的值是<code>&quot;small&quot;</code>。然后，<code>mouse[&quot;small&quot;]</code>返回<code>true</code>。</p><p>然而，使用点表示法时，这种情况不会发生。<code>mouse</code>没有一个名为<code>bird</code>的键，这意味着<code>mouse.bird</code>是<code>undefined</code>的。然后，我们使用点表示法来获取<code>size</code>：<code>mouse.bird.size</code>。由于<code>mouse.bird</code>是<code>undefined</code>的，实际上我们正在请求<code>undefined.size</code>。这是无效的，并且会引发类似于<code>Cannot read property &quot;size&quot; of undefined</code>。</p></li><li><h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">greeting</span><span class="token operator">:</span> <span class="token string">'Hey!'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> d<span class="token punctuation">;</span>d <span class="token operator">=</span> c<span class="token punctuation">;</span>c<span class="token punctuation">.</span>greeting <span class="token operator">=</span> <span class="token string">'Hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>Hello</code></li><li>B: <code>Hey!</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li><li>E: <code>TypeError</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: A**<p>在JavaScript中，当将一个对象赋值给另一个对象时，它们之间是通过引用进行交互的。这意味着，当我们将一个对象赋值给另一个变量时，实际上是将该对象的引用复制到了新变量中，而不是将对象本身复制到新变量中。</p><p>在这个例子中，变量<code>c</code>保存了一个对象的值。稍后，我们将<code>d</code>赋值为与<code>c</code>具有相同引用的对象。这意味着，<code>c</code>和<code>d</code>现在都引用同一个对象，因此对该对象的任何更改都会反映在c和d中。这种交互方式可以节省内存，因为它避免了在内存中复制大量的对象。但需要注意的是，如果我们想要复制一个对象而不是引用它，我们需要使用深拷贝（deep copy）或浅拷贝（shallow copy）的技术。</p><p><img src="/2023/05/09/javascript-jin-jie-ti-mu/image-20230525174921080.png" alt="image-20230525174921080"></p><p>当你改变一个对象时，所有引用该对象的变量都会改变。</p></li><li><h3 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let a &#x3D; 3;let b &#x3D; new Number(3);let c &#x3D; 3;console.log(a &#x3D;&#x3D; b);console.log(a &#x3D;&#x3D;&#x3D; b);console.log(b &#x3D;&#x3D;&#x3D; c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>true</code> <code>false</code> <code>true</code></li><li>B: <code>false</code> <code>false</code> <code>true</code></li><li>C: <code>true</code> <code>false</code> <code>false</code></li><li>D: <code>false</code> <code>true</code> <code>true</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p><code>new Number()</code>是一个内置的函数构造器。虽然它看起来像一个数字，但它实际上不是一个数字：它有许多额外的特性，并且是一个对象。</p><p>当我们使用<code>==</code>运算符（相等运算符）时，它只检查它们是否具有相同的值。它们都具有值<code>3</code>，因此返回<code>true</code>。</p><p>然而，当我们使用<code>===</code>运算符（严格相等运算符）时，值和类型都应该相同。但实际上它们不同：<code>new Number()</code>不是一个数字，而是一个对象。因此两者都返回<code>false</code>。</p></li><li><h3 id="类的函数"><a href="#类的函数" class="headerlink" title="类的函数"></a>类的函数</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class Chameleon &#123;  static colorChange(newColor) &#123;    this.newColor &#x3D; newColor;    return this.newColor;  &#125;  constructor(&#123; newColor &#x3D; &#39;green&#39; &#125; &#x3D; &#123;&#125;) &#123;    this.newColor &#x3D; newColor;  &#125;&#125;const freddie &#x3D; new Chameleon(&#123; newColor: &#39;purple&#39; &#125;);console.log(freddie.colorChange(&#39;orange&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>orange</code></li><li>B: <code>purple</code></li><li>C: <code>green</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: D</strong></p><p><code>colorChange</code>函数是一个静态方法，它只能存在于创建它的构造函数中，不能被传递给任何子类或在类实例上调用。因此，由于<code>freddie</code>是Chameleon类的一个实例，不能在它上面调用colorChange函数，会抛出<code>TypeError</code>错误。</p></li><li><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let greeting;greetign &#x3D; &#123;&#125;; &#x2F;&#x2F; Typo!console.log(greetign);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&#123;&#125;</code></li><li>B: <code>ReferenceError: greetign is not defined</code></li><li>C: <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>它记录了对象，因为我们刚刚在全局对象上创建了一个空对象！当我们将<code>greeting</code>拼写错误为<code>greetign</code>时，JS解释器实际上将其视为：</p><ul><li>在Node.js中，<code>global.greetign = &#123;&#125;</code> 。</li><li>在浏览器中，<code>window.greetign = &#123;&#125;</code>，<code>frames.geetign = &#123;&#125;</code>和<code>self.greetign</code>。 </li><li>在Web Workers中，<code>self.greetign</code>。</li><li>在所有环境中<code>globalThis.greetign</code>。</li><li>为了避免这种情况，我们可以使用<code>&quot;use strict&quot;</code>。这可以确保在将变量设置为任何值之前已经声明了它。</li></ul></li><li><h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function bark() &#123;  console.log(&#39;Woof!&#39;);&#125;bark.animal &#x3D; &#39;dog&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: 无事发生，这种写法完全正确。</li><li>B: <code>SyntaxError</code>。你不能以这种方式向函数添加属性。</li><li>C: 输出的结果是字符串<code>&quot;Woof&quot;</code>。</li><li>D: <code>ReferenceError</code>。</li></ul><details><summary><b>Answer</b></summary><p>**Answer: A**<p>这在JavaScript中是可能的，因为函数是<strong>对象</strong>！（除了原始类型之外，所有东西都是对象）</p><p>函数是一种特殊类型的对象。你自己编写的代码并不是实际的函数。函数是一个带有属性的对象。这个属性是可调用的。</p></li><li><h3 id="函数方法调用"><a href="#函数方法调用" class="headerlink" title="函数方法调用"></a>函数方法调用</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Person(firstName, lastName) &#123;  this.firstName &#x3D; firstName;  this.lastName &#x3D; lastName;&#125;const member &#x3D; new Person(&#39;Lydia&#39;, &#39;Hallie&#39;);Person.getFullName &#x3D; function() &#123;  return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;&#125;;console.log(member.getFullName());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>TypeError</code></li><li>B: <code>SyntaxError</code></li><li>C: <code>Lydia Hallie</code></li><li>D: <code>undefined</code> <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>在JavaScript中，函数是对象。因此，方法<code>getFullName</code>被添加到构造函数对象本身中。因此，我们可以调用<code>Person.getFullName()</code>，但是<code>member.getFullName</code>会抛出<code>TypeError</code>错误。如果你想让一个方法对所有对象实例都可用，你必须将它添加到<strong>原型属性</strong>中(这是因为原型属性是所有对象实例共享的):</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">Person.prototype.getFullName &#x3D; function() &#123;  return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Person(firstName, lastName) &#123;  this.firstName &#x3D; firstName;  this.lastName &#x3D; lastName;&#125;const lydia &#x3D; new Person(&#39;Lydia&#39;, &#39;Hallie&#39;);const sarah &#x3D; Person(&#39;Sarah&#39;, &#39;Smith&#39;);console.log(lydia);console.log(sarah);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> and <code>undefined</code></li><li>B: <code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> and <code>Person &#123;firstName: &quot;Sarah&quot;, lastName: &quot;Smith&quot;&#125;</code></li><li>C: <code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> and <code>&#123;&#125;</code></li><li>D: <code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> and <code>ReferenceError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>对于<code>sarah</code>，我们没有使用<code>new</code>关键字。当使用<code>new</code>时，<code>this</code>指的是我们创建的新空对象。然而，如果你不加<code>new</code>，<code>this</code>指的是<strong>全局对象</strong>！</p><p>我们说<code>this.firstName</code>等于<code>&quot;Sarah&quot;</code>，<code>this.lastName</code>等于<code>&quot;Smith&quot;</code>。实际上，我们定义了<code>global.firstName=&#39;Sarah&#39;</code>和<code>global.lastName=&#39;Smith&#39;</code>。<code>sarah</code>本身是<code>undefined</code>，因为我们没有从<code>Person</code>函数中返回一个值。</p><p>在JavaScript中，如果我们想要创建一个正确的对象，我们可以使用<code>return</code>语句或者使用<code>new</code>关键字。如果我们使用<code>return</code>语句，我们可以在函数内部返回一个新的对象，这个对象将成为函数的返回值。如果我们使用<code>new</code>关键字，我们可以创建一个新的空对象，并将它作为函数内部的<code>this</code>关键字的值。然后，我们可以在函数内部使用<code>this</code>关键字来设置新对象的属性和方法。最后，函数将返回这个新对象。无论是使用<code>return</code>语句还是使用<code>new</code>关键字，我们都可以创建一个正确的对象。</p></li><li><h3 id="事件传播的三个阶段是什么？"><a href="#事件传播的三个阶段是什么？" class="headerlink" title="事件传播的三个阶段是什么？"></a>事件传播的三个阶段是什么？</h3><ul><li>A: 目标阶段 &gt; 捕获阶段 &gt; 冒泡阶段</li><li>B: 冒泡阶段 &gt; 目标阶段 &gt; 捕获阶段</li><li>C: 目标阶段 &gt; 冒泡阶段 &gt; 捕获阶段</li><li>D: 捕获阶段 &gt; 目标阶段 &gt; 冒泡阶段</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: D</strong></p><p>在捕获阶段中，事件从祖先元素开始向下传播到目标元素。然后，事件到达目标元素并触发。接着，冒泡阶段开始，事件从目标元素开始向上冒泡到最外层的元素。因此，在事件传播的过程中，捕获阶段和冒泡阶段都是必要的，它们共同构成了事件传播的完整过程。</p></li><li><h3 id="所有对象都有原型？"><a href="#所有对象都有原型？" class="headerlink" title="所有对象都有原型？"></a>所有对象都有原型？</h3><ul><li>A: 正确</li><li>B: 错误</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>所有对象都有原型，除了<strong>基础对象</strong>。基础对象是由用户创建的对象，或使用<code>new</code>关键字创建的对象。基础对象可以访问一些方法和属性，例如<code>.toString</code>方法。这就是为什么可以使用内置的JavaScript方法的原因！所有类似的方法都在原型上可用。虽然JavaScript无法直接在对象上找到它，但它会沿着原型链向下查找并在那里找到它，这使得它对您可用。</p></li><li><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function sum(a, b) &#123;  return a + b;&#125;sum(1, &#39;2&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>NaN</code></li><li>B: <code>TypeError</code></li><li>C: <code>&quot;12&quot;</code></li><li>D: <code>3</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: C**<p>JavaScript是一种<strong>动态类型语言</strong>：不指定某些变量的类型。值可以自动转换为另一种类型，这被称为隐式类型转换。转换是从一种类型转换为另一种类型。</p><p>在这个例子中，JavaScript将数字<code>1</code>转换为字符串，以便函数有意义并返回一个值。在数字类型（<code>1</code>）和字符串类型（<code>&#39;2&#39;</code>）相加时，数字被视为字符串。我们可以像<code>&quot;Hello&quot;+&quot;World&quot;</code>一样连接字符串，所以这里发生的是<code>&quot;1&quot;+&quot;2&quot;</code>，返回<code>&quot;12&quot;</code>。</p></li><li><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let number &#x3D; 0;console.log(number++);console.log(++number);console.log(number);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>1</code> <code>1</code> <code>2</code></li><li>B: <code>1</code> <code>2</code> <code>2</code></li><li>C: <code>0</code> <code>2</code> <code>2</code></li><li>D: <code>0</code> <code>1</code> <code>2</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>后缀一元运算符<code>++</code>：</p><p>返回值（此处返回<code>0</code>）<br>增加值（数字现在为<code>1</code>）<br>前缀一元运算符 <code>++</code>：</p><p>增加值（数字现在为<code>2</code>）<br>返回值（此处返回<code>2</code>）<br>这将返回<code>0 2 2</code>。</p></li><li><h3 id="标记模板字面量"><a href="#标记模板字面量" class="headerlink" title="标记模板字面量"></a>标记模板字面量</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function getPersonInfo(one, two, three) &#123;  console.log(one);  console.log(two);  console.log(three);&#125;const person &#x3D; &#39;Lydia&#39;;const age &#x3D; 21;getPersonInfo&#96;$&#123;person&#125; is $&#123;age&#125; years old&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;Lydia&quot;</code> <code>21</code> <code>[&quot;&quot;, &quot; is &quot;, &quot; years old&quot;]</code></li><li>B: <code>[&quot;&quot;, &quot; is &quot;, &quot; years old&quot;]</code> <code>&quot;Lydia&quot;</code> <code>21</code></li><li>C: <code>&quot;Lydia&quot;</code> <code>[&quot;&quot;, &quot; is &quot;, &quot; years old&quot;]</code> <code>21</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>如果你使用标记模板字面量，第一个参数的值总是一个字符串值的数组。其余的参数获取传递的表达式的值！</p></li><li><h3 id="对象比较-1"><a href="#对象比较-1" class="headerlink" title="对象比较"></a>对象比较</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function checkAge(data) &#123;  if (data &#x3D;&#x3D;&#x3D; &#123; age: 18 &#125;) &#123;    console.log(&#39;You are an adult!&#39;);  &#125; else if (data &#x3D;&#x3D; &#123; age: 18 &#125;) &#123;    console.log(&#39;You are still an adult.&#39;);  &#125; else &#123;    console.log(&#96;Hmm.. You don&#39;t have an age I guess&#96;);  &#125;&#125;checkAge(&#123; age: 18 &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>You are an adult!</code></li><li>B: <code>You are still an adult.</code></li><li>C: <code>Hmm.. You don&#39;t have an age I guess</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>JavaScript中比较相等性时，原始值是按照它们的值进行比较的，而对象是按照它们的引用进行比较的。JavaScript会检查这些对象是否具有指向内存中相同位置的引用。</p><p>我们比较的两个对象没有这个引用：我们作为参数传递的对象与我们用来检查相等性的对象在内存中引用的位置不同。因此，它们被认为是不相等的。</p><blockquote><p>在JavaScript中，&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;都用于比较两个值的相等性。&#x3D;&#x3D;运算符比较两个值是否相等，但它会进行类型转换。如果两个值的类型不同，&#x3D;&#x3D;运算符会尝试将它们转换为相同的类型，然后再进行比较。例如，如果我们比较数字1和字符串”1”，&#x3D;&#x3D;运算符会将字符串”1”转换为数字1，然后再进行比较。如果两个值的类型相同，&#x3D;&#x3D;运算符会直接比较它们的值。</p></blockquote><p>这就是为什么 <code>&#123; age: 18 &#125; === &#123; age: 18 &#125;</code> 和 <code>&#123; age: 18 &#125; == &#123; age: 18 &#125;</code> 返回 <code>false</code>.</p></li><li><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function getAge(...args) &#123;  console.log(typeof args);&#125;getAge(21);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;array&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;NaN&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>rest参数（…args）允许我们将所有剩余的参数“收集”到一个数组中。数组是一个对象，因此typeof args返回”object”。这意味着我们可以使用数组的方法来操作这些参数。例如，我们可以使用args.length来获取传递的参数的数量，或者使用args.forEach来遍历这些参数。使用rest参数可以使函数更加灵活，因为它允许我们接受任意数量的参数。</p></li><li><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function getAge() &#123;  &#39;use strict&#39;;  age &#x3D; 21;  console.log(age);&#125;getAge();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>21</code></li><li>B: <code>undefined</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: C**<p>使用”use strict”可以确保不会意外地声明全局变量。在上面的代码中，我们没有声明变量age，但由于我们使用了”use strict”，它会抛出一个引用错误。如果我们没有使用”use strict”，它仍然可以工作，因为属性age会被添加到全局对象中。使用”use strict”可以帮助我们避免一些常见的错误，例如意外地声明全局变量或使用未声明的变量。它还可以使代码更加严格，从而提高代码的可读性和可维护性。</p></li><li><h3 id="计算函数"><a href="#计算函数" class="headerlink" title="计算函数"></a>计算函数</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const sum &#x3D; eval(&#39;10*10+5&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: <code>105</code></li><li>B: <code>&quot;105&quot;</code></li><li>C: <code>TypeError</code></li><li>D: <code>&quot;10*10+5&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p><code>eval</code>函数评估作为字符串传递的代码。如果它是一个表达式，就像这个例子一样，它会评估这个表达式。这个表达式是<code>10 * 10 + 5</code>。这将返回数字<code>105</code>。</p></li><li><h3 id="cool-secret-可以访问多长时间？"><a href="#cool-secret-可以访问多长时间？" class="headerlink" title="cool_secret 可以访问多长时间？"></a>cool_secret 可以访问多长时间？</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">sessionStorage.setItem(&#39;cool_secret&#39;, 123);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: 永远，数据不会丢失。</li><li>B: 当用户关闭选项卡时。</li><li>C: 当用户关闭整个浏览器时，不仅仅是选项卡。</li><li>D: 当用户关闭他们的计算机时。</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>存储在<code>sessionStorage</code>中的数据在关闭选项卡后会被删除。</p><p>如果您使用了<code>localStorage</code>，除非例如调用<code>localStorage.clear()</code>，否则数据将永久存在。</p></li><li><h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var num &#x3D; 8;var num &#x3D; 10;console.log(num);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>8</code></li><li>B: <code>10</code></li><li>C: <code>SyntaxError</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>使用<code>var</code>关键字，您可以声明多个具有相同名称的变量。变量将保存最新的值。</p><p>使用<code>let</code>或<code>const</code>无法这样做，因为它们是块作用域的。</p></li><li><h3 id="对象与集合的键"><a href="#对象与集合的键" class="headerlink" title="对象与集合的键"></a>对象与集合的键</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const obj &#x3D; &#123; 1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39; &#125;;const set &#x3D; new Set([1, 2, 3, 4, 5]);obj.hasOwnProperty(&#39;1&#39;);obj.hasOwnProperty(1);set.has(&#39;1&#39;);set.has(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>false</code> <code>true</code> <code>false</code> <code>true</code></li><li>B: <code>false</code> <code>true</code> <code>true</code> <code>true</code></li><li>C: <code>true</code> <code>true</code> <code>false</code> <code>true</code></li><li>D: <code>true</code> <code>true</code> <code>true</code> <code>true</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>所有对象的键（不包括 Symbols）在底层都是字符串，即使您没有将其键入为字符串。这就是为什么<code>obj.hasOwnProperty(&#39;1&#39;)</code>也返回<code>true</code>的原因。</p><p>但是对于集合来说，情况并非如此。我们的集合中没有<code>&#39;1&#39;</code>，所有<code>set.has(&#39;1&#39;)</code>返回<code>false</code>。它具有数字类型<code>1</code>，<code>set.has(1)</code>返回<code>true</code>。</p></li><li><h3 id="重复的键"><a href="#重复的键" class="headerlink" title="重复的键"></a>重复的键</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const obj &#x3D; &#123; a: &#39;one&#39;, b: &#39;two&#39;, a: &#39;three&#39; &#125;;console.log(obj);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>A: <code>&#123; a: &quot;one&quot;, b: &quot;two&quot; &#125;</code></li><li>B: <code>&#123; b: &quot;two&quot;, a: &quot;three&quot; &#125;</code></li><li>C: <code>&#123; a: &quot;three&quot;, b: &quot;two&quot; &#125;</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: B**<p>如果您有两个具有相同名称的键，则该键将被替换。它仍将位于其第一个位置，但具有最后指定的值。</p></li><li><h3 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h3><blockquote><p>JavaScript全局执行上下文为您创建了两个东西：全局对象和“this”关键字。</p></blockquote><ul><li>A: 正确</li><li>B: 错误</li><li>C: 取决于环境</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>基本执行上下文是全局执行上下文：它是您代码中任何地方都可以访问的内容。</p></li><li><h3 id="循环迭代"><a href="#循环迭代" class="headerlink" title="循环迭代"></a>循环迭代</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">for (let i &#x3D; 1; i &lt; 5; i++) &#123;  if (i &#x3D;&#x3D;&#x3D; 3) continue;  console.log(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>1</code> <code>2</code></li><li>B: <code>1</code> <code>2</code> <code>3</code></li><li>C: <code>1</code> <code>2</code> <code>4</code></li><li>D: <code>1</code> <code>3</code> <code>4</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p><code>continue</code>语句在某个条件返回<code>true</code>时跳过当前迭代。</p></li><li><h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">String.prototype.giveLydiaPizza &#x3D; () &#x3D;&gt; &#123;  return &#39;Just give Lydia pizza already!&#39;;&#125;;const name &#x3D; &#39;Lydia&#39;;console.log(name.giveLydiaPizza())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;Just give Lydia pizza already!&quot;</code></li><li>B: <code>TypeError: not a function</code></li><li>C: <code>SyntaxError</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p> <code>String</code>是一个内置的构造函数，我们可以向其添加属性。我刚刚向其原型添加了一个方法。原始字符串会自动转换为由字符串原型函数生成的字符串对象。因此，所有字符串（字符串对象）都可以访问该方法！这意味着，如果您向字符串原型添加一个方法，那么<strong>所有</strong>字符串都可以使用该方法。</p></li><li><h3 id="对象键"><a href="#对象键" class="headerlink" title="对象键"></a>对象键</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const a &#x3D; &#123;&#125;;const b &#x3D; &#123; key: &#39;b&#39; &#125;;const c &#x3D; &#123; key: &#39;c&#39; &#125;;a[b] &#x3D; 123;a[c] &#x3D; 456;console.log(a[b]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>123</code></li><li>B: <code>456</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>这段代码中，我们尝试将一个对象作为键设置到对象<code>a</code>中，并将其值设置为<code>123</code>。然而，当我们将一个对象转换为字符串时，它会变成<code>&quot;[object Object]&quot;</code>。因此，我们实际上是在说<code>a[&quot;[object Object]&quot;] = 123</code>。然后，我们尝试再次做同样的事情。c是另一个我们隐式转换为字符串的对象。因此，<code>a[&quot;[object Object]&quot;] = 456</code>。然后，我们记录<code>a[b]</code>，实际上是<code>a[&quot;[object Object]&quot;]</code>。我们刚刚将其设置为<code>456</code>，因此它返回<code>456</code>。</p><blockquote><p>这段代码中的关键点是对象键自动转换为字符串，因此需要小心处理对象键。</p></blockquote></li><li><h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const foo &#x3D; () &#x3D;&gt; console.log(&#39;First&#39;);const bar &#x3D; () &#x3D;&gt; setTimeout(() &#x3D;&gt; console.log(&#39;Second&#39;));const baz &#x3D; () &#x3D;&gt; console.log(&#39;Third&#39;);bar();foo();baz();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>First</code> <code>Second</code> <code>Third</code></li><li>B: <code>First</code> <code>Third</code> <code>Second</code></li><li>C: <code>Second</code> <code>First</code> <code>Third</code></li><li>D: <code>Second</code> <code>Third</code> <code>First</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: B**<p>这段代码中，我们首先调用了setTimeout函数，但是它是最后被打印出的。这是因为在浏览器中，我们不仅有运行时引擎，还有一个叫做WebAPI的东西。WebAPI为我们提供了setTimeout函数，以及例如DOM等其他功能。</p><p>在callback被推送到WebAPI之后，setTimeout函数本身（但不是callback！）被弹出堆栈。</p><p><img src="/2023/05/09/javascript-jin-jie-ti-mu/image-20230612163646188.png" alt="image-20230612163646188"></p><p>现在，foo函数被调用，”First”被记录下来。</p><p><img src="/2023/05/09/javascript-jin-jie-ti-mu/image-20230612170120088.png" alt="image-20230612170120088"></p><p>foo函数被执行完毕后，它被弹出了调用栈，然后baz函数被调用并执行。</p><p><img src="/2023/05/09/javascript-jin-jie-ti-mu/image-20230612170135795.png" alt="image-20230612170135795"></p><p>在JavaScript中，WebAPI不能随时将回调函数添加到调用栈中。相反，它将回调函数推送到一个叫做队列的数据结构中。</p><p><img src="/2023/05/09/javascript-jin-jie-ti-mu/image-20230612170150767.png" alt="image-20230612170150767"></p><p>事件循环是JavaScript中的一种机制，它用于处理异步代码。事件循环会不断地检查调用栈和任务队列。如果调用栈为空，事件循环会从任务队列中取出下一个任务，并将其推送到调用栈中执行。</p><p><img src="/2023/05/09/javascript-jin-jie-ti-mu/image-20230612170204456.png" alt="image-20230612170204456"></p></li><li><h3 id="点击按钮时哪一个是event-target？"><a href="#点击按钮时哪一个是event-target？" class="headerlink" title="点击按钮时哪一个是event.target？"></a>点击按钮时哪一个是event.target？</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'first div'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'second div'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>      Click!    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: 外层的 <code>div</code></li><li>B: 内层的 <code>div</code></li><li>C: <code>button</code></li><li>D: 所有嵌套元素的数组</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>当点击一个元素时，事件会从该元素开始向上冒泡，直到达到文档根节点。在这个过程中，每个祖先元素都会收到该事件。事件的目标元素是最深层次的嵌套元素，它是直接触发事件的元素。您可以使用<code>event.target</code>属性来访问该元素。如果您想停止事件冒泡，可以使用<code>event.stopPropagation()</code>方法。这将阻止事件继续向上冒泡，从而只触发目标元素的事件处理程序。</p></li><li><h3 id="事件处理顺序"><a href="#事件处理顺序" class="headerlink" title="事件处理顺序"></a>事件处理顺序</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>    Click here!  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>p</code> <code>div</code></li><li>B: <code>div</code> <code>p</code></li><li>C: <code>p</code></li><li>D: <code>div</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>如果我们点击一个<code>p</code>元素，我们会看到两个打印结果：<code>p</code>和<code>div</code>。在这个过程中，事件会经历三个阶段：捕获阶段、目标阶段和冒泡阶段。默认情况下，事件处理程序会在冒泡阶段执行（除非您将<code>useCapture</code>设置为<code>true</code>）。事件处理程序会从最深层次的嵌套元素开始执行，然后向外层元素逐步执行，直到达到文档根节点。</p></li><li><h3 id="引用对象的方式"><a href="#引用对象的方式" class="headerlink" title="引用对象的方式"></a>引用对象的方式</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123; name: &#39;Lydia&#39; &#125;;function sayHi(age) &#123;  return &#96;$&#123;this.name&#125; is $&#123;age&#125;&#96;;&#125;console.log(sayHi.call(person, 21));console.log(sayHi.bind(person, 21));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>undefined is 21</code> <code>Lydia is 21</code></li><li>B: <code>function</code> <code>function</code></li><li>C: <code>Lydia is 21</code> <code>Lydia is 21</code></li><li>D: <code>Lydia is 21</code> <code>function</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: D</strong></p><p>我们可以使用<code>.call</code>和<code>.bind</code>方法来指定函数中的<code>this</code>关键字所引用的对象。但是，<code>.call</code>方法会立即执行函数，而<code>.bind</code>方法则会返回一个新的函数，该函数的上下文已经绑定好了，但不会立即执行。</p></li><li><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function sayHi() &#123;  return (() &#x3D;&gt; 0)();&#125;console.log(typeof sayHi());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;object&quot;</code></li><li>B: <code>&quot;number&quot;</code></li><li>C: <code>&quot;function&quot;</code></li><li>D: <code>&quot;undefined&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p><code>sayHi</code>函数返回立即调用的函数表达式（IIFE）的返回值。这个函数返回了<code>0</code>，它的类型是<code>“number”</code>。</p><p>另外，typeof操作符可以返回以下值：<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>bigint</code>、<code>string</code>、<code>symbol</code>、<code>function</code>和<code>object</code>。需要注意的是，<code>typeof null</code>返回的是<code>&quot;object&quot;</code>。</p></li><li><h3 id="被视为false的表达式"><a href="#被视为false的表达式" class="headerlink" title="被视为false的表达式"></a>被视为false的表达式</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">0;new Number(0);(&#39;&#39;);(&#39; &#39;);new Boolean(false);undefined;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>0</code>, <code>&#39;&#39;</code>, <code>undefined</code></li><li>B: <code>0</code>, <code>new Number(0)</code>, <code>&#39;&#39;</code>, <code>new Boolean(false)</code>, <code>undefined</code></li><li>C: <code>0</code>, <code>&#39;&#39;</code>, <code>new Boolean(false)</code>, <code>undefined</code></li><li>D: All of them are falsy</li></ul><details><summary><b>Answer</b></summary><p>**Answer: A**<p>有以下8种falsy的数值：</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>NaN</code></li><li><code>false</code></li><li><code>&#39;&#39;</code> (empty string)</li><li><code>0</code></li><li><code>-0</code></li><li><code>0n</code> (BigInt(0))</li></ul><p>像new Number和new Boolean这样的函数构造器被视为truthy值</p></li><li><h3 id="类型判断-1"><a href="#类型判断-1" class="headerlink" title="类型判断"></a>类型判断</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(typeof typeof 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;string&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;undefined&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p><code>typeof 1</code> 返回 <code>&quot;number&quot;</code>. <code>typeof &quot;number&quot;</code> 返回 <code>&quot;string&quot;</code></p></li><li><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const numbers &#x3D; [1, 2, 3];numbers[10] &#x3D; 11;console.log(numbers);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>[1, 2, 3, null x 7, 11]</code></li><li>B: <code>[1, 2, 3, 11]</code></li><li>C: <code>[1, 2, 3, empty x 7, 11]</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>当你给数组中的一个元素设置一个超过数组长度的值时，JavaScript会创建一些被称为”empty slots”（空槽）的东西。实际上，它们的值是undefined，但你会看到类似于以下的结果：</p><p>[1, 2, 3, 空 x 7, 11]</p><p>具体的显示方式取决于你运行代码的环境（不同浏览器、Node等）。</p></li><li><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">(() &#x3D;&gt; &#123;  let x, y;  try &#123;    throw new Error();  &#125; catch (x) &#123;    (x &#x3D; 1), (y &#x3D; 2);    console.log(x);  &#125;  console.log(x);  console.log(y);&#125;)();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>1</code> <code>undefined</code> <code>2</code></li><li>B: <code>undefined</code> <code>undefined</code> <code>undefined</code></li><li>C: <code>1</code> <code>1</code> <code>2</code></li><li>D: <code>1</code> <code>undefined</code> <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>catch块接收参数x。这个x与我们传递参数时的变量不同。这个变量x是块级作用域的。</p><p>稍后，我们将这个块级作用域变量设置为1，并设置变量y的值。现在，我们记录块级作用域变量x的值，它等于1。</p><p>在catch块之外，x仍然是undefined，而y是2。当我们在catch块之外使用console.log(x)时，它返回undefined，而y返回2。</p></li><li><h3 id="所有在JavaScript中的元素只属于"><a href="#所有在JavaScript中的元素只属于" class="headerlink" title="所有在JavaScript中的元素只属于"></a>所有在JavaScript中的元素只属于</h3><ul><li>A: 原始类型或对象</li><li>B: 函数或对象</li><li>C: 只有对象</li><li>D: 数字或对象</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p></li><li><h3 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a>reduce方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">[[0, 1], [2, 3]].reduce(  (acc, cur) &#x3D;&gt; &#123;    return acc.concat(cur);  &#125;,  [1, 2],);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>[0, 1, 2, 3, 1, 2]</code></li><li>B: <code>[6, 1, 2]</code></li><li>C: <code>[1, 2, 0, 1, 2, 3]</code></li><li>D: <code>[1, 2, 6]</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: C**<p><code>[1, 2]</code>是我们的初始值。这是我们开始时的值，也是第一个累加器（<code>acc</code>）的值。在第一轮中，<code>acc</code>是<code>[1, 2]</code>，<code>cur</code>是<code>[0, 1]</code>。我们将它们连接起来，结果为<code>[1, 2, 0, 1]</code>。</p><p>接下来，<code>[1, 2, 0, 1]</code>成为新的<code>acc</code>，<code>[2, 3]</code>成为<code>cur</code>。我们将它们连接起来，得到<code>[1, 2, 0, 1, 2, 3]</code>。</p></li><li><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">!!null;!!&#39;&#39;;!!1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>false</code> <code>true</code> <code>false</code></li><li>B: <code>false</code> <code>false</code> <code>true</code></li><li>C: <code>false</code> <code>true</code> <code>true</code></li><li>D: <code>true</code> <code>true</code> <code>false</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p><code>null</code>是假值。<code>!null</code>返回 <code>true</code>。<code>!true</code> 返回 <code>false</code>。</p><p><code>&quot;&quot;</code> 是假值。<code>!&quot;&quot;</code> 返回 <code>true</code>。<code>!true</code> 返回 <code>false</code>。</p><p><code>1</code> 是真值。<code>!1</code> 返回 <code>false</code>。<code>!false</code> 返回 <code>true</code>。</p></li><li><h3 id="计时器函数"><a href="#计时器函数" class="headerlink" title="计时器函数"></a>计时器函数</h3><p>setInterval在浏览器中返回什么？</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">setInterval(() &#x3D;&gt; console.log(&#39;Hi&#39;), 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: 一个唯一的id</li><li>B: 指定的毫秒数</li><li>C: 传递的函数</li><li>D: <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>它返回一个唯一的 ID。此 ID 可用于通过 <code>clearInterval()</code> 函数清除该间隔。</p></li><li><h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">[...&#39;Lydia&#39;];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: <code>[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]</code></li><li>B: <code>[&quot;Lydia&quot;]</code></li><li>C: <code>[[], &quot;Lydia&quot;]</code></li><li>D: <code>[[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]]</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>字符串是可迭代的。展开运算符将可迭代对象的每个字符映射到一个元素。</p></li><li><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function* generator(i) &#123;  yield i;  yield i * 2;&#125;const gen &#x3D; generator(10);console.log(gen.next().value);console.log(gen.next().value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>[0, 10], [10, 20]</code></li><li>B: <code>20, 20</code></li><li>C: <code>10, 20</code></li><li>D: <code>0, 10 and 10, 20</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>常规函数在调用后无法在执行过程中被中止。然而，生成器函数可以在执行过程中被”停止”，并且稍后可以从停止的地方继续执行。每当生成器函数遇到一个 <code>yield</code> 关键字时，函数会生成 yield 关键字后指定的值。需要注意的是，在这种情况下，<strong>生成器函数不返回该值，而是生成该值</strong>。</p><p>首先，我们使用 <code>i</code> 等于 <code>10</code> 初始化生成器函数。我们使用 <code>next()</code> 方法调用生成器函数。第一次调用生成器函数时，<code>i</code> 等于 <code>10</code>。它遇到第一个 <code>yield</code> 关键字：生成 <code>yield</code> 后面指定的 <code>i</code> 的值。生成器现在被”暂停”，并且输出 <code>10</code>。</p><p>然后，我们再次使用 <code>next()</code> 方法调用函数。它从上次停止的地方开始继续执行，仍然将 <code>i</code> 设为 <code>10</code>。现在，它遇到下一个 <code>yield</code> 关键字，并生成 <code>i * 2</code> 的值。<code>i </code>等于 <code>10</code>，所以返回 <code>10 * 2</code>，即 <code>20</code>。这样就得到了 <code>10, 20</code> 的输出。</p></li><li><h3 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise.race方法"></a><code>Promise.race</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const firstPromise &#x3D; new Promise((res, rej) &#x3D;&gt; &#123;  setTimeout(res, 500, &#39;one&#39;);&#125;);const secondPromise &#x3D; new Promise((res, rej) &#x3D;&gt; &#123;  setTimeout(res, 100, &#39;two&#39;);&#125;);Promise.race([firstPromise, secondPromise]).then(res &#x3D;&gt; console.log(res));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;one&quot;</code></li><li>B: <code>&quot;two&quot;</code></li><li>C: <code>&quot;two&quot; &quot;one&quot;</code></li><li>D: <code>&quot;one&quot; &quot;two&quot;</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: B**<p>当我们将多个 Promise 传递给 <code>Promise.race</code> 方法时，它会解决（resolve）或拒绝（reject）第一个解决或拒绝的 Promise。对于 <code>setTimeout</code> 方法，我们传递了两个定时器：第一个 Promise（<code>firstPromise</code>）设置了 500 毫秒的定时器，而第二个 Promise（<code>secondPromise</code>）设置了 100 毫秒的定时器。这意味着第二个 Promise（<code>secondPromise</code>）会先解决，并带有值 <code>&#39;two&#39;</code>。此时，变量 <code>res</code> 持有值 <code>&#39;two&#39;</code>，并被输出。</p><p><strong>这个方法对于需要同时发起多个异步操作，并且只关心最快结果的情况非常有用。</strong></p></li><li><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let person &#x3D; &#123; name: &#39;Lydia&#39; &#125;;const members &#x3D; [person];person &#x3D; null;console.log(members);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>null</code></li><li>B: <code>[null]</code></li><li>C: <code>[&#123;&#125;]</code></li><li>D: <code>[&#123; name: &quot;Lydia&quot; &#125;]</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: D</strong></p><p>首先，我们声明一个变量<code>person</code>，并赋值为一个具有<code>name</code>属性的对象。</p><img src="68747470733a2f2f692e696d6775722e636f6d2f544d4c314d62532e706e67.png" alt="img" style="zoom:50%;" /><p>然后，我们声明一个名为<code>members</code>的变量。我们将该数组的第一个元素设置为<code>person</code>变量的值。当将对象相互赋值时，它们通过引用进行交互。当将一个变量的引用赋给另一个变量时，会复制该引用。（请注意，<strong>它们不具有相同的引用！</strong>）</p><img src="image-20230616140054327.png" alt="image-20230616140054327" style="zoom:50%;" /><p>然后，我们将变量<code>person</code>的值设置为<code>null</code>。</p><img src="68747470733a2f2f692e696d6775722e636f6d2f73596a63734d542e706e67.png" alt="img" style="zoom:50%;" /><p>我们只修改了<code>person</code>变量的值，而没有修改数组中的第一个元素，因为该元素具有与对象的不同（已复制的）引用。members数组中的第一个元素仍然保留对原始对象的引用。当我们记录（log）members数组时，第一个元素仍然保留着对象的值，并将其记录下来。</p></li><li><h3 id="对象循环"><a href="#对象循环" class="headerlink" title="对象循环"></a>对象循环</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;  name: &#39;Lydia&#39;,  age: 21,&#125;;for (const item in person) &#123;  console.log(item);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&#123; name: &quot;Lydia&quot; &#125;, &#123; age: 21 &#125;</code></li><li>B: <code>&quot;name&quot;, &quot;age&quot;</code></li><li>C: <code>&quot;Lydia&quot;, 21</code></li><li>D: <code>[&quot;name&quot;, &quot;Lydia&quot;], [&quot;age&quot;, 21]</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>使用<code>for-in</code>循环，我们可以迭代对象的键（在这种情况下为name和age）。在底层，对象的键是字符串（如果它们不是Symbol类型）。在每次循环中，我们将item的值设置为当前迭代的键。首先，item等于name，并进行记录。然后，item等于age，并进行记录。</p></li><li><h4 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h4><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(3 + 4 + &#39;5&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: <code>&quot;345&quot;</code></li><li>B: <code>&quot;75&quot;</code></li><li>C: <code>12</code></li><li>D: <code>&quot;12&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>运算符的结合性（associativity）是编译器按照左到右或右到左的顺序计算表达式的方式。这仅在所有运算符具有相同的优先级时才会发生。在这里，我们只有一种运算符：<code>+</code>。对于加法运算，其结合性是从左到右。</p><p>首先计算<code>3 + 4</code>，结果为数字<code>7</code>。</p><p>接着计算<code>7 + &#39;5&#39;</code>，结果为<code>&quot;75&quot;</code>，这是由于类型转换。JavaScript将数字<code>7</code>转换为字符串，参见问题15。我们可以使用<code>+</code>运算符来连接两个字符串。<code>&quot;7&quot; + &quot;5&quot;</code>的结果是<code>&quot;75&quot;</code>。</p></li><li><h3 id="parseInt方法"><a href="#parseInt方法" class="headerlink" title="parseInt方法"></a><code>parseInt</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const num &#x3D; parseInt(&#39;7*6&#39;, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: <code>42</code></li><li>B: <code>&quot;42&quot;</code></li><li>C: <code>7</code></li><li>D: <code>NaN</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: C**<p>只有字符串中的第一个数字被返回。基于基数（作为第二个参数，用于指定要将其解析为的数字类型：十进制、十六进制、八进制、二进制等），<code>parseInt</code>函数会检查字符串中的字符是否有效。一旦遇到在基数中无效的字符，它就会停止解析并忽略后面的字符。</p><p><code>*</code>不是一个有效的数字。它只解析<code>&quot;7&quot;</code>为十进制数<code>7</code>。现在，变量<code>num</code>的值为<code>7</code>。</p></li><li><h3 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a><code>map</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">[1, 2, 3].map(num &#x3D;&gt; &#123;  if (typeof num &#x3D;&#x3D;&#x3D; &#39;number&#39;) return;  return num * 2;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>[]</code></li><li>B: <code>[null, null, null]</code></li><li>C: <code>[undefined, undefined, undefined]</code></li><li>D: <code>[ 3 x empty ]</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>在对数组进行映射（mapping）时，变量num的值等于当前正在循环的元素。在这种情况下，元素是数字，因此if语句的条件typeof num &#x3D;&#x3D;&#x3D; “number”返回true。map函数创建一个新数组，并将从函数返回的值插入其中。</p><p>然而，我们没有返回一个值。<strong>当我们从函数中没有返回值时，函数将返回undefined</strong>。对于数组中的每个元素，函数块都会被调用，因此对于每个元素，我们都返回undefined。</p></li><li><h3 id="引用复制"><a href="#引用复制" class="headerlink" title="引用复制"></a>引用复制</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function getInfo(member, year) &#123;  member.name &#x3D; &#39;Lydia&#39;;  year &#x3D; &#39;1998&#39;;&#125;const person &#x3D; &#123; name: &#39;Sarah&#39; &#125;;const birthYear &#x3D; &#39;1997&#39;;getInfo(person, birthYear);console.log(person, birthYear);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&#123; name: &quot;Lydia&quot; &#125;, &quot;1997&quot;</code></li><li>B: <code>&#123; name: &quot;Sarah&quot; &#125;, &quot;1998&quot;</code></li><li>C: <code>&#123; name: &quot;Lydia&quot; &#125;, &quot;1998&quot;</code></li><li>D: <code>&#123; name: &quot;Sarah&quot; &#125;, &quot;1997&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>参数按值传递，除非其值是一个对象，那么它们将按引用传递。<code>birthYear</code>是一个字符串，而不是一个对象，所以它是按值传递的。当我们按值传递参数时，会创建该值的副本（参见问题46）。</p><p>变量<code>birthYear</code>引用的是值<code>&quot;1997&quot;</code>。参数<code>year</code>也引用了值<code>&quot;1997&quot;</code>，但它引用的值与<code>birthYear</code>引用的不是同一个。当我们通过将<code>year</code>设置为<code>&quot;1998&quot;</code>来更新<code>year</code>的值时，只是更新了<code>year</code>的值，<code>birthYear</code>仍然等于<code>&quot;1997&quot;</code>。</p><p><code>person</code>的值是一个对象。参数<code>member</code>复制了对同一对象的引用。当我们修改<code>member</code>引用的对象的属性时，<code>person</code>的值也会被修改，因为它们都引用同一个对象。<code>person</code>的<code>name</code>属性现在等于值<code>&quot;Lydia&quot;</code>。</p></li><li><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function greeting() &#123;  throw &#39;Hello world!&#39;;&#125;function sayHi() &#123;  try &#123;    const data &#x3D; greeting();    console.log(&#39;It worked!&#39;, data);  &#125; catch (e) &#123;    console.log(&#39;Oh no an error:&#39;, e);  &#125;&#125;sayHi();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>It worked! Hello world!</code></li><li>B: <code>Oh no an error: undefined</code></li><li>C: <code>SyntaxError: can only throw Error objects</code></li><li>D: <code>Oh no an error: Hello world!</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: D</strong></p><p>使用<code>throw</code>语句，我们可以创建自定义错误。通过该语句，您可以抛出异常。异常可以是字符串、数字、布尔值或对象。在这种情况下，我们的异常是字符串<code>&#39;Hello world!&#39;</code>。</p><p>使用<code>catch</code>语句，我们可以指定在<code>try</code>块中抛出异常时要执行的操作。一个异常被抛出：字符串<code>&#39;Hello world!&#39;</code>。现在，变量<code>e</code>的值等于该字符串，我们将其记录下来。结果是<code>&#39;Oh an error: Hello world!&#39;</code>。</p></li><li><h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Car() &#123;  this.make &#x3D; &#39;Lamborghini&#39;;  return &#123; make: &#39;Maserati&#39; &#125;;&#125;const myCar &#x3D; new Car();console.log(myCar.make);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;Lamborghini&quot;</code></li><li>B: <code>&quot;Maserati&quot;</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>当您返回一个属性时，该属性的值等于返回的值，而不是构造函数中设置的值。我们返回字符串<code>&quot;Maserati&quot;</code>，所以<code>myCar.make</code>等于<code>&quot;Maserati&quot;</code>。</p></li><li><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">(() &#x3D;&gt; &#123;  let x &#x3D; (y &#x3D; 10);&#125;)();console.log(typeof x);console.log(typeof y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;undefined&quot;, &quot;number&quot;</code></li><li>B: <code>&quot;number&quot;, &quot;number&quot;</code></li><li>C: <code>&quot;object&quot;, &quot;number&quot;</code></li><li>D: <code>&quot;number&quot;, &quot;undefined&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p><code>let x = (y = 10);</code> 实际上是以下代码的简写形式：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">y &#x3D; 10; let x &#x3D; y; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们将<code>y</code>设置为<code>10</code>时，实际上是向全局对象添加了一个属性<code>y</code>（在浏览器中是<code>window</code>对象，在Node中是<code>global</code>对象）。在浏览器中，<code>window.y</code>现在等于<code>10</code>。</p><p>然后，我们声明一个变量<code>x</code>，其值为<code>y</code>，即<code>10</code>。使用<code>let</code>关键字声明的变量是块级作用域的，它们只在声明它们的块中定义；在这种情况下是立即调用的函数表达式（IIFE）。当我们使用<code>typeof</code>运算符时，操作数<code>x</code>未定义：我们试图在声明它的块之外访问<code>x</code>。这意味着<code>x</code>未定义。尚未被赋值或声明的值的类型是<code>&quot;undefined&quot;</code>。<code>console.log(typeof x)</code>返回<code>&quot;undefined&quot;</code>。</p><p>然而，当我们将<code>y</code>设置为<code>10</code>时，我们创建了一个全局变量<code>y</code>。这个值可以在我们的代码的任何地方访问。<code>y</code>已经定义，并且具有<code>&quot;number&quot;</code>类型的值。<code>console.log(typeof y)</code>返回<code>&quot;number&quot;</code>。</p></li><li><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class Dog &#123;  constructor(name) &#123;    this.name &#x3D; name;  &#125;&#125;Dog.prototype.bark &#x3D; function() &#123;  console.log(&#96;Woof I am $&#123;this.name&#125;&#96;);&#125;;const pet &#x3D; new Dog(&#39;Mara&#39;);pet.bark();delete Dog.prototype.bark;pet.bark();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;Woof I am Mara&quot;</code>, <code>TypeError</code></li><li>B: <code>&quot;Woof I am Mara&quot;</code>, <code>&quot;Woof I am Mara&quot;</code></li><li>C: <code>&quot;Woof I am Mara&quot;</code>, <code>undefined</code></li><li>D: <code>TypeError</code>, <code>TypeError</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: A**<p>我们可以使用<code>delete</code>关键字从对象中删除属性，也可以从原型上删除属性。通过从原型上删除属性，该属性将不再在原型链中可用。在这种情况下，在删除了<code>Dog.prototype.bark</code>之后，<code>bark</code>函数在原型上不再可用，但我们仍然尝试访问它。</p><p>当我们试图调用不是函数的东西时，会抛出<code>TypeError</code>错误。在这种情况下，抛出的错误是<code>TypeError: pet.bark is not a function</code>，因为<code>pet.bark</code>是<code>undefined</code>。</p></li><li><h3 id="集合输出"><a href="#集合输出" class="headerlink" title="集合输出"></a>集合输出</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const set &#x3D; new Set([1, 1, 2, 3, 4]);console.log(set);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>[1, 1, 2, 3, 4]</code></li><li>B: <code>[1, 2, 3, 4]</code></li><li>C: <code>&#123;1, 1, 2, 3, 4&#125;</code></li><li>D: <code>&#123;1, 2, 3, 4&#125;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: D</strong></p><p><code>Set</code>对象是一个包含唯一值的集合：在一个集合中，一个值只能出现一次。</p><p>我们传递了可迭代对象<code>[1, 1, 2, 3, 4]</code>，其中有一个重复值<code>1</code>。由于在一个集合中不能有两个相同的值，其中一个被移除。结果是<code>&#123;1, 2, 3, 4&#125;</code>。</p></li><li><h3 id="模块导出与导入"><a href="#模块导出与导入" class="headerlink" title="模块导出与导入"></a>模块导出与导入</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; counter.jslet counter &#x3D; 10;export default counter;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; index.jsimport myCounter from &#39;.&#x2F;counter&#39;;myCounter +&#x3D; 1;console.log(myCounter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>10</code></li><li>B: <code>11</code></li><li>C: <code>Error</code></li><li>D: <code>NaN</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>导入的模块是只读的：你不能修改导入的模块。只有导出它们的模块可以改变它们的值。</p><p>当我们尝试增加<code>myCounter</code>的值时，会抛出一个错误：<code>myCounter</code>是只读的，不能被修改。</p></li><li><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const name &#x3D; &#39;Lydia&#39;;age &#x3D; 21;console.log(delete name);console.log(delete age);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>false</code>, <code>true</code></li><li>B: <code>&quot;Lydia&quot;</code>, <code>21</code></li><li>C: <code>true</code>, <code>true</code></li><li>D: <code>undefined</code>, <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p><code>delete</code>运算符返回一个布尔值：如果删除成功则返回<code>true</code>，否则返回<code>false</code>。然而，使用<code>var</code>、<code>const</code>或<code>let</code>关键字声明的变量无法使用<code>delete</code>运算符删除。</p><p><code>name</code>变量是使用<code>const</code>关键字声明的，所以删除操作不成功：返回<code>false</code>。当我们将<code>age</code>设置为<code>21</code>时，实际上是向全局对象添加了一个名为<code>age</code>的属性。你可以通过这种方式成功删除对象的属性，也可以删除全局对象，因此<code>delete age</code>返回<code>true</code>。</p></li><li><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const numbers &#x3D; [1, 2, 3, 4, 5];const [y] &#x3D; numbers;console.log(y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>[[1, 2, 3, 4, 5]]</code></li><li>B: <code>[1, 2, 3, 4, 5]</code></li><li>C: <code>1</code></li><li>D: <code>[1]</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>我们可以通过解构来从数组中解包值或从对象中解包属性。例如：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">[a, b] &#x3D; [1, 2];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在<code>a</code>的值是<code>1</code>，<code>b</code>的值是<code>2</code>。在问题中实际上我们做的是：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">[y] &#x3D; [1, 2, 3, 4, 5];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这意味着<code>y</code>的值等于数组中的第一个值，即数字<code>1</code>。当我们记录<code>y</code>时，返回的是<code>1</code>。</p></li><li><h3 id="展开运算符-1"><a href="#展开运算符-1" class="headerlink" title="展开运算符"></a>展开运算符</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const user &#x3D; &#123; name: &#39;Lydia&#39;, age: 21 &#125;;const admin &#x3D; &#123; admin: true, ...user &#125;;console.log(admin);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&#123; admin: true, user: &#123; name: &quot;Lydia&quot;, age: 21 &#125; &#125;</code></li><li>B: <code>&#123; admin: true, name: &quot;Lydia&quot;, age: 21 &#125;</code></li><li>C: <code>&#123; admin: true, user: [&quot;Lydia&quot;, 21] &#125;</code></li><li>D: <code>&#123; admin: true &#125;</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: B**<p>使用展开运算符（spread operator）<code>...</code>可以将对象进行合并。它可以创建一个对象的键&#x2F;值对的副本，并将其添加到另一个对象中。在这种情况下，我们创建了<code>user</code>对象的副本，并将其添加到<code>admin</code>对象中。<code>admin</code>对象现在包含了复制的键&#x2F;值对，结果为<code>&#123; admin: true, name: &quot;Lydia&quot;, age: 21 &#125;</code>。</p></li><li><h3 id="枚举对象"><a href="#枚举对象" class="headerlink" title="枚举对象"></a>枚举对象</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123; name: &#39;Lydia&#39; &#125;;Object.defineProperty(person, &#39;age&#39;, &#123; value: 21 &#125;);console.log(person);console.log(Object.keys(person));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code>, <code>[&quot;name&quot;, &quot;age&quot;]</code></li><li>B: <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code>, <code>[&quot;name&quot;]</code></li><li>C: <code>&#123; name: &quot;Lydia&quot;&#125;</code>, <code>[&quot;name&quot;, &quot;age&quot;]</code></li><li>D: <code>&#123; name: &quot;Lydia&quot;&#125;</code>, <code>[&quot;age&quot;]</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>使用<code>defineProperty</code>方法，我们可以向对象添加新属性或修改现有属性。当我们使用<code>defineProperty</code>方法向对象添加属性时，默认情况下它们是<strong>不可枚举</strong>的。<code>Object.keys</code>方法从对象中返回所有可枚举的属性名，本例中只有<code>&quot;name&quot;</code>。</p><p>使用<code>defineProperty</code>方法添加的属性默认是不可变的。您可以使用<code>writable</code>、<code>configurable</code>和<code>enumerable</code>属性来覆盖此行为。这样，<code>defineProperty</code>方法使您对要添加到对象中的属性具有更多控制权。</p></li><li><h3 id="stringify方法"><a href="#stringify方法" class="headerlink" title="stringify方法"></a><code>stringify</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const settings &#x3D; &#123;  username: &#39;lydiahallie&#39;,  level: 19,  health: 90,&#125;;const data &#x3D; JSON.stringify(settings, [&#39;level&#39;, &#39;health&#39;]);console.log(data);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;&#123;&quot;level&quot;:19, &quot;health&quot;:90&#125;&quot;</code></li><li>B: <code>&quot;&#123;&quot;username&quot;: &quot;lydiahallie&quot;&#125;&quot;</code></li><li>C: <code>&quot;[&quot;level&quot;, &quot;health&quot;]&quot;</code></li><li>D: <code>&quot;&#123;&quot;username&quot;: &quot;lydiahallie&quot;, &quot;level&quot;:19, &quot;health&quot;:90&#125;&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p><code>JSON.stringify</code>的第二个参数是<em>replacer</em>。<em>replacer</em>可以是一个函数或一个数组，它允许您控制值的字符串化方式和内容。</p><p>如果replacer是一个<em>array</em>，只有数组中包含的属性名将被添加到JSON字符串中。在这种情况下，只有名为<code>&quot;level&quot;</code>和<code>&quot;health&quot;</code>的属性被包含在内，<code>&quot;username&quot;</code>被排除在外。<code>data</code>现在等于<code>&quot;&#123; &quot;level&quot;: 19, &quot;health&quot;: 90 &#125;&quot;</code>。</p><p>如果replacer是一个函数，该函数将在您对对象进行字符串化时调用。从该函数返回的值将成为将属性添加到JSON字符串时的属性值。如果值为<code>undefined</code>，则该属性将被排除在JSON字符串之外。</p></li><li><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let num &#x3D; 10;const increaseNumber &#x3D; () &#x3D;&gt; num++;const increasePassedNumber &#x3D; number &#x3D;&gt; number++;const num1 &#x3D; increaseNumber();const num2 &#x3D; increasePassedNumber(num1);console.log(num1);console.log(num2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>10</code>, <code>10</code></li><li>B: <code>10</code>, <code>11</code></li><li>C: <code>11</code>, <code>11</code></li><li>D: <code>11</code>, <code>12</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: A**<p>一元运算符<code>++</code>首先返回操作数的值，然后递增操作数的值。<code>num1</code>的值是<code>10</code>，因为<code>increaseNumber</code>函数首先返回<code>num</code>的值，即<code>10</code>，然后才递增<code>num</code>的值。</p><p><code>num2</code>的值是<code>10</code>，因为我们将<code>num1</code>传递给了<code>increasePassedNumber</code>函数。<code>number</code>等于<code>10</code>（即<code>num1</code>的值）。同样，一元运算符<code>++</code>首先返回操作数的值，然后递增操作数的值。<code>number</code>的值是<code>10</code>，所以<code>num2</code>等于<code>10</code>。</p></li><li><h3 id="ES6参数传递"><a href="#ES6参数传递" class="headerlink" title="ES6参数传递"></a>ES6参数传递</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const value &#x3D; &#123; number: 10 &#125;;const multiply &#x3D; (x &#x3D; &#123; ...value &#125;) &#x3D;&gt; &#123;  console.log((x.number *&#x3D; 2));&#125;;multiply();multiply();multiply(value);multiply(value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>20</code>, <code>40</code>, <code>80</code>, <code>160</code></li><li>B: <code>20</code>, <code>40</code>, <code>20</code>, <code>40</code></li><li>C: <code>20</code>, <code>20</code>, <code>20</code>, <code>40</code></li><li>D: <code>NaN</code>, <code>NaN</code>, <code>20</code>, <code>40</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: C**<p>在ES6中，我们可以使用默认值初始化参数。如果没有将其他值传递给函数，或者参数的值为<code>&quot;undefined&quot;</code>，则参数的值将是默认值。在这种情况下，我们将<code>value</code>对象的属性展开到一个新对象中，因此<code>x</code>具有默认值<code>&#123; number: 10 &#125;</code>。</p><p>默认参数是在调用时计算的！每次调用函数时，都会创建一个新对象。我们前两次调用<code>multiply</code>函数时都没有传递值：<code>x</code>具有默认值<code>&#123; number: 10 &#125;</code>。然后，我们记录该数字的乘积值，即<code>20</code>。</p><p>第三次调用<code>multiply</code>时，我们传递了一个参数：名为<code>value</code>的对象。<code>*=</code>运算符实际上是<code>x.number = x.number * 2</code>的简写：我们修改了<code>x.number</code>的值，并记录了乘以后的值<code>20</code>。</p><p>第四次调用时，我们再次传递<code>value</code>对象。<code>x.number</code>先前已经修改为<code>20</code>，所以<code>x.number = 2</code>记录了<code>40</code>。</p></li><li><h3 id="reduce方法-1"><a href="#reduce方法-1" class="headerlink" title="reduce方法"></a><code>reduce</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">[1, 2, 3, 4].reduce((x, y) &#x3D;&gt; console.log(x, y));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: <code>1</code> <code>2</code> and <code>3</code> <code>3</code> and <code>6</code> <code>4</code></li><li>B: <code>1</code> <code>2</code> and <code>2</code> <code>3</code> and <code>3</code> <code>4</code></li><li>C: <code>1</code> <code>undefined</code> and <code>2</code> <code>undefined</code> and <code>3</code> <code>undefined</code> and <code>4</code> <code>undefined</code></li><li>D: <code>1</code> <code>2</code> and <code>undefined</code> <code>3</code> and <code>undefined</code> <code>4</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: D**<p><code>reduce</code>方法接收的第一个参数是累加器，本例中为<code>x</code>。第二个参数是当前值，为<code>y</code>。使用<code>reduce</code>方法，我们在数组中的每个元素上执行一个回调函数，最终可能会得到一个单一的值。</p><p>在这个例子中，我们并没有返回任何值，只是记录了累加器和当前值的值。</p><p>累加器的值等于回调函数先前返回的值。如果您没有将可选的<code>initialValue</code>参数传递给<code>reduce</code>方法，<strong>第一次调用</strong>时累加器等于第一个元素。</p><p>在第一次调用时，累加器（<code>x</code>）为<code>1</code>，当前值（<code>y</code>）为<code>2</code>。我们没有从回调函数返回值，而是记录了累加器和当前值：输出为<code>1</code>和<code>2</code>。</p><p>如果您没有从函数中返回值，它将返回<code>undefined</code>。在下一次调用时，累加器为<code>undefined</code>，当前值为<code>3</code>。输出为<code>undefined</code>和<code>3</code>。</p><p>在第四次调用时，我们再次没有从回调函数返回值。累加器再次为<code>undefined</code>，当前值为<code>4</code>。输出为<code>undefined</code>和<code>4</code>。</p></li><li><h3 id="使用哪个构造函数可以成功继承Dog类？"><a href="#使用哪个构造函数可以成功继承Dog类？" class="headerlink" title="使用哪个构造函数可以成功继承Dog类？"></a>使用哪个构造函数可以成功继承<code>Dog</code>类？</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">class Dog &#123;  constructor(name) &#123;    this.name &#x3D; name;  &#125;&#125;;class Labrador extends Dog &#123;  &#x2F;&#x2F; 1   constructor(name, size) &#123;    this.size &#x3D; size;  &#125;  &#x2F;&#x2F; 2  constructor(name, size) &#123;    super(name);    this.size &#x3D; size;  &#125;  &#x2F;&#x2F; 3  constructor(size) &#123;    super(name);    this.size &#x3D; size;  &#125;  &#x2F;&#x2F; 4   constructor(name, size) &#123;    this.name &#x3D; name;    this.size &#x3D; size;  &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: 1</li><li>B: 2</li><li>C: 3</li><li>D: 4</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>在子类中，在调用<code>super</code>之前不能访问到<code>this</code>关键字。 如果这样做，它将抛出一个<code>ReferenceError</code>：1 和 4 将引发一个引用错误。</p><p>使用<code>super</code>关键字，需要用给定的参数来调用父类的构造函数。 父类的构造函数接收<code>name</code>参数，因此我们需要将<code>name</code>传递给<code>super</code>。</p><p><code>Labrador</code>类接收两个参数，<code>name</code>参数是由于它继承了<code>Dog</code>，<code>size</code>作为<code>Labrador</code>类的额外属性，它们都需要传递给<code>Labrador</code>的构造函数，因此使用构造函数 2 正确完成。</p></li><li><h3 id="模块引入"><a href="#模块引入" class="headerlink" title="模块引入"></a>模块引入</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; index.jsconsole.log(&#39;running index.js&#39;);import &#123; sum &#125; from &#39;.&#x2F;sum.js&#39;;console.log(sum(1, 2));&#x2F;&#x2F; sum.jsconsole.log(&#39;running sum.js&#39;);export const sum &#x3D; (a, b) &#x3D;&gt; a + b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>running index.js</code>, <code>running sum.js</code>, <code>3</code></li><li>B: <code>running sum.js</code>, <code>running index.js</code>, <code>3</code></li><li>C: <code>running sum.js</code>, <code>3</code>, <code>running index.js</code></li><li>D: <code>running index.js</code>, <code>undefined</code>, <code>running sum.js</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p><code>import</code>命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。</p><p>这是 CommonJS 中<code>require()</code>和<code>import</code>之间的区别。使用<code>require()</code>，您可以在运行代码时根据需要加载依赖项。 如果我们使用<code>require</code>而不是<code>import</code>，<code>running index.js</code>，<code>running sum.js</code>，<code>3</code>会被依次打印。</p></li><li><h3 id="类型判断-2"><a href="#类型判断-2" class="headerlink" title="类型判断"></a>类型判断</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(Number(2) &#x3D;&#x3D;&#x3D; Number(2))console.log(Boolean(false) &#x3D;&#x3D;&#x3D; Boolean(false))console.log(Symbol(&#39;foo&#39;) &#x3D;&#x3D;&#x3D; Symbol(&#39;foo&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>true</code>, <code>true</code>, <code>false</code></li><li>B: <code>false</code>, <code>true</code>, <code>false</code></li><li>C: <code>true</code>, <code>false</code>, <code>true</code></li><li>D: <code>true</code>, <code>true</code>, <code>true</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>每个<code>Symbol</code>都是完全唯一的。传递给<code>Symbol</code>的参数只是给<code>Symbol</code>的一个描述。 <code>Symbol</code>的值不依赖于传递的参数。 当我们测试相等时，我们创建了两个全新的符号：第一个<code>Symbol（&#39;foo&#39;）</code>，第二个<code>Symbol（&#39;foo&#39;）</code>，这两个值是唯一的，彼此不相等，因此返回<code>false</code>。</p></li><li><h3 id="padStart方法"><a href="#padStart方法" class="headerlink" title="padStart方法"></a><code>padStart</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const name &#x3D; &quot;Lydia Hallie&quot;console.log(name.padStart(13))console.log(name.padStart(2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;Lydia Hallie&quot;</code>, <code>&quot;Lydia Hallie&quot;</code></li><li>B: <code>&quot;           Lydia Hallie&quot;</code>, <code>&quot;  Lydia Hallie&quot;</code> (<code>&quot;[13x whitespace]Lydia Hallie&quot;</code>, <code>&quot;[2x whitespace]Lydia Hallie&quot;</code>)</li><li>C: <code>&quot; Lydia Hallie&quot;</code>, <code>&quot;Lydia Hallie&quot;</code> (<code>&quot;[1x whitespace]Lydia Hallie&quot;</code>, <code>&quot;Lydia Hallie&quot;</code>)</li><li>D: <code>&quot;Lydia Hallie&quot;</code>, <code>&quot;Lyd&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>使用<code>padStart</code>方法，我们可以在字符串的开头添加填充。传递给此方法的参数是字符串的总长度（包含填充）。字符串<code>Lydia Hallie</code>的长度为<code>12</code>，因此<code>name.padStart（13）</code>在字符串的开头只会插入 1（<code>13 - 12 = 1</code>）个空格。</p><p>如果传递给<code>padStart</code>方法的参数小于字符串的长度，则不会添加填充。</p></li><li><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(&quot;🥑&quot; + &quot;💻&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: <code>&quot;🥑💻&quot;</code></li><li>B: <code>257548</code></li><li>C: A string containing their code points</li><li>D: Error</li></ul><details><summary><b>Answer</b></summary><p>**Answer: A**<p>使用<code>+</code>运算符，您可以连接字符串。 上述情况，我们将字符串<code>&quot;🥑&quot;</code>与字符串<code>&quot;💻&quot;</code>连接起来，产生<code>&quot;🥑💻&quot;</code>。</p></li><li><h3 id="生成器函数-1"><a href="#生成器函数-1" class="headerlink" title="生成器函数"></a>生成器函数</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function* startGame() &#123;  const 答案 &#x3D; yield &quot;Do you love JavaScript?&quot;;  if (答案 !&#x3D;&#x3D; &quot;Yes&quot;) &#123;    return &quot;Oh wow... Guess we&#39;re gone here&quot;;  &#125;  return &quot;JavaScript loves you back ❤️&quot;;&#125;const game &#x3D; startGame();console.log(&#x2F;* 1 *&#x2F;); &#x2F;&#x2F; Do you love JavaScript?console.log(&#x2F;* 2 *&#x2F;); &#x2F;&#x2F; JavaScript loves you back ❤️<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>game.next(&quot;Yes&quot;).value</code> and <code>game.next().value</code></li><li>B: <code>game.next.value(&quot;Yes&quot;)</code> and <code>game.next.value()</code></li><li>C: <code>game.next().value</code> and <code>game.next(&quot;Yes&quot;).value</code></li><li>D: <code>game.next.value()</code> and <code>game.next.value(&quot;Yes&quot;)</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p><code>generator</code>函数在遇到<code>yield</code>关键字时会 “暂停” 其执行。 首先，我们需要让函数产生字符串<code>Do you love JavaScript?</code>，这可以通过调用<code>game.next().value</code>来完成。上述函数的第一行就有一个<code>yield</code>关键字，那么运行立即停止了，<code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>，这意味着此时变量 <code>答案</code> 为<code>undefined</code>。</p><p><code>next</code>方法可以带一个参数，该参数会被当作上一个 <code>yield</code> 表达式的返回值。当我们调用<code>game.next(&quot;Yes&quot;).value</code>时，先前的 <code>yield</code> 的返回值将被替换为传递给<code>next()</code>函数的参数<code>&quot;Yes&quot;</code>。此时变量 <code>答案</code> 被赋值为 <code>&quot;Yes&quot;</code>，<code>if</code>语句返回<code>false</code>，所以<code>JavaScript loves you back ❤️</code>被打印。</p></li><li><h3 id="String-raw方法"><a href="#String-raw方法" class="headerlink" title="String.raw方法"></a><code>String.raw</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">console.log(String.raw&#96;Hello\nworld&#96;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>A: <code>Hello world!</code></li><li>B: <code>Hello</code><br>   <code>world</code></li><li>C: <code>Hello\nworld</code></li><li>D: <code>Hello\n</code><br>   <code>world</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p><code>String.raw</code>函数是用来获取一个模板字符串的原始字符串的，它返回一个字符串，其中忽略了转义符（<code>\n</code>，<code>\v</code>，<code>\t</code>等）。但反斜杠可能造成问题，因为你可能会遇到下面这种类似情况：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const path &#x3D; &#96;C:\Documents\Projects\table.html&#96;String.raw&#96;$&#123;path&#125;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这将导致：</p><p><code>&quot;C:DocumentsProjects able.html&quot;</code></p><p>直接使用<code>String.raw</code></p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">String.raw&#96;C:\Documents\Projects\table.html&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会忽略转义字符并打印：<code>C:\Documents\Projects\table.html</code></p><p>上述情况，字符串是<code>Hello\nworld</code>被打印出。</p></li><li><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">async function getData() &#123;  return await Promise.resolve(&quot;I made it!&quot;);&#125;const data &#x3D; getData();console.log(data);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;I made it!&quot;</code></li><li>B: <code>Promise &#123;&lt;resolved&gt;: &quot;I made it!&quot;&#125;</code></li><li>C: <code>Promise &#123;&lt;pending&gt;&#125;</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p>异步函数始终返回一个 promise。<code>await</code>仍然需要等待 promise 的解决：当我们调用<code>getData()</code>并将其赋值给<code>data</code>，此时<code>data</code>为<code>getData</code>方法返回的一个挂起的 promise，该 promise 并没有解决。</p><p>如果我们想要访问已解决的值<code>&quot;I made it!&quot;</code>，可以在<code>data</code>上使用<code>.then()</code>方法：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">data.then(res &#x3D;&gt; console.log(res))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样将打印 <code>&quot;I made it!&quot;</code></p></li><li><h3 id="list-push方法"><a href="#list-push方法" class="headerlink" title="list.push方法"></a><code>list.push</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function addToList(item, list) &#123;  return list.push(item);&#125;const result &#x3D; addToList(&quot;apple&quot;, [&quot;banana&quot;]);console.log(result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>[&#39;apple&#39;, &#39;banana&#39;]</code></li><li>B: <code>2</code></li><li>C: <code>true</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p><code>push()</code>方法返回新数组的长度。一开始，数组包含一个元素（字符串<code>&quot;banana&quot;</code>），长度为 1。 在数组中添加字符串<code>&quot;apple&quot;</code>后，长度变为 2，并将从<code>addToList</code>函数返回。</p><p><code>push</code>方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在 push <code>item</code>之后返回<code>list</code>。</p></li><li><h3 id="Object-freeze方法"><a href="#Object-freeze方法" class="headerlink" title="Object.freeze方法"></a><code>Object.freeze</code>方法</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const box &#x3D; &#123; x: 10, y: 20 &#125;;Object.freeze(box);const shape &#x3D; box;shape.x &#x3D; 100;console.log(shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&#123; x: 100, y: 20 &#125;</code></li><li>B: <code>&#123; x: 10, y: 20 &#125;</code></li><li>C: <code>&#123; x: 100 &#125;</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: B**<p><code>Object.freeze</code>使得无法添加、删除或修改对象的属性（除非属性的值是另一个对象）。</p><p>当我们创建变量<code>shape</code>并将其设置为等于冻结对象<code>box</code>时，<code>shape</code>指向的也是冻结对象。你可以使用<code>Object.isFrozen</code>检查一个对象是否被冻结，上述情况，<code>Object.isFrozen(shape)</code>将返回<code>true</code>。</p><p>由于<code>shape</code>被冻结，并且<code>x</code>的值不是对象，所以我们不能修改属性<code>x</code>。 <code>x</code>仍然等于<code>10</code>，<code>&#123;x：10，y：20&#125;</code>被打印。</p><p>注意，上述例子我们对属性<code>x</code>进行修改，可能会导致抛出 TypeError 异常（最常见但不仅限于严格模式下时）。</p></li><li><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const &#123; name: myName &#125; &#x3D; &#123; name: &quot;Lydia&quot; &#125;;console.log(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;Lydia&quot;</code></li><li>B: <code>&quot;myName&quot;</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: D</strong></p><p>当我们从右侧的对象解构属性<code>name</code>时，我们将其值<code>Lydia</code>分配给名为<code>myName</code>的变量。</p><p>使用<code>&#123;name：myName&#125;</code>，我们是在告诉 JavaScript 我们要创建一个名为<code>myName</code>的新变量，并且其值是右侧对象的<code>name</code>属性的值。</p><p>当我们尝试打印<code>name</code>，一个未定义的变量时，就会引发<code>ReferenceError</code>。</p></li><li><h3 id="纯函数判断"><a href="#纯函数判断" class="headerlink" title="纯函数判断"></a>纯函数判断</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function sum(a, b) &#123;  return a + b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: Yes</li><li>B: No</li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>纯函数在相同的输入值时，需产生相同的输出，其输出的结果，与输入值以外的其他隐藏信息或状态无关，也和由 I&#x2F;O 设备产生的外部输出无关。 纯函数不会产生副作用。</p><p>纯函数与副作用的定义可参考： <a href="https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)</a></p></li><li><h3 id="记忆函数"><a href="#记忆函数" class="headerlink" title="记忆函数"></a>记忆函数</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const add &#x3D; () &#x3D;&gt; &#123;  const cache &#x3D; &#123;&#125;;  return num &#x3D;&gt; &#123;    if (num in cache) &#123;      return &#96;From cache! $&#123;cache[num]&#125;&#96;;    &#125; else &#123;      const result &#x3D; num + 10;      cache[num] &#x3D; result;      return &#96;Calculated! $&#123;result&#125;&#96;;    &#125;  &#125;;&#125;;const addFunction &#x3D; add();console.log(addFunction(10));console.log(addFunction(10));console.log(addFunction(5 * 2));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>Calculated! 20</code> <code>Calculated! 20</code> <code>Calculated! 20</code></li><li>B: <code>Calculated! 20</code> <code>From cache! 20</code> <code>Calculated! 20</code></li><li>C: <code>Calculated! 20</code> <code>From cache! 20</code> <code>From cache! 20</code></li><li>D: <code>Calculated! 20</code> <code>From cache! 20</code> <code>Error</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p><code>add</code>函数是一个记忆函数。 通过记忆化，我们可以缓存函数的结果，以加快其执行速度。上述情况，我们创建一个<code>cache</code>对象，用于存储先前返回过的值。</p><p>如果我们使用相同的参数多次调用<code>addFunction</code>函数，它首先检查缓存中是否已有该值，如果有，则返回缓存值，这将节省执行时间。如果没有，那么它将计算该值，并存储在缓存中。</p><p>我们用相同的值三次调用了<code>addFunction</code>函数：</p><p>在第一次调用，<code>num</code>等于<code>10</code>时函数的值尚未缓存，if 语句<code>num in cache</code>返回<code>false</code>，else 块的代码被执行：<code>Calculated! 20</code>，并且其结果被添加到缓存对象，<code>cache</code>现在看起来像<code>&#123;10：20&#125;</code>。</p><p>第二次，<code>cache</code>对象包含<code>10</code>的返回值。 if 语句 <code>num in cache</code> 返回<code>true</code>，<code>From cache! 20</code>被打印。</p><p>第三次，我们将<code>5 * 2</code>(值为 10) 传递给函数。 <code>cache</code>对象包含<code>10</code>的返回值。 if 语句 <code>num in cache</code> 返回<code>true</code>，<code>From cache! 20</code>被打印。</p></li><li><h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const myLifeSummedUp &#x3D; [&quot;☕&quot;, &quot;💻&quot;, &quot;🍷&quot;, &quot;🍫&quot;]for (let item in myLifeSummedUp) &#123;  console.log(item)&#125;for (let item of myLifeSummedUp) &#123;  console.log(item)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>0</code> <code>1</code> <code>2</code> <code>3</code> and <code>&quot;☕&quot;</code> <code> &quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code></li><li>B: <code>&quot;☕&quot;</code> <code> &quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code> and <code>&quot;☕&quot;</code> <code> &quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code></li><li>C: <code>&quot;☕&quot;</code> <code> &quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code> and <code>0</code> <code>1</code> <code>2</code> <code>3</code></li><li>D: <code>0</code> <code>1</code> <code>2</code> <code>3</code> and <code>&#123;0: &quot;☕&quot;, 1: &quot;💻&quot;, 2: &quot;🍷&quot;, 3: &quot;🍫&quot;&#125;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>通过<code>for-in</code>循环，我们可以遍历一个对象<strong>自有的</strong>、<strong>继承的</strong>、<strong>可枚举的</strong>、<strong>非 Symbol 的</strong>属性。 在数组中，可枚举属性是数组元素的 “键”， 即它们的索引。 类似于下面这个对象：</p><p><code>&#123;0: &quot;☕&quot;, 1: &quot;💻&quot;, 2: &quot;🍷&quot;, 3: &quot;🍫&quot;&#125;</code></p><p>其中键则是可枚举属性，因此 <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>被记录。</p><p>通过<code>for-of</code>循环，我们可以迭代<strong>可迭代对象</strong>（包括 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>arguments</code>等）。当我们迭代数组时，在每次迭代中，不同属性的值将被分配给变量<code>item</code>，因此<code>“☕”</code>，<code>“💻”</code>，<code>“🍷”</code>，<code>“🍫”</code>被打印。</p></li><li><h3 id="数组元素"><a href="#数组元素" class="headerlink" title="数组元素"></a>数组元素</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const list &#x3D; [1 + 2, 1 * 2, 1 &#x2F; 2]console.log(list)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>A: <code>[&quot;1 + 2&quot;, &quot;1 * 2&quot;, &quot;1 / 2&quot;]</code></li><li>B: <code>[&quot;12&quot;, 2, 0.5]</code></li><li>C: <code>[3, 2, 0.5]</code></li><li>D: <code>[1, 1, 1]</code></li></ul><details><summary><b>Answer</b></summary><p>**Answer: C**<p>数组元素可以包含任何值。 数字，字符串，布尔值，对象，数组，<code>null</code>，<code>undeifned</code>，以及其他表达式，如日期，函数和计算。</p><p>元素将等于返回的值。 <code>1 + 2</code>返回<code>3</code>，<code>1 * 2</code>返回<code>2</code>，<code>1 / 2</code>返回<code>0.5</code>。</p></li><li><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function sayHi(name) &#123;  return &#96;Hi there, $&#123;name&#125;&#96;&#125;console.log(sayHi())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>Hi there, </code></li><li>B: <code>Hi there, undefined</code></li><li>C: <code>Hi there, null</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>默认情况下，如果不给函数传参，参数的值将为<code>undefined</code>。 上述情况，我们没有给参数<code>name</code>传值。 <code>name</code>等于<code>undefined</code>，并被打印。</p><p>在 ES6 中，我们可以使用默认参数覆盖此默认的<code>undefined</code>值。 例如：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function sayHi(name &#x3D; &#39;Lydia&#39;)&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，如果我们没有传递值或者如果我们传递<code>undefined</code>，<code>name</code>总是等于字符串<code>Lydia</code></p></li><li><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a><code>this</code>指向</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var status &#x3D; &quot;😎&quot;setTimeout(() &#x3D;&gt; &#123;  const status &#x3D; &quot;😍&quot;  const data &#x3D; &#123;    status: &quot;🥑&quot;,    getStatus() &#123;      return this.status    &#125;  &#125;  console.log(data.getStatus())  console.log(data.getStatus.call(this))&#125;, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;🥑&quot;</code> and <code>&quot;😍&quot;</code></li><li>B: <code>&quot;🥑&quot;</code> and <code>&quot;😎&quot;</code></li><li>C: <code>&quot;😍&quot;</code> and <code>&quot;😎&quot;</code></li><li>D: <code>&quot;😎&quot;</code> and <code>&quot;😎&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p><code>this</code>关键字的指向取决于使用它的位置。 在<strong>函数</strong>中，比如<code>getStatus</code>，<code>this</code>指向的是调用它的对象，上述例子中<code>data</code>对象调用了<code>getStatus</code>，因此<code>this</code>指向的就是<code>data</code>对象。 当我们打印<code>this.status</code>时，<code>data</code>对象的<code>status</code>属性被打印，即<code>&quot;🥑&quot;</code>。</p><p>使用<code>call</code>方法，可以更改<code>this</code>指向的对象。<code>data.getStatus.call(this)</code>是将<code>this</code>的指向由<code>data</code>对象更改为全局对象。在全局对象上，有一个名为<code>status</code>的变量，其值为<code>”😎“</code>。 因此打印<code>this.status</code>时，会打印<code>“😎”</code>。</p></li><li><h3 id="对象引用-1"><a href="#对象引用-1" class="headerlink" title="对象引用"></a>对象引用</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;  name: &quot;Lydia&quot;,  age: 21&#125;let city &#x3D; person.citycity &#x3D; &quot;Amsterdam&quot;console.log(person)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code></li><li>B: <code>&#123; name: &quot;Lydia&quot;, age: 21, city: &quot;Amsterdam&quot; &#125;</code></li><li>C: <code>&#123; name: &quot;Lydia&quot;, age: 21, city: undefined &#125;</code></li><li>D: <code>&quot;Amsterdam&quot;</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: A</strong></p><p>我们将变量<code>city</code>设置为等于<code>person</code>对象上名为<code>city</code>的属性的值。 这个对象上没有名为<code>city</code>的属性，因此变量<code>city</code>的值为<code>undefined</code>。</p><p>请注意，我们没有引用<code>person</code>对象本身，只是将变量<code>city</code>设置为等于<code>person</code>对象上<code>city</code>属性的当前值。</p><p>然后，我们将<code>city</code>设置为等于字符串<code>“Amsterdam”</code>。 这不会更改 person 对象：<strong>没有对该对象的引用</strong>。</p><p>因此打印<code>person</code>对象时，会返回未修改的对象。</p></li><li><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function checkAge(age) &#123;  if (age &lt; 18) &#123;    const message &#x3D; &quot;Sorry, you&#39;re too young.&quot;  &#125; else &#123;    const message &#x3D; &quot;Yay! You&#39;re old enough!&quot;  &#125;  return message&#125;console.log(checkAge(21))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>&quot;Sorry, you&#39;re too young.&quot;</code></li><li>B: <code>&quot;Yay! You&#39;re old enough!&quot;</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: C</strong></p><p><code>const</code>和<code>let</code>声明的变量是具有<strong>块级作用域</strong>的，块是大括号（<code>&#123;&#125;</code>）之间的任何东西，即上述情况<code>if / else</code>语句的花括号。 由于块级作用域，我们无法在声明的块之外引用变量，因此抛出<code>ReferenceError</code>。</p></li><li><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fetch(&#39;https:&#x2F;&#x2F;www.website.com&#x2F;api&#x2F;user&#x2F;1&#39;)  .then(res &#x3D;&gt; res.json())  .then(res &#x3D;&gt; console.log(res))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>A: <code>fetch</code>方法的结果</li><li>B: 第二次调用<code>fetch</code>方法的结果</li><li>C: 前一个<code>.then()</code>中回调方法返回的结果</li><li>D: 总是<code>undefined</code></li></ul><details><summary><b>Answer</b></summary><p><p><strong>Answer: B</strong></p><p>第二个<code>.then</code>中<code>res</code>的值等于前一个<code>.then</code>中的回调函数返回的值。 你可以像这样继续链接<code>.then</code>，将值传递给下一个处理程序。</p></li><li><p>ds</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试汇总</title>
      <link href="/2023/05/09/qian-duan-mian-shi-hui-zong/"/>
      <url>/2023/05/09/qian-duan-mian-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h2><h3 id="在制作一个网页应用或网站的过程中，你是如何考虑其-UI、安全性、高性能、SEO、可维护性以及技术因素的？"><a href="#在制作一个网页应用或网站的过程中，你是如何考虑其-UI、安全性、高性能、SEO、可维护性以及技术因素的？" class="headerlink" title="在制作一个网页应用或网站的过程中，你是如何考虑其 UI、安全性、高性能、SEO、可维护性以及技术因素的？"></a><strong>在制作一个网页应用或网站的过程中，你是如何考虑其 UI、安全性、高性能、SEO、可维护性以及技术因素的？</strong></h3><p>在制作一个网页应用或网站的过程中，我会考虑以下几个方面：</p><ol><li>UI设计：我会根据网站或应用的定位和目标用户来设计UI，使其简洁、易用、美观、符合用户习惯，并且能够提高用户体验。</li><li>安全性：我会考虑如何保护用户的隐私和数据安全，采用安全的编程技术和框架，防止SQL注入、XSS攻击等安全问题。</li><li>高性能：我会优化网站或应用的性能，减少页面加载时间，提高响应速度，采用缓存技术、CDN加速等手段来提高性能。</li><li>SEO：我会考虑如何优化网站或应用的SEO，采用合适的关键词、网站结构、页面标题、描述等手段来提高搜索引擎排名。</li><li>可维护性：我会采用模块化、可重用的代码设计，注重代码的可读性和可维护性，使得代码易于维护和扩展。</li><li>技术因素：我会根据项目需求和技术选型来选择合适的技术栈，如前端框架、后端语言、数据库等，以及采用最新的技术和工具来提高开发效率和质量。</li></ol><h3 id="假若你有-5-个不同的样式文件-stylesheets-整合进网站的最好方式是"><a href="#假若你有-5-个不同的样式文件-stylesheets-整合进网站的最好方式是" class="headerlink" title="假若你有 5 个不同的样式文件 (stylesheets), 整合进网站的最好方式是?"></a><strong>假若你有 5 个不同的样式文件 (stylesheets), 整合进网站的最好方式是?</strong></h3><p>整合五个不同的样式文件最好的方式是将它们合并成一个单独的样式文件，以减少页面加载时间和HTTP请求次数。可以使用CSS预处理器如Sass或Less来管理和组织样式文件，以便更好地维护和扩展。另外，可以使用压缩工具如CSSMin或YUI Compressor来压缩样式文件，以减小文件大小，提高页面加载速度。</p><h3 id="你能描述渐进增强-progressive-enhancement-和优雅降级-graceful-degradation-之间的不同吗"><a href="#你能描述渐进增强-progressive-enhancement-和优雅降级-graceful-degradation-之间的不同吗" class="headerlink" title="你能描述渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 之间的不同吗?"></a><strong>你能描述渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 之间的不同吗?</strong></h3><p>渐进增强是指在设计和开发网站或应用时，先考虑基本功能和核心内容，然后逐步添加更高级的功能和特性，以适应不同的设备和浏览器。这种方法强调的是向前兼容性，即确保网站或应用在旧版浏览器上也能正常运行，同时提供更好的用户体验和更多的功能。</p><p>优雅降级则是指在设计和开发网站或应用时，先考虑高级功能和特性，然后逐步降低要求，以适应旧版浏览器和设备。这种方法强调的是向后兼容性，即确保网站或应用在旧版浏览器上也能正常运行，但可能会牺牲一些高级功能和用户体验。</p><p>总的来说，渐进增强和优雅降级都是为了提高网站或应用的兼容性和用户体验，但它们的思路和方法不同。渐进增强更注重向前兼容性和逐步增强功能，而优雅降级更注重向后兼容性和逐步降低要求。</p><h3 id="你如何对网站的文件和资源进行优化？"><a href="#你如何对网站的文件和资源进行优化？" class="headerlink" title="你如何对网站的文件和资源进行优化？"></a><strong>你如何对网站的文件和资源进行优化？</strong></h3><p>对网站的文件和资源进行优化可以从以下几个方面入手：</p><ol><li>压缩文件：可以使用压缩工具如Gzip来压缩HTML、CSS、JavaScript等文件，以减小文件大小，提高页面加载速度。</li><li>合并文件：可以将多个CSS或JavaScript文件合并成一个单独的文件，以减少HTTP请求次数，提高页面加载速度。</li><li>使用CDN：可以使用CDN（内容分发网络）来加速静态资源的加载，如图片、CSS、JavaScript等文件，以提高页面加载速度。</li><li>图片优化：可以使用图片压缩工具如TinyPNG来压缩图片大小，以减小文件大小，提高页面加载速度。</li><li>延迟加载：可以将页面中不必要的资源延迟加载，如图片、视频等，以减少页面加载时间，提高用户体验。</li><li>缓存控制：可以使用缓存控制技术如ETag、Expires、Cache-Control等来控制浏览器缓存，以减少HTTP请求次数，提高页面加载速度。</li><li>代码优化：可以优化HTML、CSS、JavaScript等代码，如删除不必要的空格、注释、重复代码等，以减小文件大小，提高页面加载速度。</li><li>DNS预解析：可以使用DNS预解析技术来预先解析页面中的域名，以减少DNS查询时间，提高页面加载速度。</li></ol><p>综上所述，对网站的文件和资源进行优化可以提高页面加载速度和用户体验，同时减少服务器负载和带宽消耗。</p><h3 id="浏览器同一时间可以从一个域名下载多少资源？有什么例外吗？"><a href="#浏览器同一时间可以从一个域名下载多少资源？有什么例外吗？" class="headerlink" title="浏览器同一时间可以从一个域名下载多少资源？有什么例外吗？"></a><strong>浏览器同一时间可以从一个域名下载多少资源？有什么例外吗？</strong></h3><p>浏览器同一时间可以从一个域名下载的资源数量是有限制的，这个限制通常被称为“并发请求限制”。不同的浏览器对于并发请求限制的数量有不同的限制，但通常情况下，现代浏览器可以同时从一个域名下载6-8个资源。这个限制是为了避免过多的HTTP请求导致服务器负载过高，同时也可以提高页面加载速度和用户体验。为了避免并发请求限制，可以使用CDN（内容分发网络）来加速静态资源的加载，或者将资源分散到多个域名下，以提高并发请求的数量。</p><p>有一些例外情况可以突破浏览器的并发请求限制，例如使用HTTP&#x2F;2协议、使用不同的子域名或使用不同的协议（如HTTP和HTTPS）。HTTP&#x2F;2协议支持多路复用，可以在同一连接上同时传输多个请求和响应，从而避免了并发请求限制。使用不同的子域名可以将资源分散到多个域名下，从而提高并发请求的数量。使用不同的协议可以避免浏览器对同一域名下HTTP请求的并发限制，例如将静态资源放在HTTPS协议下，将动态资源放在HTTP协议下。但是，这些方法也会增加服务器的负担和复杂度，需要根据具体情况进行权衡和选择。</p><h3 id="请说出三种减少页面加载时间的方法。-加载时间指感知的时间或者实际加载时间"><a href="#请说出三种减少页面加载时间的方法。-加载时间指感知的时间或者实际加载时间" class="headerlink" title="请说出三种减少页面加载时间的方法。(加载时间指感知的时间或者实际加载时间)"></a><strong>请说出三种减少页面加载时间的方法。(加载时间指感知的时间或者实际加载时间)</strong></h3><ol><li>压缩和合并文件：将多个CSS和JavaScript文件压缩成一个文件，可以减少HTTP请求次数，从而减少页面加载时间。</li><li>图片优化：使用适当的图片格式和大小，可以减少图片的加载时间。例如，使用JPEG格式的图片可以减少文件大小，从而减少加载时间。</li><li>使用CDN：使用内容分发网络（CDN）可以将静态资源（如CSS、JavaScript和图片）缓存在全球各地的服务器上，从而加快页面加载速度。</li></ol><h3 id="如果你参与到一个项目中，发现他们使用-Tab-来缩进代码，但是你喜欢空格，你会怎么做？"><a href="#如果你参与到一个项目中，发现他们使用-Tab-来缩进代码，但是你喜欢空格，你会怎么做？" class="headerlink" title="如果你参与到一个项目中，发现他们使用 Tab 来缩进代码，但是你喜欢空格，你会怎么做？"></a><strong>如果你参与到一个项目中，发现他们使用 Tab 来缩进代码，但是你喜欢空格，你会怎么做？</strong></h3><p>如果我喜欢使用空格来缩进代码，但是项目中使用 Tab，我会先和团队成员沟通，看看是否可以统一使用空格或者 Tab。如果团队成员不同意改变，我会尊重团队的决定，继续使用 Tab 来缩进代码。</p><p>如果我认为使用空格更加方便和清晰，我会在自己的编辑器中设置将 Tab 转换成空格，这样就可以在自己的编辑器中使用空格来缩进代码了。但是在提交代码时，我会将空格转换成 Tab，以符合团队的规范。</p><h3 id="请谈谈你对网页标准和标准制定机构重要性的理解。"><a href="#请谈谈你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="请谈谈你对网页标准和标准制定机构重要性的理解。"></a><strong>请谈谈你对网页标准和标准制定机构重要性的理解。</strong></h3><p>网页标准是指由W3C（万维网联盟）制定的一系列规范，包括HTML、CSS、JavaScript等。这些规范定义了网页的结构、样式和行为，使得不同的浏览器可以正确地解析和渲染网页。标准制定机构的重要性在于确保网页的兼容性和可访问性，使得网页可以在不同的设备和浏览器上正确地显示和使用。如果没有标准制定机构，每个浏览器都可以自行解析和渲染网页，导致网页在不同的浏览器上显示不一致，甚至无法正常使用。标准制定机构还可以推动技术的发展和创新，使得网页可以更加丰富和交互。因此，遵循网页标准和支持标准制定机构的工作是非常重要的。</p><h3 id="什么是-FOUC-无样式内容闪烁-？你如何来避免-FOUC？"><a href="#什么是-FOUC-无样式内容闪烁-？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC (无样式内容闪烁)？你如何来避免 FOUC？"></a><strong>什么是 FOUC (无样式内容闪烁)？你如何来避免 FOUC？</strong></h3><p>FOUC（无样式内容闪烁）是指在页面加载时，由于CSS文件的加载延迟或者JavaScript操作DOM的延迟，导致页面上的内容在没有样式的情况下显示出来，然后突然闪烁一下，再显示出样式。这种现象会给用户带来不好的体验，因为页面的内容会突然变化，影响用户的阅读和操作。</p><p>为了避免FOUC，可以采取以下措施：</p><ol><li>将CSS文件放在页面头部：将CSS文件放在页面头部可以让浏览器在加载页面时先加载CSS文件，从而避免页面内容在没有样式的情况下显示出来。</li><li>使用内联样式：将CSS样式直接写在HTML标签中，可以避免CSS文件的加载延迟。</li><li>使用JavaScript延迟加载：使用JavaScript延迟加载可以让页面先加载完毕再加载CSS文件，从而避免FOUC。</li><li>使用样式预加载：使用样式预加载可以让浏览器在加载页面时先加载CSS文件，从而避免FOUC。</li><li>使用样式闪避：使用样式闪避可以让页面在没有样式的情况下隐藏内容，直到样式加载完毕再显示出来，从而避免FOUC。</li></ol><h3 id="请解释什么是-ARIA-和屏幕阅读器-screenreaders-，以及如何使网站实现无障碍访问-accessible-。"><a href="#请解释什么是-ARIA-和屏幕阅读器-screenreaders-，以及如何使网站实现无障碍访问-accessible-。" class="headerlink" title="请解释什么是 ARIA 和屏幕阅读器 (screenreaders)，以及如何使网站实现无障碍访问 (accessible)。"></a><strong>请解释什么是 ARIA 和屏幕阅读器 (screenreaders)，以及如何使网站实现无障碍访问 (accessible)。</strong></h3><p>ARIA（Accessible Rich Internet Applications）是一种用于增强网页可访问性的技术，它可以为那些无法使用鼠标或键盘的用户提供更好的访问体验。屏幕阅读器是一种软件，它可以将网页内容转换成语音或者盲文，以帮助视力障碍者访问网页。</p><p>为了使网站实现无障碍访问，可以采取以下措施：</p><ol><li>使用语义化的HTML：使用语义化的HTML可以让屏幕阅读器更好地理解网页内容，从而提高可访问性。</li><li>使用ARIA属性：使用ARIA属性可以为那些无法使用鼠标或键盘的用户提供更好的访问体验，例如，使用ARIA属性可以让屏幕阅读器更好地理解网页中的表单和控件。</li><li>提供文本替代品：为图片、音频和视频等媒体提供文本替代品可以让屏幕阅读器更好地理解网页内容，从而提高可访问性。</li><li>使用高对比度的颜色：使用高对比度的颜色可以帮助视力障碍者更好地阅读网页内容。</li><li>提供键盘快捷键：提供键盘快捷键可以让那些无法使用鼠标的用户更方便地访问网页内容。</li><li>测试可访问性：定期测试网站的可访问性，以确保网站可以被所有用户访问。</li></ol><h3 id="请解释-CSS-动画和-JavaScript-动画的优缺点。"><a href="#请解释-CSS-动画和-JavaScript-动画的优缺点。" class="headerlink" title="请解释 CSS 动画和 JavaScript 动画的优缺点。"></a><strong>请解释 CSS 动画和 JavaScript 动画的优缺点。</strong></h3><p>CSS 动画和 JavaScript 动画都可以用来实现网页动画效果，它们各有优缺点。</p><p>CSS 动画的优点是：</p><ol><li>简单易用：CSS 动画可以通过简单的 CSS 属性设置来实现，不需要编写复杂的 JavaScript 代码。</li><li>性能好：CSS 动画是由浏览器自己处理的，因此可以更好地利用硬件加速，性能比 JavaScript 动画更好。</li><li>兼容性好：CSS 动画可以在大多数现代浏览器中运行，而且不需要额外的插件或库。</li></ol><p>CSS 动画的缺点是：</p><ol><li>功能受限：CSS 动画只能实现一些简单的动画效果，比如平移、旋转、缩放等，无法实现复杂的动画效果。</li><li>控制不灵活：CSS 动画的控制比较有限，无法实现复杂的交互效果。</li></ol><p>JavaScript 动画的优点是：</p><ol><li>功能强大：JavaScript 动画可以实现复杂的动画效果，比如路径动画、粒子动画等。</li><li>控制灵活：JavaScript 动画可以通过编写 JavaScript 代码来实现复杂的交互效果，比如鼠标悬停、点击等。</li></ol><p>JavaScript 动画的缺点是：</p><ol><li>编写复杂：JavaScript 动画需要编写复杂的 JavaScript 代码，对于不熟悉 JavaScript 的开发者来说比较困难。</li><li>性能差：JavaScript 动画是由 JavaScript 引擎处理的，性能比 CSS 动画差，特别是在移动设备上。</li></ol><p>综上所述，CSS 动画适合实现简单的动画效果，而 JavaScript 动画适合实现复杂的动画效果和交互效果。在实际开发中，可以根据具体需求选择使用哪种动画方式。</p><h3 id="什么是跨域资源共享-CORS-？它用于解决什么问题？"><a href="#什么是跨域资源共享-CORS-？它用于解决什么问题？" class="headerlink" title="什么是跨域资源共享 (CORS)？它用于解决什么问题？"></a><strong>什么是跨域资源共享 (CORS)？它用于解决什么问题？</strong></h3><p>跨域资源共享（CORS）是一种机制，它允许在一个域名下的网页向另一个域名下的服务器请求资源，即跨域请求。CORS用于解决同源策略（Same-Origin Policy）所导致的跨域问题。</p><p>同源策略是浏览器的一种安全策略，它限制了一个域名下的网页只能访问同一域名下的资源，而不能访问其他域名下的资源。这种限制可以防止恶意网站窃取用户的信息，但也会导致一些正常的跨域请求无法完成。</p><p>CORS机制通过在服务器端设置响应头信息，告诉浏览器该服务器允许哪些域名下的网页进行跨域请求。当浏览器发起跨域请求时，会先向服务器发送一个预检请求（OPTIONS请求），服务器返回响应头信息，告诉浏览器是否允许跨域请求。如果允许，浏览器才会发送真正的跨域请求。</p><p>CORS机制可以使得网页在不同的域名下进行数据交互，从而实现更加丰富的功能和更好的用户体验。但需要注意的是，CORS机制并不能完全解决跨域问题，仍然存在一些安全风险，需要开发者在使用时注意安全性。</p><h2 id="HTML相关问题"><a href="#HTML相关问题" class="headerlink" title="HTML相关问题"></a>HTML相关问题</h2><h3 id="doctype-文档类型-的作用是什么？"><a href="#doctype-文档类型-的作用是什么？" class="headerlink" title="doctype(文档类型) 的作用是什么？"></a><code>doctype</code>(文档类型) 的作用是什么？</h3><p>doctype（文档类型）是一种指示浏览器使用哪种 HTML 或 XHTML 规范来解析页面的声明。它告诉浏览器如何正确地渲染页面，以确保页面在不同浏览器和设备上的一致性。如果没有正确的 doctype 声明，浏览器可能会以不同的方式解释页面，导致页面显示不正确。因此，doctype 声明是编写有效的 HTML 或 XHTML 文档的重要组成部分。</p><h3 id="浏览器标准模式-standards-mode-、几乎标准模式（almost-standards-mode）和怪异模式-quirks-mode-之间的区别是什么？"><a href="#浏览器标准模式-standards-mode-、几乎标准模式（almost-standards-mode）和怪异模式-quirks-mode-之间的区别是什么？" class="headerlink" title="浏览器标准模式 (standards mode) 、几乎标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？"></a>浏览器标准模式 (standards mode) 、几乎标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？</h3><p>浏览器标准模式、几乎标准模式和怪异模式是浏览器解析 HTML 或 XHTML 文档时的三种不同模式。它们的区别如下：</p><ol><li>标准模式：浏览器按照 HTML 或 XHTML 规范解析文档，并且尽可能地遵循最新的 Web 标准。在标准模式下，页面的布局和渲染方式与不同浏览器之间的差异最小。</li><li>几乎标准模式：浏览器按照 HTML 或 XHTML 规范解析文档，但是在某些方面可能会有一些不兼容的行为。几乎标准模式是为了兼容旧的 Web 页面而设计的。</li><li>怪异模式：浏览器使用一种类似于早期浏览器的解析方式来解析文档。在怪异模式下，页面的布局和渲染方式可能会与标准模式下的差异很大。</li></ol><p>要在页面中指定使用哪种模式，需要使用 doctype 声明。如果没有正确的 doctype 声明，浏览器可能会默认使用怪异模式，导致页面显示不正确。因此，编写有效的 HTML 或 XHTML 文档时，正确使用 doctype 声明是非常重要的。</p><h3 id="HTML-和-XHTML-有什么区别？"><a href="#HTML-和-XHTML-有什么区别？" class="headerlink" title="HTML 和 XHTML 有什么区别？"></a>HTML 和 XHTML 有什么区别？</h3><p>HTML（Hypertext Markup Language）和XHTML（Extensible Hypertext Markup Language）都是用于创建网页的标记语言，它们之间的主要区别在于语法和规范。</p><ol><li>语法：HTML的语法比较宽松，允许一些不规范的写法，而XHTML的语法比较严格，必须遵循XML的语法规则，包括必须有一个根元素、所有元素必须有结束标签等。</li><li>规范：HTML和XHTML的规范也有所不同。HTML的规范由W3C（World Wide Web Consortium）和WHATWG（Web Hypertext Application Technology Working Group）共同制定，而XHTML的规范由W3C制定。</li><li>MIME类型：HTML的MIME类型是”text&#x2F;html”，而XHTML的MIME类型是”application&#x2F;xhtml+xml”。</li><li>兼容性：由于XHTML的语法比较严格，不允许一些不规范的写法，因此在一些旧版本的浏览器中可能无法正常显示。而HTML的语法比较宽松，兼容性比较好。</li></ol><p>总的来说，XHTML是HTML的一种更加严格的版本，它强制要求遵循XML的语法规则，可以提高网页的可靠性和可维护性。但是，由于XHTML的语法比较严格，需要更加谨慎地编写代码，同时也需要考虑兼容性问题。</p><h3 id="如果页面使用-‘application-x2F-xhtml-xml’-会有什么问题吗？"><a href="#如果页面使用-‘application-x2F-xhtml-xml’-会有什么问题吗？" class="headerlink" title="如果页面使用 ‘application&#x2F;xhtml+xml’ 会有什么问题吗？"></a>如果页面使用 ‘application&#x2F;xhtml+xml’ 会有什么问题吗？</h3><p>如果页面使用 ‘application&#x2F;xhtml+xml’，会有一些问题：</p><ol><li>兼容性问题：不是所有的浏览器都支持 ‘application&#x2F;xhtml+xml’ 类型的文档，特别是旧版本的浏览器。这可能会导致页面无法正常显示或者无法加载。</li><li>语法问题：’application&#x2F;xhtml+xml’ 类型的文档必须遵循 XML 的语法规则，包括必须有一个根元素、所有元素必须有结束标签等。如果页面中存在语法错误，可能会导致页面无法正常显示或者无法加载。</li><li>脚本问题：’application&#x2F;xhtml+xml’ 类型的文档不支持内联脚本，必须使用外部脚本。这可能会导致页面的性能受到影响，因为每次加载页面时都需要加载外部脚本。</li><li>样式问题：’application&#x2F;xhtml+xml’ 类型的文档不支持内联样式，必须使用外部样式表。这可能会导致页面的性能受到影响，因为每次加载页面时都需要加载外部样式表。</li></ol><p>因此，如果页面使用 ‘application&#x2F;xhtml+xml’，需要考虑以上问题，并确保页面的语法正确、兼容性良好、脚本和样式的性能优化等。</p><h3 id="如果网页内容需要支持多语言，你会怎么做？"><a href="#如果网页内容需要支持多语言，你会怎么做？" class="headerlink" title="如果网页内容需要支持多语言，你会怎么做？"></a>如果网页内容需要支持多语言，你会怎么做？</h3><p>如果网页内容需要支持多语言，我会使用国际化（i18n）技术来实现。具体来说，我会将网页中的所有文本内容都提取出来，然后将其存储在一个翻译文件中，每个语言对应一个翻译文件。当用户选择不同的语言时，我会根据用户的选择加载对应的翻译文件，并将网页中的文本内容替换为对应语言的翻译。这样就可以实现网页内容的多语言支持了。</p><h2 id="CSS相关问题"><a href="#CSS相关问题" class="headerlink" title="CSS相关问题"></a>CSS相关问题</h2><h3 id="CSS-中类-classes-和-ID-的区别。"><a href="#CSS-中类-classes-和-ID-的区别。" class="headerlink" title="CSS 中类 (classes) 和 ID 的区别。"></a>CSS 中类 (classes) 和 ID 的区别。</h3><p>类 (classes) 和 ID 是 CSS 中用于标识和选择元素的两种不同方式。</p><p>类是一种可以在 HTML 中多次使用的标识符，用于标识一组具有相似特征的元素。在 CSS 中，可以使用类选择器来选择具有相同类的所有元素，并对它们应用相同的样式。</p><p>ID 是一种在 HTML 中唯一使用的标识符，用于标识一个具有唯一特征的元素。在 CSS 中，可以使用 ID 选择器来选择具有特定 ID 的元素，并对它们应用相同的样式。</p><p>因此，类和 ID 的主要区别在于它们在 HTML 中的使用方式和在 CSS 中的选择方式。类可以在多个元素中使用，而 ID 只能在一个元素中使用。同时，类选择器可以选择多个元素，而 ID 选择器只能选择一个元素。</p><h3 id="请问-“resetting”-和-“normalizing”-CSS-之间的区别？你会如何选择，为什么？"><a href="#请问-“resetting”-和-“normalizing”-CSS-之间的区别？你会如何选择，为什么？" class="headerlink" title="请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？"></a>请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？</h3><p>“Resetting” 和 “normalizing” CSS 都是用于重置浏览器默认样式的技术，但它们的实现方式和效果略有不同。</p><p>“Resetting” CSS 是通过将所有元素的默认样式重置为零来实现的，以确保在不同浏览器和设备上的一致性。这意味着所有元素都将没有边距、填充、字体大小等样式，需要手动为每个元素添加样式。</p><p>“Normalizing” CSS 是通过在所有浏览器中应用一组公共样式来实现的，以确保在不同浏览器和设备上的一致性。这意味着所有元素都将具有相同的基本样式，但仍然保留了一些默认样式，以确保页面的可访问性和可用性。</p><p>选择使用哪种技术取决于具体情况。如果您需要完全控制页面的样式，并且不希望受到浏览器默认样式的影响，则可以使用“Resetting” CSS。如果您希望页面具有一致的外观和可访问性，并且希望保留一些默认样式，则可以使用“Normalizing” CSS。</p><h3 id="请解释浮动-Floats-及其工作原理。"><a href="#请解释浮动-Floats-及其工作原理。" class="headerlink" title="请解释浮动 (Floats) 及其工作原理。"></a>请解释浮动 (Floats) 及其工作原理。</h3><p>浮动（Floats）是CSS中的一种布局方式，它可以让元素脱离文档流并向左或向右浮动，使得其他元素可以环绕在其周围。浮动元素通常用于创建多列布局、图像浮动等效果。</p><p>浮动元素的工作原理如下：</p><ol><li>浮动元素会脱离文档流，不再占据原来的位置，而是向左或向右浮动，直到遇到父元素的边界或其他浮动元素。</li><li>父元素的高度会塌陷，因为浮动元素不再占据原来的位置。为了解决这个问题，可以使用清除浮动（Clearfix）技术。</li><li>其他元素会环绕在浮动元素的周围，如果浮动元素的宽度超过了父元素的宽度，那么浮动元素会被截断。</li></ol><p>需要注意的是，浮动元素的宽度默认是自适应的，可以通过设置宽度或使用盒模型来控制宽度。同时，浮动元素的高度也是自适应的，可以根据内容自动调整高度。</p><p>浮动元素的应用非常广泛，可以用于创建多列布局、图像浮动、导航菜单等效果。但是，需要注意浮动元素可能会影响其他元素的布局，需要谨慎使用。同时，需要注意清除浮动，以避免父元素高度塌陷的问题。</p><h3 id="描述z-index和叠加上下文是如何形成的。"><a href="#描述z-index和叠加上下文是如何形成的。" class="headerlink" title="描述z-index和叠加上下文是如何形成的。"></a>描述<code>z-index</code>和叠加上下文是如何形成的。</h3><p><code>z-index</code>是CSS中用于控制元素在垂直方向上的叠放顺序的属性。具体来说，<code>z-index</code>值越大的元素会覆盖在<code>z-index</code>值较小的元素之上。</p><p>叠加上下文是指一个元素及其子元素形成的一个独立的图层，该图层可以影响元素的<code>z-index</code>值。叠加上下文的形成有以下几种情况：</p><ol><li>根元素：根元素是所有元素的祖先元素，它形成了一个叠加上下文。</li><li><code>position</code>属性为<code>fixed</code>或<code>sticky</code>的元素：这些元素会形成一个独立的图层，可以影响其他元素的<code>z-index</code>值。</li><li><code>position</code>属性为<code>relative</code>或<code>absolute</code>的元素，并且<code>z-index</code>值不为<code>auto</code>的元素：这些元素会形成一个独立的图层，可以影响其他元素的<code>z-index</code>值。</li><li><code>opacity</code>值小于1的元素：这些元素会形成一个独立的图层，可以影响其他元素的<code>z-index</code>值。</li></ol><p>当一个元素形成了叠加上下文后，它的子元素也会继承该叠加上下文，除非子元素自身也形成了叠加上下文。</p><p>需要注意的是，<code>z-index</code>值只能在同一叠加上下文中比较大小，不同叠加上下文中的<code>z-index</code>值无法比较。因此，在使用<code>z-index</code>属性时，需要注意元素的叠加上下文，以避免出现意外的覆盖效果。</p><h3 id="请描述-BFC-Block-Formatting-Context-及其如何工作。"><a href="#请描述-BFC-Block-Formatting-Context-及其如何工作。" class="headerlink" title="请描述 BFC(Block Formatting Context) 及其如何工作。"></a>请描述 BFC(Block Formatting Context) 及其如何工作。</h3><p>BFC（Block Formatting Context）是CSS中的一个概念，它是用于控制块级元素布局的一种机制。具体来说，BFC可以将一个块级元素及其子元素包含在一个独立的布局环境中，从而影响元素的布局和渲染。</p><p>BFC的工作原理如下：</p><ol><li>创建BFC：当一个元素满足以下条件之一时，它会创建一个BFC：</li></ol><ul><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>属性为<code>absolute</code>或<code>fixed</code></li><li><code>display</code>属性为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code>、<code>grid</code>或<code>inline-grid</code></li><li><code>overflow</code>属性不为<code>visible</code></li></ul><ol><li>形成独立的布局环境：当一个元素创建了BFC后，它会形成一个独立的布局环境，该环境与其他元素的布局环境相互独立，不会影响其他元素的布局。</li><li>影响元素的布局和渲染：BFC可以影响元素的布局和渲染，具体表现如下：</li></ol><ul><li>清除浮动：当一个元素的子元素都浮动时，该元素会塌陷，高度为0。但是，如果该元素创建了BFC，它会包含浮动元素，从而避免塌陷的问题。</li><li>防止外边距合并：当两个相邻的元素都有外边距时，它们的外边距会合并，从而影响布局。但是，如果其中一个元素创建了BFC，它会形成一个独立的布局环境，从而避免外边距合并的问题。</li><li>控制元素的位置：当一个元素创建了BFC后，它的位置会受到限制，只能在BFC的范围内移动，从而影响元素的布局和渲染。</li></ul><p>BFC的应用非常广泛，可以用于清除浮动、防止外边距合并、实现多列布局等效果。但是，需要注意BFC的创建条件和影响范围，以避免出现意外的布局问题。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通俗易懂介绍下JS闭包</title>
      <link href="/2023/05/04/tong-su-yi-dong-jie-shao-xia-js-bi-bao/"/>
      <url>/2023/05/04/tong-su-yi-dong-jie-shao-xia-js-bi-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript中的闭包"><a href="#JavaScript中的闭包" class="headerlink" title="JavaScript中的闭包"></a>JavaScript中的闭包</h1><blockquote><p>以下讨论中，Javascript均为ECMAScript的别名，仅代表ECMA-262协议的实现，不指代包括DOM、BOM在内的Web Javascript系统。</p></blockquote><h2 id="闭包概念"><a href="#闭包概念" class="headerlink" title="闭包概念"></a>闭包概念</h2><p>首先用一张图来直观看看JavaScript闭包：</p><p><img src="/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E4%BB%8B%E7%BB%8D%E4%B8%8BJS%E9%97%AD%E5%8C%85/closure.png" alt="image-center"></p><p>将闭包比喻成一个函数携带着一个背包。这张图就很简单地描述了这种关系：<strong>闭包 &#x3D; 函数 + 外部上下文</strong></p><p>其中闭包中的这个函数一般是由另一个函数创建、返回的，这样对于这个函数来讲，外部的函数在执行时创建出来的上下文对于它就是一个外部上下文，这个外部上下文中包含了外部函数中声明的所有变量，包括闭包函数本身。</p><p>你可以将外部函数的外部函数执行时产生的上下文也理解为外部上下文，该上下文也属于闭包的一部分。层层而上，一直回溯到全局执行上下文，都是属于这个闭包。</p><h2 id="闭包重点"><a href="#闭包重点" class="headerlink" title="闭包重点"></a>闭包重点</h2><ol><li><strong>闭包不是一个函数</strong>，而是一个函数和它的外部上下文的组合。</li><li>闭包的产生并不影响外部上下文的回收，闭包中的外部上下文只是在创建闭包时创建的一个副本。当然，对于同级的闭包来讲，它们会引用同一个外部上下文的副本，而不是各自创建属于自己的副本。</li><li>Javascript中所有函数都可以理解为闭包函数，因为即使是最外层定义的函数，它也有属于自己的外部上下文——<strong>全局上下文</strong>。</li><li>不推荐嵌套过多层闭包，因为<u>每个闭包创建时都会把所有外部上下文回溯到全局上下文中的变量作为属于它的外部上下文部分创建拷贝存储起来</u>，如果嵌套层次过多会引起内存不必要的浪费。</li><li>同样，不推荐使用没有必要的闭包。比如在一个函数中创建了另外一个函数，但是在这个内部函数中根本就不会引用到外部这个函数中声明的变量，这个内部函数产生的闭包会保存这些没有用处的变量，造成不必要的内存浪费。</li></ol><h2 id="闭包作用"><a href="#闭包作用" class="headerlink" title="闭包作用"></a>闭包作用</h2><p>初学者容易从教材中混淆以下概念，认为是闭包的作用：</p><ol><li>避免变量全局污染</li><li>使数据私有化，外部无法修改内部数据</li><li>可以让外部可以使用内部的私有数据</li></ol><p>但其实这都是JavaScript中<strong>函数的作用，而并非闭包的作用</strong>。</p><p>闭包的核心作用（普通函数不具备的）：</p><blockquote><p><strong>使变量可以驻留在内存，不被回收。</strong></p></blockquote><p>示例代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>a<span class="token operator">++</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出11,11,11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码其实没有用到闭包，完全是函数本身的作用，例如避免全局污染，数据私有化等。</p><p>那么应该如何做使得变量a常驻在内存当中呢，即每次变量a的值递增1？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>a<span class="token operator">++</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出11,12,13</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是在fn()函数中<strong>嵌套一个函数</strong>，用到了<strong>外层函数的变量</strong>，此时形成了闭包。</p><blockquote><p> 注意：除第一次<code>let f = fn()</code>外，其余三次执行函数只执行了fn()函数中的匿名函数，即没有执行<code>let a = 10</code>这条语句，所以a没有被重复赋值，同时因为闭包的特点，a变量驻留在内存当中，从而可以自增。</p></blockquote><p>由于闭包不影响外部上下文的回收，所以<strong>闭包本身不会造成内存泄露</strong>，但是如果闭包中引用了外部函数的变量或对象，而这些变量或对象没有被正确地释放，就会导致内存泄漏。</p><blockquote><p>内存泄漏：程序在运行过程中创建的对象变量是一个内存地址（指针），若该对象重新赋值一个新的指针，而之前的指针指向的内存未进行回收，则内存泄漏。这个现象一般出现在需要手动析构对象的语言中，如C&#x2F;C++。内存泄漏会导致无用的内存被占用且无法进行回收，程序长时间运行下去内存会只增不减直到内存溢出Crash。</p></blockquote><p>闭包在销毁前会一直保留外部上下文中的变量，如果闭包创建过多而没有及时被GC回收，<strong>可能会造成内存溢出（Out of Memory）</strong>。</p><blockquote><p>内存溢出：程序运行过程中正常分配的内存超过了运行时的最大内存，导致无法请求新的内存，运行时Crash。</p></blockquote><p>如果想避免内存泄露（触发内存回收时恢复不到原点），可以手动清理闭包：<code>f = null;</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶--文本效果</title>
      <link href="/2023/04/06/css-jin-jie-wen-ben-xiao-guo/"/>
      <url>/2023/04/06/css-jin-jie-wen-ben-xiao-guo/</url>
      
        <content type="html"><![CDATA[<h1 id="文本效果"><a href="#文本效果" class="headerlink" title="文本效果"></a>文本效果</h1><h2 id="深入text-indent"><a href="#深入text-indent" class="headerlink" title="深入text-indent"></a>深入text-indent</h2><ol><li>实现首行缩进2字符：<code>text-indent:2em</code></li><li>在引擎优化中，h1是非常重要的标签，一般情况下，我们都是把网站的LOGO图片放在h1标签中。但是搜索引擎只能识别文字，不能识别图片。为了更好地进行搜索引擎优化，一个很好的解决方案是：<ul><li>指定h1元素的长宽和LOGO图片的长宽一样</li><li>定义h1的背景图片为LOGO图片</li><li>使用<code>text-indent:-9999px</code>来隐藏h1的文字内容</li></ul></li></ol><h2 id="深入text-align"><a href="#深入text-align" class="headerlink" title="深入text-align"></a>深入text-align</h2><p>text-align属性用来定义文本或图片的对齐方式，常用取值为left、right、center。</p><p>text-align属性对文本、inline元素以及inline-block元素都会起作用，但对block元素不起作用。</p><h3 id="关于页面居中"><a href="#关于页面居中" class="headerlink" title="关于页面居中"></a>关于页面居中</h3><p>在实现页面居中的方式中，<code>text-align:center</code>和<code>margin:0 auto</code>是最常见的两种居中方式，不过这两者也有着本质的区别。</p><ul><li><code>text-align:center</code> 实现的是文本、inline元素以及inline-block元素的水平居中。</li><li><code>margin:0 auto</code>实现的是block元素的水平居中。</li><li><code>text-align:center</code> 在<strong>父元素</strong>中定义，<code>margin:0 auto</code>在<strong>当前元素</strong>中定义。</li></ul><h2 id="深入line-height"><a href="#深入line-height" class="headerlink" title="深入line-height"></a>深入line-height</h2><p>line-height的准确定义：两行文字<strong>基线</strong>之间的距离。关于顶线、中线、基线、底线的内容本文不再赘述。</p><h3 id="height和line-height"><a href="#height和line-height" class="headerlink" title="height和line-height"></a>height和line-height</h3><p>line-height是有默认值的，当没有定义line-height属性时，浏览器就会采用默认的line-height值。</p><p>一行文字的高度是由line-height决定，而不是由height决定。例如在p标签中，一个p标签的文字可以有很多行，其中line-height定义的是一行文字的高度，而height定义的才是整个段落的高度（即p标签的高度）。</p><h3 id="line-height的取值"><a href="#line-height的取值" class="headerlink" title="line-height的取值"></a>line-height的取值</h3><p>当line-height的取值为百分比或者em值时，元素的行高是相对于“当前元素”的font-size值来计算的。计算公式如下：</p><p><code>line-height = （当前元素font-size）×（百分比）</code> </p><p><code>line-height =（当前元素font-size）×（em值）</code></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li><p>对于多行文字：控制行与行之间的距离。</p></li><li><p>对于单行文字：让<code>height</code>等于<code>line-height</code>，可以实现文字<strong>垂直居中</strong>。</p><blockquote><p>由于字体设计原因，靠上述办法实现的居中，并不是绝对的垂直居中，但如果一行中都是文字，不会太影响观感。</p></blockquote></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote><ol><li><code>line-height</code>过小——文字产生重叠，且最小值是<code>0</code>，不能为负数。</li><li><code>line-height</code>是可以继承的，且为了能更好的呈现文字，最好写数值。</li><li><code>line-height</code>和<code>height</code>是什么关系？<ul><li>设置了<code>height</code>，那么高度就是<code>height</code>的值。</li><li>不设置<code>height</code>的时候，会根据<code>line-height</code>计算高度。</li></ul></li></ol></blockquote><h2 id="深入vertical-align"><a href="#深入vertical-align" class="headerlink" title="深入vertical-align"></a>深入vertical-align</h2><p>W3C官方对vertical-align属性的定义有以下4个方面的解释。</p><ul><li>vertical-align属性用于定义<strong>周围的文字、inline元素以及inline-block元素内文字的垂直对齐方式</strong>（<strong>同一行元素、表格单元格</strong>）。</li><li>在表格单元格中，vertical-align属性可以定义单元格td元素中内容的对齐方式。td元素是table-cell元素，也就是说vertical-align属性对table-cell类型元素有效（<strong>针对自身而言</strong>）。</li><li>vertical-align属性对inline元素、inline-block元素和table-cell元素有效，对block元素无效。</li><li>vertical-align属性允许制定负长度值（如-2px）和百分比值（如50%）。</li></ul><p>vertical-align属性中最常见的属性值有4个：top、middle、baseline、bottom</p><ol><li><code>baseline</code>（默认值）：使元素的基线与父元素的基线对齐。</li><li><code>top</code>：使元素的顶部与其所在行的顶部对齐。</li><li><code>middle</code>：使元素的中部与父元素的基线加上父元素字母x的一半对齐。</li><li><code>bottom</code>：使元素的底部与其所在行的底部对齐。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器中的重绘和重排</title>
      <link href="/2023/03/30/liu-lan-qi-zhong-de-chong-hui-he-chong-pai/"/>
      <url>/2023/03/30/liu-lan-qi-zhong-de-chong-hui-he-chong-pai/</url>
      
        <content type="html"><![CDATA[<h1 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h1><p>阅读基础：掌握<a href="https://qt7274.co/2023/03/29/liu-lan-qi-yun-zuo-yuan-li/">浏览器运作原理 | QT-7274 (qt7274.co)</a></p><ul><li><p>当DOM结构中的元素发生改变，或者浏览器窗口大小改变，或者元素位置、大小、内容发生改变时，会重新进行样式计算（Style）、布局（Layout）、绘制（Paint）以及后面的所有流程，也就是整个页面都会重新渲染。这种行为我们称为<strong>重排</strong>。</p></li><li><p>当元素的样式（如颜色、背景、边框等）发生改变时，浏览器会重新绘制元素的外观，这个过程叫做重绘。重绘不会重新触发布局（Layout），但会触发样式计算（Style）和绘制（Paint），这种行为称为<strong>重绘</strong>。</p></li><li><p>区别：重排和重绘都会影响页面的渲染性能，但是<strong>重排的开销更大</strong>，因为它会重新计算元素的位置和大小，重新布局整个页面。而重绘只是重新绘制元素的外观，对于页面渲染性能的影响相对较小。因此，为了提高页面性能，尽量减少重排的次数，优化CSS样式，避免频繁操作DOM。</p></li></ul><h2 id="为什么要避免大量的重绘和重排？"><a href="#为什么要避免大量的重绘和重排？" class="headerlink" title="为什么要避免大量的重绘和重排？"></a>为什么要避免大量的重绘和重排？</h2><p>重排和重绘都会占用主线程，同时JavaScript也会占用主线程，即他们会出现抢占执行时间的问题。</p><p>如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。如果在运行动画时还有大量的JavaScript代码，当在一帧的时间内布局和绘制结束后，还有剩余时间，JS就会拿到主线程的使用权。如果JS执行时间过长，就会导致在<strong>下一帧开始时JS没有及时归还主线程</strong>，导致下一帧动画没有按时渲染，就会出现页面动画<strong>卡顿</strong>。</p><h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><ol><li>通过<code>requestAnimationFrame()</code>这个API帮助我们解决这个问题，这个方法会在每一帧被调用，通过API的回调，我们可以把JS运行任务分成一些更小的任务块，在每一帧时间用完前暂停JS执行，归还主线程。这样在下一帧开始时，主线程可以按时执行布局和绘制。React的渲染引擎React Fiber就是用到了这个api来做了很多优化。</li><li>栅格化的整个流程是不占用主线程的，意味着它无需和JS抢夺主线程。而CSS中有个动画属性为<code>transform</code>，通过该属性实现的动画不会经过布局和绘制，而是<strong>直接运行在合成器线程和栅格化线程中</strong>，所以不会受到主线程中JS执行的影响。且通过<code>transform</code>实现的动画由于不需要经过布局绘制、样式计算等操作，节省了很多运算时间。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器运作原理</title>
      <link href="/2023/03/29/liu-lan-qi-yun-zuo-yuan-li/"/>
      <url>/2023/03/29/liu-lan-qi-yun-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h1><p>浏览器的结构可以简单地划分为以下模块：</p><ul><li>用户界面</li><li>浏览器引擎：其中包括数据持久层</li><li>渲染引擎：其中包括网络、JS解析器等</li></ul><p>其中渲染引擎可以说是一个浏览器的<strong>核心</strong>和<strong>灵魂</strong>，也就是我们常说的浏览器<strong>内核</strong>。</p><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><ul><li>IE浏览器：Trident内核</li><li>Firefox浏览器：Gecko内核</li><li>Safari浏览器：Webkit内核（已开源）</li><li>Chrome&#x2F;Opera&#x2F;Edge浏览器：Blink内核</li></ul><p>本文以Chrome内核为基础进行解释。</p><h2 id="从单进程进化到多进程结构"><a href="#从单进程进化到多进程结构" class="headerlink" title="从单进程进化到多进程结构"></a>从单进程进化到多进程结构</h2><p>以前的浏览器是单进程浏览器，一个进程中大概有页面线程负责页面，JS线程负责执行JS代码，还有其他各种线程。单进程的浏览器引发了很多问题：</p><ol><li>其中一个线程的卡死可能会导致整个进程出问题。</li><li>安全性堪忧，多个线程间共享数据。</li><li>流畅度差，一个进程需要负责太多事情，导致浏览器运行效率低。</li></ol><p>目前的浏览器采用多进程结构，分类如下：</p><ul><li><p><strong>浏览器进程</strong></p><ol><li>负责控制除标签页外的用户界面，包括地址栏、书签、后退和前进按钮。</li><li>负责与浏览器的其他进程协调工作。</li></ol></li><li><p><strong>渲染进程</strong></p><ol><li>负责控制显示tab标签内的所有内容，将其转换为用户可视化的内容。</li><li>负责与浏览器进程通信，处理用户输入和鼠标操作等。</li></ol><p>浏览器默认情况下会为每个标签页创建一个进程。浏览器默认情况下会为每个标签页创建一个进程。这种进程模型会占用更多内存，但是更加安全，各个标签页相互独立，当其中一个标签页渲染器进程卡死，并不会影响其他标签。</p><blockquote><p>注意：Chrome一共有4种进程模型，默认为每个实例创建一个渲染器进程，详见官方文档。</p></blockquote></li><li><p><strong>缓存进程</strong></p><ol><li>负责管理浏览器的缓存数据，包括将访问过的网页和资源文件存储在本地缓存中，下次访问同一网页时可以更快地加载页面。缓存进程还可以根据用户的使用习惯，预加载可能需要访问的网页和资源文件，以提升用户的体验。</li><li>负责在后台执行一些优化操作，如缓存常用的资源文件，以提高浏览器的性能和响应速度。</li></ol></li><li><p><strong>网络进程</strong></p><p>负责处理网络请求，包括DNS解析、建立TCP连接、SSL认证等。每个标签页都有一个独立的网络进程，这样可以避免一个标签页的网络请求影响到其他标签页的性能。</p></li><li><p><strong>GPU进程</strong></p><p>负责处理GPU相关的任务，如图形渲染、图像处理等。这个进程在Windows和Linux上是独立的进程，而在macOS上则与浏览器进程合并，称为“GPU进程”。</p></li><li><p><strong>插件进程</strong></p><p>负责运行浏览器插件，如Flash、PDF阅读器等。插件进程是一个独立的进程，与浏览器进程和渲染进程分别通信。</p></li></ul><h1 id="浏览器内部工作原理"><a href="#浏览器内部工作原理" class="headerlink" title="浏览器内部工作原理"></a>浏览器内部工作原理</h1><p>当你在浏览器地址栏输入地址时，浏览器进程的UI线程会捕捉你的输入内容：</p><ul><li>如果输入内容是网址，则UI线程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器获取数据。</li><li>如果输入内容不是网址而是一串关键词，浏览器知道你是要搜索，于是会使用默认搜索引擎来进行搜索。</li></ul><p>当网络线程获取数据之后：</p><ol><li><p>当网络线程获取数据之后，会通过SafeBrowsing来检查网站是否是恶意站点。</p></li><li><p>当网络数据接收完毕，安全检验通过后，网络线程会通知UI线程。</p></li><li><p>UI线程创建渲染器进程来渲染页面。浏览器进程通过<strong>IPC管道</strong>将数据传递给渲染器进程。</p></li><li><p><strong>（Dom）</strong>渲染器进程的主线程对HTML内容进行解析，构造DOM数据结构（DOM是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API）：</p><ol><li><p>HTML首先通过Tokeniser通过词法分析将输入的html内容解析成多个标记。根据识别后的标记进行DOM树构造。</p></li><li><p>在DOM树构造过程中会创建document对象，然后以document的为根节点的DOM树不断进行修改，向其中添加各种元素。</p></li><li><p>HTML代码中往往会引入一些额外的资源，例如图片、CSS、JS脚本等。图片和CSS资源需要通过网络下载或者从缓存中直接加载。这些资源不会阻塞html的解析，因为它们不会影响DOM的生成。<strong>但当html解析中遇到script标签，就会停止html解析流程，转而去加载解析并且执行JS。</strong></p><blockquote><p>为什么不跳过JS解析，等html解析完成了再去加载运行JS呢？</p></blockquote><p>这是因为浏览器并不知道JS执行是否会改变当前页面的HTML结构，如果JS代码里调用了document.write方法来修改html，那么之前的html解析就没有任何意义了。</p><p><u>这也是为什么script标签的位置，使用async或defer属性来异步加载JS的重要性。</u></p></li></ol></li><li><p><strong>（Style）</strong>在script标签加载完成后，我们会获得一个DOM树，但我们仍然不知道每个树节点上的样式。主线程需要解析CSS，并确定每个DOM节点的计算样式。</p></li><li><p><strong>（Layout）</strong>接下来需要知道每个节点放在页面上哪个位置，即节点坐标以及该节点需要占用多大的区域。</p></li><li><p>主线程通过遍历DOM和计算好的样式来生成Layout树。LAYOUT树上的每个节点都记录了x，y坐标和边框尺寸。</p><p>注意：DOM树和Layout树并不是一一对应的。</p><ul><li>设置了display:none的节点不会出现在Layout树上。</li><li>在before伪类中添加了content值的元素，content里的内容会出现在Layout树上，而不会出现在DOM树中。这是因为DOM是通过HTML解析获得，并不关心样式。</li></ul></li><li><p><strong>（Paint）</strong>我们还需知道以何种顺序来绘制节点。例如z-index属性会影响节点绘制的层级关系，如果按照DOM的层级结构来绘制页面则会导致错误的渲染。所以主线程遍历Layout树创建一个绘制记录表，代表了绘制的顺序，这个阶段称为绘制。</p></li><li><p><strong>（Rastering）</strong>在知道文档的绘制顺序后，终于到了该把这些信息转化为像素点的时候了。这种行为被称为栅格化。</p><p>Chrome最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分。这种方式带来的缺点显而易见，会导致显示延迟。</p><p>随着不断的优化升级，现在的Chrome使用了一种更复杂的栅格化流程，叫做<strong>合成（Composting）</strong>。合成是一种将页面的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程中单独进行合成页面的技术。</p></li><li><p><strong>（Layer）</strong>主线程遍历Layout树生成Layer树，当Layer树生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程。合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块，然后将每个图块发送给栅格化线程（Raster Thread）。</p></li><li><p>栅格化线程栅格化每个图块，并将它们存储在GPU内存中，当图块栅格化完成后，合成器线程将收集称为“draw quads”的图块信息。这些信息里记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息，根据这些信息合成器线程生成了一个合成器帧。</p></li><li><p>合成器帧通过IPC传送给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。</p></li></ol><h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><p>①浏览器进程中的网络线程请求获取到html数据——②通过IPC将数据传给渲染器进程的主线程——③主线程将html解析构造DOM树——④样式计算——⑤根据DOM树和生成好的样式生成Layout树——⑥通过遍历Layout树生成绘制顺序表——⑦通过遍历Layout树生成Layer树——⑧主线程将Layer树和绘制顺序表一起传给合成器线程——⑨合成器线程根据规则划分图层——⑩将图层分为更小的图块（tiles）传给栅格化线程进行栅格化——⑪栅格化完成后合成器线程会获得栅格化线程传过来的“draw quads”图块信息——⑫根据图块信息合成器线程上合成了一个合成器帧——⑬该合成器帧通过IPC传回给浏览器进程——⑭浏览器进程再传给GPU进行渲染——⑮将图像展示在屏幕上</p><p><img src="/2023/03/29/liu-lan-qi-yun-zuo-yuan-li/image-20230525174756341.png" alt="image-20230525174756341"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶--display简介</title>
      <link href="/2023/03/22/css-jin-jie-display-jian-jie/"/>
      <url>/2023/03/22/css-jin-jie-display-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h1><h2 id="块元素、行内元素、行内块元素"><a href="#块元素、行内元素、行内块元素" class="headerlink" title="块元素、行内元素、行内块元素"></a>块元素、行内元素、行内块元素</h2><p>块元素（block）特点：</p><ul><li><strong>块元素独占一行，排斥其他元素（包括块元素和行内元素）与其位于同一行。</strong></li><li><strong>块元素内部可以容纳其他块元素和行内元素。</strong></li><li><strong>可以定义width，也可以定义height。</strong></li><li><strong>可以定义4个方向的margin。</strong></li></ul><p>行内元素（inline）特点：</p><ul><li><strong>行内元素可以与其他行内元素位于同一行。</strong></li><li><strong>行内元素内部可以容纳其他行内元素，但不可以容纳块元素。</strong></li><li><strong>无法定义height，也无法定义width。</strong></li><li><strong>可以定义margin-left和margin-right，无法定义margin-top和margin-bottom。</strong></li></ul><p>行内块元素（inline-block）特点：</p><p><strong>同时具备了block元素和inline元素的特点。</strong></p><p>在HTML5中，最典型的inline-block元素有两个：<strong>img</strong>和<strong>input</strong>。</p><h2 id="display-none"><a href="#display-none" class="headerlink" title="display:none"></a>display:none</h2><p>对于display:none，我们需要注意以下两点：</p><ul><li>display:none元素一般用来配合JavaScript动态隐藏元素，被隐藏的元素不占据原来的位置。</li><li>display:none不推荐用来隐藏一些对SEO关键的部分，因为对于搜索引擎而言，它不会将display:none隐藏的内容加入权重考虑。</li></ul><h3 id="display-none和visibility-none的区别"><a href="#display-none和visibility-none的区别" class="headerlink" title="display:none和visibility:none的区别"></a>display:none和visibility:none的区别</h3><p>虽然两种方式都可以隐藏元素，但二者之间有本质的区别：</p><ul><li>display:none：元素被隐藏后，<strong>不占据原来的位置</strong>。</li><li>visibility:none：元素被隐藏后，<strong>依然占据原来的位置</strong>。</li></ul><h2 id="display-table-cell"><a href="#display-table-cell" class="headerlink" title="display:table-cell"></a>display:table-cell</h2><p>display:table-cell可以让元素以表格单元格的形式呈现。换句话说，就是table-cell类型元素具有td元素的特点。</p><p>常见用途有以下三种：</p><ul><li>图片垂直居中于元素</li><li>等高布局</li><li>自动平均划分元素</li></ul><h3 id="图片垂直居中于元素"><a href="#图片垂直居中于元素" class="headerlink" title="图片垂直居中于元素"></a>图片垂直居中于元素</h3><p>我们可以配合使用display:table-cell和vertical-align: middle来实现<strong>大小不固定的图片的垂直居中</strong>效果。</p><p>（图片的水平居中可以使用text-align:center来实现)</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 父元素 */</span>      <span class="token punctuation">&#123;</span>          <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>          <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token comment">/* 子元素 */</span>      <span class="token punctuation">&#123;</span>          <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="等高布局"><a href="#等高布局" class="headerlink" title="等高布局"></a>等高布局</h3><p>我们知道，同一行的单元格td元素高度是相等的，因此，table-cell元素也具备这个特点。根据这个特点，我们可以实现<strong>等高布局</strong>效果。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html>&lt;html lang=<span class="token string">"en"</span>>&lt;head>    &lt;meta charset=<span class="token string">"UTF-8"</span> />    &lt;meta http-equiv=<span class="token string">"X-UA-Compatible"</span> content=<span class="token string">"IE=edge"</span> />    &lt;meta name=<span class="token string">"viewport"</span> content=<span class="token string">"width=device-width, initial-scale=1.0"</span> />    &lt;title>&lt;/title>    &lt;style type=<span class="token string">"text/css"</span>>        <span class="token comment">/* 定义父元素具备的特点 */</span>        <span class="token selector">#wrapper</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-row<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#img-box</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token comment">/* 垂直居中 */</span>            <span class="token property">vertical-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token comment">/* 水平居中  */</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#text-box</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    &lt;/style>    &lt;script>    &lt;/script>&lt;/head>&lt;body>    &lt;div id=<span class="token string">"wrapper"</span>>        &lt;div id=<span class="token string">"img-box"</span>>            &lt;img src=<span class="token string">"http://www.cxy521.com/static/img/index/image/baidu_favicon.ico"</span> alt=<span class="token string">""</span> class=<span class="token string">"img"</span> />        &lt;/div>        &lt;div id=<span class="token string">"text-box"</span>>            &lt;span>baidu&lt;/span>        &lt;/div>    &lt;/div>&lt;/body>&lt;/html><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自动平均划分元素"><a href="#自动平均划分元素" class="headerlink" title="自动平均划分元素"></a>自动平均划分元素</h3><p>可以为每一个li元素定义display:table-cell，它会<strong>自动平均划分元素，并且使得它们在同一行显示</strong>。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 父元素 */</span>       <span class="token punctuation">&#123;</span>           <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span> <span class="token comment">/* 子元素 */</span>       <span class="token punctuation">&#123;</span>          <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后为父元素定义一定的宽度，那么此时子元素的宽度就会根据子元素的个数自动平均划分。</p><h2 id="inline-block元素间距"><a href="#inline-block元素间距" class="headerlink" title="inline-block元素间距"></a>inline-block元素间距</h2><p>inline-block元素之间有一定的间距。在实际开发中，这种间距有时会对我们的布局产生影响。大多数时候我们需要去除inline-block元素的间距。</p><p>在CSS中，我们可以为<strong>父元素</strong>定义一个”<strong>font-size:0;</strong>“来去除inline-block元素的间距。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 父元素 */</span>       <span class="token punctuation">&#123;</span>          <span class="token property">font-size</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：<u>因为父元素使用了font-size:0，所以子元素如果有文字需要定义自身的font-size，不然会因为继承而看不到文字。</u></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶--负margin技术</title>
      <link href="/2023/03/19/css-jin-jie-fu-margin-ji-zhu/"/>
      <url>/2023/03/19/css-jin-jie-fu-margin-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h1 id="负margin技术"><a href="#负margin技术" class="headerlink" title="负margin技术"></a>负margin技术</h1><p>当margin取值为负数时，margin对普通文档流元素和对浮动元素的影响是不一样的。其中，margin对普通文档流元素的影响，可以分为以下两种情况：</p><ul><li>当元素的margin-top或者margin-left为负数时，“<strong>当前元素</strong>”会被拉向指定方向。</li><li>当元素的margin-bottom或者margin-right为负数时，“<strong>后续元素</strong>”会被拉向指定方向。</li></ul><p>对于浮动元素，我们只需要比普通文档流元素多考虑一点，那就是浮动元素的“流动方向”。</p><h2 id="负margin技巧"><a href="#负margin技巧" class="headerlink" title="负margin技巧"></a>负margin技巧</h2><h3 id="图片与文本对齐"><a href="#图片与文本对齐" class="headerlink" title="图片与文本对齐"></a>图片与文本对齐</h3><p>当图片与文本放到一起的时候，它们在底部水平方向上往往都是不对齐的。这是因为在默认情况下，图片与周围的文本是基线对齐，也就是vertical-align:baseline。如果想让它们在底部水平方向上对齐，有两种方法：一种是使用vertical-align:text-bottom；另一种是使用负margin技术。</p><p>默认情况下，图片与文字在底部水平方向上是不对齐的。我们在CSS中添加：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">img</span><span class="token punctuation">&#123;</span><span class="token property">margin</span><span class="token punctuation">:</span>0 3px -3px 0<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="自适应两列布局"><a href="#自适应两列布局" class="headerlink" title="自适应两列布局"></a>自适应两列布局</h3><p>自适应两列布局，指的是在两列布局中，其中一列的宽度是固定的，而另外一列宽度自适应。如果使用浮动来做的话，只能实现固定的左右两列布局，并不能实现其中一列为自适应的布局。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">#main,#sidebar</span>        <span class="token punctuation">&#123;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#main</span>        <span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">margin-right</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#sidebar</span>        <span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span>        <span class="token comment">/* 防止浏览器可视区域宽度不足时发生文本重叠 */</span>        <span class="token selector">#main p</span> <span class="token punctuation">&#123;</span><span class="token property">margin-right</span><span class="token punctuation">:</span> 210px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">           </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是主体部分，自适应宽度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sidebar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是侧边栏部分，固定宽度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="元素垂直居中"><a href="#元素垂直居中" class="headerlink" title="元素垂直居中"></a>元素垂直居中</h3><p>想要实现块元素的垂直居中，一般来说比较麻烦，不过有一个经典的方法就是使用position结合负margin来实现：首先，给父元素写上position:relative，这样做是为了给子元素添加position:absolute的时候不会定位到外太空去；然后给子元素添加如下属性：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">父元素</span><span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token selector">子元素</span><span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>        <span class="token property">margin-top</span><span class="token punctuation">:</span> “height值一半的负值”<span class="token punctuation">;</span>        <span class="token property">margin-left</span><span class="token punctuation">:</span> “width值一般的负值”<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tab选项卡"><a href="#tab选项卡" class="headerlink" title="tab选项卡"></a>tab选项卡</h3><p>具体技巧就是使用margin-top:-1px消除tab选项卡的下边框。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶--外边距叠加</title>
      <link href="/2023/03/19/css-jin-jie-wai-bian-ju-die-jia/"/>
      <url>/2023/03/19/css-jin-jie-wai-bian-ju-die-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h1><p>外边距叠加，又称“margin叠加”，指的是当两个垂直外边距相遇时，这两个外边距将会合并成一个外边距。</p><p>其中，<strong>叠加之后的外边距高度，等于发生叠加之前的两个外边距中的<u>最大值</u></strong></p><p>外边距叠加有三种情况：同级元素、父级元素、空元素</p><h2 id="同级元素"><a href="#同级元素" class="headerlink" title="同级元素"></a>同级元素</h2><p>当一个元素出现在另一个元素上面的时候，第1个元素的<strong>下边距</strong>（margin-bottom）将会与第2个元素的<strong>上边距</strong>（margin-top）发生合并。</p><h2 id="父子元素"><a href="#父子元素" class="headerlink" title="父子元素"></a>父子元素</h2><p>当一个元素包含在另外一个元素中时（呈父子关系），假如没有padding或border把外边距分隔开，父元素和子元素的<strong>相邻上下外边距</strong>也会发生合并。</p><h2 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h2><p>空元素，指的是没有子元素或者没有文字内容的元素，当一个空元素有上下外边距时，如果没有border或padding，则元素的上外边距与下外边距就会合并。如果空元素的外边距碰到另外一个元素的外边距，它们也会发生合并。</p><p>注意：</p><ol><li><strong>水平外边距，永远不会有叠加，水平外边距指的是margin-left和margin-right。</strong></li><li><strong>垂直外边距只有在以上三种情况下会叠加。</strong></li><li><strong>外边距叠加之后的外边距高度，等于发生叠加之前的两个外边距中的最大值。</strong></li><li><strong>外边距叠加针对的是block以及inline-block元素，不包括inline元素。因为inline元素的margin-top和margin-bottom设置无效。</strong></li></ol><p>建议：</p><p><span style="color: red">最好统一使用margin-top或margin-bottom，不要混合使用，从而降低出现问题的风险。</span></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶——CSS单位</title>
      <link href="/2023/03/19/css-jin-jie-css-dan-wei/"/>
      <url>/2023/03/19/css-jin-jie-css-dan-wei/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h2><p>总体来说，CSS单位可以分为绝对单位和相对单位两大类。</p><h3 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h3><p>绝对单位多用于传统页面印刷中，极少用于前端开发。</p><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p>在CSS中，相对单位定义的大小是不固定的，一般是相对于其他长度而言。在CSS中，常用的相对单位如下表所示：</p><table><thead><tr><th>相对单位</th><th>说明</th></tr></thead><tbody><tr><td>px</td><td>像素</td></tr><tr><td>%</td><td>百分比</td></tr><tr><td>em</td><td>1em等于“<strong>当前元素</strong>”字体大小</td></tr><tr><td>rem</td><td>1rem等于“<strong>根元素</strong>”字体大小</td></tr></tbody></table><h4 id="像素（px）"><a href="#像素（px）" class="headerlink" title="像素（px）"></a>像素（px）</h4><p>px，全称pixel（像素），指一张图片中最小的点，或者是计算机屏幕中最小的点。严格来讲，px属于相对单位，因为屏幕分辨率不同，1px大小也是不同的。但是<u>如果不考虑屏幕分辨率，我们也可以把px当作绝对单位来看待</u>，这也是为什么很多地方说px是绝对单位的原因。</p><h4 id="百分比（-）"><a href="#百分比（-）" class="headerlink" title="百分比（%）"></a>百分比（%）</h4><p>在CSS中，支持百分比作为单位的属性很多，大致可以分为3类。</p><ul><li>width，height，font-size的百分比是相对于<strong>父元素“相同属性”的值</strong>来计算的、</li><li>line-height的百分比是相对于<strong>当前元素</strong>的font-size值来计算的。</li><li>vertical-align的百分比是相对于<strong>当前元素</strong>的line-height值决定的。</li></ul><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>在CSS中，em是相对于“<strong>当前元素</strong>”的字体大小而言的。其中，1em就等于“当前元素”字体大小。这里的字体大小指的是以px为单位的font-size值。</p><blockquote><p>注意：如果当前元素的font-size没有定义，则当前元素会继承父元素的font-size。如果当前元素的所有祖先元素都没有定义font-size，则当前元素会继承浏览器默认的font-size。其中，所有浏览器默认的font-size的值都是16px。</p><p>为了简化font-size的计算，我们在CSS中提前声明body{font-size:62.5%;}。通过这个声明，我们可以使默认字体大小变为16px×62.5%&#x3D;10px，此时1em&#x3D;10px。</p></blockquote><p>在CSS中，使用em作为单位有以下3个小技巧：</p><ol><li>首行缩进使用text-indent:2em来实现。</li><li>使用em作为统一单位：在实际开发中，对于em我们一般需要计算两次——第一次，当前元素font-size属性的px值；第二次，当前元素其他属性（如width、height等）的px值，因为如果当前元素其他属性要以em为单位，就得以当前元素的font-size值再计算一次。</li><li>使用em作为字体大小单位：如果想控制一个页面的字体大小，最佳选择是使用em作为单位，当需要改变页面整体的文字大小时，我们只需要改变根元素字体大小即可。这个特点在跨平台网站开发中有着明显的优势。</li></ol><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem，是指相对于<strong>根元素</strong>（即html元素）的字体大小。rem是CSS3新引入的单位，目前的主流浏览器，除了IE8外，大部分是支持rem的。rem布局是移动端最常见的布局方式之一。</p><p>rem和em很相似，不过也有明显区别：<u>em是相对“当前元素”的字体大小，而rem是相对“根元素”的字体大小。</u></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS进阶——CSS特性与优先级</title>
      <link href="/2023/03/14/css-jin-jie-css-te-xing-yu-you-xian-ji/"/>
      <url>/2023/03/14/css-jin-jie-css-te-xing-yu-you-xian-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ol><li><a href="https://qt-7274.github.io/2023/06/23/qian-tan-css-zhong-de-xuan-ze-qi/">浅谈CSS中的选择器 | QT-7274</a></li><li><a href="https://qt-7274.github.io/2023/06/24/css-xuan-ze-qi-quan-chong-ji-suan/">CSS选择器权重计算 | QT-7274 (qt7274.co)</a></li></ol><h2 id="CSS特性"><a href="#CSS特性" class="headerlink" title="CSS特性"></a>CSS特性</h2><p>CSS具有两大特性：继承性和层叠性。</p><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>CSS的继承性，是指子元素继承了父元素的某些样式特性。但不是所有属性都具有继承性。</p><p>在CSS中，具有继承性的属性有3类：</p><ul><li><strong>文本相关属性</strong>：font-family、font-size、font-style、font-weight、font、line-height、text-align、text-indent、word-spacing。</li><li><strong>列表相关属性</strong>：list-style-image、list-style-position、list-style-type、list-style。</li><li><strong>颜色相关属性</strong>：color</li></ul><blockquote><p>注意：<strong>a元素本身有默认的颜色样式，优先级要比继承的颜色高。</strong>如果要想改变a元素的颜色，必须选中a元素进行操作才行。当然，如果想要a元素也能继承父元素颜色的话，可以在a元素中使用“color:inherit;”来实现。</p></blockquote><p>CSS的继承性，可以让我们少写很多代码，只要在父元素中定义了属性，就不需要在子元素中重复定义了，这样让CSS代码显得更加精简优雅，提高可读性和可维护性。</p><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>如果在网页中，对于同一个元素，我们重复定义了多个相同的属性时，CSS应该如何处理？</p><p>CSS的层叠性，指的就是样式的覆盖。对于同一个元素来说，如果我们重复定义多个相同的属性，并且这些样式具有相同的权重，CSS会以最后定义的属性值为准，也就是遵循“<strong>后来者居上</strong>”原则。</p><p>“后来者居上”原则必须符合以下3个条件才生效：</p><ol><li><strong>元素相同</strong></li><li><strong>属性相同</strong></li><li><strong>权重相同</strong></li></ol><h2 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h2><p>CSS全称层叠样式表。很多人只知道CSS是用来控制样式的，并没有深入理解“层叠”这两个字的含义。</p><p>“层叠”，其实指的是样式的覆盖。当样式的覆盖发生冲突时，以优先级高的为准。当“同一个元素”的“同一个样式属性”被运用上多个属性值时，我们就需要遵循一定的优先级规则来选择一个属性值了。</p><p>对于样式覆盖发生的冲突，常见的共有以下5种情况：</p><ol><li>引用方式冲突</li><li>继承方式冲突</li><li>指定样式冲突</li><li>继承样式和指定样式冲突</li><li>!important</li></ol><h3 id="引用方式冲突"><a href="#引用方式冲突" class="headerlink" title="引用方式冲突"></a>引用方式冲突</h3><p>CSS有3种常用的引用方式：外部样式、内部样式和行内样式。</p><p>这3种引入方式的优先级如下：</p><p><strong>行内样式＞（内部样式&#x3D;外部样式）</strong></p><p>行内样式的优先级最高，内部样式与外部样式优先级相同。如果内部样式与外部样式同时存在，则以最后引用的样式为准（“后来者居上”原则。）</p><h3 id="继承方式冲突"><a href="#继承方式冲突" class="headerlink" title="继承方式冲突"></a>继承方式冲突</h3><p>如果是由于继承方式引起的冲突，则“<strong>最近的祖先元素</strong>”获胜。祖先元素，指的是当前元素的父元素等。</p><h3 id="指定样式冲突"><a href="#指定样式冲突" class="headerlink" title="指定样式冲突"></a>指定样式冲突</h3><p>所谓的指定样式，指的是指定“<strong>当前元素</strong>”的样式。当直接指定的样式发生冲突，样式<strong>权重高者</strong>获胜。</p><p>在CSS中，各种选择器的权重如下表所示：</p><table><thead><tr><th>选择器</th><th>权重</th></tr></thead><tbody><tr><td>通配符</td><td>0</td></tr><tr><td>伪元素</td><td>1</td></tr><tr><td>元素选择器</td><td>1</td></tr><tr><td>class选择器</td><td>10</td></tr><tr><td>伪类</td><td>10</td></tr><tr><td>属性选择器</td><td>10</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>行内样式</td><td>1000</td></tr></tbody></table><p>常见的伪元素只有4个：::before、::after、::first-letter、::first-line。伪类我们经常见到，如hover、:first-child等。常见的选择器优先级如下。</p><p><strong>行内样式＞id选择器＞class选择器＞元素选择器</strong></p><blockquote><p>注意：在CSS中，选择器的权重计算只针对指定样式（<strong>当前元素</strong>），<strong>并不能用于继承样式</strong>。</p></blockquote><h3 id="继承样式和指定样式冲突"><a href="#继承样式和指定样式冲突" class="headerlink" title="继承样式和指定样式冲突"></a>继承样式和指定样式冲突</h3><p><u>当继承样式和指定样式发生冲突时，指定样式获胜。</u></p><h3 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h3><p>在CSS中，我们可以使用!important规则来改变样式的优先级。如果一个样式使用“!important”来声明，则这个样式会覆盖CSS中<strong>其他的任何样式</strong>声明。</p><p><strong>如果你想要覆盖其他所有样式，可以使用!important来实现。</strong></p><h4 id="important的用法"><a href="#important的用法" class="headerlink" title="!important的用法"></a><code>!important</code>的用法</h4><p>在CSS中，<code>!important</code>有以下两种常见的使用情况。</p><ol><li><pre><code class="css">#someId p&#123;color:red;&#125;p&#123;color:green;&#125;</code></pre><p>这种情况下，如果不使用<code>!important</code>，则第一条样式永远比第二条样式优先级更高。</p></li><li><p>如果写了一些很差的行内样式，但是又想在内部样式表或外部样式表修改这个样式，这种情况下，就需要在内部样式表或外部样式表中使用<code>!important</code>来覆盖那些行内样式。</p></li></ol><h4 id="如何覆盖-important"><a href="#如何覆盖-important" class="headerlink" title="如何覆盖!important"></a>如何覆盖<code>!important</code></h4><p>想要覆盖<code>!important</code>声明的样式很简单，共有两种解决方法。</p><ol><li><p>使用相同的选择器，再添加一条<code>!important</code>的CSS语句。</p><p>不过这个CSS语句得放在后面，因为在优先级相同的情况下，后面定义的属性会覆盖前面定义的属性。</p></li><li><p>使用更高优先级的选择器，再添加一条<code>!important</code>的CSS语句。</p></li></ol><p>总而言之，对于CSS优先级的内容，主要掌握以下两条黄金定律即可：</p><blockquote><ol><li><strong>优先级高的样式覆盖优先级低的样式。</strong></li><li><strong>同一优先级的样式，后定义的覆盖先定义的，即“后来则居上”原则。</strong></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动多尺度峰值查找算法</title>
      <link href="/2023/03/07/zi-dong-duo-chi-du-feng-zhi-cha-zhao-suan-fa/"/>
      <url>/2023/03/07/zi-dong-duo-chi-du-feng-zhi-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Automatic-multiscale-based-peak-detection-AMPD"><a href="#Automatic-multiscale-based-peak-detection-AMPD" class="headerlink" title="Automatic multiscale-based peak detection (AMPD)"></a>Automatic multiscale-based peak detection (AMPD)</h1><p>本文算法的原始论文出处：<a href="https://link.zhihu.com/?target=https://www.mdpi.com/1999-4893/5/4/588/htm">Algorithms | Free Full-Text | An Efficient Algorithm for Automatic Peak Detection in Noisy Periodic and Quasi-Periodic Signals | HTML (mdpi.com)</a></p><p>本文代码的原始出处：<a href="https://zhuanlan.zhihu.com/p/549588865">推荐一个非常实用的峰值查找算法（peak detection） - 知乎 (zhihu.com)</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment"># 自动峰检测算法，参考：https://zhuanlan.zhihu.com/p/549588865</span><span class="token keyword">def</span> <span class="token function">AMPD</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    实现AMPD算法    在AMPD算法中，将输入数据平均分成多个长度相等的窗口，并逐个对窗口进行峰值检测。首先选择一个窗口长度k（从1开始逐渐增大）。    然后算法会从第k个数据点开始遍历，对于每个数据点i，都会检查其左侧和右侧距离为k的数据点，如果i点的数值比这两个点都要大，那么就认为i点是一个峰值。如果在一个窗口内有多个峰值，则窗口内的峰值指数之和会越小，因为要同时满足窗口内所有峰值的条件。    这样就可以通过比较不同窗口长度的峰值指数之和，找到一个最合适的窗口大小，并用它来检测所有的波峰。    :param data: 1-D numpy.ndarray    :return: 波峰所在索引值的列表    """</span>        p_data <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>data<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span> <span class="token comment"># 创建一个和data具有相同形状的新数组，初始化全为0，数据类型为int32。这个数组用于在算法中记录每个数据点的峰值指数，即这个数据点处于多少个窗口的峰值位置。</span>    count <span class="token operator">=</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># 获取数据数组的长度。</span>    arr_rowsum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment"># 用于存储每个窗口的峰值指数之和。因为算法会遍历不同长度的窗口，并计算每个窗口内的峰值的数量，最终累加到对应的arr_rowsum列表位置上，通过比较其中所有元素的大小，选择最小那个值对应的窗口长度作为最终判断波峰的阈值。</span>    <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 指定窗口长度的循环范围，从1到数据长度的1/2，使用循环变量k依次代表窗口长度。</span>        row_sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># 当前窗口的峰值指数之和</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> count <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 遍历当前窗口内的所有数据点，判断当前是否为峰值，如果当前点为峰值，则row_sum减去1，表示当前窗口内多了一个峰值。</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span> <span class="token keyword">and</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">:</span>                row_sum <span class="token operator">-=</span> <span class="token number">1</span>        arr_rowsum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>row_sum<span class="token punctuation">)</span> <span class="token comment"># 将当前窗口的峰值指数之和添加到列表arr_rowsum中，以便后续比较窗口质量。</span>    min_index <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>arr_rowsum<span class="token punctuation">)</span> <span class="token comment"># 使用NumPy库的argmin函数找到arr_rowsum中最小值对应的索引，也就是最小的峰值指数之和所对应的窗口长度，赋值给max_window_length</span>    max_window_length <span class="token operator">=</span> min_index    <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> max_window_length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> count <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 再次判断当前点是否为峰值，并将p_data数组中当前点的值加1，表示当前点出现在一个峰值之中，标记了这个峰值的位置。</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span> <span class="token keyword">and</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">:</span>                p_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>p_data <span class="token operator">==</span> max_window_length<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># 返回波峰所在索引值的列表</span>    <span class="token comment"># 注意：第一次对点进行判断，是为了计算当前窗口的峰值个数，用来衡量当前窗口的质量，也就是计算峰值指数之和。第二次对点进行判断，是为了标记每个峰值的位置。</span><span class="token triple-quoted-string string">"""用于模拟生成由3个信号叠加而成，其中包含了频率为100HZ和300HZ的信号以及随机噪声的长度为1000的数组y，来模拟真实环境下信号的特性"""</span><span class="token keyword">def</span> <span class="token function">sim_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    N <span class="token operator">=</span> <span class="token number">1000</span>    x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>    y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi <span class="token operator">*</span> <span class="token number">300</span> <span class="token operator">*</span> x<span class="token punctuation">)</span> \         <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">*</span> x<span class="token punctuation">)</span> \        <span class="token operator">+</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>N<span class="token punctuation">)</span>    <span class="token keyword">return</span> y<span class="token keyword">def</span> <span class="token function">wav_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 数据来源：https://github.com/LXP-Never/blog_data/tree/master/machine_learning_date</span>    <span class="token keyword">import</span> scipy<span class="token punctuation">.</span>io<span class="token punctuation">.</span>wavfile <span class="token keyword">as</span> wf    sample_rate<span class="token punctuation">,</span> noised_sigs <span class="token operator">=</span> wf<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token string">'../实验数据/music.wav'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sample_rate<span class="token punctuation">)</span>  <span class="token comment"># sample_rate：采样率44100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>noised_sigs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># noised_sigs:存储音频中每个采样点的采样位移(220500,)</span>    times <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>noised_sigs<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">/</span> sample_rate <span class="token comment"># 该数组中每个元素表示对应采样点的时刻（单位为秒）。</span>    <span class="token keyword">return</span> noised_sigs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3000</span><span class="token punctuation">]</span> <span class="token comment"># 只返回前3000个采样点的采样位移值，即只返回音频信号的前3000个采样点数据。</span><span class="token keyword">def</span> <span class="token function">vis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    y <span class="token operator">=</span> sim_data<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># y = wav_data()</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>    px <span class="token operator">=</span> AMPD<span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment"># 获取信号中的峰值位置px。</span>    plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>px<span class="token punctuation">,</span> y<span class="token punctuation">[</span>px<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"red"</span><span class="token punctuation">)</span> <span class="token comment"># 在原始信号图像上标注出峰值位置，峰值处的点具有红色。</span>    a <span class="token operator">=</span> plt<span class="token punctuation">.</span>axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">.4</span><span class="token punctuation">,</span> <span class="token number">.2</span><span class="token punctuation">,</span> <span class="token number">.4</span><span class="token punctuation">,</span> <span class="token number">.4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 创建一个新的子图，显示信号的局部细节，并将峰值可视化。</span>    a<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>px<span class="token punctuation">,</span> y<span class="token punctuation">[</span>px<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"red"</span><span class="token punctuation">)</span>    a<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">u"原信号"</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'green'</span><span class="token punctuation">)</span>    a<span class="token punctuation">.</span>set_xlim<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token comment"># 设置x轴的显示范围</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>vis<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以对该代码进一步优化，特别是在窗口长度的循环部分。一种可能的优化方法是使用numpy中的矩阵运算来替代循环操作，以提高计算效率。具体来说，可以使用np.maximum函数来找到每个窗口内的最大值，并将其与当前点的值进行比较，得到一个布尔型矩阵，其中True表示当前点处于峰值位置。然后使用np.sum函数对这个矩阵进行求和，即可得到当前窗口内的峰值数量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_peaks</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>     p_data <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>data<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>     count <span class="token operator">=</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>     arr_rowsum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 使用numpy矩阵运算替代循环操作 </span>        max_data <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         is_peak <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token operator">></span> max_data<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         row_sum <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>is_peak<span class="token punctuation">)</span>         arr_rowsum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>row_sum<span class="token punctuation">)</span>     min_index <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>arr_rowsum<span class="token punctuation">)</span>     max_window_length <span class="token operator">=</span> min_index     <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> max_window_length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 同样使用numpy矩阵运算替代循环操作 </span>        max_data <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         is_peak <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token operator">></span> max_data<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         p_data<span class="token punctuation">[</span>k<span class="token punctuation">:</span>count<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>is_peak<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">return</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>p_data <span class="token operator">==</span> max_window_length<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5新增元素</title>
      <link href="/2023/02/27/html5-xin-zeng-yuan-su/"/>
      <url>/2023/02/27/html5-xin-zeng-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h1><h2 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h2><p>HTML5新增的主要结构元素有6个：header、nav、article、aside、section、footer</p><h3 id="header元素"><a href="#header元素" class="headerlink" title="header元素"></a>header元素</h3><p>在HTML5中，header元素一般用于3个地方：页面头部、文章头部和区块元素。</p><ul><li>当header元素用于页面头部时，header元素一般用于包含网站名称、页面LOGO、顶部导航、介绍信息等。</li><li>当header元素用于文章头部时，header元素一般用于包含文章标题、meta信息。meta信息一般指作者、点赞数、评论数等。</li><li>当header元素用于区块头部时，header元素一般用于只包含区块的标题内容。</li></ul><h3 id="nav元素"><a href="#nav元素" class="headerlink" title="nav元素"></a>nav元素</h3><p>在HTML5中，nav元素一般用于3个地方：<strong>顶部导航</strong>、<strong>侧栏导航</strong>和<strong>分页导航</strong>。</p><p>当用于顶部导航时，nav元素可以放到header元素内部，也可以放到header元素外部。具体放在里面还是外面，取决于实际开发需求。</p><h3 id="article元素"><a href="#article元素" class="headerlink" title="article元素"></a>article元素</h3><p>在HTML5中，article元素一般只会用于一个地方：<strong>文章内容部分</strong>。</p><p>可以把article看成一个独立的部分，它内部可以包含标题以及其他部分。</p><blockquote><p>注意：在严格意义上，每一个article元素内部都应该有一个header元素。</p></blockquote><h3 id="aside元素"><a href="#aside元素" class="headerlink" title="aside元素"></a>aside元素</h3><p>在HTML5中，aside元素一般用于表示跟周围区域相关的内容。</p><h3 id="section元素"><a href="#section元素" class="headerlink" title="section元素"></a>section元素</h3><p>在HTML5中，section元素一般用于<strong>某一个需要标题内容的区块</strong>。</p><p>如果页面某个区块不需要标题，直接使用div元素即可，否则建议使用section元素。</p><p>在HTML5中，article、aside元素是比section元素更具语义化的元素，可以看成是特殊的seciton元素。</p><h3 id="footer元素"><a href="#footer元素" class="headerlink" title="footer元素"></a>footer元素</h3><p>在HTML5中，footer元素一般用于两个地方：一个是“<strong>页面底部</strong>”，另一个是“<strong>文章底部</strong>”。</p><p>当用于页面底部时，footer元素一般包含友情链接、版权声明、备案信息等。</p><p>当用于文章底部时，也就是放在article元素内部时，footer元素一般包含“上一篇&#x2F;下一篇导航”“文章分类”“发布信息”等。</p><h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><p>HTML5在HTML4.01的基础上，对表单进行了以下两个方向的扩展。</p><ul><li>新增input元素类型</li><li>新增其他表单元素</li></ul><h3 id="新增input元素类型"><a href="#新增input元素类型" class="headerlink" title="新增input元素类型"></a>新增input元素类型</h3><p>在HTML5中，大量地增加了input元素的种类——input元素的type属性新增了大量属性值：</p><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">email</td><td align="center">邮件类型</td></tr><tr><td align="center">tel</td><td align="center">电话号码</td></tr><tr><td align="center">url</td><td align="center">URL类型</td></tr></tbody></table><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">range</td><td align="center">取数字（滑块方式）</td></tr><tr><td align="center">number</td><td align="center">取数字（微调方式）</td></tr><tr><td align="center">color</td><td align="center">取颜色</td></tr></tbody></table><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">取日期（如2018-11-11）</td></tr><tr><td align="center">time</td><td align="center">取时间（如08:04)</td></tr><tr><td align="center">month</td><td align="center">取月份</td></tr><tr><td align="center">week</td><td align="center">取周数</td></tr></tbody></table><h4 id="验证型"><a href="#验证型" class="headerlink" title="验证型"></a>验证型</h4><h5 id="email"><a href="#email" class="headerlink" title="email"></a>email</h5><blockquote><p>注意：<strong>必须是submit按钮才会进行email验证，使用其他按钮（如button按钮）则不会。</strong>这是因为email类型的文本框采用了浏览器内置的验证机制，而浏览器内置的验证机制必须使用submit按钮才会触发。</p></blockquote><h5 id="tel"><a href="#tel" class="headerlink" title="tel"></a>tel</h5><blockquote><p>注意：tel类型文本框并不具备完整的验证功能，如果想要验证效果，则需要结合pattern属性来实现。</p></blockquote><h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><blockquote><p>注意：url类型文本框并不具备完整的验证功能，如果想要验证效果，则需要结合pattern属性来实现。</p></blockquote><h4 id="取值型"><a href="#取值型" class="headerlink" title="取值型"></a>取值型</h4><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><p>设置不同的value值，滑块也会出现在对应数值的位置。</p><h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>number类型和range类型功能非常相似，都是获取一个范围内的数字。不过两者的外观不同，其中number类型使用的是“微调按钮”，而range类型使用的是“滑块”。</p><h5 id="color"><a href="#color" class="headerlink" title="color"></a>color</h5><p>可通过直接使用浏览器自带的取色工具来获取颜色值。color类型元素不仅可以选择颜色，还可以将常用的颜色值添加到自定义颜色栏中，以便再次使用，非常方便。</p><h5 id="date"><a href="#date" class="headerlink" title="date"></a>date</h5><p>当我们点击date类型元素时，浏览器会弹出自带的日历工具，以方便直接选取日期。value属性用于设置日期初始值，格式必须如“2018-05-20”。</p><h5 id="time"><a href="#time" class="headerlink" title="time"></a>time</h5><p>可通过直接使用浏览器自带的工具来获取时间（时、分）。</p><h5 id="month"><a href="#month" class="headerlink" title="month"></a>month</h5><p>可通过直接使用浏览器自带的工具来获取“月数”。value属性用于设置月份初始值，格式必须如“2018-08”。</p><h5 id="week"><a href="#week" class="headerlink" title="week"></a>week</h5><p>可通过直接使用浏览器自带的工具来获取“周数”。value属性用于设置初始值，格式必须如“2018-W08”。其中W是week的缩写。</p><h3 id="新增其他表单元素"><a href="#新增其他表单元素" class="headerlink" title="新增其他表单元素"></a>新增其他表单元素</h3><p>HTML5还新增了3个表单元素：output、datalist、keygen。</p><h4 id="output元素"><a href="#output元素" class="headerlink" title="output元素"></a>output元素</h4><p>在HTML5中，可以使用output元素来定义表单元素的输出结果或计算结果。</p><p>output是一个<strong>行内元素</strong>，只不过它比span更具有语义化。<u>output元素一般放在form元素内部，并且配合其他表单元素来使用。</u></p><h4 id="datalist元素"><a href="#datalist元素" class="headerlink" title="datalist元素"></a>datalist元素</h4><p>在HTML5中，可以使用datalist元素来为文本框提供一个可选的列表。</p><p><u>如果想要把datalist绑定某个文本框，需要设置该文本框的list属性值等于datalist的id值。</u></p><h4 id="keygen元素"><a href="#keygen元素" class="headerlink" title="keygen元素"></a>keygen元素</h4><p>在HTML5中，可以使用keygen元素来生成页面的密钥。它在各大浏览器中的兼容性很差，仅作了解。</p><h2 id="其他新增元素"><a href="#其他新增元素" class="headerlink" title="其他新增元素"></a>其他新增元素</h2><p>HTML5还增加了大量语义化元素，其中最重要的有以下6个：</p><ul><li>address</li><li>time</li><li>progress</li><li>meter</li><li>figure和figcaption</li><li>fieldset和legend</li></ul><h3 id="address元素"><a href="#address元素" class="headerlink" title="address元素"></a>address元素</h3><p>在HTML5中，可以使用更具语义化的address元素来为“整个页面”或者“某一个article元素”添加地址信息（电子邮件或真实地址）。</p><h3 id="time元素"><a href="#time元素" class="headerlink" title="time元素"></a>time元素</h3><p>在HTML5中，可以使用更具语义化的time元素来显示页面中的日期时间信息。</p><p>其中datetime属性取值是一个时间，可以省略不写。datetime属性中的时间是提供给搜索引擎看的，而time标签内的时间是提供给用户看的，两者内容可以一样也可以不一样。time元素与datetime属性的关系，有点类似于img元素与alt元素的关系。</p><h3 id="progress元素"><a href="#progress元素" class="headerlink" title="progress元素"></a>progress元素</h3><p>在HTML5中，可以使用progress元素以进度条的形式来显示某一个任务的完成度。</p><p>对于progress元素来说，<strong>它只有max值而没有min值</strong>：任何进度条的最小值都是0，因此progress元素默认最小值也是0。此外，max和value必须是0或正数，并且max值必须大于等于value值。</p><h3 id="meter元素"><a href="#meter元素" class="headerlink" title="meter元素"></a>meter元素</h3><p>在HTML5中，可以使用进度条的形式来显示数据所占的比例。</p><p>meter元素和progress元素非常相似，都是以进度条形式来显示数据比例。不过，两者在语义上有很大的区别：</p><ul><li>meter元素一般用于显示<strong>静态数据</strong>比例。所谓的静态数据，指的是很少改变的数据。</li><li>progress元素一般用于显示<strong>动态数据</strong>比例。所谓的动态数据，指的是会不断改变的数据。</li></ul><h3 id="figure和figcaption元素"><a href="#figure和figcaption元素" class="headerlink" title="figure和figcaption元素"></a>figure和figcaption元素</h3><p><u>figure元素用于包含图片和图注，figcaption元素用于表示图注文字。</u>在实际开发中，对于“图片+图注”效果，我们都建议使用figure和figcation这两个元素来实现，从而使得页面的语义更加良好。</p><h3 id="fieldset和legend元素"><a href="#fieldset和legend元素" class="headerlink" title="fieldset和legend元素"></a>fieldset和legend元素</h3><p>在HTML5中，可以使用fieldset元素来给表单元素进行分组。其中，legend元素用于定义某一组表单的标题。</p><p>他们的作用一是可以增强表单的语义，二是可以定义field元素的disabled属性来禁用整个组中的表单元素。</p><h2 id="改良后的元素"><a href="#改良后的元素" class="headerlink" title="改良后的元素"></a>改良后的元素</h2><h3 id="a元素"><a href="#a元素" class="headerlink" title="a元素"></a>a元素</h3><p>HTML5为a元素新增了3个属性：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>download</td><td>定义可被下载的目标（如文件、图片等）</td></tr><tr><td>media</td><td>定义被链接文档为何种媒介&#x2F;设备优化的</td></tr><tr><td>type</td><td>定义被链接文档的MIME类型</td></tr></tbody></table><p>其中download属性用于为文件取一个新的文件名。如果download属性值省略，则表示使用旧的文件名。</p><h3 id="ol元素"><a href="#ol元素" class="headerlink" title="ol元素"></a>ol元素</h3><p>HTML5为ol元素新增了一个reversed属性，用于设置列表顺序为降序显示。</p><h3 id="small元素"><a href="#small元素" class="headerlink" title="small元素"></a>small元素</h3><p>在HTML5中，我们可以使用更具语义化的small元素来表示“小字印刷体”的文字。small元素一般用于网站底部的免责声明、版权声明等。</p><h3 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h3><p>HTML5为script元素新增了两个属性：defer和async。这两个属性的作用都是加快页面的加载速度，两者区别如下：</p><ul><li>defer属性用于异步加载外部JavaScript文件，当异步加载完成后，<strong>该外部JavaScript文件不会立即执行，而是等到整个HTML文档加载完成才会执行。</strong></li><li>async属性用于异步加载外部JavaScript文件，当异步加载完成后，<strong>该外部JavaScript文件会立即执行，即使整个HTML文档还没有加载完成。</strong></li></ul><p>defer和async都是异步加载的，两者区别在于，异步加载外部JavaScript文件完成后何时执行。从上面也可以看出，defer属性更符合大多数开发场景对脚本加载执行的要求。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式总结</title>
      <link href="/2023/01/09/zheng-ze-biao-da-shi-zong-jie/"/>
      <url>/2023/01/09/zheng-ze-biao-da-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式总结"><a href="#正则表达式总结" class="headerlink" title="正则表达式总结"></a>正则表达式总结</h1><h2 id="正则表达式入门"><a href="#正则表达式入门" class="headerlink" title="正则表达式入门"></a>正则表达式入门</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li>搜索文件中包含的字符</li><li>在Web网页中生成一些合法的HTML代码</li><li>检查电子邮件是否符合正确的语法格式</li><li>替换代码中的字符</li><li>定向检索包含某字符的文件</li><li>将数据批量导入应用程序</li><li>搜索文件中特定文本的位置</li></ol><p>根本上来说，正则表达式的两种基本用途：<strong>搜索</strong>和<strong>替换</strong></p><h3 id="正则表达式概念"><a href="#正则表达式概念" class="headerlink" title="正则表达式概念"></a>正则表达式概念</h3><p>正则表达式是一些用来匹配和处理文本的字符串，这种语言的用途就是为了解决我们前面所描述的种种问题。</p><h3 id="JavaScript中的正则表达式"><a href="#JavaScript中的正则表达式" class="headerlink" title="JavaScript中的正则表达式"></a>JavaScript中的正则表达式</h3><p>JavaScript 1.x版本在String和RegEx对象的以下几个方法里实现了正则表达式处理。</p><ul><li>exec：一个用来搜索一个匹配的RegEx方法</li><li>match：一个用来匹配一个字符串的String方法</li><li>replace：一个用来完成替换操作的String方法</li><li>search：一个用来测试在某给定字符串里是否存在着一个匹配String方法</li><li>split：一个用来把一个字符串拆分为多个子串的String方法</li><li>test：一个用来测试在某给定字符串里是否存在着一个匹配的RegEx方法</li></ul><p>注意：</p><ul><li>JavaScript使用命令行选项来管理全局的区分大小写搜索：g选项激活全局搜索功能，i选项让匹配操作不区分字母的大小写，这两个选项可以组合为gi。</li><li>其他命令行选项包括：m，支持多行字符串；s，支持单行字符串；x，忽略正则表达式模式里的空白字符。</li><li>在使用回溯引用的时候，$’将返回被匹配字符串前面的所有东西，$&#96;将返回被匹配字符串后面的所有东西，$+将返回最后一个被匹配的子表达式，$&amp;将返回被匹配到的所有东西。</li><li>JavaScript提供了一个名为RegExp的全局对象，在执行完一个正则表达式之后，你们可以通过这个对象获得与这次执行有关的信息。</li><li>JavaScript不支持POSIX字符类。</li><li>JavaScript不支持\A和\Z。</li></ul><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><h3 id="匹配纯文本"><a href="#匹配纯文本" class="headerlink" title="匹配纯文本"></a>匹配纯文本</h3><p>正则表达式可以包含<strong>纯文本</strong>（甚至可以只包含纯文本），所以看起来可能不像是一个正则表达式。当然，像这样使用正则表达式是一种浪费。</p><h3 id="多个匹配结果"><a href="#多个匹配结果" class="headerlink" title="多个匹配结果"></a>多个匹配结果</h3><p>绝大多数正则表达式引擎的<strong>默认行为是只返回第1个匹配结果</strong>。</p><blockquote><p>在JavaScript中，可选的为g（global，全局）标志将返回一个包含着所有匹配的结果数组。</p></blockquote><h3 id="字母的大小写问题"><a href="#字母的大小写问题" class="headerlink" title="字母的大小写问题"></a>字母的大小写问题</h3><p>正则表达式是<strong>区分字母大小写</strong>的。</p><blockquote><p>在JavaScript中，可以用i标志来强制执行一次不区分字母大小写的搜索。</p></blockquote><h3 id="匹配任意字符"><a href="#匹配任意字符" class="headerlink" title="匹配任意字符"></a>匹配任意字符</h3><p><code>.</code>字符可以匹配任何一个单个的字符（<strong>但在大多数的正则表达式中，<code>.</code>不能匹配换行符</strong>）。在SQL中相当于_字符。</p><h3 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h3><p>如果需要匹配<code>.</code>字符本身而不是它在正则表达式里的特殊含义，必须在<code>.</code>的前面加上一个<code>\</code>（反斜杠）字符来对它进行转义。</p><h2 id="匹配一组字符"><a href="#匹配一组字符" class="headerlink" title="匹配一组字符"></a>匹配一组字符</h2><h3 id="匹配多个字符中的某一个"><a href="#匹配多个字符中的某一个" class="headerlink" title="匹配多个字符中的某一个"></a>匹配多个字符中的某一个</h3><p>可以使用元字符<code>[</code>和<code>]</code>来定义一个字符集合。在字符集合中，这两个元字符之间的所有字符都是该集合的组成部分，字符集合的匹配结果是能够与该集合里的任意一个成员相匹配的文本。</p><p>注意：</p><ol><li><strong>字符集合中的字符涉及位置匹配问题。</strong></li><li>字符集合在<strong>不需要区分字母大小写的搜索操作中较为常见</strong>。最适合用在从全局看需要区分字母大小写，但在某个局部不需要区分字母大小写的搜索操作里。</li></ol><h3 id="利用字符集合区间"><a href="#利用字符集合区间" class="headerlink" title="利用字符集合区间"></a>利用字符集合区间</h3><p>使用正则表达式的时候，会频繁地用到一些字符区间。为了简化字符区间的定义，正则表达式提供了一个特殊的元字符，字符区间可以用<code>-</code>（连字符）来定义：</p><ul><li>A-Z：匹配从A到Z的所有大写字母。</li><li>a-z：匹配从a到Z的所有小写字母。</li><li>A-z：匹配从ASCII字符A到ASCII字符z的所有字母。这个模式一般不常用，因为它还包含着[和^等在ASCII字符表里排列在Z和a之间的字符。</li><li>0-9：数字区间。</li></ul><p>注意：</p><ol><li>在定义一个字符区间的时候，<strong>一定要避免让这个区间的尾字符小于它的首字符。</strong></li><li><code>-</code>是一个特殊的元字符，作为元字符它只能用在<code>[</code>和<code>]</code>之间。在字符集合以外的地方，<code>-</code>只是一个普通字符，只能与-本身相匹配，因此在正则表达式里，<code>-</code>字符不需要被转义。</li><li>在同一个字符集合里可以给出多个字符区间。</li></ol><h3 id="取非匹配"><a href="#取非匹配" class="headerlink" title="取非匹配"></a>取非匹配</h3><p>在某些场合，我们需要反过来做，给出一组不需要得到的字符。换句话说，除了那个字符集合中的字符，其他字符都可以匹配。</p><p>用元字符<code>^</code>来表明你想对一个字符集合进行<strong>取非匹配</strong>，和逻辑非运算很相似。</p><p>注意：</p><blockquote><p><strong><code>^</code>的效果将作用于给定字符集合里的所有字符或字符区间，而不是仅限于紧跟在<code>^</code>字符后面的那一个字符或字符区间。</strong></p></blockquote><h2 id="使用元字符"><a href="#使用元字符" class="headerlink" title="使用元字符"></a>使用元字符</h2><h3 id="对特殊字符进行转义"><a href="#对特殊字符进行转义" class="headerlink" title="对特殊字符进行转义"></a>对特殊字符进行转义</h3><p>任何一个元字符都可以通过给它加上一个反斜杠字符<code>\</code>作为前缀的办法来<strong>转义</strong>。</p><h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>空白元字符：</p><ul><li>[\b]：回退（并删除）一个字符</li><li>\f：换页符</li><li>\n：换行符</li><li>\r：回车符</li><li>\t：制表符</li><li>\v：垂直制表符</li></ul><h2 id="匹配特定的字符类别"><a href="#匹配特定的字符类别" class="headerlink" title="匹配特定的字符类别"></a>匹配特定的字符类别</h2><h3 id="匹配数字（与非数字）"><a href="#匹配数字（与非数字）" class="headerlink" title="匹配数字（与非数字）"></a>匹配数字（与非数字）</h3><ul><li>\d：任何一个数字字符</li><li>\D：任何一个非数字字符</li></ul><h3 id="匹配字母和数字（与非字母和数字）"><a href="#匹配字母和数字（与非字母和数字）" class="headerlink" title="匹配字母和数字（与非字母和数字）"></a>匹配字母和数字（与非字母和数字）</h3><ul><li>\w：任何一个字母数字字符（大小写均可）或下划线字符</li><li>\W：任何一个非字母数字或非下划线字符</li></ul><h3 id="匹配空白字符（与非空白字符）"><a href="#匹配空白字符（与非空白字符）" class="headerlink" title="匹配空白字符（与非空白字符）"></a>匹配空白字符（与非空白字符）</h3><ul><li>\s：任何一个空白字符（除了\b字符）</li><li>\S：任何一个非空白字符（除了\b字符）</li></ul><h3 id="匹配十六进制或八进制数值"><a href="#匹配十六进制或八进制数值" class="headerlink" title="匹配十六进制或八进制数值"></a>匹配十六进制或八进制数值</h3><p>使用十六进制：前缀\x来给出</p><p>使用八进制：前缀\0来给出</p><h2 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h2><h3 id="匹配一个或多个字符"><a href="#匹配一个或多个字符" class="headerlink" title="匹配一个或多个字符"></a>匹配一个或多个字符</h3><p>要想匹配<strong>同一个字符（或字符集合）的多次重复</strong>，只要简单地给这个字符（或字符集合）加上一个<code>+</code>元字符作为后缀即可。</p><blockquote><p>注意：要给一个字符集合加上<code>+</code>后缀时，<strong>必须把<code>+</code>放在这个字符集合的外面</strong>。</p></blockquote><h3 id="匹配零个或多个字符"><a href="#匹配零个或多个字符" class="headerlink" title="匹配零个或多个字符"></a>匹配零个或多个字符</h3><p>想要匹配一个可有可无的字符，需要使用<code>*</code>元字符来完成，用法和<code>+</code>完全一样，<strong>但可以匹配该字符（或字符集合）连续出现零次或多次的情况。</strong></p><h3 id="匹配零个或一个字符"><a href="#匹配零个或一个字符" class="headerlink" title="匹配零个或一个字符"></a>匹配零个或一个字符</h3><p><code>?</code>只能匹配一个字符（或字符集合）的<strong>零次或一次出现，最多不超过一次</strong>。</p><h3 id="匹配的重复次数"><a href="#匹配的重复次数" class="headerlink" title="匹配的重复次数"></a>匹配的重复次数</h3><p>正则表达式里的<code>+</code>、<code>*</code>和<code>?</code>解决了许多问题，但有些问题光靠它们还不够：</p><ul><li><code>+</code>和<code>*</code>匹配的字符个数<strong>没有上限</strong>。我们无法为它们将匹配的字符个数设定一个最大值。</li><li><code>+</code>、<code>*</code>和<code>?</code>至少匹配零个或一个字符。我们无法为它们将匹配的字符个数另行设定一个最小值。</li><li>如果只使用<code>+</code>和<code>*</code>，我们无法把它们将匹配的字符个数设定为一个精确的数字。</li></ul><p>正则表达式提供了一个用来设定重复次数的语法。重复次数要用<code>&#123;</code>和<code>&#125;</code>字符来给出，<strong>把数值写在它们之间</strong>。</p><h3 id="为重复匹配次数设定一个区间"><a href="#为重复匹配次数设定一个区间" class="headerlink" title="为重复匹配次数设定一个区间"></a>为重复匹配次数设定一个区间</h3><p> <code>&#123;</code> <code>&#125;</code>语法还可以用来为重复匹配次数设定一个区间，也就是为重复匹配次数设定一个最小值和一个最大值。例如区间{2,4}的含义是最少重复2次，最多重复4次。</p><h3 id="匹配“至少重复多少次”"><a href="#匹配“至少重复多少次”" class="headerlink" title="匹配“至少重复多少次”"></a>匹配“至少重复多少次”</h3><p> <code>&#123;</code> <code>&#125;</code>语法的最后一种用法是给出一个最小的重复次数（但不必给出一个最大值）。<code>&#123;</code> <code>&#125;</code>的这种用法与我们用来为重复匹配次数设定一个区间的 <code>&#123;</code> <code>&#125;</code>语法很相似，只是省略了最大值部分而已。</p><h3 id="防止过度匹配"><a href="#防止过度匹配" class="headerlink" title="防止过度匹配"></a>防止过度匹配</h3><p><code>*</code>和<code>+</code>元字符在重复匹配次数方面都没有上限值，而这样做<strong>有时会导致过度匹配</strong>的现象。</p><p>因为<code>*</code>和<code>+</code>都是所谓的“贪婪型”元字符，它们在进行匹配时的行为模式是多多益善而不是适可而止的，<strong>它们会尽可能地从一段文本的开头一直匹配到这段文本的末尾，而不是从这段文本的开头匹配到碰到第一个匹配时为止。</strong></p><p>使用“懒惰型”版本可以避免这个问题，写法很简单，只要给贪婪型元字符加上一个<code>?</code>后缀即可。</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><p>在某些场合，只需要对某段文本的<strong>特定位置</strong>进行匹配，这就引出了位置匹配的概念。</p><h3 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h3><p>使用边界限定符，也就是在正则表达式里用一些特殊的元字符来表明我们想让匹配操作在什么位置（或边界）发生。</p><p>第一种边界：由限定符<code>\b</code>指定的单词边界，<code>\b</code>用来匹配一个单词的开始或结尾。</p><p>注意：</p><ul><li>如果你想匹配一个<strong>完整的单独的单词</strong>，就必须在你想要匹配的文本的<strong>前后</strong>都加上<code>\b</code>限定符。</li><li>\b匹配且只匹配一个位置，不匹配任何字符。</li></ul><p>如果你想表明不匹配一个单词边界，请使用<code>\B</code>（例如查找前后都有多余空格的连字符）。</p><h3 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h3><p>用来定义字符串边界的元字符有两个：<strong>一个是用来定义字符串开头的<code>^</code>，另一个是用来定义字符串结尾的<code>$</code>。</strong></p><p>注意：^是几个有着多种用途的元字符之一。</p><ul><li>只有当它<strong>出现在一个字符集合里并紧跟在左方括号[的后面时，它才能发挥求非的作用</strong>。</li><li>如果是在<strong>一个字符集合的外面并位于一个模式的开头，<code>^</code>将匹配字符串的开头</strong>。</li></ul><h3 id="分行匹配模式"><a href="#分行匹配模式" class="headerlink" title="分行匹配模式"></a>分行匹配模式</h3><p>用来启用分行匹配模式的<code>(?m)</code>记号就是一个能够改变其他元字符行为的元字符序列（<strong>必须出现在整个模式的最前面</strong>）。</p><p>分行匹配模式将使得正则表达式引擎把<strong>行分隔符当作一个字符串分隔符来对待</strong>，在分行匹配模式下，^不仅匹配正常的字符串开头，还将匹配行分隔符（换行符）后面的开始位置（这个位置是不可见的）；类似地，$不仅匹配正常的字符串结尾，还讲匹配行分隔符（换行符）后面的结束位置。</p><p>警告：有许多正则表达式实现不支持<code>(?m)</code>。</p><h2 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h2><p>子表达式是一个更大的表达式的一部分：把一个表达式划分为一系列子表达式的<strong>目的是为了把那些子表达式当作一个独立元素来使用。</strong></p><p>子表达式必须用<code>(</code>和<code>)</code>括起来。</p><h3 id="子表达式的嵌套"><a href="#子表达式的嵌套" class="headerlink" title="子表达式的嵌套"></a>子表达式的嵌套</h3><p>子表达式允许多重嵌套，这种嵌套的层次在理论上没有限制，但在实际工作中还是应该遵循适可而止的原则。</p><h2 id="回溯引用：前后一致匹配"><a href="#回溯引用：前后一致匹配" class="headerlink" title="回溯引用：前后一致匹配"></a>回溯引用：前后一致匹配</h2><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p><strong>某个模式的第二部分对这个模式的第一部分毫无所知</strong>，即使匹配到也有可能是不合法的编程语言写法，所以需要借助回溯引用。</p><h3 id="回溯引用匹配"><a href="#回溯引用匹配" class="headerlink" title="回溯引用匹配"></a>回溯引用匹配</h3><p>回溯引用指的是<strong>模式的后半部分引用在前半部分中定义的子表达式</strong>。——可以将回溯引用想象成<strong>变量</strong>。</p><p>注意：</p><ol><li>回溯引用只能用来引用模式里的<strong>子表达式</strong>。</li><li>回溯引用匹配通常从1开始计数（\1、\2等）。在许多现实里，第0个匹配（\0）可以用来代表整个正则表达式。</li><li>子表达式是通过它们的相对位置来引用的。虽然收到普遍的支持，但这种语法存在着一个严重的不足：如果子表达式的想对位置发生了变化，整个模式也许就不能再完成原来的工作，删除或添加子表达式的后果可能更为严重。<ul><li>为了弥补这一不足，一些比较新的正则表达式实现还支持“命名捕获”：给某个子表达式起一个唯一的名字，然后用这个名字（而不是相对位置）来引用这个子表达式，但还没有得到广泛支持，而且已支持的实现具体的语法也极不统一。</li></ul></li></ol><h3 id="回溯引用在替换操作中的应用"><a href="#回溯引用在替换操作中的应用" class="headerlink" title="回溯引用在替换操作中的应用"></a>回溯引用在替换操作中的应用</h3><p>同一个子表达式可以被引用任意多次，只要在需要用到它的地方写出它的回溯引用就行了。</p><p>在JavaScript中使用<code>$</code>符号引用。</p><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p>有些正则表达式实现允许我们使用元字符对字母进行大小写转换。</p><ul><li>\E：结束\L或\U转换</li><li>\l：把下一个字符转换为小写</li><li>\L：把\L到\E之间的字符全部转换为小写</li><li>\u：把下一个字符转换为大写</li><li>\U：把\U到\E之间的字符全部转换为大写</li></ul><h2 id="前后查找"><a href="#前后查找" class="headerlink" title="前后查找"></a>前后查找</h2><p>前文中正则表达式都是用来匹配文本的，但有时我们还需要使用正则表达式标记我们想要匹配的文本的位置（不仅仅是文本本身）。这就引出了前后查找（对某一位置的前、后内容进行查找）的概念。</p><p> 注意：JavaScript仅支持向前查找。</p><h3 id="向前查找"><a href="#向前查找" class="headerlink" title="向前查找"></a>向前查找</h3><p>向前查找指定了一个<strong>必须匹配但不在结果中返回的模式</strong>。（<strong>它必须用在一个子表达式里</strong>）</p><p>从语法上来看，一个向前查找模式其实就是一个以<code>?=</code>开头的子表达式，需要匹配的文本跟在<code>=</code>的后面。</p><p><strong>在向前查找里，被匹配的文本不包含在最终返回的匹配结果里，这被称为“不消费”。</strong></p><blockquote><p>注意：向前查找模式<code>?=</code>其实和子表达式<code>(</code> <code>)</code>匹配的东西是一样的，<strong>区别在于匹配到的字符是否出现在最终的匹配结果里。</strong></p></blockquote><h3 id="向后查找"><a href="#向后查找" class="headerlink" title="向后查找"></a>向后查找</h3><p>向后查找就是<strong>查找出现在被匹配文本之前的字符（但不消费它）</strong>，向后查找操作符是<code>?&lt;=</code>。</p><p>警告：</p><ul><li><strong>向前查找模式的长度是可变的</strong>，它们可以包含<code>.</code>和<code>+</code>之类的元字符，所以非常灵活。</li><li><strong>向后查找模式只能是固定长度</strong>。</li></ul><h3 id="对前后查找取非"><a href="#对前后查找取非" class="headerlink" title="对前后查找取非"></a>对前后查找取非</h3><p>前后查找还有一种不太常见的用法叫做负前后查找。负向前查找将<strong>向前查找不与给定模式相匹配的文本</strong>，负向后查找<strong>将向后查找不与给定模式相匹配的文本</strong>。</p><p>负前后查找使用<code>!</code>来取非（它将替换掉<code>=</code>）。</p><h2 id="嵌入条件"><a href="#嵌入条件" class="headerlink" title="嵌入条件"></a>嵌入条件</h2><h3 id="正则表达式中的条件"><a href="#正则表达式中的条件" class="headerlink" title="正则表达式中的条件"></a>正则表达式中的条件</h3><p>正则表达式里的条件要用<code>?</code>来定义。嵌入条件分为以下两种情况：</p><ol><li>根据一个回溯引用来进行条件处理。</li><li>根据一个前后查找来进行条件处理。</li></ol><h3 id="回溯引用条件"><a href="#回溯引用条件" class="headerlink" title="回溯引用条件"></a>回溯引用条件</h3><p>回溯引用条件只在一个<strong>前面的子表达式搜索取得成功的情况下才允许使用一个表达式</strong>。</p><p>用来定义这种条件的语法是<code>(?(backreference)true-regex)</code>，其中<code>?</code>表明这是一个条件，括号里的backreference是一个回溯引用，true-regex是一个只在backreference存在时才会被执行的子表达式。</p><p>条件还可以有否则表达式，否则表达式只在给定的回溯引用不存在（也就是条件没有得到满足）时才会被执行。用来定义这种条件的语法是<code>(?(backreference)true-regex | false-regex)</code>，这个语法接受一个条件和两个将分别在这个条件得到满足和没有得到满足时执行的子表达式。</p><h3 id="前后查找条件"><a href="#前后查找条件" class="headerlink" title="前后查找条件"></a>前后查找条件</h3><p>前后查找条件只在一个向前查找或向后查找操作取得成功的情况下才允许一个表达式被使用。定义一个前后查找条件的语法与定义一个回溯引用条件的语法大同小异，只需把回溯引用（括号里的回溯引用编号）替换为一个完整的前后查找表达式就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6标准总结</title>
      <link href="/2023/01/08/es6-biao-zhun-zong-jie/"/>
      <url>/2023/01/08/es6-biao-zhun-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6标准总结"><a href="#ES6标准总结" class="headerlink" title="ES6标准总结"></a>ES6标准总结</h1><h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><ol><li>声明的变量只在let命令所在的代码块内有效。</li><li>声明的变量一定要在声明后使用，否则报错。</li><li>只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部影响（封闭作用域）。</li><li>不允许在相同作用域内重复声明同一个变量。</li><li>为JavaScript新增了块级作用域，防止了内层变量覆盖外层变量或泄露为全局变量。</li><li>在块级作用域之前加上do，使得块级作用域可以变为表达式，得到返回值（本质上块级作用域是一个语句，没有返回值）。</li></ol><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ol><li>声明一个只读的常量。一旦声明，常量的值就不能改变。</li><li>一旦声明常量，就必须立即初始化，不能留到以后赋值。</li><li>只在声明所在的块级作用域内有效。</li><li>声明的变量一定要在声明后使用，否则报错。</li><li>const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。<ul><li>对于简单类型的数据（数值、字符串、布尔值〉而言，值就保存在变量指向的内存地址中，因此等同于常量。</li><li>但对于复合类型的数据（主要是 对象和数组）而言，变量指向的内存地址保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。</li></ul></li></ol><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>在ES5中，顶层变量（在浏览器环境中指的是window对象，在Node环境中指的是global对象）&#x3D;全局变量，有以下缺点：</p><ol><li>无法在编译时就提示变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。</li><li>很容易不知不觉地就创建全局变量。</li><li>顶层对象的属性是到处都可以读写的，这非常不利于模块化编程。</li><li>window对象有实体含义，指的是浏览器的窗口对象，这样也是不合适的。</li></ol><p>从ES6开始，全局变量逐步与顶层对象的属性隔离：</p><ol><li>var命令和function命令声明的全局变量 &#x3D; 顶层对象的属性。</li><li>let命令、const命令、class命令声明的全局变量 ≠ 顶层对象的属性。</li></ol><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>ES6允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构。</p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><ol><li><p>模式匹配——只要等号两边的模式（对应位置）相同，左边的变量就会被赋予对应的值。</p></li><li><p>解构不成功，变量的值等于undefined。</p></li><li><p>不完全解构，即等号左边的模式只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p></li><li><p>如果等号的右边不是数组（严格来说不是可遍历的结构），那么将会报错。</p><p>因为等号右边的值或是转为对象以后不具备Iterator接口，或是本身就不具备Iterator接口。</p></li><li><p>解构赋值允许指定默认值。默认值生效的条件是，数组成员的属性值严格等于undefined。</p><ul><li>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到时才会求值。</li><li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</li></ul></li></ol><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><ol><li>对象的属性没有次序，变量必须与属性同名才能取到正确的值。</li><li>解构赋值允许指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。</li><li>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</li><li>应该将整个解构赋值语句放在一个圆括号里面，否则JavaScript引擎会将句首{}理解成一个代码块，从而发生语法错误。</li><li>解构赋值允许等号左边的模式之中不放置任何变量名。</li><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</li></ol><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><ol><li>字符串被转换了一个类似数组的对象，所以也可以解构赋值。</li><li>类似数组的对象都有一个length属性，因此还可以对这个属性进行解构赋值。</li></ol><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><ol><li>如果等号右边是数值和布尔值，则会先转为对象。</li><li>只要等号右边的值不是对象或数组，就先将其转为对象。</li></ol><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><ol><li>只要有可能导致解构的歧义，就不得使用圆括号。<ul><li>变量声明语句，模式不能使用圆括号。</li><li>函数参数属于变量声明，不能使用圆括号。</li><li>赋值语句的模式不能使用圆括号。</li></ul></li><li>可以使用圆括号的情况只有一种：赋值语句的非模式部分可以使用圆括号。</li></ol><h3 id="解构用途"><a href="#解构用途" class="headerlink" title="解构用途"></a>解构用途</h3><ol><li>交换变量的值</li><li>从函数返回多个值</li><li>设置函数参数</li><li>提取JSON数据</li><li>设置函数参数的默认值</li><li>遍历Map结构</li><li>输入模块的指定方法</li></ol><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h3><ol><li>JavaScript允许采用 \uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。但是，这种表示法只限于码点在 \u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用2个双字节的形式表达。</li><li>ES6允许将码点放入大括号，就能正确解读该字符。</li></ol><h3 id="CodePointAt"><a href="#CodePointAt" class="headerlink" title="CodePointAt()"></a>CodePointAt()</h3><ol><li>JavaScript内部，字符以UTF-16的格式存储，每个字符固定为2个字节。对于那些需要4个字节存储的字符，JavaScript会认为它们是两个字符。</li><li>ES6提供了codePointAt()方法，能够正确处理4个字节存储的字符，返回一个字符的码点（十进制值）。</li><li>该方法定义在字符串的实例对象上。</li></ol><h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><ol><li>可以识别大于 0xFFFF 的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</li><li>该方法定义在String对象上。</li></ol><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><ol><li>ES6为字符串添加了遍历器接口，使得字符串可以由for…of循环遍历。除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</li></ol><h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><ol><li>字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。</li></ol><h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><ol><li>ES6为字符串实例提供了normalize方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</li></ol><h3 id="其余方法"><a href="#其余方法" class="headerlink" title="其余方法"></a>其余方法</h3><ol><li>includes()：返回布尔值，表示是否找到了参数字符串。（使用第二个参数n，针对从第n个位置到字符串结束位置之间的字符）</li><li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。（使用第二个参数n，针对从第n个位置到字符串结束位置之间的字符）</li><li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。（使用第二个参数n，针对前n个字符）</li></ol><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>返回一个新字符串，表示将原字符串重复n次。</p><ol><li>参数如果是小数，会被取整。</li><li>参数如果是负数或者Infinity，会报错。</li><li>参数如果是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。</li><li>参数如果是NaN等同于0。</li><li>参数如果是字符串，则会先转换成数字。</li></ol><h3 id="padStart-、padEnd"><a href="#padStart-、padEnd" class="headerlink" title="padStart()、padEnd()"></a>padStart()、padEnd()</h3><p>如果某个字符串不够指定长度，会在头部或者尾部补全。</p><p>padStart()用于头部补全，padEnd()用于尾部补全。</p><ol><li>第一个参数：指定字符串的最小长度</li><li>第二个参数：用来补全的字符串</li><li>如果原字符串的长度等于或大于指定的最小长度，则返回原字符串。</li><li>如果用来补全的宇符串与原字符串的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</li><li>如果省略第二个参数，则会用空格来补全。</li><li>可用来提示字符串格式。</li></ol><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>增强版的字符串，用反引号（&#96;）标识。</p><ol><li>可以当作普通字符串使用</li><li>可以用来定义多行字符串</li><li>字符串中嵌入变量</li><li>如果在模板字符串中需要使用反引号，则在其前面要用反斜杠转义。</li><li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出中。</li><li>大括号内可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</li><li>如果大括号中的值不是字符串，将按照一般的规则转换为字符串（例如对象）。</li><li>模板字符串中还能调用函数。</li><li>如果模板字符串中的变量没有声明，将报错。</li></ol><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</p><h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h3><p>该方法往往用来充当模板字符串的处理函数，返回一个反斜线都被转义（即反斜线前面再加一个反斜线）的字符串，对应于替换变量后的模板字符串。</p><ol><li>如果原字符串中的反斜线已经被转义，那么String.raw不会做任何处理。</li><li>该方法也可以作为正常的函数使用，其第一个参数应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</li></ol><h3 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h3><p>标签模板中可以内嵌其他语言，但是模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p><ol><li>有一个解决方法是放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，且从raw属性上可以得到原始字符串（只在标签模板解析字符串时生效，非标签模板场合依然会报错。）。</li></ol><h2 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h2><h3 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h3><p>在ES5中，RegExp构造函数的参数有两种情况：</p><ol><li>第一种情况：参数是字符串，这时第二个参数表示正则表达式的修饰符。</li><li>第二种情况：参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝。但是，此时ES5不允许使用第二个参数添加修饰符，否则会报错。</li></ol><p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有正则表达式的修饰符，只使用新指定的修饰符。</p><h3 id="U修饰符"><a href="#U修饰符" class="headerlink" title="U修饰符"></a>U修饰符</h3><p>ES6对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，可以正确处理4个字节的UTF-16编码。</p><h4 id="点字符"><a href="#点字符" class="headerlink" title="点字符"></a>点字符</h4><p><code>.</code>字符在正则表达式中的含义是除换行符以外的任意单个字符，对于码点大于0xFFFF的Unicode字符，<code>.</code>字符不能识别，必须加上u修饰符。</p><p>后面的以后再写，懒得写了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6标准入门</title>
      <link href="/2022/11/08/es6-biao-zhun-ru-men/"/>
      <url>/2022/11/08/es6-biao-zhun-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>为什么选择ES6的Promise？——Promise能比较好地解决<strong>异步嵌套</strong>问题，ES6代表前端的未来，涉及很多现代编程语言概念中很流行的部分，让前端程序员的代码更加优美并且能够向前兼容。</p></blockquote><h3 id="ES6和JS的关系"><a href="#ES6和JS的关系" class="headerlink" title="ES6和JS的关系"></a>ES6和JS的关系</h3><blockquote><p>ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的 一 种实现。</p></blockquote><h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6中的let命令用法类似于var，但是<strong>所声明的变量只在let命令所在的代码块内生效</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a <span class="token comment">// ReferenceError: a is not defined.</span>b <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>for循环的计数器就很适合使用let命令：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 如果此处使用var变量，则a[6]为10</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因如下：</p><ul><li><p>如果变量 i 是用var声明的，则该变量在全局范围内都有效，全局只有一个变量 i，每一次循环i的值都会发生变化。也就是说，所有数组 a 的成员中的 i 指向的都是同 一个 i ，导致运行时输出的是最后一轮的 i 值，也就是 10 。</p></li><li><p>如果变量 i 是用let声明的，则当前i只在本轮循环中有效，所以每一次循环 i 都是一个新的变量，所以最终输出6</p><blockquote><p>如果每一轮循环的变量 i 都是重新声明的，那么它怎么知道上一轮的循环的值从而计算出本轮循环的值呢？</p><p>JavaScript引擎内部会<strong>记住</strong>上一次循环的值，初始化本轮的 i 值时，就在上一轮的循环中计算。</p></blockquote></li></ul><p>此外，for循环还有一个特别之处：<strong>设置循环变量的那一部分是一个父作用域，循环内部是一个单独的子作用域</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token string">'abc'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// abc</span><span class="token comment">// abc</span><span class="token comment">// abc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><ul><li>var命令会出现变量提升现象，即变量可以在声明前使用，值为undefined。</li><li><strong>let所声明的变量一定要在声明后使用</strong></li></ul><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><blockquote><p>只要块级作用域存在let命令，它所声明的变量就“<strong>绑定</strong>”这个区域，不受外部影响：</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tmp <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span><span class="token keyword">let</span> tmp<span class="token punctuation">;</span> <span class="token comment">// let的声明导致tmp变量绑定这个作用域</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上称为“<strong>暂时性死区</strong>”（temporal deadzone，简称TDZ）。</p><p>“暂时性死区”也意味着 typeof 不再是一个百分之百的安全操作。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">typeof</span> x<span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span><span class="token keyword">let</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的代码中，变量x使用let命令声明，所以在声明之前都属于x的“死区”，只要用到该变量就会报错。</p><p>几种较为隐蔽的“死区”：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//1.</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">x <span class="token operator">=</span> y<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 之所以调用bar函数报错，是因为参数x的默认值等于另一个参数y，而此时y还没有声明。如果y的默认值是x，就不会报错。</span><span class="token punctuation">&#125;</span><span class="token comment">//2.</span><span class="token comment">// 不报错</span><span class="token keyword">var</span> x <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">// 报错</span><span class="token keyword">let</span> x <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">// ReferenceError:x is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p><strong>let不允许在相同作用域内重复声明同一个变量。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 报错</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 报错</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> arg <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h4><ol><li><strong>外层作用域无法读取内层作用域的变量</strong></li><li><strong>内层作用域可以定义外层作用域的同名变量</strong></li></ol><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数匿名函数（IIFE）不再必要了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// IIFE写法</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 块级作用域写法</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> tmp <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>ES6引入了块级作用域，明确<strong>允许在块级作用域之中声明函数</strong>。</p><p>ES6规定，在块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><blockquote><p>注意：在ES6浏览器中，块级作用域内声明函数的行为类似于var声明变量！</p></blockquote><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成<strong>函数表达式的形式</strong>，而不是函数声明语句：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：ES6的块级作用域允许声明函数的规则<strong>只在使用大括号的情况下成立</strong>，如果没用使用大括号则会报错！</p></blockquote><h4 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h4><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没用返回值。即在外部无法获取块级作用域内部变量的值。</p><p>现在有一个提案，使得块级作用域可以变为表达式，即可以返回值，方法就是在<strong>块级作用域之前加上do语句</strong>，使它变为do表达式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">do</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t <span class="token operator">*</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 变量x会得到整个块级作用域的返回值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><blockquote><p>const声明一个只读的常量，一旦声明，常量的值就不能改变。</p><p>————这意味着，const一旦声明常量，就<strong>必须立即进行初始化</strong>，不能留到以后赋值。</p></blockquote><ul><li>const作用域与let命令相同，只在声明所在的块级作用域内有效。</li><li>const命令声明的常量也不会提升，同样存在暂存性死区，只能在声明后使用。</li><li>const声明常量和let一样，不可重复声明</li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>const实际上保证的并不是变量的值不得改动，而是变量指向的<strong>那个内存地址</strong>不得改动。</p><p>对于简单类型的数据（数值、字符串、布尔值）而言，值就保存在变量指向的内存地址中，因此等同于常量。</p><p>但对于复合类型的数据（主要是对象和数组）而言，变量指向的内存地址保存的<strong>只是一个指针</strong>，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。——因此声明一个对象为常量时必须非常小心。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 为foo添加一个属性，可以成功</span>foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span>prop <span class="token comment">// 123</span><span class="token comment">// 将foo指向另一个对象，就会报错</span>foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: "foo" is read-only</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：不可变的只是这个对象的地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p></blockquote><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code> 方法。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> foo <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 常规模式时，下面一行不起作用，因为该对象被冻结</span><span class="token comment">// 严格模式时，改行会报错</span>foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">constantize</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">constantize</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ES6声明变量的六种方法"><a href="#ES6声明变量的六种方法" class="headerlink" title="ES6声明变量的六种方法"></a>ES6声明变量的六种方法</h4><ul><li>var命令</li><li>function命令</li><li>let命令</li><li>const命令</li><li>import命令</li><li>class命令</li></ul><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>顶层对象在浏览器环境中指的是window对象，在Node环境中指的是global对象。在ES5中，顶层对象的属性与全局变量是等价的。</p><p>顶层对象的属性与全局变量相关，被认为是JavaScript语言中最大的设计败笔之一 ：</p><ol><li>无法在编译时就提示变量未声明的错误，只有在运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。</li><li>程序员很容易不知不觉地创建全局变量。</li><li>顶层对象的属性是到处都可以读写的，这非常不利于模块化编程。</li><li>window对象有实体含义，指的是浏览器的窗口对象，这样也是不合适的。</li></ol><p>ES6为了改变这一点，规定：</p><blockquote><ul><li><strong>为了保持兼容性，var命令和function命令声明的全局变量依旧是顶层对象的属性</strong></li><li><strong>另一方面规定，let命令、const命令、class命令声明的全局变量不属于顶层对象的属性</strong></li></ul></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 如果在Node的REPL环境，可以写成gloabal.a</span><span class="token comment">// 或者采用通用方法，写成this.a</span>window<span class="token punctuation">.</span>a <span class="token comment">// 1</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span>b <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>ES5的顶层对象本身也是一个问题，因为它在各种实现中是不统一的。</p><ul><li><strong>在浏览器中，顶层对象是window，但 Node 和 Web Worker 没有 window。</strong></li><li>在浏览器和Web Worker中，self也指向顶层对象，但是Node没有self。</li><li><strong>在Node中，顶层对象是global，但其他环境都不支持。</strong></li></ul><p>同一段代码为了能够在各种环境中取到顶层对象，目前一般是使用<code>this</code>变量，但是也有局限性。</p><ul><li>在全局环境中，this 会返回顶层对象。<strong>但是，在 Node 模块和 ES6模块中，this返回的是当前模块。</strong></li><li>对于函数中的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，this会返回 undefined。</li><li>不管是严格模式，还是普通模式，<code>new Function (&#39;return this&#39;) ()</code>总会返回全局对象。但是，如果浏览器用了 CSP（内容安全政策），那么eval、new Function 这些方法都可能无法使用。</li></ul><p>现有一个提案，在语言标准的局面引入 <code>global</code> 作为顶层对象。也就是说，<code>global</code> 都是存在的，都可以拿到顶层对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// CommonJS的写法</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'system.global/shim'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ES6模块的写法</span><span class="token keyword">import</span> shim <span class="token keyword">from</span> <span class="token string">'system.global/shim'</span><span class="token punctuation">;</span> <span class="token function">shim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码可以保证，在各种环境中global对象都是存在的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// CommonJS的写法</span><span class="token keyword">var</span> global <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'system.global'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ES6模块的写法</span><span class="token keyword">import</span> getGlobal <span class="token keyword">from</span> <span class="token string">'system.global'</span><span class="token punctuation">;</span><span class="token keyword">const</span> global <span class="token operator">=</span> <span class="token function">getGlobal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码将顶层对象放入变量global中。</p><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h3><h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li>ES6语法可以从数组中提取值，按照对应位置对变量赋值：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>bar<span class="token punctuation">]</span><span class="token punctuation">,</span> baz<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> third<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token string">'baz'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>head<span class="token punctuation">,</span> <span class="token operator">...</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>head <span class="token comment">// 1</span>tail <span class="token comment">// [2, 3, 4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本质上这种写法属于<strong>模式匹配</strong>，只要等号两边的模式相同，左边的变量就会赋予对应的值。</p><ul><li>如果解构不成功，变量的值就等于undefined。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>bar<span class="token punctuation">,</span> foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>另一种情况是不完全解构，即等号左边的模式<strong>只匹配一部分的等号右边的数组</strong>，这种情况下，解构依然可以成功。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>x <span class="token comment">// 1</span>y <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果等号的右边不是数组（或者严格说不是可遍历的结构）那么将会报错：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 报错</span><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NAN</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的语句都会报错，因为等号右边的值或是转为对象以后不具备Iterator接口，或是本身就不具备Iterator接口。</p><p>对于Set结构，也可以使用数组的解构赋值——<strong>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</strong></p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul><li>解构赋值允许指定默认值：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>foo <span class="token comment">// true</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x = 'a', y = 'b'</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x = 'a', y = 'b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：ES6内部使用严格相等运算符（&#x3D;&#x3D;&#x3D;）判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p></blockquote><p>例如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">undefined</span><span class="token punctuation">]</span><span class="token punctuation">;</span>x <span class="token comment">// 1</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">]</span><span class="token punctuation">;</span>x <span class="token comment">// null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined</p><ul><li>如果默认值是一个表达式，那么这个表达式是<strong>惰性求值</strong>的，<strong>即只有在用到时才会求值</strong>。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'aaa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>上面的代码中，因为x能取到值，所以函数f根本不会执行。上面的代码等价如下：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>默认值可以引用解构赋值的其他变量，<strong>但该变量必须已经声明</strong>。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x=1; y=1</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x=2; y=2</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x=1; y=2</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> y<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// ReferenceError</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p><blockquote><p>对象的解构和数组有一个重要的不同——</p><p>数组的元素是按次序排列的，变量的取值是由它的位置决定的；</p><p>而对象的属性没有次序，<strong>变量必须与属性同名才能取到正确的值。</strong></p></blockquote><p>如果变量名和属性名不一致，必须写成下面这样：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> baz <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">'bbb'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>baz <span class="token comment">// 'aaa'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，对象的赋值解解构是下面形式的简写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> foo<span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> bar <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">'bbb'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>也就是说，对象的解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量。<strong>真正被赋值的是后者，而不是前者。</strong></p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> baz <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">'bbb'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>baz <span class="token comment">// "aaa"</span>foo <span class="token comment">// error: foo is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><ul><li>与数组一样，解构也可以用于嵌套结构的对象。</li><li>对象的解构也可以指定默认值——默认值生效的条件是，对象的属性值严格等于undefined。</li><li><strong>如果解构失败，变量的值等于<code>undefined</code>。</strong></li><li><strong>如果解构模式是嵌套的对象，且子对象所在的父属性不存在，那么将会报错。</strong></li></ul><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// SyntaxError: syntax error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为JavaScript引擎会将 {x} 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>关于圆括号与赋值结构的关系，参见下文：</p><p>解构赋值允许等号左边的模式之中不放置任何变量名：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的表达式虽然毫无意义，但可以执行。</p><p>对象的解构赋值可以很方便地将现有对象的方法赋值到某个变量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">&#123;</span> log<span class="token punctuation">,</span> sin<span class="token punctuation">,</span> cos <span class="token punctuation">&#125;</span> <span class="token operator">=</span> Math<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的代码将Math对象的对数、正弦、余弦三个方法赋值到对应的变量上，使用起来就方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><ul><li>字符串可以解构赋值，因为此时<strong>字符串被转换成了一个类似数组的对象</strong>。</li><li>类似数组的对象都有一个length对象，因此还可以对这个属性进行解构赋值。</li></ul><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是<strong>数值</strong>和<strong>布尔值</strong>，则会先转为对象。</p><blockquote><p>赋值解构的规则是：<strong>只要等号右边的值不是对象或数组，就先将其转为对象。</strong></p><p>由于undefined和null无法转换为对象，所以对它们进行解构赋值时会报错。</p></blockquote><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y，对于函数内部的代码来说，它们能感受到的参数就是x和y。</p><p>另一个例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [3, 7]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。<br>由此带来的问题是，如果模式中出现圆括号该怎么处理？</p><blockquote><p>ES6的规则是，只要有可能导致解构的歧义，就<strong>不得使用圆括号</strong>。</p></blockquote><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><ol><li>变量声明语句</li><li>函数参数</li><li>赋值语句的模式，即将整个模式放在圆括号中（而非将整个赋值语句放在圆括号中）</li></ol><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><blockquote><p>可以使用圆括号的情况只有 一 种 ： 赋值语句的<strong>非模式部分</strong>可以使用圆括号。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">p</span><span class="token operator">:</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">.</span>prop<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门-动态规划</title>
      <link href="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/"/>
      <url>/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解为若干子问题，自顶向下求解各子问题，合并子问题的解，从而得到原问题的解。动态规划也是把原问题分解为若干子问题，然后自底向上，先求解最小的子问题，把结果存储在表格中，再求解大的子问题时，直接从表格中查询小的子问题的解，避免重复计算，从而提高算法效率。</p><blockquote><p>与分治法的区别：在分治法中，各个子问题是互不相交的，即相互独立。如果各个子问题有重叠，不是相互独立的，动态规划闪亮登场！</p></blockquote><h3 id="算法要素："><a href="#算法要素：" class="headerlink" title="算法要素："></a>算法要素：</h3><p>什么问题可以使用动态规划呢？我们首先要分析问题是否具有以下两个性质：</p><ol><li><p>最优子结构</p><p><strong>最优子结构性质是指问题的最优解包含其子问题的最优解。</strong>最优子结构是使用动态规划的最基本条件，如果不具有最优子结构性质，就不可以使用动态规划解决。</p></li><li><p>子问题重叠</p><p>子问题重叠是指在求解子问题的过程中，<strong>有大量的子问题是重复的，那么只需要求解一次，然后把结果存储在表中</strong>，以后使用时可以直接查询，不需要再次求解。</p><p>子问题重叠不是使用动态规划的必要条件，但问题存在子问题重叠更能够充分彰显动态规划的优势。</p></li></ol><h3 id="解题秘籍："><a href="#解题秘籍：" class="headerlink" title="解题秘籍："></a>解题秘籍：</h3><p>遇到一个实际问题，如何采用动态规划来解决呢？</p><ol><li><strong>分析最优解的结构特征。</strong></li><li><strong>建立最优值的递归式。</strong></li><li><strong>自底向上计算最优值，并记录。</strong></li><li><strong>构造最优解。</strong></li></ol><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><p>给定两个序列 X&#x3D;{x1，x2，x3，…，x m}和 Y&#x3D;{y1，y2，y3，…，yn}，找出 X 和 Y 的一个最长的公共子序列。</p><p>例如：X&#x3D;（A，B，C，B，A，D，B），Y&#x3D;（B，C，B，A，A，C），那么最长公共子序列是 B，C，B，A。</p><p>如何找到最长公共子序列呢？</p><p>如果使用暴力搜索方法，需要穷举 X 的所有子序列，检查每个子序列是否也是 Y 的子序列，记录找到的最长公共子序列。X 的子序列有 2m 个，因此暴力求解的方法时间复杂度为指数阶，这是我们避之不及的爆炸性时间复杂度。</p><p>那么能不能用动态规划算法呢？<br>下面分析该问题是否具有最优子结构性质。</p><ol><li><p>分析最优解的结构特征</p><p>假设已经知道 Zk&#x3D;{z1，z2，z3，…，zk}是 X m&#x3D;{x1，x2，x3，…，x m}和 Yn&#x3D;{y1，y2，y3，…，y n}的最长公共子序列。</p><p><strong>这个假设很重要，我们都是这样假设已经知道了最优解。</strong></p><p>那么可以分 3 种情况讨论。</p><ul><li><p>xm&#x3D; yn&#x3D; zk：那么 Zk−1&#x3D;{z1，z2，z3，…，zk−1}是 Xm−1 和 Yn−1 的最长公共子序列：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027222127785.png" alt="image-20221027222127785"></p><p>反证法证明：如果 Zk−1 &#x3D;{z1，z2，z3，…，zk−1 }不是 X m−1 和 Yn−1 的最长公共子序列，那么它们一定存在一个最长公共子序列。设 M 为 X m−1 和 Yn−1 的最长公共子序列，M 的长度大于Zk−1 的长度，即|M|&gt;|Zk−1|。如果在 X m−1 和 Yn−1 的后面添加一个相同的字符 xm&#x3D; y n，则 zk&#x3D;xm&#x3D;y n，|M+{zk}|&gt;|Zk−1+{zk}|&#x3D;|Zk|，那么 Zk 不是 X m 和 Yn 的最长公共子序列，这与假设 Zk 是 X m 和 Yn 的最长公共子序列矛盾，问题得证。</p></li><li><p>xm≠yn，xm≠zk：我们可以把 xm 去掉，那么 Zk 是 Xm−1 和 Yn 的最长公共子序列：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027222217619.png" alt="image-20221027222217619"></p><p>反证法证明：如果 Zk 不是 X m−1 和 Y n 的最长公共子序列，那么它们一定存在一个最长公共子序列。设 M 为 X m−1 和 Y n 的最长公共子序列，M 的长度大于 Zk 的长度，即|M|&gt;|Zk|。如果我们在 X m−1 的后面添加一个字符 x m，那么 M 也是 X m 和 Yn 的最长公共子序列，因为|M|&gt;|Zk|，那么 Zk 不是 X m 和 Y n 的最长公共子序列，这与假设 Zk 是 X m 和 Y n 的最长公共子序列矛盾，问题得证。</p></li><li><p>xm≠yn，yn≠zk：我们可以把 y n 去掉，那么 Zk 是 X m 和 Yn−1 的最长公共子序列：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027222826143.png" alt="image-20221027222826143"></p><p>反证法证明：如果 Zk 不是 X m 和 Y n−1 的最长公共子序列，那么它们一定存在一个最长公共子序列。设 M 为 X m 和 Y n−1 的最长公共子序列，M 的长度大于 Zk 的长度，即|M|&gt;|Zk|。如果我们在 Yn−1 的后面添加一个字符 yn，那么 M 也是 Xm 和 Yn 的最长公共子序列，因为|M|&gt;|Zk|，那么 Zk不是 Xm 和 Yn 的最长公共子序列，这与假设 Zk 是 Xm 和 Yn 的最长公共子序列矛盾，问题得证。</p></li></ul></li><li><p>建立最优值的递归式</p><p>设 c[i][j]表示 X i 和 Y j 的最长公共子序列长度。</p><ul><li><p>xm &#x3D; yn &#x3D; zk：那么 c[i][j] &#x3D; c[i−1][j−1]+1；</p></li><li><p>xm ≠ yn：那么我们只需要求解 X i 和 Y j−1 的最长公共子序列和 X i−1 和 Y j 的最长公共子序列，比较它们的长度哪一个更大，就取哪一个值。即 c[i][j]&#x3D; max{c[i][j−1],c[i−1][j]}。</p></li><li><p>最长公共子序列长度递归式：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027223715163.png" alt="image-20221027223715163"></p></li></ul></li><li><p>底向上计算最优值，并记录最优值和最优策略</p><p>i&#x3D;1 时：{x1 }和{y1，y2，y3，…，y n}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p><p>i&#x3D;2 时：{x2 }和{y1，y2，y3，…，y n}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p><p>……</p><p>i&#x3D;m 时：{x m}和{y1，y2，y3，…，yn}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p></li><li><p>构造最优解</p><p>上面的求解过程只是得到了最长公共子序列长度，并不知道最长公共子序列是什么，那怎么办呢？</p><p>例如，现在已经求出 c[m][n]&#x3D;5，表示 X m 和 Y n 的最长公共子序列长度是 5，那么这个 5是怎么得到的呢？我们可以反向追踪 5 是从哪里来的。根据递推式，有如下情况。</p><p>x i &#x3D; y j 时：c[i][j]&#x3D; c[i−1][j−1]+1；</p><p>x i ≠ y j 时：c[i][j]&#x3D; max{c[i][j−1], c[i−1][j]}；</p><p>那么 c[i][j]的来源一共有 3 个：c[i][j]&#x3D; c[i−1][j−1]+1，c[i][j]&#x3D; c[i][j−1]，c[i][j]&#x3D; c[i−1][j]。在第 3 步自底向上计算最优值时，用一个辅助数组 b [i][j]记录这 3 个来源：</p><p>c[i][j]&#x3D; c[i−1][j−1]+1，b[i][j]&#x3D;1；</p><p>c[i][j]&#x3D; c[i][j−1]，b[i][j]&#x3D;2；</p><p>c[i][j]&#x3D; c[i−1][j]，b[i][j]&#x3D;3。</p><p>这样就可以根据 b[m][n]反向追踪最长公共子序列，当 b[i][j]&#x3D;1 时，输出 x i；当 b [i][j]&#x3D;2时，追踪 c[i][j−1]；当 b[i][j]&#x3D;3 时，追踪 c[i−1][j]，直到 i&#x3D;0 或 j&#x3D;0 停止。</p></li></ol><h3 id="图解分析："><a href="#图解分析：" class="headerlink" title="图解分析："></a>图解分析：</h3><p>以字符串 s1 &#x3D;“ABCADAB”，s2&#x3D;“BACDBA”为例。</p><ol><li><p>初始化</p><p>len1&#x3D;7，len2&#x3D;6，初始化 c[][]第一行、第一列元素为 0：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027225817829.png" alt="image-20221027225817829"></p></li><li><p>i&#x3D;1：s1[0]与 s2[j−1]比较，j&#x3D;1，2，3，…，len2。即“A”与“BACDBA”分别比较一次。</p><p><strong>如果字符相等，c[i][j]取<u>左上角</u>数值加 1，记录最优值来源 b[i][j]&#x3D;1。</strong></p><p><strong>如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果 c[i][j]的值来源于左侧 b[i][j]&#x3D;2，来源于上面 b[i][j]&#x3D;3。</strong></p><ul><li><p>j&#x3D;1：A≠B，左侧&#x3D;上面，取左侧数值，c[1][1]&#x3D; 0，最优策略来源 b[1][1]&#x3D;2：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027230443409.png" alt="image-20221027230443409"></p></li><li><p>j&#x3D;2：A&#x3D;A，则取左上角数值加 1，c[1][2]&#x3D; c[0][1]+1&#x3D;2，最优策略来源 b[1][2] &#x3D;1：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027230615500.png" alt="image-20221027230615500"></p></li><li><p>j&#x3D;3：A≠C，左侧≥上面，取左侧数值，c[1][3]&#x3D; 1，最优策略来源 b[1][3] &#x3D;2：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027230649108.png" alt="image-20221027230649108"></p></li><li><p>j&#x3D;6：A&#x3D;A，则取左上角数值加 1，c[1][6]&#x3D;1，最优策略来源 b[1][6]&#x3D;1：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027230840156.png" alt="image-20221027230840156"></p></li></ul></li><li><p>i&#x3D;2：s1[1]与 s2 [j−1]比较，j&#x3D;1，2，3，…，len2。即“B”与“BACDBA”分别比较一次。</p><p>如果字符相等，c[i][j]取左上角数值加 1，记录最优值来源 b[i][j]&#x3D;1。</p><p>如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果 c[i][j]的值来源于左侧 b[i][j]&#x3D;2，来源于上面 b[i][j]&#x3D;3：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027231109658.png" alt="image-20221027231109658"></p></li><li><p>继续处理 i&#x3D;2，3，…，len1：s1[i−1]与 s2 [j−1]比较，j&#x3D;1，2，3，…，len2。处理结果如下：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027231613378.png" alt="image-20221027231613378"></p><blockquote><p>c[][]右下角的值即为最长公共子序列的长度。</p></blockquote><p>c[7][6]&#x3D;4，即字符串 s1 &#x3D;“ABCADAB”，s2 &#x3D;“BACDBA”的最长公共子序列的长度为 4。</p><p>那么最长公共子序列包含哪些字符呢？</p></li><li><p>构造最优解</p><p>首先读取 b[7][6]&#x3D;2，说明来源为 2，向左找 b[7][5]；</p><p>b[7][5]&#x3D;1，向左上角找 b[6][4]，返回时输出 s[6]&#x3D;“B”；<br>b[6][4]&#x3D;3，向上找 b[5][4]；<br>b[5][4]&#x3D;1，向左上角找 b[4][3]，返回时输出 s[4]&#x3D;“D”；<br>b[4][3]&#x3D;2，向左找 b[4][2]；<br>b[4][2]&#x3D;1，向左上角找 b[3][1]，返回时输出 s[3]&#x3D;“C”；<br>b[3][1]&#x3D;3，向上找 b[2][1]；<br>b[2][1]&#x3D;1，向左上角找，返回时输出 s[1]&#x3D;“B”；</p><p>b[1][0]中列为 0，算法停止，返回，输出最长公共子序列为 BCDB：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221027232645959.png" alt="image-20221027232645959"></p><blockquote><p>即输出追踪到的左上角元素</p></blockquote></li></ol><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li><p>最长公共子序列求解函数</p><p>首先计算两个字符串的长度，然后从 i&#x3D;1 开始，s1 [0]与 s2 中的每一个字符比较。<br>如果当前字符相同，则公共子序列的长度为 c[i−1][j−1]+1，并记录最优策略来源 b[i][j] &#x3D; 1。<br>如果当前字符不相同，则公共子序列的长度为 c[i][j−1]和 c[i−1][j]中的最大值，如果c[i][j−1]≥c[i−1][j]，则最优策略来源 b[i][j]&#x3D;2；如果 c[i][j−1]&lt;c[i−1][j]，则最优策略来源b[i][j]&#x3D;3。直到 i&gt; len1 时，算法结束，这时 c[len1][len2]就是我们要的最长公共序列长度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">LCSL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//控制s1序列不同的子问题</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//控制s2序列不同的子问题</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>s2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//如果当前字符相同，则公共子序列的长度为该字符前的最长公共序列+1</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最优解输出函数</p><p>输出最优解仍然使用倒推法。因为我们在求最长公共子序列长度 c[i][j]的过程中，用 b[i][j]记录了 c[i][j]的来源，那么就可以根据 b[i][j]数组倒推最优解。</p><p>如果 b[i][j]&#x3D;1，说明 s1[i−1]&#x3D;s2[j−1]，那么我们就可以递归输出 print(i−1，j−1)；然后输出 s1[i−1]。</p><p>如果 b[i][j]&#x3D;2，说明 s1[i−1]≠s2[j−1]且最优解来源于 c[i][j]&#x3D;c[i][j−1]，递归输出 print(i，j−1)。</p><p>如果 b[i][j]&#x3D;3，说明 s1[i−1]≠s2[j−1]且最优解来源于 c[i][j]&#x3D;c[i−1][j]，递归输出 print(i−1，j)。<br>当 i&#x3D;&#x3D;0||j&#x3D;&#x3D;0 时，递归结束。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token comment">//根据记录下来的信息构造最长公共子序列（从b[i][j]开始递推）</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>            <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 4-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1002</span><span class="token punctuation">;</span><span class="token keyword">int</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> s1<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>s2<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> len1<span class="token punctuation">,</span>len2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LCSL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//控制s1序列不同的子问题</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//控制s2序列不同的子问题</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>s2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//如果当前字符相同，则公共子序列的长度为该字符前的最长公共序列+1</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token comment">//根据记录下来的信息构造最长公共子序列（从b[i][j]开始递推）</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>            <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入字符串s1:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s1<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入字符串s2:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s2<span class="token punctuation">;</span>    len1 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算两个字符串的长度</span>    len2 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化第一列为0</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化第一行为0</span>    <span class="token punctuation">&#125;</span>    <span class="token function">LCSL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s1和s2的最长公共子序列长度是:"</span><span class="token operator">&lt;&lt;</span>c<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s1和s2的最长公共子序列是:"</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span>len2<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment">// /*用于测试</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"c[i][j]数组："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          cout <span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token operator">&lt;&lt;</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"b[i][j]数组："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          cout <span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token operator">&lt;&lt;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// */用于测试</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度："><a href="#算法复杂度：" class="headerlink" title="算法复杂度："></a>算法复杂度：</h3><ol><li><p>时间复杂度：</p><p>由于每个数组单元的计算耗费 Ο(1)时间，如果两个字符串的长度分别是 m、n，那么算法时间复杂度为 Ο(m*n)。</p></li><li><p>空间复杂度：</p><p>空间复杂度主要为两个二维数组 c[][]，b[][]，占用的空间为 O(m*n)。</p></li></ol><h3 id="优化拓展："><a href="#优化拓展：" class="headerlink" title="优化拓展："></a>优化拓展：</h3><p>因为 c[i][j]有 3 种来源：c[i−1][j−1]+1、c[i][j−1]、c[i−1][j]。我们可以利用 c 数组本身来判断来源于哪个值，从而不用 b[][]，这样可以节省 O(m<em>n)个空间。但因为 c 数组还是 O(m</em>n)个空间，所有空间复杂度数量级仍然是 O(m*n)，只是从常数因子上的改进。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028175628346.png" alt="image-20221028175628346"></p><h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><h3 id="问题分析：-1"><a href="#问题分析：-1" class="headerlink" title="问题分析："></a>问题分析：</h3><p>矩阵连乘问题就是对于给定 n 个连乘的矩阵，找出一种加括号的方法，使得矩阵连乘的计算量（乘法次数）最小。</p><ol><li><p>什么是矩阵可乘？</p><blockquote><p>如果两个矩阵，<strong>第 1 个矩阵的列等于第 2 个矩阵的行时，那么这两个矩阵是可乘的。</strong></p></blockquote><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028180740102.png" alt="image-20221028180740102"></p></li><li><p>矩阵相乘后的结果是什么？</p><p><strong>多个矩阵相乘的结果矩阵，其行、列分别等于第 1 个矩阵的行、最后 1 个矩阵的列。</strong>而且无论矩阵的计算次序如何都不影响它们的结果矩阵。</p></li><li><p>两个矩阵相乘需要多少次乘法？</p><blockquote><p><strong>Am×n、An×k 相乘执行乘法运算的次数为 m×n×k。</strong></p></blockquote></li></ol><p>如果穷举所有的加括号方法，那么加括号的所有方案是一个卡特兰数序列，其算法时间复杂度为 2<sup>n</sup>，是指数阶。因此穷举的办法是很糟的，那么能不能用动态规划呢？</p><p>下面分析矩阵连乘问题 AiAi+1…Aj 是否具有最优子结构性质。</p><ol><li><p>分析最优解的结构特征</p><ul><li><p>假设我们已经知道了在第 k 个位置加括号会得到最优解，那么原问题就变成了两个子问题：（AiAi+1…Ak），（Ak+1Ak+2…Aj）:</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028181917124.png" alt="image-20221028181917124"></p><p>原问题的最优解是否包含子问题的最优解呢？</p></li><li><p>假设 AiAi+1…Aj 的乘法次数是 c，（AiAi+1…Ak）的乘法次数是 a，（Ak+1Ak+2…Aj）的乘法次数是 b，（AiAi+1…Ak）和（Ak+1Ak+2…Aj）的结果矩阵相乘的乘法次数是 d，那么c&#x3D;a+b+d，无论两个子问题（AiAi+1…Ak）、（Ak+1Ak+2…Aj）的计算次序如何，都不影响它们结果矩阵，两个结果矩阵相乘的乘法次数 d 不变。</p><p>因此我们只需要证明如果 c 是最优的，则 a 和 b 一定是最优的（即原问题的最优解包含子问题的最优解）。</p></li></ul></li><li><p>建立最优值递归式</p><ul><li><p>用 m[i][j]表示 AiAi+1 …Aj 矩阵连乘的最优值，那么两个子问题（AiAi+1 …Ak ）、（Ak+1Ak+2…Aj）对应的最优值分别是 m[i][k]、m[k+1][j]。剩下的只需要考查（AiAi+1…Ak）和（Ak+1Ak+2…Aj）的结果矩阵相乘的乘法次数了。</p></li><li><p>设矩阵 Am 的行数为 p m，列数为 q m，m&#x3D;i，i+1, …，j，且矩阵是可乘的，即相邻矩阵前一个矩阵的列等于下一个矩阵的行（q m&#x3D; p m+1）。（AiAi+1…Ak）的结果是一个 p i×q k矩阵，（Ak+1Ak+2…Aj）的结果是一个 p k+1×qj 矩阵，q k&#x3D; p k+1，两个结果矩阵相乘的乘法次数是 p i*p k+1 *q j。</p></li><li><p>当 i&#x3D;j 时，只有一个矩阵，m[i][j]&#x3D;0；</p><p>当 i&gt;j 时，m[i][j]&#x3D;min{m[i][k]+m[k+1][j]+pi×pk+1×qj}</p><p>如果用一维数组 p[]来记录矩阵的行和列，第 i 个矩阵的行数存储在数组的第 i−1 位置，列数存储在数组的第 i 位置，那么 pi<em>p k+1</em>qj 对应的数组元素相乘为 p[i−1]<em>p[k]</em> p[j]，原递归式变为：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028183443792.png" alt="image-20221028183443792"></p></li></ul></li><li><p>自底向上计算并记录最优值</p><p>先求两个矩阵相乘的最优值，再求 3 个矩阵相乘的最优值，直到 n 个矩阵连乘的最优值。</p></li><li><p>构造最优解</p><p>上面得到的最优值只是矩阵连乘的最小的乘法次数，并不知道加括号的次序，需要从记录表中还原加括号次序，构造出最优解，例如 A1（A2A3）。</p></li></ol><h3 id="图解分析：-1"><a href="#图解分析：-1" class="headerlink" title="图解分析："></a>图解分析：</h3><p>假设有5个矩阵：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028184059795.png" alt="image-20221028184059795"></p><ol><li><p>初始化</p><p>采用一维数组 p[]记录矩阵的行和列，实际上只需要记录每个矩阵的行，再加上最后一个矩阵的列即可。m[i][i]&#x3D;0，s[i][i]&#x3D;0，其中 i&#x3D; 1，2，3，4，5。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028184442920.png" alt="image-20221028184442920"></p><p>最优值数组 m[i][i]&#x3D;0，最优决策数组 s[i][i]&#x3D;0，其中 i&#x3D; 1，2，3，4，5。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028184457563.png" alt="image-20221028184457563"></p></li><li><p>计算两个矩阵相乘的最优值</p><p>规模 r&#x3D;2。根据递归式：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028185814891.png" alt="image-20221028185814891"></p><ul><li><p>A1 *A2：k&#x3D;1，m[1][2]&#x3D;min{ m[1][1]+ m[2][2]+p0p1p2 }&#x3D;150；s[1][2]&#x3D;1。</p></li><li><p>A2 *A3：k&#x3D;2，m[2][3]&#x3D;min{ m[2][2]+ m[3][3]+p1p2p3 }&#x3D;400；s[2][3]&#x3D;2。</p></li><li><p>A3 *A4：k&#x3D;3，m[3][4]&#x3D;min{ m[3][3]+ m[4][4]+p2p3p4 }&#x3D;160；s[3][4]&#x3D;3。</p></li><li><p>A4 *A5：k&#x3D;4，m[4][5]&#x3D;min{ m[4][4]+ m[5][5]+p3p4p5 }&#x3D;64； s[4][5]&#x3D;4。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028185848792.png" alt="image-20221028185848792"></p></li></ul></li><li><p>计算 3 个矩阵相乘的最优值</p><p>规模 r&#x3D;3。根据递归式：</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028185814891.png" alt="image-20221028185814891"></p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190045501.png" alt="image-20221028190045501"></p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190053112.png" alt="image-20221028190053112"></p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190209778.png" alt="image-20221028190209778"></p></li><li><p>计算 4 个矩阵相乘的最优值</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190253904.png" alt="image-20221028190253904"></p></li><li><p>计算 5 个矩阵相乘的最优值</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190650549.png" alt="image-20221028190650549"></p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190705171.png" alt="image-20221028190705171"></p></li><li><p>根据最优解</p><p>根据最优决策数组 s[][]中的数据来构造最优解，即加括号的位置。</p><p>首先读取 s[1][5]&#x3D;4，表示在 k&#x3D;4 的位置把矩阵分为两个子问题：（A1A2A3A4）、A5。</p><p>再看第一个子问题（A1A2A3A4），读取 s[1][4]&#x3D;1，表示在 k&#x3D;1 的位置把矩阵分为两个子问题：A1、（A2A3A4）。</p><p>子问题 A1 不用再分解，输出；子问题（A2A3A4），读取 s[2][4]&#x3D;2，表示在 k&#x3D;2 的位置把矩阵分为两个子问题：A2、（A3A4）。</p><p>子问题 A2 不用再分解，输出；子问题(A3A4 )，读取 s[3][4]&#x3D;3，表示在 k&#x3D;3 的位置把矩阵分为两个子问题：A3、A4。这两个子问题都不用再分解，输出</p><p>子问题 A5 不用再分解，输出。</p><p><img src="/2022/10/27/suan-fa-ru-men-dong-tai-gui-hua/image-20221028190934126.png" alt="image-20221028190934126"></p><p>最优解为：（（A1（A2（A3A4）））A5）。<br>最优值为：314。</p></li></ol><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><p>按照算法思想和设计，以下程序将矩阵的行和列存储在一维数组 p[]，m[][]数组用于存储分成的各个子问题的最优值，s[][]数组用于存储各个子问题的决策点，然后在一个 for 循环里，将问题分为规模为 r 的子问题，求每个规模子问题的最优解，那么得到的 m[1][n]就是最小的计算量。</p><ol><li><p>矩阵连乘求解函数</p><p>首先将数组 m[][]，s[][]初始化为 0，然后自底向上处理不同规模的子问题，r 为问题的规模，r&#x3D; 2；r &lt;&#x3D; n；r++，当 r&#x3D; 2 时，表示矩阵连乘的规模为 2，即两个矩阵连乘。求解两个矩阵连乘的最优值和最优策略，根据递归式对每一个 k 值，找到最小值用 m[i][j]记录，并用 s[i][j]记录取得最小值的 k 值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">matrixchain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>r<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> r <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token comment">//不同规模的子问题</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">-</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>           j <span class="token operator">=</span> i <span class="token operator">+</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>           m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//决策为k=i的乘法次数</span>           s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                     <span class="token comment">//子问题的最优策略是i;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//对从i到j的所有决策，求最优值，记录最优策略</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> t <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最优解输出函数</p><p>根据存储表格 s[][]中的数据来构造最优解，即加括号的位置。首先打印一个左括号，然后递归求解子问题 print（i，s[i][j]），print（s[i][j]+1，j），再打印右括号，当 i&#x3D;j 即只剩下一个矩阵时输出该矩阵即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> j <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout <span class="token operator">&lt;&lt;</span><span class="token string">"A["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 4-4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> msize <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> m<span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> s<span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">[</span>msize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">matrixchain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>r<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> r <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token comment">//不同规模的子问题</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">-</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>           j <span class="token operator">=</span> i <span class="token operator">+</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>           m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//决策为k=i的乘法次数</span>           s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                     <span class="token comment">//子问题的最优策略是i;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//对从i到j的所有决策，求最优值，记录最优策略</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> t <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> j <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout <span class="token operator">&lt;&lt;</span><span class="token string">"A["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入矩阵的个数 n:"</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token punctuation">,</span>j<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请依次输入每个矩阵的行数和最后一个矩阵的列数:"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>        cin <span class="token operator">>></span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">matrixchain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">/*用于测试    for (i = 1; i &lt;= n; i++ )        &#123;          for (j = i; j &lt;= n; j++ )            cout &lt;&lt; m[i][j]&lt;&lt;"  " ;          cout &lt;&lt; endl;        &#125;     for (i = 1; i &lt;= n; i++ )        &#123;          for (j = i; j &lt;= n; j++ )            cout &lt;&lt; s[i][j]&lt;&lt;"  " ;          cout &lt;&lt; endl;        &#125;    cout &lt;&lt; endl;    */</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小计算量的值为 "</span> <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度：-1"><a href="#算法复杂度：-1" class="headerlink" title="算法复杂度："></a>算法复杂度：</h3><ol><li><p>时间复杂度</p><p>由程序可以得出：语句 t&#x3D; m[i][k] + m[k+1][j] +p[i−1]*p[k]*p[j]，它是算法的基本语句，在 3 层 for 循环中嵌套。最坏情况下，该语句的执行次数为 O(n<sup>3</sup>)，print()函数算法的时间主要取决于递归，时间复杂度为 O(n)。故该程序的时间复杂度为 O(n<sup>3</sup>)。</p></li><li><p>空间复杂度</p><p>该程序的输入数据的数组为 p[]，辅助变量为 i、j、r、t、k、m[][]、s[][]，空间复杂度取决于辅助空间，因此空间复杂度为 O(n<sup>2</sup>)。</p></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门-分治法</title>
      <link href="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/"/>
      <url>/2022/10/23/suan-fa-ru-men-fen-zhi-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="分治法本质"><a href="#分治法本质" class="headerlink" title="分治法本质"></a>分治法本质</h2><blockquote><p>分治算法，其本质就是将一个大规模的问题分解为若干个规模较小的相同子问题，分而治之。</p></blockquote><p>那么在现实生活中，什么样的问题才能使用分治法解决呢？简单来说，需要满足以下 3 个条件：</p><ol><li>原问题可分解为若干个规模较小的相同子问题。</li><li>子问题相互独立。</li><li>子问题的解可以合并为原问题的解。</li></ol><h2 id="分治法解题步骤"><a href="#分治法解题步骤" class="headerlink" title="分治法解题步骤"></a>分治法解题步骤</h2><ul><li>分解：将要解决的问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。</li><li>治理：求解各个子问题。由于各个子问题与原问题形式相同，只是规模较小而已，而当子问题划分得足够小时，就可以用较简单的方法解决。</li><li>合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。</li></ul><blockquote><p><strong>递归</strong>是彰显分治法优势的利器。</p></blockquote><h2 id="二分搜索技术"><a href="#二分搜索技术" class="headerlink" title="二分搜索技术"></a>二分搜索技术</h2><h3 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h3><p>问题描述：给定 n 个元素，这些元素是<strong>有序</strong>的（假定为升序），从中查找特定元素 x。</p><p>算法思想：将有序序列分成规模大致相等的两部分，然后取中间元素与特定查找元素 x 进行比较，如果 x 等于中间元素，则查找成功，算法终止；如果 x 小于中间元素，则在序列的前半部分继续查找，即在序列的前半部分重复分解和治理操作；否则，在序列的后半部分继续查找，即在序列的后半部分重复分解和治理操作。</p><p>算法设计：用一维数组 S[]存储该有序序列，设变量 low 和 high 表示查找范围的下界和上界，middle 表示查找范围的中间位置，x 为特定的查找元素。</p><ul><li>初始化。令 low&#x3D;0，即指向有序数组 S[]的第一个元素；high&#x3D;n−1，即指向有序数组S[]的最后一个元素。</li><li>middle&#x3D;（low+high）&#x2F;2，即指示查找范围的中间元素。</li><li>判定 low≤high 是否成立，如果成立，转第 4 步，否则，算法结束。</li><li>判断 x 与 S[middle]的关系。如果 x&#x3D;S[middle]，则搜索成功，算法结束；如果x&gt;S[middle]，则令 low&#x3D;middle+1；否则令 high&#x3D;middle−1，转为第 2 步。</li></ul><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 3-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdlib></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> M<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span>n<span class="token punctuation">,</span>i<span class="token punctuation">;</span><span class="token keyword">int</span> s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> low<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>high<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//low指向有序数组的第一个元素，high指向有序数组的最后一个元素</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> middle<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//middle为查找范围的中间值</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>s<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">//x等于查找范围的中间值，算法结束</span>          <span class="token keyword">return</span> middle<span class="token punctuation">;</span>       <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">></span>s<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//x大于查找范围的中间元素，则从左半部分查找</span>              low<span class="token operator">=</span>middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>   <span class="token comment">//x小于查找范围的中间元素，则从右半部分查找</span>              high<span class="token operator">=</span>middle<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"该数列中的元素个数n为："</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入数列中的元素："</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>           cin<span class="token operator">>></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>s<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"排序后的数组为："</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>           cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入要查找的元素："</span><span class="token punctuation">;</span>        cin<span class="token operator">>></span>x<span class="token punctuation">;</span>        i<span class="token operator">=</span><span class="token function">BinarySearch</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>s<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"该数列中没有要查找的元素"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"要查找的元素在第"</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">"位"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析："><a href="#算法复杂度分析：" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p><strong>时间复杂度：</strong></p><ol><li><p>首先需要进行排序，调用 sort 函数，进行排序复杂度为 O(nlogn)，如果数列本身有序，那么这部分不用考虑。</p></li><li><p>如果我们用 T(n)来表示 n 个有序元素的二分查找算法时间复杂度，那么：</p><ul><li><p>当 n&#x3D;1 时，需要一次比较，T(n)&#x3D;O(1)</p></li><li><p>当 n&gt;1 时，特定元素和中间位置元素比较，需要 O(1)时间，如果比较不成功，那么需要在前半部分或后半部分搜索，问题的规模缩小了一半，时间复杂度变为 T(n&#x2F;2)。</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023113347212.png" alt="image-20221023113347212"></p></li><li><p>当 n&gt;1 时，可以递推求解如下。</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023113358680.png" alt="image-20221023113358680"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup>，则x &#x3D; logn。</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023113505382.png" alt="image-20221023113505382"></p><p>二分查找算法的时间复杂度为 O(logn)。</p></li></ul></li></ol><p><strong>空间复杂度：</strong>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为 O(1)。</p><h3 id="优化拓展："><a href="#优化拓展：" class="headerlink" title="优化拓展："></a>优化拓展：</h3><p>在上面程序中，我们采用 BinarySearch（int n，int s[]，int x）函数来实现二分搜索，那么能不能用递归来实现呢？因为递归有自调用问题，那么就需要增加两个参数 low 和 high 来标记搜索范围的开始和结束。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">recursionBS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">></span>high<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>middle<span class="token punctuation">)</span>      <span class="token keyword">return</span> middle   <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span>middle<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token function">recursionBS</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> low<span class="token punctuation">,</span> middle<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">else</span>         <span class="token keyword">return</span> <span class="token function">recursionBS</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间复杂度：</strong></p><p>在递归算法中，每一次递归调用都需要一个栈空间存储，那么我们只需要看看有多少次调用。</p><p>假设原问题的规模为 n，那么第一次递归就分为两个规模为 n&#x2F;2 的子问题，这两个子问题并不是每个都执行，只会执行其中之一。</p><p>因为我们和中间值比较后，要么去前半部分查找，要么去后半部分查找；然后再把规模为 n&#x2F;2的子问题继续划分为两个规模为 n&#x2F;4 的子问题，选择其一；继续分治下去，最坏的情况会分治到只剩下一个数值，那么我们执行的节点数就是从树根到叶子所经过的节点，每一层执行一个，直到最后一层：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023120324903.png" alt="image-20221023120324903"></p><p>递归调用最终的规模为 1，即 n&#x2F;2x&#x3D;1，则x&#x3D;logn。假设阴影部分是搜索经过的路径，一共经过了 logn 个节点，也就是说递归调用了 logn 次。</p><p>因此，二分搜索递归算法的空间复杂度为 O(logn)。</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><h3 id="算法设计：-1"><a href="#算法设计：-1" class="headerlink" title="算法设计："></a>算法设计：</h3><p>合并排序是采用分治策略实现对 n 个元素进行排序的算法，是分治法的一个典型应用和完美体现。它是一种平衡、简单的二分分治策略，过程大致分为：</p><ul><li>分解—将待排序元素分成大小大致相同的两个子序列。</li><li>治理—对两个子序列进行合并排序。</li><li>合并—将排好序的有序子序列进行合并，得到最终的有序序列。</li></ul><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023123323025.png" alt="image-20221023123323025"></p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li><p>合并操作：</p><p>设置 3 个工作指针 i、j、k（整型数）和一个辅助数组 B[]。其中，i 和 j 分别指向两个待排序子序列中当前待比较的元素，k 指向辅助数组 B[]中待放置元素的位置。比较 A[i]和A[j]，将较小的赋值给 B[k]，同时相应指针向后移动。如此反复，直到所有元素处理完毕。最后把辅助数组 B 中排好序的元素复制到 A 数组中：</p><p>第 1 次比较 A[i]&#x3D;4 和 A[j]&#x3D;2，将较小元素 2 放入 B 数组中，j++，k++：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023124616377.png" alt="image-20221023124616377"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//按从小到大存放到辅助数组B[]中</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>           B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">else</span>           B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当j&gt;high 了，while 循环结束，但 A 数组还剩有元素（i≤mid）怎么办呢？直接放置到 B 数组就可以了：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将数组中剩下的元素放置B中</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完整的合并程序如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>B<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>high<span class="token operator">-</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//申请一个辅助数组</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span> j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//按从小到大存放到辅助数组B[]中</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将数组中剩下的元素放置B中</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>low<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>B<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>递归形式的合并排序算法</p><p>将序列分为两个子序列，然后对子序列进行递归排序，再把两个已排好序的子序列合并成一个有序的序列。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//取中点</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对A[low:mid]中的元素合并排序</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对A[mid+1:high]中的元素合并排序</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//合并</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 3-2</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>B<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>high<span class="token operator">-</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//申请一个辅助数组</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span> j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//按从小到大存放到辅助数组B[]中</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将数组中剩下的元素放置B中</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>low<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>B<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//取中点</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对A[low:mid]中的元素合并排序</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对A[mid+1:high]中的元素合并排序</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//合并</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> A<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入数列中的元素个数n为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入数列中的元素："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>       cin<span class="token operator">>></span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"合并排序结果："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>       cout<span class="token operator">&lt;&lt;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-1"><a href="#算法复杂度分析：-1" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p><strong>时间复杂度：</strong></p><ul><li>分解：这一步仅仅是计算出子序列的中间位置，需要常数时间 O(1)。</li><li>解决子问题：递归求解两个规模为 n&#x2F;2 的子问题，所需时间为 2T(n&#x2F;2)。</li><li>合并：Merge 算法可以在 O(n)的时间内完成。</li></ul><p>所以总运行时间为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023130510198.png" alt="image-20221023130510198"></p><p>当 n&gt;1 时，可以递推求解：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023130523916.png" alt="image-20221023130523916"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup> ，则x &#x3D; logn ，那么</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023130559888.png" alt="image-20221023130559888"></p><p>合并排序算法的时间复杂度为 O(nlogn)。</p><p><strong>空间复杂度：</strong></p><p>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，每调用一个 Merge()，会分配一个适当大小的缓冲区，且退出时释放。最多分配大小为 n，所以空间复杂度为 O(n)。递归调用所使用的栈空间是O(logn)：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023130703054.png" alt="image-20221023130703054"></p><p>递归调用时占用的栈空间是递归树的深度，  n &#x3D; 2<sup>x</sup> ，则 x &#x3D; logn ，递归树的深度为 logn。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>它的基本思想是通过一组排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此使所有数据变成有序序列。</p></blockquote><h3 id="算法设计：-2"><a href="#算法设计：-2" class="headerlink" title="算法设计："></a>算法设计：</h3><p>快速排序的基本思想是基于分治策略的，其算法思想如下。</p><ol><li>分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分解为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。</li><li>治理：对两个子序列进行快速排序。</li><li>合并：将排好序的两个子序列合并在一起，得到原问题的解。</li></ol><p>设当前待排序的序列为 R[low:high]，其中 low≤high，如果序列的规模足够小，则直接进行排序，否则分 3 步处理。</p><ol><li><p>分解：在 R[low: high]中选定一个元素 R[pivot]，以此为标准将要排序的序列划分为两个序列 R[low:pivot−1]和 R[pivot+1:high]，并使用序列 R[low:pivot−1]中所有元素的值小于等于 R[pivot]，序列 R[pivot+1:high]中所有元素均大于 R[pivot]，此时基准元素已经位于正确的位置，它无需参加后面的排序：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023225113169.png" alt="image-20221023225113169"></p></li><li><p>治理：对于两个子序列 R[low:pivot−1]和 R[pivot+1:high]，分别通过递归调用快速排序算法来进行排序。</p></li><li><p>合并：由于对 R[low:pivot−1]和 R[pivot+1:high]的排序是原地进行的，所以在R[low:pivot−1]和 R[pivot+1:high]都已经排好序后，合并步骤无需做什么，序列 R[low:high]就已经排好序了。</p></li></ol><blockquote><p>如何分解是一个难题，因为如果基准元素选取不当，有可能分解成规模为 0 和 n−1 的两个子序列，这样快速排序就退化为冒泡排序了。</p></blockquote><p>例如序列（30，24，5，58，18，36，12，42，39），第一次选取 5 做基准元素，第二次选取 12 做基准元素。这样做的效率是最差的，最理想的状态是把序列分解为两个规模相当的子序列，那么怎么选择基准元素呢？一般来说，基准元素选取有以下几种方法：</p><ul><li>取第一个元素。</li><li>取最后一个元素。</li><li>取中间位置元素。</li><li>取第一个、最后一个、中间位置元素三者之中位数。</li><li>取第一个和最后一个之间位置的随机数 k（low≤k≤high），选 R[k]做基准元素。</li></ul><h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li><p>划分函数</p><p>我们编写划分函数对原序列进行分解，分解为两个子序列，以基准元素 pivot 为界，左侧子序列都比 pivot 小，右侧子序列都比 pivot 大。先从右向左扫描，找小于等于 pivot 的数，找到后两者交换（r[i]和 r[j]交换后 i++）；再从左向右扫描，找比基准元素大的数，找到后两者交换（r[i]和 r[j]交换后 j−−）。扫描交替进行，直到 i&#x3D;j 停止，返回划分的中间位置 i。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//划分函数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>high<span class="token punctuation">,</span>pivot<span class="token operator">=</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//基准元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//向左扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换后i+1右移一位</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//向右扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换 后j-1左移一位</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token comment">//返回最终划分完成后基准元素所在的位置</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>快速排序递归算法</p><p>首先对原序列执行划分，得到划分的中间位置 mid，然后以中间位置为界，分别对左半部分（low，mid−1）执行快速排序，右半部分（mid+1，high）执行快速排序。递归结束的条件是 low≥high。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//实现快排算法</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mid<span class="token operator">=</span><span class="token function">Partition</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//基准位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左区间递归快排</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右区间递归快排</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 3-3</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//划分函数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>high<span class="token punctuation">,</span>pivot<span class="token operator">=</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//基准元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//向左扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换后i+1右移一位</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//向右扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换 后j-1左移一位</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token comment">//返回最终划分完成后基准元素所在的位置</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//实现快排算法</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mid<span class="token operator">=</span><span class="token function">Partition</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//基准位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左区间递归快排</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右区间递归快排</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>N<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请先输入要排序的数据的个数："</span><span class="token punctuation">;</span>    cin<span class="token operator">>></span>N<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入要排序的数据："</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin<span class="token operator">>></span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"排序后的序列为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span> <span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-2"><a href="#算法复杂度分析：-2" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p><strong>最好时间复杂度：</strong></p><ul><li>分解：划分函数 Partition 需要扫描每个元素，每次扫描的元素个数不超过 n，因此时间复杂度为 O(n)。</li><li>解决子问题：在最理想的情况下，每次划分将问题分解为两个规模为 n&#x2F;2 的子问题，递归求解两个规模为 n&#x2F;2 的子问题，所需时间为 2T(n&#x2F;2)。</li><li>合并：因为是原地排序，合并操作不需要时间复杂度。</li></ul><p>所以总运行时间为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023231955341.png" alt="image-20221023231955341"></p><p>当 n&gt;1 时，可以递推求解：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023232011137.png" alt="image-20221023232011137"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup>，则x &#x3D; logn，则快速排序算法最好的时间复杂度为 O(nlogn)。</p><p><strong>空间复杂度：</strong></p><p>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，递归调用所使用的栈空间是 O(logn)。</p><p><strong>最坏时间复杂度：</strong></p><ul><li><p>分解：划分函数 Partition 需要扫描每个元素，每次扫描的元素个数不超过 n，因此时间复杂度为 O(n)。</p></li><li><p>解决子问题：在最坏的情况下，每次划分将问题分解后，基准元素的左侧（或者右侧）没有元素，基准元素的另一侧为 1 个规模为 n−1 的子问题，递归求解这个规模为 n−1 的子问题，所需时间为 T(n−1)。</p></li><li><p>合并：因为是原地排序，合并操作不需要时间复杂度。</p><p>所以总运行时间为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023233135333.png" alt="image-20221023233135333"></p><p>当 n&gt;1 时，可以递推求解如下：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023233158324.png" alt="image-20221023233158324"></p><p>快速排序算法最坏的时间复杂度为 O(n<sup>2</sup> )。</p></li></ul><p><strong>平均时间复杂度：</strong></p><p>假设我们划分后基准元素的位置在第 k（k&#x3D;1，2，…，n）个，则：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221023233714369.png" alt="image-20221023233714369"></p><p>由归纳法可以得出，T(n)的数量级也为 O(nlogn)。快速排序算法平均情况下，时间复杂度为 O(nlogn)，递归调用所使用的栈空间也是 O(logn)。</p><h3 id="优化拓展：-1"><a href="#优化拓展：-1" class="headerlink" title="优化拓展："></a>优化拓展：</h3><p>从上述算法可以看出，每次交换都是在和基准元素进行交换，实际上没必要这样做，我们的目的就是想把原序列分成以基准元素为界的两个子序列，左侧子序列小于等于基准元素，右侧子序列大于基准元素。</p><p>那么有很多方法可以实现，我们可以从右向左扫描，找小于等于 pivot 的数 R[j]，然后从左向右扫描，找大于 pivot 的数 R[i]，让 R[i]和 R[j]交换，一直交替进行，直到 i 和 j 碰头为止，这时将基准元素与 R[i]交换即可。这样就完成了一次划分过程，但交换元素的个数少了很多。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Partition2</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token comment">//划分函数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>high<span class="token punctuation">,</span>pivot<span class="token operator">=</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//基准元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//向左扫描</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//向右扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[j]交换</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i-1]和r[low]交换</span>        <span class="token keyword">return</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//返回最终划分完成后基准元素所在的位置</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//r[i]和r[low]交换</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token comment">//返回最终划分完成后基准元素所在的位置</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><blockquote><p>在解决两个大的整数相乘时，我们可以将一个大的整数乘法分而治之，将大问题变成小问题，变成简单的小数乘法再进行合并。</p></blockquote><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><ul><li><p>分解：首先将 2 个大整数 a（n 位）、b（m 位）分解为两部分：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025105405840.png" alt="image-20221025105405840"></p><p>ah 表示大整数 a 的高位，al 表示大整数 a 的低位。bh 表示大整数 b 的高位，bl 表示大整数 b 的低位。</p><p>2 个大整数 a（n 位）、b（m 位）相乘转换成了 4 个乘法运算 *ah bh、 *ah bl、 *al bh、 *al bl ，而<strong>乘数的位数变为了原来的一半</strong>。</p></li><li><p>求解子问题</p><p>继续分解每个乘法运算，直到分解有一个乘数为 1 位数时停止分解，进行乘法运算并记录结果。</p></li><li><p>合并</p><p>将计算出的结果相加并回溯，求出最终结果。</p></li></ul><p>具体如何处理呢？</p><ol><li><p>首先将两个大数以字符串的形式输入，转换成数字后，<strong>倒序存储</strong>在数组 s[]中，l 用来表示数的长度，c 表示次幂。两个大数的初始次幂为 0。</p><blockquote><p>倒序存储的原因——因为乘法加法运算中有可能产生进位，倒序存储时可以让进位存储在数组的末尾</p></blockquote><ul><li>cp()函数：用于将一个 n 位的数分成两个 n&#x2F;2 的数并存储，记录它的长度和次幂。</li><li>mul()函数：用于将两个数进行相乘，不断地进行分解，直到有一个乘数为 1 位数时停止分解，进行乘法运算并记录结果。</li><li>add()函数：将分解得到的数进行相加合并。</li></ul></li><li><p>乘法运算：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025110347497.png" alt="image-20221025110347497"></p><p>3 首先和 1 相乘得到 3 存储在下面数组的第 0 位；然后 3 和 4 相乘得到 12，先存储先存储 12%10&#x3D;2，然后存储进位 12&#x2F;10&#x3D;1，这样乘法运算的结果是 321，<strong>注意是倒序</strong>，实际含义是 3×41&#x3D;123；两数相乘时，结果的次幂是两个乘数次幂之和，3×10<sup>3</sup> ×41×10<sup>3</sup> &#x3D;123×10<sup>6</sup>。</p></li></ol><h3 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li><p>数据结构</p><p>将两个大数以字符串的形式输入，然后定义结构体 Node，其中 s[]数组用于存储大数，注意是倒序存储！l 用于表示长度，c 表示次幂。两个大数的初始次幂为 0。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">char</span> sa<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> sb<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_Node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l<span class="token punctuation">;</span>            <span class="token comment">//代表字符串的长度</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Node<span class="token punctuation">,</span><span class="token operator">*</span>pNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>划分函数</p><p>其中，cp()函数用于将一个 n 位的数分成两个 n&#x2F;2 的数并存储，记录它的次幂。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">cp</span><span class="token punctuation">(</span>pNode src<span class="token punctuation">,</span> pNode des<span class="token punctuation">,</span> <span class="token keyword">int</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//src 表示待分解的数结点，des 表示分解后得到的数结点</span>    <span class="token comment">//st 表示从 src 结点数组中取数的开始位置，l 表示取数的长度</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>st<span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>st<span class="token operator">+</span>l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//从 src 结点数组中 st 位置开始，取 l 个数</span>    <span class="token punctuation">&#123;</span>        des<span class="token operator">-></span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将这些数放入到 des 结点的数组中</span>    <span class="token punctuation">&#125;</span>    des<span class="token operator">-></span>l <span class="token operator">=</span> l<span class="token punctuation">;</span><span class="token comment">//des 长度等于取数的长度</span>    des<span class="token operator">-></span>c <span class="token operator">=</span> st <span class="token operator">+</span> src<span class="token operator">-></span>c<span class="token punctuation">;</span>  <span class="token comment">//des 次幂等于开始取数的位置加上 src 次幂</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>乘法运算</p><p>定义的 mul()函数用于将两个数进行相乘，不断地进行分解，<strong>直到有一个乘数为 1 位时停止</strong>，让这两个数相乘，并记录结果回溯。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mul</span><span class="token punctuation">(</span>pNode pa<span class="token punctuation">,</span> pNode pb<span class="token punctuation">,</span> pNode ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> cc<span class="token punctuation">,</span> w<span class="token punctuation">;</span>    <span class="token keyword">int</span> ma <span class="token operator">=</span> pa<span class="token operator">-></span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">,</span> mb <span class="token operator">=</span> pb<span class="token operator">-></span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//长度除2</span>    Node ah<span class="token punctuation">,</span> al<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> bl<span class="token punctuation">;</span>    Node t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">,</span> t4<span class="token punctuation">,</span> z<span class="token punctuation">;</span>    pNode temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ma <span class="token operator">||</span> <span class="token operator">!</span>mb<span class="token punctuation">)</span> <span class="token comment">//如果其中个数为1</span>    <span class="token punctuation">&#123;</span>    <span class="token comment">//如果!ma 说明 ma=0，即 a 的长度为 1，该乘数为 1 位数</span>    <span class="token comment">//如果!mb 说明 mb=0，即 b 的长度为 1，该乘数为 1 位数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ma<span class="token punctuation">)</span>   <span class="token comment">//如果a串的长度为1，pa,pb交换，pa的长度大于等于pb的长度</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> pa<span class="token punctuation">;</span>            pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>            pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans<span class="token operator">-></span>c <span class="token operator">=</span> pa<span class="token operator">-></span>c <span class="token operator">+</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>        w <span class="token operator">=</span> pb<span class="token operator">-></span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//此时的进位为c</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pa<span class="token operator">-></span>l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>w<span class="token operator">*</span>pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            cc<span class="token operator">=</span> <span class="token punctuation">(</span>w<span class="token operator">*</span>pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>            ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> cc<span class="token punctuation">;</span> <span class="token comment">//如果到最后还有进位，则存入结果</span>        ans<span class="token operator">-></span>l <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token comment">//记录结果的长度</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//分治的核心</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> ma<span class="token punctuation">,</span> pa<span class="token operator">-></span>l<span class="token operator">-</span>ma<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//先分成4部分al,ah,bl,bh</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ma<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> mb<span class="token punctuation">,</span> pb<span class="token operator">-></span>l<span class="token operator">-</span>mb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//分成4部分相乘</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t4<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> ans<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并函数</p><p>add()函数将分解得到的数进行相加合并。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>pNode pa<span class="token punctuation">,</span> pNode pb<span class="token punctuation">,</span> pNode ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>cc<span class="token punctuation">,</span>k<span class="token punctuation">,</span>palen<span class="token punctuation">,</span>pblen<span class="token punctuation">,</span>len<span class="token punctuation">;</span>    <span class="token keyword">int</span> ta<span class="token punctuation">,</span> tb<span class="token punctuation">;</span>    pNode temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pa<span class="token operator">-></span>c<span class="token operator">&lt;</span>pb<span class="token operator">-></span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//保证Pa的次幂大</span>    <span class="token punctuation">&#123;</span>        temp <span class="token operator">=</span> pa<span class="token punctuation">;</span>        pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>        pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ans<span class="token operator">-></span>c <span class="token operator">=</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    cc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    palen<span class="token operator">=</span>pa<span class="token operator">-></span>l <span class="token operator">+</span> pa<span class="token operator">-></span>c<span class="token punctuation">;</span>    pblen<span class="token operator">=</span>pb<span class="token operator">-></span>l <span class="token operator">+</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>palen<span class="token operator">></span>pblen<span class="token punctuation">)</span>        len<span class="token operator">=</span>palen<span class="token punctuation">;</span>    <span class="token keyword">else</span>        len<span class="token operator">=</span>pblen<span class="token punctuation">;</span>    k<span class="token operator">=</span>pa<span class="token operator">-></span>c <span class="token operator">-</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token operator">-</span>ans<span class="token operator">-></span>c<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//结果的长度最长为pa，pb之中的最大长度减去最低次幂</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">)</span>            ta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            ta <span class="token operator">=</span> pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//次幂高的补0，大于低的长度后与0进行计算</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>pb<span class="token operator">-></span>l<span class="token punctuation">)</span>            tb <span class="token operator">=</span> pb<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            tb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>pa<span class="token operator">-></span>l<span class="token operator">+</span>k<span class="token punctuation">)</span>            ta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ta <span class="token operator">+</span> tb <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token punctuation">(</span>ta <span class="token operator">+</span> tb <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>        ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> cc<span class="token punctuation">;</span>    ans<span class="token operator">-></span>l <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>完整代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 3-4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">char</span> sa<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> sb<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_Node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l<span class="token punctuation">;</span>            <span class="token comment">//代表字符串的长度</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Node<span class="token punctuation">,</span><span class="token operator">*</span>pNode<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">cp</span><span class="token punctuation">(</span>pNode src<span class="token punctuation">,</span> pNode des<span class="token punctuation">,</span> <span class="token keyword">int</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>st<span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>st<span class="token operator">+</span>l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        des<span class="token operator">-></span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    des<span class="token operator">-></span>l <span class="token operator">=</span> l<span class="token punctuation">;</span>    des<span class="token operator">-></span>c <span class="token operator">=</span> st <span class="token operator">+</span> src<span class="token operator">-></span>c<span class="token punctuation">;</span>  <span class="token comment">//次幂</span><span class="token punctuation">&#125;</span><span class="token comment">/*分治法 大数乘法X = A*10^n + BY = C*10^m + DX*Y = A*C*10^(n+m) + A*D*10^n + B*C*10^m + B*D*/</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>pNode pa<span class="token punctuation">,</span> pNode pb<span class="token punctuation">,</span> pNode ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>cc<span class="token punctuation">,</span>k<span class="token punctuation">,</span>palen<span class="token punctuation">,</span>pblen<span class="token punctuation">,</span>len<span class="token punctuation">;</span>    <span class="token keyword">int</span> ta<span class="token punctuation">,</span> tb<span class="token punctuation">;</span>    pNode temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pa<span class="token operator">-></span>c<span class="token operator">&lt;</span>pb<span class="token operator">-></span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//保证Pa的次幂大</span>    <span class="token punctuation">&#123;</span>        temp <span class="token operator">=</span> pa<span class="token punctuation">;</span>        pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>        pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ans<span class="token operator">-></span>c <span class="token operator">=</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    cc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    palen<span class="token operator">=</span>pa<span class="token operator">-></span>l <span class="token operator">+</span> pa<span class="token operator">-></span>c<span class="token punctuation">;</span>    pblen<span class="token operator">=</span>pb<span class="token operator">-></span>l <span class="token operator">+</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>palen<span class="token operator">></span>pblen<span class="token punctuation">)</span>        len<span class="token operator">=</span>palen<span class="token punctuation">;</span>    <span class="token keyword">else</span>        len<span class="token operator">=</span>pblen<span class="token punctuation">;</span>    k<span class="token operator">=</span>pa<span class="token operator">-></span>c <span class="token operator">-</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token operator">-</span>ans<span class="token operator">-></span>c<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//结果的长度最长为pa，pb之中的最大长度减去最低次幂</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">)</span>            ta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            ta <span class="token operator">=</span> pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//次幂高的补0，大于低的长度后与0进行计算</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>pb<span class="token operator">-></span>l<span class="token punctuation">)</span>            tb <span class="token operator">=</span> pb<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            tb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>pa<span class="token operator">-></span>l<span class="token operator">+</span>k<span class="token punctuation">)</span>            ta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ta <span class="token operator">+</span> tb <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token punctuation">(</span>ta <span class="token operator">+</span> tb <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>        ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> cc<span class="token punctuation">;</span>    ans<span class="token operator">-></span>l <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">mul</span><span class="token punctuation">(</span>pNode pa<span class="token punctuation">,</span> pNode pb<span class="token punctuation">,</span> pNode ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> cc<span class="token punctuation">,</span> w<span class="token punctuation">;</span>    <span class="token keyword">int</span> ma <span class="token operator">=</span> pa<span class="token operator">-></span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">,</span> mb <span class="token operator">=</span> pb<span class="token operator">-></span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//长度除2</span>    Node ah<span class="token punctuation">,</span> al<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> bl<span class="token punctuation">;</span>    Node t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">,</span> t4<span class="token punctuation">,</span> z<span class="token punctuation">;</span>    pNode temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ma <span class="token operator">||</span> <span class="token operator">!</span>mb<span class="token punctuation">)</span> <span class="token comment">//如果其中个数为1</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ma<span class="token punctuation">)</span>   <span class="token comment">//如果a串的长度为1，pa,pb交换，pa的长度大于等于pb的长度</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> pa<span class="token punctuation">;</span>            pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>            pb <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans<span class="token operator">-></span>c <span class="token operator">=</span> pa<span class="token operator">-></span>c <span class="token operator">+</span> pb<span class="token operator">-></span>c<span class="token punctuation">;</span>        w <span class="token operator">=</span> pb<span class="token operator">-></span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//此时的进位为c</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pa<span class="token operator">-></span>l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>w<span class="token operator">*</span>pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            cc<span class="token operator">=</span> <span class="token punctuation">(</span>w<span class="token operator">*</span>pa<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cc<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>            ans<span class="token operator">-></span>s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> cc<span class="token punctuation">;</span> <span class="token comment">//如果到最后还有进位，则存入结果</span>        ans<span class="token operator">-></span>l <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token comment">//记录结果的长度</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//分治的核心</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> ma<span class="token punctuation">,</span> pa<span class="token operator">-></span>l<span class="token operator">-</span>ma<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//先分成4部分al,ah,bl,bh</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ma<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> mb<span class="token punctuation">,</span> pb<span class="token operator">-></span>l<span class="token operator">-</span>mb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cp</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//分成4部分相乘</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>al<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t4<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> ans<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node ans<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入大整数 a:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> sa<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入大整数 b:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> sb<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>l<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//sa,sb以字符串进行处理</span>    b<span class="token punctuation">.</span>l<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> a<span class="token punctuation">.</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        a<span class="token punctuation">.</span>s<span class="token punctuation">[</span>z<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>             <span class="token comment">//倒向存储</span>    a<span class="token punctuation">.</span>c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> b<span class="token punctuation">.</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        b<span class="token punctuation">.</span>s<span class="token punctuation">[</span>z<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> sb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">mul</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最终结果为："</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> ans<span class="token punctuation">.</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">.</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">//ans用来存储结果，倒向存储</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-3"><a href="#算法复杂度分析：-3" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p><strong>时间复杂度：</strong></p><p>我们假设大整数 a、b 都是 n 位数，根据分治策略， ab 相乘将转换成了 4 个乘法运算ah×bh、ah×bl、al×bh、al×bl，而<strong>乘数的位数变为了原来的一半</strong>。直到最后递归分解到其中一个乘数为 1 位为止，每次递归就会使数据规模减小为原来的一半。假设两个 n 位大整数相乘的时间复杂度为 T(n)，则：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025113307465.png" alt="image-20221025113307465"></p><p>当 n&gt;1 时，可以递推求解如下：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025113650106.png" alt="image-20221025113650106"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup> 则x &#x3D; logn，所以大整数乘法的时间复杂度为O(n<sup>2</sup>)</p><p><strong>空间复杂度：</strong></p><p>程序中变量占用了一些辅助空间，都是常数阶的，但合并时结点数组占用的辅助空间为 O(n)，递归调用所使用的栈空间是 O(logn)，大整数乘法的空间复杂度为O(n<sup>2</sup>)</p><h3 id="优化拓展：-2"><a href="#优化拓展：-2" class="headerlink" title="优化拓展："></a>优化拓展：</h3><p>如果两个大整数都是 n 位数，那么有：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114210441.png" alt="image-20221025114210441"></p><p>还记得快速算出 1+2+3+…+100 的小高斯吗？这孩子长大以后更聪明，他把 4 次乘法运算变成了 3 次乘法：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114312929.png" alt="image-20221025114312929"></p><p>这样公式中，只需要进行 3 次乘法。</p><p>那么时间复杂度为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114401541.png" alt="image-20221025114401541"></p><p>当 n&gt;1 时，可以递推求解如下：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114416856.png" alt="image-20221025114416856"></p><p>递推最终的规模为 1，令 n &#x3D; 2<sup>x</sup> ，则 x &#x3D; logn，那么有：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114522459.png" alt="image-20221025114522459"></p><p>优化改进后的大整数乘法的时间复杂度从 O(n2 )降为 O(n1.59 )，这是一个巨大的改进！</p><p>但是需要注意：在上面的公式中，A 和 B 必须 2<sup>n</sup> 位。很容易证明，如果不为 2<sup>n</sup>，那么 A或者 B 在分解过程中必会出现奇数，那么 a<em>c 和（（a−b）（d−c）+a</em>c+b*d）的次幂就有可能不同，无法变为 3 次乘法了，解决方法也很简单，只需要补齐位数即可，在数前（高位）补 0。</p><h2 id="分治算法复杂度求解秘籍"><a href="#分治算法复杂度求解秘籍" class="headerlink" title="分治算法复杂度求解秘籍"></a>分治算法复杂度求解秘籍</h2><p>分治法的道理非常简单，就是把一个大的复杂问题分为 a（a&gt;1）个形式相同的子问题，这些子问题的规模为 n&#x2F;b，如果分解或者合并的复杂度为 f(n)，那么总的时间复杂度可以表示为：</p><p><img src="/2022/10/23/suan-fa-ru-men-fen-zhi-fa/image-20221025114832010.png" alt="image-20221025114832010"></p><p>上面的求解方式都是递推求解，写出其递推式，最后求出结果。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-图</title>
      <link href="/2022/10/03/shu-ju-jie-gou-ru-men-tu/"/>
      <url>/2022/10/03/shu-ju-jie-gou-ru-men-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote><p>图形结构是<strong>多对多</strong>的关系，任何两个数据元素都可能有关系，每个节点可以有多个前驱和后继。</p></blockquote><h3 id="图的基本术语"><a href="#图的基本术语" class="headerlink" title="图的基本术语"></a>图的基本术语</h3><p>图通常用一个二元组 G&#x3D;&lt;V, E&gt;表示，V 表示顶点集，E 表示边集。</p><ul><li>|V|表示顶点集中元素的个数，即顶点数，n 个顶点的图称为 n 阶图。</li><li>|E|表示边集中元素的个数，即边数。</li></ul><blockquote><p>注意：顶点集 V 和边集 E 均为有限集合，其中 <strong>E 可以为空集，V 不可以为空集</strong>，但在运算中，可能产生 V 为空集。</p><p><strong>V 为空集</strong>的图称为空图，记为φ 。</p></blockquote><ol><li><p><strong>无向图</strong></p><p>若图 G 中每条边都是没有方向的，则称为无向图。</p><p>每条边都是两个顶点组成的无序对，例如顶点 v<sub>1</sub> 和顶点 v<sub>3</sub> 之间的边，记为（v<sub>1</sub> , v<sub>3</sub>）或（v<sub>3</sub> , v<sub>1</sub>）</p></li><li><p><strong>有向图</strong></p><p>若图 G 中每条边都是有方向的，则称为有向图。</p><p>有向边也称为<strong>弧</strong>，每条弧都是由两个顶点组成的有序对，例如从顶点 v<sub>1</sub> 到顶点 v<sub>3</sub> 的弧，记为&lt;v<sub>1</sub>，v<sub>3</sub> &gt;，v<sub>1</sub> 称为弧尾，v<sub>3</sub> 称为弧头。</p></li><li><p><strong>简单图</strong></p><p>既不含平行边也不含环的图称为简单图。</p><ul><li><p>平行边：</p><p>在无向图中，若关联一对顶点的无向边多于一条，则称这些边为平行边，平行边的条数称为重数；</p><p>在有向图中，若关联一对顶点的有向边多于一条，并且这些边的始点和终点相同（<strong>方向一致</strong>），则称这些边为平行边</p><blockquote><p>含有平行边的图称为多重图。平行边的条数称为重数。</p></blockquote></li><li><p>自环：</p><p>自环是指一条边关联的两个顶点为同一个顶点，也就是说自己到自己有一条边。</p></li></ul></li><li><p><strong>完全图</strong></p><p>在无向图中，若<strong>任意两个点都有一条边</strong>，则该图称为无向完全图。</p><blockquote><p>含有 n 个顶点的无向图，每个顶点到其他的 n−1 个顶点都有边，一共有 n(n−1)&#x2F;2 条边。</p></blockquote><p>在有向图中，若<strong>任意两个点都有两条方向相反的两条弧</strong>，则该图称为有向完全图。</p><blockquote><p>含有 n 个顶点的有向图，每个顶点发出 n−1 条边，并且进来 n−1 条边，一共有 n(n−1)条边。</p></blockquote></li><li><p><strong>稀疏图和稠密图</strong></p><p>有很少边或弧的图称为稀疏图，反之，则称为稠密图。这是一个非常模糊的概念，很难讲多少算稀疏，多少算稠密，一般来说，若图 G 满足|E|&lt;|V|×log|V|，则称 G 为稀疏图。</p></li><li><p><strong>网</strong></p><p>在实际应用中，经常在边上标注如距离、时间、耗费等数值，该数值称为边的权值。带权的图称为网。</p></li><li><p><strong>邻接和关联</strong></p><p>邻接是指<strong>顶点和顶点</strong>之间的关系，关联是指<strong>边和顶点</strong>之间的关系。</p><p>有边&#x2F;弧相连的两个顶点之间的关系，如无向边(v<sub>i</sub>, v<sub>j</sub>)，则称 v<sub>i</sub> 和 v<sub>j</sub> 互为邻接点；有向边&lt;v<sub>i</sub>, v<sub>j</sub>&gt;，则称 v<sub>i</sub> 邻接到v<sub>j</sub>，v<sub>j</sub> 邻接于 v<sub>i</sub>。若存在(v<sub>i</sub>, v<sub>j</sub>)或&lt;v<sub>i</sub>, v<sub>j</sub>&gt;，则称该边或弧关联于 v<sub>i</sub> 和 v<sub>j</sub>，</p></li><li><p><strong>顶点的度</strong></p><p>顶点的度是指与该顶点相关联的边的数目，记为 TD(v)。</p><p><strong>握手定理</strong>：<strong>度数之和等于边数的两倍</strong></p><p><img src="/2022/10/03/shu-ju-jie-gou-ru-men-tu/image-20221003105732197.png" alt="image-20221003105732197"></p><p>如果在计算度数时，每算一度划一条线，则可以看出每条边被计算了两次。</p><p>在有向图中，顶点的度又分为入度和出度：</p><ul><li>顶点 v 的入度是以 v 为终点的有向边的条数，记作 ID(v)，即进来的边数。</li><li>顶点 v 的出度是以 v 为始点的有向边的条数，记作 OD(v)，即发出的边数。</li></ul><p>顶点 v 的度等于其入度和出度之和，即：</p><p><img src="/2022/10/03/shu-ju-jie-gou-ru-men-tu/image-20221003105848735.png" alt="image-20221003105848735"></p><p>在有向图中，所有顶点的入度之和等于出度之和，又因为所有顶点度数之和等于边的 2倍，因此：</p><p><img src="/2022/10/03/shu-ju-jie-gou-ru-men-tu/image-20221003110514033.png" alt="image-20221003110514033"></p></li><li><p><strong>路径、路径长度和距离</strong></p><p>路径：接续的边的顶点构成的序列。</p><p>路径长度：路径上边或弧的数目。</p><p>距离：从顶点到另一顶点的最短路径长度。</p></li><li><p><strong>回路（环）、简单路径和简单回路</strong></p><p>回路（环）：第一个顶点和最后一个顶点相同的路径。</p><p>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。</p><p>简单回路：除路径起点和终点相同外，其余顶点均不相同的路径。</p></li><li><p><strong>子图与生成子图</strong></p><p>子图：设有两个图 G&#x3D;(V, E)、G1 &#x3D;(V1 , E1 )，若 V1⊆V，E1 ⊆ E，则称 G1 是 G 的子图。从图中选择若干个顶点、若干条边构成的图称为原图的子图。</p><p>生成子图：从图中选择所有顶点，若干条边构成的图称为原图的生成子图。</p></li><li><p><strong>连通图和连通分量</strong></p><p>连通图：在无向图中，如果顶点 v i 到 v j 有路径，则称 v i 和 vj 是连通的。</p><p>如果图中<strong>任何两个顶点都是连通的</strong>，则称 G 为连通图。</p><p>连通分量：无向图 G 的极大连通子图称为 G 的连通分量。极大连通子图意思是：该子图是 G 的连通子图，<strong>如果再加入一个顶点，该子图不连通</strong>。</p><blockquote><p>对于连通图，其连通分量就是它自己；对于非连通图，则有 2 个以上连通分量。</p></blockquote></li><li><p><strong>强连通图和强连通分量</strong></p><p>强连通图：<strong>在有向图中</strong>，如果图中任何两个顶点 v i 到 v j 有路径，且 v j 到 v i 也有路径，则称 G 为强连通图。</p><p>强连通分量：有向图 G 的极大强连通子图称为 G 的强连通分量。极大强连通子图意思是：该子图是 G 的强连通子图，如果再加入一个顶点，该子图不再是强连通的。</p></li><li><p><strong>树和有向树</strong></p><p>从图论的角度来看，树是一个无环连通图。</p><p>一个含 n 个顶点、m 条边的图，只要满足下列 5 个条件之一就是一棵树：</p><ul><li>G 是连通图且 m&#x3D;n−1；</li><li>G 是连通图且无环；</li><li>G 是连通图，但删除任意一条边就不连通；</li><li>G 是无环图，但添加任意一条边就会产生环；</li><li>G 中任意一对顶点之间仅存在一条简单路径。</li></ul><blockquote><p>有向树：<strong>只有一个顶点入度为 0，其余顶点入度均为 1 的有向图</strong></p></blockquote></li><li><p><strong>生成树和生成森林</strong></p><p>极小连通子图：该子图是 G 的连通子图，在<strong>该子图中删除任何一条边，该子图不再连通</strong>。</p><p>生成树：包含无向图 G <strong>所有顶点的极小连通子图</strong>。</p><blockquote><p>因为生成树包含所有顶点，因此只有连通图才有生成树，而非连通图，每一个连通分量会有一棵生成树。</p></blockquote><p>生成森林：对非连通图，由各个连通分量的生成树组成的集合。</p></li><li><p><strong>二分图</strong></p><p>二分图，又称为二部图，是图论中的一种特殊模型。设 G&#x3D;&lt;V，E&gt;是一个无向图，如果顶点集 V 可分割为两个互不相交的子集 V1、V2，并且图中的每条边(i, j)所关联的两个顶点 i 和 j 分别属于这两个不同的顶点集(i∈V1 , j∈V2 )，则称图 G 为二分图：</p><p><img src="/2022/10/03/shu-ju-jie-gou-ru-men-tu/image-20221003114408992.png" alt="image-20221003114408992"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英雄联盟大乱斗攻略</title>
      <link href="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/"/>
      <url>/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="英雄联盟大乱斗攻略"><a href="#英雄联盟大乱斗攻略" class="headerlink" title="英雄联盟大乱斗攻略"></a>英雄联盟大乱斗攻略</h2><blockquote><p><strong>版本：12.16版本 2022.08.25</strong></p></blockquote><h3 id="乱斗须知："><a href="#乱斗须知：" class="headerlink" title="乱斗须知："></a>乱斗须知：</h3><ol><li>大乱斗生态里<strong>战士最高</strong>，<strong>法师最低</strong>、<strong>射手是后期的绝对保障</strong>。原因是法师后期刮痧（只有少数法师具有高爆发），丢丢怪一冲就烂。</li><li>但是在路人局里，丢丢怪<strong>前期压制力高</strong>、<strong>操作简单</strong>、<strong>通用性强</strong>，因此胜率明显更高。</li><li>大乱斗作为一个随机模式，一个英雄的胜率并不完全等于其强度。</li></ol><h3 id="BP环节："><a href="#BP环节：" class="headerlink" title="BP环节："></a>BP环节：</h3><ol><li>（<strong>优先</strong>）确保己方清线没有问题。——<strong>线权优先</strong><ul><li>线权是推塔守塔的基础，尤其是“炮车线”，这时候可以用各种手段压制对面不能轻易守塔（越塔，死歌去送，大树大招，兰博大招等），配合“炮车线”能把塔打到半血以下甚至推掉。</li><li>部分英雄需要兵线与技能配合：亚索、永恩、狗头、小法、格温、刀妹、吸血鬼、大树</li></ul></li><li>（<strong>优先</strong>）确保己方控制没有问题。——<strong>团战优先</strong></li><li>确保OB英雄别同时出场太多。——类似发育型提莫、天使，观战型寡妇、小丑</li><li>尽量倾向：前排有威胁、射手有消耗、法师有控制<ul><li>前排有威胁指的是敌人不可能无视你越过你去攻击你的队友。只要能让对面优先针对你，那你就是合格的前排。</li><li>射手有消耗指的是射手可以随时随地打输出，不必强迫自家前排去开团自己再开始A人。</li><li>法师有控制法师几乎全有控制，所以法师的控制指的是要有“摸奖型控制”。摸奖型控制不需要在特定的情况下使用，决定了队伍绝对的先手权。</li></ul></li></ol><blockquote><p>注意：</p><ul><li><strong>前排不一定是坦克</strong>，类似死歌、冰女也算前排。</li><li><strong>前排≥2；1≤ADC≤2；法师+辅助≤2</strong>。特殊情况：1ADC或4ADC。</li></ul></blockquote><hr><p><strong>大乱斗前排基本玩法：</strong></p><ol><li>给己方后排当保镖，永不先手，谁过来打谁，比如盖伦布隆。——仅限己方后排比对方后排强的时候</li><li>追着对方后排控，即便打不死也要让对方无法输出，而且确保自己也不会轻易死。——对方后排比己方后排强的时候</li><li>打先手直接进人堆强拉仇恨，比如石头木木。——当己方团战更强时</li><li>让己方后排拉仇恨，对面切后排时直接忽视，躲草丛强冲对方后排，比如瑞雯剑圣。——当自己是个很强的输出型近战时</li></ol><h3 id="大乱斗专属机制BUFF："><a href="#大乱斗专属机制BUFF：" class="headerlink" title="大乱斗专属机制BUFF："></a>大乱斗专属机制BUFF：</h3><p><strong>远程削弱：</strong>来自1000码外的英雄伤害会削减15%，不包含大招和DOT伤害。</p><p><strong>治疗机制：</strong>友军治疗减少50%。血包回复8%已损状态，2.5s的光环回复16%已损状态。</p><p><strong>近战福利：</strong>近战直接获得10点魔抗。近战对防御塔造成20%额外伤害。</p><p><strong>兵线机制：</strong>AOE伤害对小兵仅造成75%伤害。兵线生成效率为1波&#x2F;(25s-13s)。</p><p><strong>骰子机制：</strong>Points&#x3D;65+1.5\times 点数满250点则提供一个骰子（可积累最多2个）。国服乱斗提供：3周周免 + 4永久 &#x3D; 49英雄</p><h3 id="嚎哭深渊光环："><a href="#嚎哭深渊光环：" class="headerlink" title="嚎哭深渊光环："></a>嚎哭深渊光环：</h3><ol><li>+70召唤师技能急速</li><li>每秒回复0.15%最大法力值</li><li>每秒获得5点经验</li><li>友军治疗减少50%</li><li>附近非你击杀的敌方小兵提供6金币</li><li>近战英雄，获得10点额外魔抗</li><li>近战英雄，普通攻击对炮车和超级兵造成额外20%伤害</li><li>近战英雄，对建筑物造成额外20%伤害</li><li>所有英雄，对建筑物造成0~25%额外伤害（随时间增长，于18：00达到最大值）。<br>——8.9条不会同时生效，仅会取较大值</li><li>来自1000码外的英雄伤害会减少15%，不包括DOT和大招伤害</li></ol><h3 id="兵线机制："><a href="#兵线机制：" class="headerlink" title="兵线机制："></a>兵线机制：</h3><ol><li><p>兵线每隔（25秒~13秒）出发一波。</p><p>——该时间随着游戏时间增加而缩短。<br>——送头回家之前要计算兵线的进程。<br>（两个高地之间走路需要耗时22s）</p></li><li><p>兵线的移动速度变化是（325~425），基于游戏时间增长。</p></li><li><p>每“第3波”兵线会伴随1个炮车，炮车会探索1100码内的陷阱。</p><p>发现陷阱后4秒内，如果没有发现新的陷阱，炮车会失去这个技能。</p></li><li><p>小兵仅会受到75%的群体伤害。</p></li><li><p>受到英雄伤害后，超过<strong>15s</strong>送塔才算塔杀</p></li></ol><h3 id="赏金机制："><a href="#赏金机制：" class="headerlink" title="赏金机制："></a>赏金机制：</h3><ol><li>击杀提供180金币。</li><li>助攻者平分90金币的50%~100%（基于游戏时间）。</li><li>一血提供额外50%的击杀和助攻助攻金币。</li><li>终结额外赏金对应：2连杀+150；3连杀+300；4连杀+375；5连杀+450；6连杀+600。</li><li>和峡谷一样，死多了也会掉身价（指低于180）。</li></ol><p>从计算中可以看出来，击杀之后被终结的话，双方的经济其实是差不多的。所以，大乱斗想赢游戏，绝对不是靠杀人，而是靠兵线和防御塔的运营。</p><h3 id="血包机制："><a href="#血包机制：" class="headerlink" title="血包机制："></a>血包机制：</h3><ol><li><p>捡血包的人会回复8%的已损失血量和蓝量。</p></li><li><p>光环在2.5s后落下，范围内的人会回复16%的已损失血量和蓝量。</p><p>根据计算，如果已损失血量为1000，两段之和比第二段仅仅多回复67血。<br>前期谁吃无所谓不用让，重要的是大家一起吃就好。</p></li><li><p>龙女吃到敌方半区的治疗光环，会永久获得双抗和怒气恢复速度。（1护甲+1魔抗+0.05怒气恢复速度）</p></li></ol><h3 id="符文调整："><a href="#符文调整：" class="headerlink" title="符文调整："></a>符文调整：</h3><p>——削弱——</p><p>气定神闲：回复量由20%最大法力值<strong>降低</strong>至10%；对英雄造成伤害回蓝</p><p>黑暗收割：每层伤害由5<strong>降低</strong>至2</p><p>凯旋：回复量由12%已损失生命值<strong>降低</strong>至6%；金币由20<strong>降低</strong>至10</p><p>爆破： 充能伤害由（100+35%最大生命值）<strong>降低</strong>至（50+25%最大生命值）</p><p>——增强——</p><p>不灭之握：近战英雄获得的生命值由5<strong>提高</strong>到10；远程英雄获得的生命值由3<strong>提高</strong>到6</p><p>电刑：CD由25-20s<strong>降低</strong>至15-10s</p><p>血之滋味：CD由20s<strong>降低</strong>至15s</p><p>无效法球：CD由60s<strong>降低</strong>至30s</p><p>风暴聚集：自变量由10min<strong>减少</strong>至6min</p><p>调节： 生效时间由12min<strong>降低</strong>至8min</p><p>过度生长：获得的生命值由3<strong>提高</strong>到5；获得3.5%额外最大生命值的要求数量由120<strong>降低</strong>至80</p><p>神奇之鞋：生效时间由（12min-45s击杀）<strong>降低</strong>至（8min-30s击杀）</p><h3 id="符文选择："><a href="#符文选择：" class="headerlink" title="符文选择："></a>符文选择：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921103913715.png" alt="image-20220921103913715"></p><h3 id="符文通用模板："><a href="#符文通用模板：" class="headerlink" title="符文通用模板："></a>符文通用模板：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921104135297.png" alt="image-20220921104135297"></p><h3 id="出装通用模板："><a href="#出装通用模板：" class="headerlink" title="出装通用模板："></a>出装通用模板：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921104555438.png" alt="image-20220921104555438"></p><h3 id="装备选择雷区："><a href="#装备选择雷区：" class="headerlink" title="装备选择雷区："></a>装备选择雷区：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921104706893.png" alt="image-20220921104706893"></p><p>——在全联盟回血都被砍的情况下，振奋的百分之25回血回盾是很不错的装备，适用于被动回血回盾或者小技能回血回盾的英雄，虽然说没有自然之力魔抗强但是续航能力会高上不少（例如鳄鱼）</p><p>——战士装备可选：咳血+血手&#x2F;死舞+振奋</p><h3 id="大乱斗黄金节点："><a href="#大乱斗黄金节点：" class="headerlink" title="大乱斗黄金节点："></a>大乱斗黄金节点：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921105115254.png" alt="image-20220921105115254"></p><h3 id="大乱斗送死时机："><a href="#大乱斗送死时机：" class="headerlink" title="大乱斗送死时机："></a>大乱斗送死时机：</h3><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220921105220294.png" alt="image-20220921105220294"></p><blockquote><p>转载于<a href="https://tieba.baidu.com/p/7993064213?pn=1">【图片】【12.16】大乱斗攻略&amp;全英雄玩法分析～【极地大乱斗吧】_百度贴吧 (baidu.com)</a>，作者果知芽。</p></blockquote><p>附上最近打的几把乱斗：</p><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220922174649602.png" alt="image-20220922174649602"></p><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220922174732483.png" alt="image-20220922174732483"></p><p><img src="/2022/09/20/ying-xiong-lian-meng-da-luan-dou-gong-lue/image-20220922174810604.png" alt="image-20220922174810604"></p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门--树</title>
      <link href="/2022/09/19/shu-ju-jie-gou-ru-men-shu/"/>
      <url>/2022/09/19/shu-ju-jie-gou-ru-men-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>可以从集合论和图论两个角度定义树。本章从集合论的角度递归定义树，后续将从图论的角度再次定义树，读者可以体会两种定义的不同之处。</p><blockquote><p>树（tree）是 n（n≥0）个节点的有限集合，当 n&#x3D;0 时，为空树；n&gt;0 时，为非空树。</p></blockquote><p>任意一棵非空树，满足以下两个条件：</p><ol><li><strong>有且仅有一个称为根的节点</strong></li><li><strong>除根节点以外，其余节点可分为 m（m＞0）个互不相交的有限集 T1 , T2 , …, Tm</strong>，其中每一个集合本身又是一棵树，并且称为根的子树（subtree）</li></ol><p>与树相关的术语：</p><ul><li><p><strong>节点</strong>——节点包含数据元素及若干指向子树的分支信息。</p></li><li><p><strong>节点的度</strong>——节点拥有的子树个数。</p></li><li><p><strong>树的度</strong>——树中节点的最大度数。</p></li><li><p><strong>终端节点</strong>——度为 0 的节点，又称为叶子。</p></li><li><p><strong>分支节点</strong>——度大于 0 的节点。除了叶子都是分支节点。</p></li><li><p><strong>内部节点</strong>——除了树根和叶子都是内部节点。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919154441720.png" alt="image-20220919154441720"></p></li><li><p><strong>节点的层次</strong>——从根到该节点的层数（根节点为第 1 层）。</p></li><li><p><strong>树的深度（或高度）</strong>——指所有节点中最大的层数。例如，一棵树如图所示，根为第 1 层，根的子节点为第 2 层……该树的最大层次为 4，因此树的深度为 4。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919160646531.png" alt="image-20220919160646531"></p></li><li><p><strong>路径</strong>——树中两个节点之间所经过的节点序列。</p></li><li><p><strong>路径长度</strong>——两节点之间路径上经过的边数。例如，一棵树如图所示，D 到 A的路径为 D—B—A，D 到 A 的路径长度为 2。由于树中没有环，因此树中任意两个节点之间的路径都是唯一的。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919160705691.png" alt="image-20220919160705691"></p></li><li><p><strong>双亲、孩子</strong>——节点的子树的根称为该节点的孩子，反之，该节点为其孩子的双亲。</p></li><li><p><strong>兄弟</strong>——双亲相同的节点互称兄弟。</p></li><li><p><strong>堂兄弟</strong>——双亲是兄弟的节点互称堂兄弟。</p></li><li><p><strong>祖先</strong>——从该节点到树根经过的所有节点称为该节点的祖先。</p></li><li><p><strong>子孙</strong>——节点的子树中的所有节点都称为该节点的子孙。</p></li><li><p><strong>有序树</strong>——节点的各子树从左至右有序，不能互换位置。</p></li><li><p><strong>无序树</strong>——节点各子树可互换位置。</p></li><li><p><strong>森林</strong>——由 m（m≥0）棵不相交的树组成的集合。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919160717545.png" alt="image-20220919160717545"></p></li></ul><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>顺序存储采用一段连续的存储空间，因为树中节点的数据关系是一对多的逻辑关系，不仅要存储数据元素，<strong>还要存储它们之间的逻辑关系</strong>。</p><p>以下图为例，讲述三种顺序存储方法：双亲表示法、孩子表示法和双亲孩子表示法。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919161018120.png" alt="image-20220919161018120"></p><ol><li><p><strong>双亲表示法</strong></p><blockquote><p>双亲表示法，除了存储数据元素之外，还存储其双亲节点的存储位置下标，其中“−1”表示不存在。</p></blockquote><p>每一个节点有两个域，即数据域 data 和双亲域 parent：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220919170529719.png" alt="image-20220919170529719"></p><p>树根 A 没有双亲，双亲记为−1，B、C、D 的双亲为 A，而 A 的存储位置下标为 0，因此，B、C、D 的双亲记为 0。同样，E、F 的双亲为 B，而 B 的存储位置下标为 1，因此，E、F 的双亲记为 1。同理，其他节点也这样存储。</p></li><li><p><strong>孩子表示法</strong></p><p>孩子表示法是指除了存储数据元素之外，还存储其所有孩子的存储位置下标。</p><p>A 有 3 个孩子 B、C 和 D，而 B、C 和 D 的存储位置下标为 1、2 和 3，因此将 1、2 和 3 存入 A 的孩子域。同样，B 有 2 个孩子 E 和 F，而 E 和 F 的存储位置下标为 4 和 5，因此，将 4 和 5 存入 B 的孩子域。因为本题中每个节点都分配了 3 个孩子域（想一想，为什么？–树的度即节点的最大度为3），B 只有两个孩子，另一个孩子域记为−1，表示不存在。同理，其他节点也这样存储。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920112818666.png" alt="image-20220920112818666"></p></li><li><p><strong>双亲孩子表示法</strong></p><p>双亲孩子表示法是指除了存储数据元素之外，还存储其双亲和所有孩子的存储位置下标。此方法其实就是在孩子表示法的基础上增加了一个双亲域，其他<br>的都和孩子表示法相同，是双亲表示法和孩子表示法的结合体。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920112949426.png" alt="image-20220920112949426"></p></li></ol><p><strong>三种方法的优缺点：</strong></p><ul><li>双亲表示法只记录了每个节点的双亲，无法直接得到该节点的孩子。</li><li>孩子表示法可以得到该节点的孩子，但是无法直接得到该节点的双亲，而且由于不知道每个节点到底有多少个孩子，因此只能按照树的度（树中节点的最大度）分配孩子空间，这样做可能会浪费很多空间。</li><li>双亲孩子表示法是在孩子表示法的基础上，增加了一个双亲域，可以快速得到节点的双亲和孩子，其缺点和孩子表示法一样，可能浪费很多空间。</li></ul><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>由于树中每个节点的孩子数量无法确定，因此在使用链式存储时，<strong>孩子指针域不确定分配多少个合适</strong>。</p><p>如果采用“异构型”数据结构，每个节点的指针域个数按照节点的孩子数分配，则数据结构描述困难；如果采用每个节点都分配固定个数（如树的度）的指针域，则浪费很多空间。</p><blockquote><p>一种是采用<strong>邻接表</strong>的思路，将节点的所有孩子存储在一个单链表中，称为<strong>孩子链表表示法</strong>；</p><p>一种是采用<strong>二叉链表</strong>的思路，左指针存储第一个孩子，右指针存储右兄弟，称为<strong>孩子兄弟表示法</strong>。</p></blockquote><ol><li><p>孩子链表表示法</p><p>孩子链表表示法类似于邻接表，表头包含数据元素并指向第一个孩子指针，将所有孩子放入一个单链表中。</p><blockquote><p>在表头中，<code>data</code> 存储数据元素，<code>first</code> 为指向第 1 个孩子的指针。单链表中的节点记录<strong>该节点的下标和下一个节点的地址</strong>。</p></blockquote><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920120139111.png" alt="image-20220920120139111"></p><p>孩子链表表示法中，如果在表头中再增加一个双亲域 parent，则为双亲孩子链表表示法。</p></li><li><p>孩子兄弟表示法</p><blockquote><p>节点除了存储数据元素之外，还有两个指针域 lchild 和 rchild，被称为二叉链表。lchild 存储第一个孩子地址，rchild 存储右兄弟地址。</p></blockquote><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920121102928.png" alt="image-20220920121102928"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920121208519.png" alt="image-20220920121208519"></p><blockquote><p>孩子兄弟表示法的<strong>秘诀</strong>：<strong>长子当作左孩子，兄弟关系向右斜。</strong></p></blockquote></li></ol><h3 id="树、森林和二叉树的转换"><a href="#树、森林和二叉树的转换" class="headerlink" title="树、森林和二叉树的转换"></a>树、森林和二叉树的转换</h3><ol><li><p><strong>树和二叉树的转换</strong></p><p>根据树转换为二叉链表的秘诀，可以把任何一棵树转换为二叉树：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920152155413.png" alt="image-20220920152155413"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920152319975.png" alt="image-20220920152319975"></p></li><li><p><strong>森林和二叉树的转换</strong></p><p>森林是由 m（m≥0）棵不相交的树组成的集合。</p><p>可以把森林中的每棵树的树根看作兄弟关系，因此 3 棵树的树根 B、C 和 D 是兄弟，兄弟关系在右斜线上，其他的转换和树转二叉树一样，<strong>长子当作左孩子</strong>，<strong>兄弟关系向右斜</strong>。</p><p>或者把森林中的每一棵树转换成二叉树，然后把每棵树的根节点连接在右斜线上即可。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920152500257.png" alt="image-20220920152500257"></p></li></ol><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920152559528.png" alt="image-20220920152559528"></p><blockquote><p>由于普通的树每个节点的子树个数不同，存储和运算都比较困难，因此在实际应用中，可以将树或森林转换为二叉树，然后进行存储和运算。</p><p>二者存在唯一的对关系，因此不影响其结果。</p></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树（binary tree）是 n（n≥0）个节点构成的集合，它或为空树（n&#x3D;0），或满足以下两个条件：</p><ol><li><strong>有且仅有一个称为根的节点</strong>；</li><li>除根节点以外，其余节点分为两个互不相交的子集 T1 和 T2，分别称为 T 的<strong>左子树</strong>和<strong>右子树</strong>，且 T1 和 T2 本身都是二叉树。</li></ol><p>二叉树是一种特殊的树，<strong>它最多有两个子树</strong>，分别为左子树和右子树，<strong>二者是有序的</strong>，不可以互换。</p><blockquote><p><strong>也就是说，二叉树中不存在度大于 2 的节点。</strong></p></blockquote><p>二叉树一共有 5 种形态：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920153010650.png" alt="image-20220920153010650"></p><p>二叉树的结构最简单，规律性最强，因此通常被作为重点讲解。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><blockquote><p><strong>性质 1：在二叉树的第 i 层上至多有 2<sup>(i−1)</sup>个节点。</strong></p></blockquote><p>因为上一层的每个节点最多有两个孩子，因此当前层最多是上一层节点数的 2 倍：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920154158302.png" alt="image-20220920154158302"></p><blockquote><p><strong>性质 2：深度为 k 的二叉树至多有 2<sup>k</sup>−1 个节点。</strong></p></blockquote><p>把每层的节点数加起来就是整棵二叉树的最大节点数:</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920154419331.png" alt="image-20220920154419331"></p><blockquote><p><strong>性质 3：对于任何一棵二叉树，若叶子数为 n<sub>0</sub>，度为 2 的节点数为 n<sub>2</sub>，则 n<sub>0</sub>&#x3D;n<sub>2</sub>+1。</strong></p></blockquote><p><strong>证明：</strong>二叉树中的节点度数不超过 2，因此一共有 3 种节点，即度为 0、度为 1、度为 2。设二叉树总的节点数为 n，度为 0 的节点数为 n<sub>0</sub>，度为 1 的节点数为 n<sub>1</sub>，度为 2 的节点数为n<sub>2</sub>，总节点数等于 3 种节点数之和，即 n&#x3D;n<sub>0</sub> +n<sub>1</sub> +n<sub>2</sub>。</p><p>而总节点数又等于“<strong>分支数 b+1</strong>”，即 n&#x3D;b+1。为什么呢？</p><p>从下向上看，每一个节点对应一个分支，<strong>只有树根没有对应分支</strong>，因此总的节点数为“分支数 b+1”：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920161555719.png" alt="image-20220920161555719"></p><p>而分支数 b 怎么计算呢？</p><p>从上向下看，每个度为 2 的节点产生 2 个分支，度为 1 的节点产生 1个分支，度为 0 的节点没有分支，因此分支数 b&#x3D;n<sub>1</sub> +2n<sub>2</sub>，则 n&#x3D;b+1&#x3D;n<sub>1</sub>+2n<sub>2</sub> +1。而前面已经得到 n&#x3D;n<sub>0</sub> +n<sub>1</sub> +n<sub>2</sub>，两式联合得：n<sub>0</sub> &#x3D;n<sub>2</sub> +1。</p><p>有两种比较特殊的二叉树：满二叉树和完全二叉树。</p><ul><li><p><strong>满二叉树</strong>：一棵深度为 k 且有 2<sup>k</sup> −1 个节点的二叉树。满二叉树每一层都“充满”了节点，达到最大节点数。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920162104772.png" alt="image-20220920162104772"></p></li><li><p><strong>完全二叉树：</strong>除了最后一层外，每一层都是满的（达到最大节点数），最后一层节点是从左向右出现的（必须从左向右排列）。</p><p>深度为 k 的完全二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中编号 1～n 的节点<strong>一一对应</strong>。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920162233489.png" alt="image-20220920162233489"></p><blockquote><p>也就是说，如果 2 没有左孩子，就不可以有右孩子；如果 2 没有右孩子，3 不可以有左孩子。</p></blockquote></li></ul><blockquote><p><strong>性质 4：具有 n 个节点的完全二叉树的深度必为⎣log<sub>2</sub>n⎦ +1。</strong></p></blockquote><p>证明：假设完全二叉树的深度为 k，那么除了最后一层外，前 k−1 层都是满的，最后一层最少有一个节点，最后一层最多也可以充满节点，即 2<sup>k−1 </sup>个节点：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920163644646.png" alt="image-20220920163644646"></p><p>因此，2<sup>k−1</sup>≤n≤2<sup>k</sup>−1，右边放大后，2<sup>k−1</sup>≤n&lt;2<sup>k</sup>，同时取对数，k−1≤log<sub>2</sub>n&lt;k，所以k&#x3D;⎣log<sub>2</sub>n⎦+1。其中，⎣⎦表示取下限，⎣x⎦表示小于 x 的最大整数，如⎣3.6⎦&#x3D;3。</p><blockquote><p><strong>性质 5：对于完全二叉树，若从上至下、从左至右编号，则编号为 i 的节点，其左孩子编号必为 2i，其右孩子编号必为 2i +1，其双亲的编号必为 i&#x2F;2。</strong></p></blockquote><p><strong>例题 1：</strong>一棵完全二叉树有 1001 个节点，其中叶子节点的个数是多少？</p><p><strong>解题思路：</strong>首先找到最后一个节点 1001 的双亲节点，其双亲节点编号为 1001&#x2F;2&#x3D;500，该节点是最后一个拥有孩子的节点，其后面全是叶子，即 1001−500&#x3D;501 个叶子。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920170039952.png" alt="image-20220920170039952"></p><p><strong>例题 2：</strong>一棵完全二叉树第 6 层有 8 个叶子，则该完全二叉树最少有多少节点，最多有多少个节点？</p><p><strong>解题思路：完全二叉树的叶子分布在最后一层或倒数第二层</strong>，因此该树有可能为 6 层或 7 层。</p><p>节点最少的情况（6 层）：8 个叶子在最后一层，即第 6 层，前 5 层是满的。最少有 2<sup>5</sup>−1+8&#x3D;39 个节点。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920170949639.png" alt="image-20220920170949639"></p><p>节点最多的情况（7 层）：8 个叶子在倒数第二层，即第 6 层，前 6 层是满的，第 7 层最少缺失了 8×2 个节点，因为第 6层的 8 个叶子如果生成孩子的话，会有 16个节点。最多有 27−1−16&#x3D;111 个节点。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920171052194.png" alt="image-20220920171052194"></p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>二叉树也可以采用顺序存储，按完全二叉树的节点层次编号，依次存放二叉树中的数据元素。</p><p>完全二叉树很适合顺序存储方式，而普通二叉树在顺序存储时需要补充为完全二叉树，在对应完全二叉树没有孩子的位置<strong>补 0</strong>：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920171448183.png" alt="image-20220920171448183"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920171504011.png" alt="image-20220920171504011"></p><blockquote><p>显然，普通二叉树不适合顺序存储方式，因为有可能在补充为完全二叉树过程中，补充太多的 0，而<strong>浪费大量空间</strong>，因此普通二叉树可以使用链式存储。</p></blockquote><h4 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h4><p>二叉树采用链式存储方式：每个节点包含一个数据域，存储节点信息；还包含两个指针域，指向左右两个孩子。这种存储方式称为二叉链表：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920171945572.png" alt="image-20220920171945572"></p><p>一般情况下，二叉树采用二叉链表存储即可，但是在实际问题中，如果经常需要访问双亲节点，二叉链表存储则必须从根出发查找其双亲节点，这样做非常麻烦。</p><p>为了解决这一问题，<strong>可以增加一个指向双亲节点的指针域</strong>，这样每个节点就包含3 个指针域，分别指向两个孩子节点和双亲节点，还包含一个数据域，用来存储节点信息。这种存储方式称为三叉链表：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920172044758.png" alt="image-20220920172044758"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220920172134453.png" alt="image-20220920172134453"></p><h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><p>如果对二叉树进行操作，必须先创建一棵二叉树。如何创建一棵二叉树呢？</p><blockquote><p>从二叉树的定义就可以看出，它是递归定义的（除了根之外，左、右子树也是一棵二叉树），因此可以用<strong>递归</strong>来创建二叉树。</p></blockquote><p>递归创建二叉树有两种方法，分别是询问法和补空法。</p><ol><li><p><strong>询问法</strong></p><p>每次输入节点信息后，询问是否创建该节点的左子树，如果是，则递归创建其左子树，否则其左子树为空；询问是否创建该节点的右子树，如果是，则递归创建其右子树，否则其右子树为空。</p><p><strong>算法步骤：</strong></p><ol><li>输入节点信息，创建一个节点 T。</li><li>询问是否创建 T 的左子树，如果是，则递归创建其左子树，否则其左子树为 NULL。</li><li>询问是否创建 T 的右子树，如果是，则递归创建其右子树，否则其右子树为 NULL。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Bnode</span><span class="token punctuation">&#123;</span> <span class="token comment">/*定义二叉树存储结构*/</span><span class="token keyword">char</span> data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Bnode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Bnode<span class="token punctuation">,</span><span class="token operator">*</span>Btree<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">createtree</span><span class="token punctuation">(</span>Btree <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token comment">/*创建二叉树函数*/</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> check<span class="token punctuation">;</span><span class="token comment">/*判断是否创建左右孩子*/</span>    T<span class="token operator">=</span><span class="token keyword">new</span> Bnode<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入结点信息:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">/*输入根结点数据*/</span>    cin<span class="token operator">>></span>T<span class="token operator">-></span>data<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"是否添加 "</span><span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"的左孩子? (Y/N)"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">/*询问是否创建T的左子树*/</span>    cin<span class="token operator">>></span>check<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>check<span class="token operator">==</span><span class="token char">'Y'</span><span class="token punctuation">)</span>        <span class="token function">createtree</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        T<span class="token operator">-></span>lchild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"是否添加"</span><span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"的右孩子? (Y/N)"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">/*询问是否创建T的右子树*/</span>    cin<span class="token operator">>></span>check<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>check<span class="token operator">==</span><span class="token char">'Y'</span><span class="token punctuation">)</span>        <span class="token function">createtree</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        T<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>补空法</strong></p><p>补空法是指如果左子树或右子树为空时，则用特殊字符补空，如“#”，然后按照根、左子树、右子树的顺序，得到先序遍历序列，根据该序列递归创建二叉树：</p><p><strong>算法步骤：</strong></p><ol><li>输入补空后的二叉树先序遍历序列。</li><li>如果 ch&#x3D;&#x3D;’#’，T&#x3D;NULL；否则创建一个新节点 T，令 T-&gt;data&#x3D;ch；递归创建 T 的左子树；递归创建 T 的右子树。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span><span class="token comment">//引入队列头文件</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Bnode</span><span class="token punctuation">&#123;</span><span class="token comment">/*定义二叉树存储结构*/</span><span class="token keyword">char</span> data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Bnode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Bnode<span class="token punctuation">,</span><span class="token operator">*</span>Btree<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Createtree</span><span class="token punctuation">(</span>Btree <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token comment">/*创建二叉树函数*/</span><span class="token punctuation">&#123;</span>    <span class="token comment">//按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span><span class="token keyword">char</span> ch<span class="token punctuation">;</span>cin<span class="token operator">>></span>ch<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token char">'#'</span><span class="token punctuation">)</span>        T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//递归结束，建空树</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>T<span class="token operator">=</span><span class="token keyword">new</span> Bnode<span class="token punctuation">;</span>T<span class="token operator">-></span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span><span class="token comment">//生成根结点</span><span class="token function">Createtree</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归创建左子树</span><span class="token function">Createtree</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归创建右子树</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><blockquote><p>二叉树的遍历就是按某条搜索路径访问二叉树中的每个节点一次且只有一次。</p></blockquote><p>按照根的访问顺序不同，根在前面称为<strong>先序遍历</strong>（DLR），根在中间称为<strong>中序遍历</strong>（LDR），根在最后称为<strong>后序遍历</strong>（LRD）。</p><p>因为树的定义本身就是递归的，因此树和二叉树的基本操作用递归算法很容易实现。</p><h4 id="先序遍历："><a href="#先序遍历：" class="headerlink" title="先序遍历："></a>先序遍历：</h4><p>先序遍历是指先访问根，然后先序遍历左子树，再先序遍历右子树，即 DLR。</p><p><strong>算法步骤：</strong></p><p>如果二叉树为空，则空操作，否则：</p><ol><li>访问根节点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><blockquote><p><strong>左子树为空或已遍历才可以遍历右子树。</strong></p></blockquote><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//先序遍历</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout<span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>       <span class="token function">preorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">preorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h4><p>中序遍历是指中序遍历左子树，然后访问根，再中序遍历右子树，即 LDR。</p><p><strong>算法步骤：</strong></p><p>如果二叉树为空，则空操作，否则：</p><ol><li><p>中序遍历左子树</p></li><li><p>访问根节点</p></li><li><p>中序遍历右子树</p><blockquote><p><strong>左子树为空或已遍历才可以访问根</strong></p></blockquote></li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//中序遍历</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token function">inorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>       cout<span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>       <span class="token function">inorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h4><p>后序遍历是指后序遍历左子树，后序遍历右子树，然后访问根，即 LRD。</p><p><strong>算法步骤：</strong></p><p>如果二叉树为空，则空操作，否则：</p><ol><li><p>后序遍历左子树</p></li><li><p>后序遍历右子树</p></li><li><p>访问根节点</p><blockquote><p><strong>左子树、右子树为空或已遍历才可以访问根</strong></p></blockquote></li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">posorder</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//后序遍历</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token function">posorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">posorder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>       cout<span class="token operator">&lt;&lt;</span>T<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="投影法："><a href="#投影法：" class="headerlink" title="投影法："></a>投影法：</h4><p>如果不需要按照程序执行流程，那么只要写出二叉树的遍历序列即可，还可以使用投影法快速得到遍历序列。</p><p>原图：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122047322.png" alt="image-20220922122047322"></p><ol><li><p>中序遍历：</p><p>中序遍历就像在无风的情况下，遍历顺序为左子树、根、右子树，太阳直射，将所有的节点投影到地上</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922120407427.png" alt="image-20220922120407427"></p></li><li><p>先序遍历：</p><p>先序遍历就像在左边大风的情况下，将二叉树树枝刮向右方，且顺序为根、左子树、右子树，太阳直射，将所有的节点投影到地上</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922120828446.png" alt="image-20220922120828446"></p></li><li><p>后序遍历：</p><p>后序遍历就像在右边大风的情况下，将二叉树树枝刮向左方，且顺序为左子树、右子树、根，太阳直射，将所有的节点投影到地上</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122118027.png" alt="image-20220922122118027"></p></li></ol><h4 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h4><blockquote><p>首先遍历第 1 层，然后第 2层……同一层按照从左向右的顺序访问，直到最后一层。</p></blockquote><p>程序是怎么实现层次遍历的呢？</p><p>通过观察可以发现，先被访问的节点，其孩子也先被访问，先来先服务，因此可以用<strong>队列</strong>实现</p><p>下面以下图中的二叉树为例，展示该二叉树层次遍历的过程：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122047322.png" alt="image-20220922122047322"></p><p><strong>算法步骤：</strong></p><ol><li><p>首先创建一个队列 Q，令树根入队。（注意：实际上是指向树根 A 的指针入队，这里为了图解方便，直接把数据入队了。）</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122713832.png" alt="image-20220922122713832"></p></li><li><p>队头元素出队，输出 A，同时令 A 的孩子 B、C 入队（从左向右顺序，如果是普通树，则包含所有孩子）</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122738214.png" alt="image-20220922122738214"></p></li><li><p>队头元素出队，输出 B，同时令 B 的孩子 D、E 入队：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122809548.png" alt="image-20220922122809548"></p></li><li><p>队头元素出队，输出 C，同时令 C 的孩子 F 入队：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922122845581.png" alt="image-20220922122845581"></p></li><li><p>队头元素出队，输出 D，同时令 D 的孩子入队，D 没有孩子，什么也不做。</p></li><li><p>以此类推，直到队列为空，算法结束。</p></li></ol><p><strong>代码步骤：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Leveltraverse</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Btree p<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>Btree<span class="token operator">></span>Q<span class="token punctuation">;</span> <span class="token comment">//创建一个普通队列(先进先出)，里面存放指针类型</span>    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根指针入队</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果队列不空</span>    <span class="token punctuation">&#123;</span>        p<span class="token operator">=</span>Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取出队头元素作为当前扩展结点livenode</span>        Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//队头元素出队</span>        cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span>            Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//左孩子指针入队</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span>            Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//右孩子指针入队</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>二叉树是非线性数据结构，而遍历序列是线性序列，二叉树遍历实际上是将一个非线性结构进行线性化的操作。</p><p>根据线性序列的特性，除了第一个元素外，每一个节点都有唯一的前驱，除了最后一个元素外，每一个节点都有唯一的后继。而根据遍历序列的不同，每个节点的前驱和后继也不同。</p><blockquote><p>采用二叉链表存储时，只记录了左、右孩子的信息，无法直接得到每个节点的前驱和后继。</p></blockquote><h3 id="线索二叉树存储结构"><a href="#线索二叉树存储结构" class="headerlink" title="线索二叉树存储结构"></a>线索二叉树存储结构</h3><p>二叉树采用二叉链表存储时，每个节点有两个指针域。如果二叉链表有 n 个节点，则一共有 2n 个指针域，而只有 n−1 个是实指针，其余 n+1 个都是空指针，为什么呢？</p><p><strong>推导过程：</strong></p><p>因为二叉树有 n−1 个分支，每个分支对应一个实指针，每一个节点对应一个分支，只有树根没有对应分支，因此分支数等于节点数减 1，即 b&#x3D;n−1。</p><p>每个分支对应一个实指针，所以有 n−1 个实指针。</p><p>总的的指针数减去实指针数，即为空指针数，即 2n− (n−1)&#x3D;n+1。</p><blockquote><p>n 个节点的二叉链表中有 n+1 个空指针，<strong>可以充分利用空指针记录节点的前驱或后继信息，从而加快查找节点前驱和后继的速度</strong>。</p></blockquote><hr><p>每个节点还是两个指针域，如果节点有左孩子，则 lchild 指向左孩子，否则 lchild 指向其前驱；如果节点有右孩子，则 rchild 指向右孩子，否则 rchild 指向其后继。</p><blockquote><p>那么怎么区分到底存储的是左孩子和右孩子，还是前驱和后继信息呢？</p></blockquote><p>为了避免混淆，增加两个标志域 <strong>ltag</strong> 和 <strong>rtag</strong>：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922131353508.png" alt="image-20220922131353508"></p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922131359613.png" alt="image-20220922131359613"></p><hr><p>这种带有标志域的二叉链表称为<strong>线索链表</strong>，</p><p>指向前驱和后继的指针称为<strong>线索</strong>，</p><p>带有线索的二叉树称为<strong>线索二叉树</strong>，</p><p>以某种遍历方式将二叉树转化为线索二叉树的过程称为<strong>线索化</strong>。</p><h3 id="构造线索二叉树"><a href="#构造线索二叉树" class="headerlink" title="构造线索二叉树"></a>构造线索二叉树</h3><p>每种遍历顺序不同，节点的前驱和后继也不同，因此二叉树线索化必须指明是什么遍历顺序的线索化</p><p>线索二叉树分为前序线索二叉树、中序线索二叉树和后序线索二叉树。</p><blockquote><p><strong>二叉树线索化的过程，实际上是在遍历过程中修改空指针的过程。</strong></p></blockquote><p>可以设置两个指针，一个指针 pre 指向刚刚访问的节点，另一个指针 p 指向当前节点。也就是说，pre 指向的节点为 p 指向的节点的前驱，反之，p 指向的节点为 pre 指向的节点的后继。</p><blockquote><p>在遍历的过程中，如果当前节点 p 的左孩子为空，则该节点的 lchild 指向其前驱，即 p-&gt;lchild&#x3D;pre；</p><p>如果 pre节点的右孩子为空，则该节点的 rchild 指向其后继，即 pre-&gt;rchild&#x3D;p。</p></blockquote><p><strong>算法步骤：</strong></p><ol><li>指针 p 指向根节点，pre 初始化为空，pre 永远指向 p 的前驱。</li><li>若 p 非空，则重复下面操作：<ul><li>中序线索化 p 的左子树。</li><li>若 p 的左子树为空，则给 p 加上左线索，即 p-&gt;ltag&#x3D;1，p 的左子树指针指向 pre（前驱），即 p-&gt;lchild&#x3D;pre；否则令 p-&gt;ltag&#x3D;0。</li><li>若 pre 非空，则判断如果 pre 的右子树为空，给 pre 加上右线索，即 pre-&gt;rtag&#x3D;1，pre的右孩子指针指向 p（后继），即 pre-&gt;rchild&#x3D;p，否则令 pre-&gt;rtag&#x3D;0。</li><li>p 赋值给 pre，转向 p 的右子树。</li><li>中序线索化 p 的右子树。</li></ul></li><li>处 理 最 后 一 个 节 点 ， 令 其 后 继 为 空 ， 即pre-&gt;rchild&#x3D;NULL; pre-&gt;rtag&#x3D;1。</li></ol><hr><p>注意：如果在考试当中只要求绘图，则没必要按照程序执行的过程进行线索化，可以直接写出遍历序列。</p><blockquote><p><strong>根据该遍历序列的先后顺序，对所有的空指针域进行线索化，左指针为空，则令其指向前驱；右指针为空，则令其指向后继。</strong></p></blockquote><p>示例：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922163836111.png" alt="image-20220922163836111"></p><ol><li><p>首先写出二叉树的中序遍历序列，即 DBEAFGC，然后按照该遍历序列，对所有的空指针进行线索化。</p></li><li><p>D 的左指针为空，但在中序遍历序列中，D 是第一个元素，没有前驱，赋值为 NULL。</p></li><li><p>D 的右指针为空，中序遍历序列中 D 的后继是 B，因此 D 的右指针指向 B 节点。</p></li><li><p>同理，从中序遍历序列中可以很清楚地知道每个节点的前驱和后继，分别对所有节点的空指针进行线索化即可。</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922164012944.png" alt="image-20220922164012944"></p></li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InThread</span><span class="token punctuation">(</span>BTtree <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token comment">//中序线索化</span><span class="token punctuation">&#123;</span><span class="token comment">//pre是全局变量，指向当前结点p的前驱</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">InThread</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//左子树递归线索化</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span>   <span class="token comment">//p的左孩子为空</span><span class="token punctuation">&#123;</span>p<span class="token operator">-></span>ltag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//给p加上左线索</span>p<span class="token operator">-></span>lchild<span class="token operator">=</span>pre<span class="token punctuation">;</span> <span class="token comment">//p的左孩子指针指向pre（前驱）</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span>p<span class="token operator">-></span>ltag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token operator">-></span>rchild<span class="token punctuation">)</span>  <span class="token comment">//pre的右孩子为空</span>            <span class="token punctuation">&#123;</span>                pre<span class="token operator">-></span>rtag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//给pre加上右线索</span>                pre<span class="token operator">-></span>rchild<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//pre的右孩子指针指向p（后继）</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>                pre<span class="token operator">-></span>rtag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>pre<span class="token operator">=</span>p<span class="token punctuation">;</span>                     <span class="token comment">//保持pre指向p的前驱</span><span class="token function">InThread</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//右子树递归线索化</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h3><p>线索二叉树的线索记录了前驱和后继信息，因此可以利用这些信息进行遍历。下面以中序线索二叉树遍历为例，讲述遍历过程。</p><p><strong>算法步骤：</strong></p><ol><li>指针 p 指向根节点。</li><li>若 p 非空，则重复以下操作：<ul><li>p 指针沿左孩子向下，找到最左节点，它是中序遍历的第一个节点；</li><li>访问 p 节点；</li><li>沿着右线索查找当前节点 p 的后继节点并访问，直到右线索为 0 或遍历结束。</li></ul></li><li>遍历 p 的右子树。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InorderThread</span><span class="token punctuation">(</span>BTtree T<span class="token punctuation">)</span><span class="token comment">//遍历中序线索二叉树</span><span class="token punctuation">&#123;</span>    BTtree p<span class="token punctuation">;</span>    p<span class="token operator">=</span>T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>ltag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> p<span class="token operator">=</span>p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>  <span class="token comment">//找最左结点</span>       cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span><span class="token comment">//输出结点信息</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rtag<span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span> <span class="token comment">//右孩子为线索化，指向后继</span>       <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>   <span class="token comment">//访问后继结点</span>cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span><span class="token comment">//输出结点信息</span>       <span class="token punctuation">&#125;</span>       p<span class="token operator">=</span>p<span class="token operator">-></span>rchild<span class="token punctuation">;</span><span class="token comment">//转向p的右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于频繁查找前驱和后继的运算，线索二叉树优于普通二叉树。但是对于插入和删除操作，线索二叉树比普通二叉树开销大，因为除插入和删除操作外，还要修改相应的线索。</p><h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的遍历："><a href="#树的遍历：" class="headerlink" title="树的遍历："></a>树的遍历：</h3><p>树的遍历操作包括先根遍历和后根遍历两种方式。</p><ul><li>先根遍历：如果树非空，则先访问根节点，然后按从左向右的顺序，先根遍历根节点的每一棵子树。树的先根遍历顺序与该树对应的二叉树的先序遍历顺序相同。</li><li>后根遍历：如果树非空，则按从左向右的顺序，后根遍历根节点的每一棵子树，然后访问根节点。树的后根遍历顺序与该树对应的二叉树的中序遍历顺序相同。</li></ul><ol><li><p>先根遍历</p><p>先根遍历时，先访问根，然后按从左向右的顺序，先根遍历根节点的每一棵子树，第一棵子树遍历完毕，才可以遍历第二棵子树……</p></li><li><p>后根遍历</p><p>后根遍历时，先按从左向右的顺序后根遍历每一棵子树，没有子树或子树已遍历完毕，才可以访问根。</p></li></ol><h3 id="森林的遍历："><a href="#森林的遍历：" class="headerlink" title="森林的遍历："></a>森林的遍历：</h3><p>森林的遍历操作有先序遍历和中序遍历两种方式。</p><ul><li><p>先序遍历：</p><p>如果森林非空，则：</p><ul><li>访问第一棵树的根节点；</li><li>先序遍历第一棵树的根节点的子树森林；</li><li>先序遍历除第一个棵树之外，剩余的树构成的森林。</li></ul><p>其访问顺序与该森林对应的二叉树的先序遍历顺序相同。</p></li><li><p>中序遍历</p><p>如果森林非空，则：</p><ul><li>中序遍历第一棵树的根节点的子树森林；</li><li>访问第一棵树的根节点；</li><li>中序遍历除第一个棵树之外，剩余的树构成的森林。</li></ul><p>其访问顺序与该森林对应的二叉树的中序遍历顺序相同。</p></li></ul><h2 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h2><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>首先考虑特殊情况，如果二叉树为空，则深度为 0；一般情况下，二叉树的深度等于二叉树左右子树的<strong>深度最大值加 1</strong>。</p><p><strong>算法步骤：</strong></p><ol><li>如果二叉树为空，则深度为 0。</li><li>否则为根的左、右子树的深度最大值加 1。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//求二叉树的深度</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span>n<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//如果为空树，深度为0</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>m<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归计算左子树深度</span>n<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归计算左子树深度</span><span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">></span>n<span class="token punctuation">)</span><span class="token keyword">return</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//返回左右子树最大值加1</span><span class="token keyword">else</span><span class="token keyword">return</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的叶子数"><a href="#二叉树的叶子数" class="headerlink" title="二叉树的叶子数"></a>二叉树的叶子数</h3><p>首先考虑特殊情况，如果二叉树为空，则叶子数为 0；如果根的左、右子树都为空，则叶子数为 1；</p><blockquote><p><strong>一般情况下，二叉树的叶子数等于左子树的叶子数与右子树的叶子数之和。</strong></p></blockquote><p><strong>算法步骤：</strong></p><ol><li>如果二叉树为空，则叶子数为 0。</li><li>如果根的左、右子树都为空，则叶子数为 1。</li><li>否则求左子树的叶子数和右子树的叶子数之和，即为二叉树的叶子数。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">LeafCount</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//求二叉树的叶子数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//如果为空树，深度为0</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>T<span class="token operator">-></span>rchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//左右子树均为空，则叶子数为1</span>           <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>           <span class="token keyword">return</span> <span class="token function">LeafCount</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">LeafCount</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归计算左子树和右子树的叶子数之和</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，要计算二叉树的节点数，如果二叉树为空，则节点数为 0；</p><blockquote><p><strong>否则，二叉树的节点数等于左子树与右子树的节点数之和加 1。</strong></p></blockquote><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>Btree T<span class="token punctuation">)</span><span class="token comment">//求二叉树的结点数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//如果为空树，深度为0</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//递归计算左子树和右子树的结点数之和加1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>此类问题只需要考虑特殊情况，例如树空、只有一个根节点等，一般情况下，直接递归即可。</strong></p></blockquote><h3 id="三元组创建二叉树"><a href="#三元组创建二叉树" class="headerlink" title="三元组创建二叉树"></a>三元组创建二叉树</h3><p>假设以三元组(F, C, L&#x2F;R)的形式输入一棵二叉树的诸边（其中 F 是双亲节点的标识，C是孩子节点标识，L&#x2F;R 表示 C 为 F 的左孩子或右孩子），且在输入的三元组序列中，C 是按层次顺序出现的。</p><p>设节点的标识是字符类型，F 为 NULL 时，C 为根节点标识，若 C 亦为NULL，则表示输入结束。</p><p><strong>算法步骤：</strong></p><ol><li>输入第一组数据，创建根节点入队。因为是按层次输入的，所以可以借助队列实现。</li><li>输入下一组数据。</li><li>如果队列非空且输入数据<strong>前两项</strong>非空，则队头元素出队。</li><li><strong>判断输入数据中的双亲是否和队头元素相等</strong>，如果不相等，则转向第 3 步；如果相等，则创建一个新节点，判断该节点是其双亲的左孩子还是右孩子并做相应的处理，然后新节点入队。输入下一组数据，转向第 4 步（因为一个队头元素可能有两个孩子，所以不能创建一个孩子就结束）</li><li>直到队列为空或者输入数据前两项为空，算法停止。</li><li>输出先序、中序和后序序列。</li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">/*输入三元组 (F、C、L/R) 序列输入一棵二叉树的诸边(其中 F 表示双亲结点的标识，C 表示孩子结点标识，L/R 表示 C 为 F 的左孩子或右孩子)，且在输入的三元组序列中，C 是按层次顺序出现的。设结点的标识是字符类型。F=NULL时 C 为根结点标识，若 C 亦为NULL，则表示输入结束。试编写算法，由输入的三元组序列建立二叉树的二叉链表,并以先序、中序、后序序列输出。*/</span><span class="token comment">/*测试数据NULL A LA B LA C RB D RC E LC F RD G LF H LNULL NULL L*/</span><span class="token keyword">struct</span> <span class="token class-name">biTnode</span><span class="token punctuation">&#123;</span>    string data<span class="token punctuation">;</span>    biTnode <span class="token operator">*</span>lChild<span class="token punctuation">,</span><span class="token operator">*</span>rChild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> biTnode<span class="token operator">*</span> T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">CreatebiTree</span><span class="token punctuation">(</span>biTnode<span class="token operator">*</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    biTnode <span class="token operator">*</span>node<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>biTnode<span class="token operator">*</span><span class="token operator">></span>q<span class="token punctuation">;</span>    cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token operator">>></span>c<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token string">"NULL"</span><span class="token operator">&amp;&amp;</span>b<span class="token operator">!=</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token comment">//创建根结点</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">=</span><span class="token keyword">new</span> biTnode<span class="token punctuation">;</span>        node<span class="token operator">-></span>data<span class="token operator">=</span>b<span class="token punctuation">;</span>        node<span class="token operator">-></span>lChild<span class="token operator">=</span>node<span class="token operator">-></span>rChild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        T<span class="token operator">=</span>node<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token operator">>></span>c<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>a<span class="token operator">!=</span><span class="token string">"NULL"</span><span class="token operator">&amp;&amp;</span>b<span class="token operator">!=</span><span class="token string">"NULL"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token operator">==</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            node<span class="token operator">=</span><span class="token keyword">new</span> biTnode<span class="token punctuation">;</span>            node<span class="token operator">-></span>data<span class="token operator">=</span>b<span class="token punctuation">;</span>            node<span class="token operator">-></span>lChild<span class="token operator">=</span>node<span class="token operator">-></span>rChild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">"L"</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                p<span class="token operator">-></span>lChild<span class="token operator">=</span>node<span class="token punctuation">;</span>                cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"'s lChild is "</span><span class="token operator">&lt;&lt;</span>node<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                p<span class="token operator">-></span>rChild<span class="token operator">=</span>node<span class="token punctuation">;</span>                cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"'s rChild is "</span><span class="token operator">&lt;&lt;</span>node<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token operator">>></span>c<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历序列还原树"><a href="#遍历序列还原树" class="headerlink" title="遍历序列还原树"></a>遍历序列还原树</h3><p>根据遍历序列可以还原树，包括二叉树还原、树还原和森林还原 3 种。</p><h4 id="二叉树还原"><a href="#二叉树还原" class="headerlink" title="二叉树还原"></a>二叉树还原</h4><p>由二叉树的前序序列和中序序列，或者中序序列和后序序列，可以唯一地还原一棵二叉树。</p><blockquote><p><strong>注意：由二叉树的前序序列和后序序列不能唯一地还原一棵二叉树。</strong></p></blockquote><p><strong>算法步骤：</strong></p><ol><li><p>先序序列的第一个字符为根。</p></li><li><p>在中序序列中，以根为中心划分左右子树。</p></li><li><p>还原左右子树。</p><ul><li><p>先序序列的第一个字符 A 为根，在中序序列中以 A 为中心划分左右子树，左子树包含 DBE 三个节点，右子树包含 FGC 三个节点：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922222408128.png" alt="image-20220922222408128"></p></li><li><p>左子树 DBE，在先序序列中的顺序为 BDE，第一个字符 B 为根，在中序序列中以 B为中心划分左右子树，左右子树只有一个节点，因此直接作为 B 的左右孩子即可：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922222418292.png" alt="image-20220922222418292"></p></li><li><p>右子树 FGC，在先序序列中的顺序为 CFG，第一个字符 C 为根，在中序序列中以 C为中心划分左右子树，左子树包含 FG 节点，右子树为空：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922222429323.png" alt="image-20220922222429323"></p></li><li><p>左子树 FG，在先序序列中的顺序为 FG，第一个字符 F 为根，在中序序列中以 F 为中心划分左右子树，左为空，右子树只有一个节点 G，作为 F 的右孩子即可：</p><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922222438266.png" alt="image-20220922222438266"></p></li></ul></li></ol><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span>BiTree <span class="token function">pre_mid_createBiTree</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>mid<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token comment">//前序中序还原建立二叉树</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ch<span class="token operator">=</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//找到先序中的第一个结点</span>    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>mid<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span>ch<span class="token punctuation">)</span><span class="token comment">//在中序中找到的根结点的左边为该结点的左子树，右边为右子树</span>    <span class="token punctuation">&#123;</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    BiTree T<span class="token operator">=</span><span class="token keyword">new</span> BiTNode<span class="token punctuation">;</span><span class="token comment">//创建根结点</span>    T<span class="token operator">-></span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>    T<span class="token operator">-></span>lchild<span class="token operator">=</span><span class="token function">pre_mid_createBiTree</span><span class="token punctuation">(</span>pre<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>mid<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立左子树</span>    T<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token function">pre_mid_createBiTree</span><span class="token punctuation">(</span>pre<span class="token operator">+</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>mid<span class="token operator">+</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token operator">-</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立右子树</span>    <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码解释：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BiTree <span class="token function">pre_mid_createBiTree</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>mid<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数有 3 个参数，pre 和 mid 为指针类型，分别指向前序、中序序列的首地址；len为序列的长度。前序和中序的序列长度一定是相同的。<br>首先，先序序列的第一个字符 pre[0]为根，然后在中序序列中查找根所在的位置，用 index记录查找长度，找到后以根为中心，划分出左右子树。</p><ul><li>左子树：先序序列中的首地址为 pre+1，中序序列的首地址为 mid，长度为 index</li><li>右子树：先序序列中的首地址为 pre+index+1，中序序列的首地址为 mid+index+1，长度为 len−index−1；右子树的长度为总长度减去左子树的长度，再减去根。</li></ul><p><img src="/2022/09/19/shu-ju-jie-gou-ru-men-shu/image-20220922225011925.png" alt="image-20220922225011925"></p><p>由二叉树的后序序列和中序序列也可以唯一确定一棵二叉树，方法和上面一样，只不过后序序列的最后一个字符为根，然后在中序序列中以根为中心划分左右子树。</p><p><strong>代码实现：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BiTree <span class="token function">pro_mid_createBiTree</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>last<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>mid<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token comment">//后序中序还原建立二叉树</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>       <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ch<span class="token operator">=</span>last<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取得后序遍历顺序中最后一个结点</span>    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//在中序序列中找根结点，并用index记录长度</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>mid<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span>ch<span class="token punctuation">)</span><span class="token comment">//在中序中找到根结点，左边为该结点的左子树，右边为右子树</span>       index<span class="token operator">++</span><span class="token punctuation">;</span>    BiTree T<span class="token operator">=</span><span class="token keyword">new</span> BiTNode<span class="token punctuation">;</span><span class="token comment">//创建根结点</span>    T<span class="token operator">-></span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>    T<span class="token operator">-></span>lchild<span class="token operator">=</span><span class="token function">pro_mid_createBiTree</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立左子树</span>    T<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token function">pro_mid_createBiTree</span><span class="token punctuation">(</span>last<span class="token operator">+</span>index<span class="token punctuation">,</span>mid<span class="token operator">+</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token operator">-</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立右子树</span>    <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>先序遍历和中序遍历还原二叉树<strong>秘籍：先序找根，中序分左右。</strong></p><p>后序遍历和中序遍历还原二叉树<strong>秘籍：后序找根，中序分左右。</strong></p></blockquote><h4 id="树还原"><a href="#树还原" class="headerlink" title="树还原"></a>树还原</h4><p>由于树的先根遍历和后根遍历与其对应二叉树的先序遍历和中序遍历相同，因此可以根据该对应关系，先还原为二叉树，然后再把二叉树转换为树。</p><h4 id="森林还原"><a href="#森林还原" class="headerlink" title="森林还原"></a>森林还原</h4><p>由于森林的先序遍历和中序遍历与其对应二叉树的先序遍历和中序遍历相同，因此可以根据该对应关系，先还原为二叉树，然后再把二叉树转换为森林。</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼编码的基本思想是以<strong>字符的使用频率</strong>作为权来构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。</p><p>哈夫曼树是通过将所要编码的字符作为叶子节点，将该字符在文件中的使用频率作为叶子节点的权值，以自底向上的方式，做 n−1 次“合并”运算构造出来的。</p><blockquote><p>哈夫曼编码被广泛地应用于数据压缩，尤其是远距离通信和大容量数据存储，常用的 JPEG 图片就是采用哈夫曼编码压缩的。</p></blockquote><blockquote><p><strong>哈夫曼编码的核心思想是让权值大的叶子离根最近。</strong></p></blockquote><p>哈夫曼算法采取的<strong>贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树</strong>，构造一棵新树，新树根节点的权值为其左右孩子节点权值之和，并将新树插入树的集合中。</p><p><strong>算法步骤：</strong></p><ol><li>确定合适的数据结构。编写程序前需要考虑的情况如下：<ul><li>哈夫曼树中没有度为 1 的节点，则一棵有 n 个叶子节点的哈夫曼树共有 2n−1 个节点（n−1 次“合并”，每次产生一个新节点）。</li><li>构成哈夫曼树后，为求编码需从叶子节点出发走一条从叶子到根的路径。</li><li>译码需要从根出发走一条从根到叶子的路径。那么对每个节点而言，需要知道每个节点的权值、双亲、左孩子、右孩子和节点信息。</li></ul></li><li>初始化。构造 n 棵节点为 n 个字符的单节点树集合 T&#x3D;{t1, t2 , t3 , …, tn}，每棵树只有一个带权的根节点，权值为该字符的使用频率。</li><li>如果 T 中只剩下一棵树，则哈夫曼树构造成功，跳到第 6 步。否则，从集合 T 中取出没有双亲且权值最小的两棵树 t i 和 t j，将它们合并成一棵新树 zk，新树的左孩子为 t i，右孩子为 t j，zk 的权值为 t i 和 t j 的权值之和。</li><li>从集合 T 中删去 t i、t j，加入 zk。</li><li>重复以上第 3 步和第 4 步。</li><li>约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子节点到根节点逆向求出每个字符的哈夫曼编码，那么从根节点到叶子节点路径上的字符组成的字符串为该叶子节点的哈夫曼编码，算法结束。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA算法在人脸识别中的应用</title>
      <link href="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/"/>
      <url>/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="PCA（主成分分析）算法介绍"><a href="#PCA（主成分分析）算法介绍" class="headerlink" title="PCA（主成分分析）算法介绍"></a>PCA（主成分分析）算法介绍</h2><p>PCA是多元统计同用来分析数据的一种方法。通过<strong>正交变换</strong>将一组可能存在相关性的变量转换为一组线性不相关的向量，转换后的这组变量叫做主成分。</p><p>而这个转换的过程中，可以<strong>丢弃</strong>很多相关的成分或者对描述这个物体不重要的成分。<strong>从而达到对原始数据降维，提取重要特征的目的。</strong></p><p><strong>为什么要降维？</strong></p><blockquote><ol><li>简化计算，便于分析</li><li>去掉冗余，显现特征</li></ol></blockquote><h3 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h3><p>首先需要知道几个相关的数学概念，这是我们进行PCA分析的基础：标准差（Standard Deviation）、方差（Variance）、协方差（Covariance）、特征向量（eigenvectors）、特征值（eigenvalues）</p><ol><li><h3 id="Standard-Deviation（标准差）"><a href="#Standard-Deviation（标准差）" class="headerlink" title="Standard Deviation（标准差）"></a>Standard Deviation（标准差）</h3><p>标准差就是用来描述<strong>一组数据与平均值的偏离程度</strong>，反映了一组数据的<strong>波动情况</strong>，平均值数学表达公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181158607.png" alt="image-20220918181158607"></p><p>标准差的表达公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181218236.png" alt="image-20220918181218236"></p><p>需要注意的是分母是选择<code>n</code>还是<code>n-1</code>，取决于你选取的数据是整个完整数据还是数据中的一部分。</p></li><li><h3 id="Variance（方差）"><a href="#Variance（方差）" class="headerlink" title="Variance（方差）"></a>Variance（方差）</h3><p>方差是数据集中数据分布的另一种度量。实际上，它几乎与标准差相同。</p><p>方差的数学表达公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181303373.png" alt="image-20220918181303373"></p></li><li><h3 id="Covariance（协方差）"><a href="#Covariance（协方差）" class="headerlink" title="Covariance（协方差）"></a>Covariance（协方差）</h3><p>标准差与方差只针对一维数据进行衡量的指标，协方差是<strong>针对二维数据或者是更高维的数据</strong>进行的衡量指标，主要用来表示<strong>多维度与平均值的偏离程度</strong>。</p><p>协方差的数学表达公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181435902.png" alt="image-20220918181435902"></p></li><li><h3 id="The-covariance-Matrix（协方差矩阵）"><a href="#The-covariance-Matrix（协方差矩阵）" class="headerlink" title="The covariance Matrix（协方差矩阵）"></a>The covariance Matrix（协方差矩阵）</h3><p>协方差矩阵主要是用于当数据的维度超过3或者更多的时候，我们可以通过<strong>一个矩阵来存储各个维度的协方差</strong>，这个矩阵就被称为“协方差矩阵”。</p><p>用数学方法来表示一个N为数据的协方差矩阵可以表示为：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181804542.png" alt="image-20220918181804542"></p><p>现在假设我们有一个三个维度的数据，使用一个协方差矩阵将这三维数据的协方差表示如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918181822893.png" alt="image-20220918181822893"></p></li><li><h3 id="Eigenvectors（特征向量）"><a href="#Eigenvectors（特征向量）" class="headerlink" title="Eigenvectors（特征向量）"></a>Eigenvectors（特征向量）</h3><p>在矩阵论中，我们可以这样去理解特征值和特征向量，一个矩阵由一个变换到另一个矩阵，Aα&#x3D;λα，其中α称为矩阵A 的一个特征向量，λ称为矩阵A的一个特征值。</p><blockquote><p><strong>特征向量确定了矩阵变换的方向，特征值确定了矩阵变换的比例。</strong></p></blockquote><p>在协方差矩阵中，协方差矩阵的特征向量又反应了什么物理意义呢？</p><p>协方差矩阵的特征向量代表的意思是<strong>方差最大的数据所在的方向</strong>。</p><p>在n维数据空间中，第一特征向量指向的是<strong>数据方差最大的方向</strong>，第二特征向量是与第一特征向量垂直的数据方差最大的方向，第三特征向量是与第二特征向量垂直的数据方差最大的方向，以此类推。</p></li><li><h3 id="Choosing-components-and-forming-a-feature-vector（选择主成分并生成特征向量）"><a href="#Choosing-components-and-forming-a-feature-vector（选择主成分并生成特征向量）" class="headerlink" title="Choosing components and forming a feature vector（选择主成分并生成特征向量）"></a>Choosing components and forming a feature vector（选择主成分并生成特征向量）</h3><blockquote><p>一个协方差矩阵有着不同的特征值与特征向量，事实上<strong>最高特征值的对应的特征向量就是这个数据集的主成分</strong>。</p></blockquote><p>通常来说，一旦协方差矩阵的特征值和特征向量被计算出来了之后，就是按照特征值的大小从高到低依次排列。特征值的大小确定了主成分的重要性。</p></li></ol><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>PCA原理就是将一个高维向量<em><strong>x</strong></em>,通过一个特殊的特征向量矩阵<em><strong>U</strong></em>，投影到一个低维的向量空间中，表征为一个低维向量<em><strong>y</strong></em>，并且仅仅损失了一些次要信息。</p><blockquote><p>也就是说，<strong>通过低维表征的向量和特征向量矩阵，可以基本重构出所对应的原始高维向量。</strong></p><p>即<strong>选择特征值较大的作为主成分，从而进行降维。</strong></p></blockquote><p>比如：一开始你的数据集是N维的，在进行了协方差矩阵的特征值计算后， 你得到了N个特征值和与这些特征值相对应的特征向量。然后在主成分分析时，你选取了前P个较大的特征值，如此一来，就将原来N维的数据降维到只有P维。这样就起到了降维的效果了。</p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>其方法主要是通过<strong>对协方差矩阵进行特征分解</strong>，以得出数据的主成分（即<strong>特征向量</strong>）与它们的权值（即<strong>特征值</strong>）。</p><p>计算新生成的数据集的公式如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918182958926.png" alt="image-20220918182958926"></p><p>其中rowFeatureVector是由<strong>模式矢量作为列组成的矩阵</strong>的<strong>转置</strong>，因此它的行就是原来的模式矢量，而且对应<strong>最大特征值的特征矢量在该矩阵的最上一行</strong>。rowdataAdjust是<strong>每一维数据减去均值后，所组成矩阵的转置</strong>，即数据项目在每一列中，每一行是一维，对我们的样本来说即是，第一行为x维上数据，第二行为y维上的数据。</p><p>正是由于特征向量是两两正交的，那么我们就可以使用任何的特征向量来<strong>将原始数据变换到正交的这些坐标轴</strong>上。</p><p>在计算出协方差矩阵的特征值及特征向量后，接下来，我们<strong>选取一个较大的特征值对应的特征向量将原始数据降到一维</strong>：</p><blockquote><p><strong>将较大的特征值对应的特征向量转置然后乘以原始数据集，这样就得到新的降维后的一维数据。</strong></p></blockquote><p>换而言之，PCA提供了一种降低数据维度的有效办法；如果分析者在原数据中除掉最小的特征值所对应的成分，那么所得的低维度数据必定是最优化的（也即，这样降低维度必定是失去讯息最少的方法）。主成分分析在分析复杂数据时尤为有用，比如人脸识别。</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>设有m条n维数据（训练集）：</p><ol><li>将原始数据按列组成n行m列矩阵X</li><li>将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</li><li>求出协方差矩阵C&#x3D;(1&#x2F;m)XX^T（实对称矩阵）</li><li>求出协方差矩阵的特征值及对应的特征向量</li><li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</li><li>Y&#x3D;PX 即为降维到k维后的数据</li></ol><h2 id="PCA应用–人脸识别"><a href="#PCA应用–人脸识别" class="headerlink" title="PCA应用–人脸识别"></a>PCA应用–人脸识别</h2><p>主要思想就是用主成分分析的思想将图像从欧氏空间降维映射到特征空间中，根据<strong>不同人脸图像在特征空间中的度量距离来判断其相似度</strong>，从而实现人脸识别。</p><h3 id="主要流程："><a href="#主要流程：" class="headerlink" title="主要流程："></a>主要流程：</h3><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184204177.png" alt="image-20220918184204177"></p><p>通过上图的PCA人脸识别流程可以看出，PCA方法可以总结为以下几个阶段：训练样本、特征提取、构造特征空间、投影计算。</p><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol><li><p>使用ORL数据库。人脸图像总样本为（Q&#x3D;400），共有P（P&#x3D;40）个人，每人人均L（L&#x3D;10）幅图像，每张图像大小为 112 x 92 &#x3D; 10304。</p></li><li><p>对每张图片进行矢量化处理。其中Xi为由第i个人的图像的每一列向量堆叠而成的一列M*N维列向量，即把矩阵向量化。需要注意的是，由于每个人都有L张图像，所以Xi对应的是每个人的平均脸，其中Xij为第i个人第j个样本：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184801736.png" alt="image-20220918184801736"></p></li><li><p>计算所有训练图像的平均脸：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184914111.png" alt="image-20220918184914111"></p></li><li><p>计算每张人脸与平均脸的差值（去均值）：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184940831.png" alt="image-20220918184940831"></p></li><li><p>构造协方差矩阵：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918184952241.png" alt="image-20220918184952241"></p></li><li><p>是求解协方差矩阵的特征值和特征向量，构造特征脸：</p><ul><li>求出协方差矩阵的特征向量<em><strong>ui</strong></em>和对应的特征值<em><strong>λi</strong></em>，这些特征向量组成的矩阵<em><strong>U</strong></em>就是人脸空间的正交基底，用它们的线性组合可以重构出样本中任意的人脸图像。<strong>并且图像信息集中在特征值大的特征向量中，即使丢弃特征值小的向量也不会影响图像质量</strong>：</li></ul><blockquote><p>为什么用特征向量和特征值的线性组合可以重构出样本中任意的人脸图像？</p></blockquote><ol><li><p>在人脸识别过程中，对输入的一个测试样本x，求出它与平均脸的偏差，则这个偏差在特征脸空间U的投影，可以表示为系数向量y：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918191044392.png" alt="image-20220918191044392"></p><p>U的维数为M×d（d为特征值个数），偏差的维数为M×1，y的维数为d×1。若<strong>M</strong>为200*200&#x3D;40000维，取200个主成分，即200个特征向量，则最后投影的系数向量y维数降维200维。</p></li><li><p>根据上述式子，可以得出：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918191404110.png" alt="image-20220918191404110"></p><p>这里的x就是根据投影系数向量y重构出的人脸图像，丢失了部分图像信息，但不会影响图像质量。</p></li></ol><ul><li>将协方差矩阵的<strong>特征值按大到小排序</strong>，λ 1 &gt; λ 2 . . . &gt; λ t &gt; λ P。根据特征值的贡献率选取前t个<strong>最大</strong>的特征值及其对应的特征向量v i 。</li><li>按列取前r个特征向量，r为想降低到r维度。将r个特征向量向每一维数据减去均值后，所组成矩阵的转置矩阵的特征向量过渡。</li><li>特征向量归一化后，得到测试脸在特征向量下的数据。</li><li>获取训练数据与测试脸之间的距离，其中最小的数据对应的类别就是该类别人脸。</li></ul></li></ol><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p>首先定义一个函数用于将人脸图像矢量化为一个向量，向量的大小与图片的像素有关，代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 图片矢量化</span><span class="token keyword">def</span> <span class="token function">img2vector</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">:</span>    img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>image<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 读取图片</span>    rows<span class="token punctuation">,</span> cols <span class="token operator">=</span> img<span class="token punctuation">.</span>shape  <span class="token comment">#获取图片的像素</span>    imgVector <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> rows <span class="token operator">*</span> cols<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#初始值均设置为0，大小就是图片像素的大小</span>    imgVector <span class="token operator">=</span> np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> rows <span class="token operator">*</span> cols<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#使用imgVector变量作为一个向量存储图片矢量化信息</span>    <span class="token keyword">return</span> imgVector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来定义一个函数用来选取训练图片，并对每张图片进行前面定义过的矢量化处理：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">load_orl</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#参数K代表选择K张图片作为训练图片使用</span>    <span class="token triple-quoted-string string">'''    对训练数据集进行数组初始化，用0填充，每张图片尺寸都定为112*92,    现在共有40个人，每个人都选择k张，则整个训练集大小为40*k,112*92    '''</span>    train_face <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">*</span> k<span class="token punctuation">,</span> <span class="token number">112</span> <span class="token operator">*</span> <span class="token number">92</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    train_label <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">*</span> k<span class="token punctuation">)</span>  <span class="token comment"># [0,0,.....0](共40*k个0)</span>    test_face <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">112</span> <span class="token operator">*</span> <span class="token number">92</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    test_label <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># sample=random.sample(range(10),k)#每个人都有的10张照片中，随机选取k张作为训练样本(10个里面随机选取K个成为一个列表)</span>    sample <span class="token operator">=</span> random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 随机排序1-10 (0-9）+1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 共有40个人</span>        people_num <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 每个人都有10张照片</span>            image <span class="token operator">=</span> orlpath <span class="token operator">+</span> <span class="token string">'/s'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>people_num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'/'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>sample<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg'</span>            <span class="token comment"># 读取图片并进行矢量化</span>            img <span class="token operator">=</span> img2vector<span class="token punctuation">(</span>image<span class="token punctuation">)</span>            <span class="token keyword">if</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>                <span class="token comment"># 构成训练集</span>                train_face<span class="token punctuation">[</span>i <span class="token operator">*</span> k <span class="token operator">+</span> j<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> img                train_label<span class="token punctuation">[</span>i <span class="token operator">*</span> k <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> people_num            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 构成测试集</span>                test_face<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> img                test_label<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> people_num    <span class="token keyword">return</span> train_face<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> test_face<span class="token punctuation">,</span> test_label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前期将所有训练图片矢量化之后，开始进行PCA算法的降维操作：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PCA</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#参数r代表降低到r维</span>    data <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>    rows<span class="token punctuation">,</span> cols <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    data_mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 对列求平均值</span>    A <span class="token operator">=</span> data <span class="token operator">-</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>data_mean<span class="token punctuation">,</span> <span class="token punctuation">(</span>rows<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 将所有样例减去对应均值得到A</span>    C <span class="token operator">=</span> A <span class="token operator">*</span> A<span class="token punctuation">.</span>T  <span class="token comment"># 得到协方差矩阵</span>    D<span class="token punctuation">,</span> V <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>eig<span class="token punctuation">(</span>C<span class="token punctuation">)</span>  <span class="token comment"># 求协方差矩阵的特征值和特征向量</span>    V_r <span class="token operator">=</span> V<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>  <span class="token comment"># 按列取前r个特征向量</span>    V_r <span class="token operator">=</span> A<span class="token punctuation">.</span>T <span class="token operator">*</span> V_r  <span class="token comment"># 小矩阵特征向量向大矩阵特征向量过渡</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>        V_r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> V_r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>V_r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 特征向量归一化</span>    final_data <span class="token operator">=</span> A <span class="token operator">*</span> V_r    <span class="token keyword">return</span> final_data<span class="token punctuation">,</span> data_mean<span class="token punctuation">,</span> V_r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们进行初次训练，随机选取每个人物的五张图片作为训练图片使用。将降低的维数设定为10维，查看一下训练效果如何：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">face_recongize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#对每一个人随机选取5张照片作为训练数据</span>  train_face<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> test_face<span class="token punctuation">,</span> test_label <span class="token operator">=</span> load_orl<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#随机选择每个人物的5张图片作为训练数据</span>  x_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  y_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">#将图片降维到10维</span>  data_train_new<span class="token punctuation">,</span> data_mean<span class="token punctuation">,</span> V_r <span class="token operator">=</span> PCA<span class="token punctuation">(</span>train_face<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  num_train <span class="token operator">=</span> data_train_new<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 训练脸总数</span>  num_test <span class="token operator">=</span> test_face<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 测试脸总数</span>  temp_face <span class="token operator">=</span> test_face <span class="token operator">-</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>data_mean<span class="token punctuation">,</span> <span class="token punctuation">(</span>num_test<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  data_test_new <span class="token operator">=</span> temp_face <span class="token operator">*</span> V_r  <span class="token comment"># 得到测试脸在特征向量下的数据</span>  data_test_new <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>data_test_new<span class="token punctuation">)</span>  <span class="token comment"># mat change to array</span>  data_train_new <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>data_train_new<span class="token punctuation">)</span>  true_num <span class="token operator">=</span> <span class="token number">0</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_test<span class="token punctuation">)</span><span class="token punctuation">:</span>      testFace <span class="token operator">=</span> data_test_new<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>      diffMat <span class="token operator">=</span> data_train_new <span class="token operator">-</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>testFace<span class="token punctuation">,</span> <span class="token punctuation">(</span>num_train<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 训练数据与测试脸之间距离</span>      sqDiffMat <span class="token operator">=</span> diffMat <span class="token operator">**</span> <span class="token number">2</span>      sqDistances <span class="token operator">=</span> sqDiffMat<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 按行求和</span>      sortedDistIndicies <span class="token operator">=</span> sqDistances<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 对向量从小到大排序，使用的是索引值,得到一个向量</span>      indexMin <span class="token operator">=</span> sortedDistIndicies<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 距离最近的索引</span>      <span class="token keyword">if</span> train_label<span class="token punctuation">[</span>indexMin<span class="token punctuation">]</span> <span class="token operator">==</span> test_label<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>          true_num <span class="token operator">+=</span> <span class="token number">1</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>          <span class="token keyword">pass</span>  accuracy <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>true_num<span class="token punctuation">)</span> <span class="token operator">/</span> num_test  x_value<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  y_value<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">round</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当对每个人随机选择%d张照片降低至%d维进行训练时，The classify accuracy is: %.2f%%'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span> accuracy <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终训练得到的结果如下：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918193440884.png" alt="image-20220918193440884"></p><p>为了对比实验，我们分别选取5张、7张、9张，还是降低到10维进行对比实验：</p><p><img src="/2022/09/18/pca-suan-fa-zai-ren-lian-shi-bie-zhong-de-ying-yong/image-20220918193452524.png" alt="image-20220918193452524"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像识别 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门--数组与广义表</title>
      <link href="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/"/>
      <url>/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h2><p>数组是由相同类型的数据元素构成的有限集合。</p><p>数组一般采用顺序存储结构，因为存储单元是一维的，而数组可以是多维的，如何用一组连续的存储单元来存储多维数组呢？</p><p>以二维数组为例，可以按行序存储，即先存第一行，再存第二行……也可以按列序存储，先存第一列，再存第二列……</p><ol><li><p>按行序存储</p><p><strong>如果按行序存储，怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储 a ij 之前，前面已经存储了多少个元素：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916163751007.png" alt="image-20220916163751007"></p><p>在 a ij 之前一共有 i×n+j 个元素，如果每个元素占用 L 字节，那么共需要 (i×n+j)×L 字节，只需要用基地址加上这些字节就可以得到 a ij 的存储地址了。</p><p>按行序存储，a ij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916164635719.png" alt="image-20220916164635719"></p><p>LOC(a 00 )表示第一个元素的存储地址，即基地址，LOC(a ij)表示 a ij 的存储地址。</p></li><li><p>按列序存储</p><p><strong>如果按列序存储，怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储 a ij 之前，前面已经存储了多少个元素：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916164855734.png" alt="image-20220916164855734"></p><p>在 a ij 之前一共有 j×m+i 个元素，如果每个元素占用 L 字节，那么共需要(j×m+i)×L 字节，只需要用基地址加上这些字节就可以得到 a ij 的存储地址了。</p><p>按列序存储，a ij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916164922583.png" alt="image-20220916164922583"></p><p>LOC(a00 )表示第一个元素的存储地址，即基地址，LOC(a ij)表示 a ij 的存储地址。</p><blockquote><p><strong>注意：如果二维数组的下标是从 1 开始的，那么情形就变了。</strong></p></blockquote><p>先看看存储 a ij 之前，前面已经存储了多少个元素：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916165028591.png" alt="image-20220916165028591"></p><p>行数和个数都少 1，在 a ij 之前一共有 <strong>(i−1)×n+j−1</strong> 个元素，如果每个元素占用 L 字节，那么共需要 <strong>((i−1)×n+j−1)×L</strong> 字节，只需要用基地址加上这些字节就可以得到 a ij 的存储地址了。</p><p>如果二维数组下标从 1 开始，按行序存储，a ij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916165312801.png" alt="image-20220916165312801"></p><p>LOC(a11 )表示第一个元素的存储地址，即基地址，LOC(a ij)表示 a ij 的存储地址。</p><p>如果二维数组下标从 1 开始，按列序存储，a ij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916165344784.png" alt="image-20220916165344784"></p><p>也就是说，如果下标是从 1 开始的，相应的公式需要行减 1，列减 1。</p></li></ol><blockquote><p>存储地址计算秘籍：<strong>a ij 的存储地址等于第一个元素的存储地址，加上前面的元素个数乘以每个元素占用的字节数。</strong></p><p>LOC(aij) &#x3D; LOC(第一个元素) +(aij 前面的元素个数) × 每个元素占的字节</p></blockquote><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><ul><li><strong>什么是压缩存储？</strong>给多个相同的元素分配一个存储空间，元素为 0 的不分配空间。</li><li><strong>什么样的矩阵能够压缩？</strong>一些特殊矩阵，如对称矩阵、三角矩阵、对角矩阵、稀疏矩阵等。</li><li><strong>什么叫稀疏矩阵？</strong>矩阵中非零元素的个数较少，怎样才算是较少呢？一般认为非零元素个数小于 5%的矩阵为稀疏矩阵。</li></ul><h3 id="对称矩阵："><a href="#对称矩阵：" class="headerlink" title="对称矩阵："></a>对称矩阵：</h3><p>对称矩阵比较特殊，其数据元素沿着对角线对称，即：aij &#x3D; aji</p><p>那么，因为上三角和下三角是一样的，因此只存储其中的一个就可以了。如果用一维数组存储下三角，则只需要 <strong>n(n+1)&#x2F;2</strong> 个空间，比全部存储需要 n^2 个空间少了很多。</p><p><strong>如果按行序存储下三角，那么怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储下三角中的 a ij 之前，前面已经存储了多少个元素:</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916171702433.png" alt="image-20220916171702433"></p><p>如果将对称矩阵的下三角（i≥j）存储在一维数组 s[]中，那么下三角中 a ij 的下标就是 <strong>i(i−1)&#x2F;2+j−1</strong></p><p>而上三角的元素（i&lt;j），根据对称性，a ij &#x3D; a ji，可以直接读取下三角中的 a ji，因此按行序存储下三角时，a ij 的下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916172113874.png" alt="image-20220916172113874"></p><p><strong>存储下标计算秘籍：</strong>如果用一维数组 s[]存储（下标从 0 开始），则 a ij 的存储下标 k 等于a ij 前面的元素个数。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916174820163.png" alt="image-20220916174820163"></p><p>如果一维数组的下标从 1 开始呢？——公式后面再加 1 就行了。</p><p>上面的公式是计算一维数组存储的下标，如果给了基地址（a11 的存储地址），那么 aij 的存储地址为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916175406759.png" alt="image-20220916175406759"></p><p>即 LOC(a ij)&#x3D;LOC(第一个元素)+(a ij 前面的元素个数)×每个元素占用的字节。</p><h3 id="三角矩阵："><a href="#三角矩阵：" class="headerlink" title="三角矩阵："></a>三角矩阵：</h3><p>三角矩阵比较特殊，分为下三角矩阵和上三角矩阵，下三角矩阵是指矩阵的下三角有数据，而其余的都是常数 c 或者为 0：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220916180925565.png" alt="image-20220916180925565"></p><p>在下三角矩阵存储时，<strong>只需要存储其下三角中的元素，最后一个空间存储常数 c 即可。如果上面全为 0，则不需要存储</strong>；下三角也是如此。</p><p>例如下三角矩阵按行存储在一维数组 s[]中：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917122504003.png" alt="image-20220917122504003"></p><p><strong>下三角矩阵如果按行序存储，怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储 a ij 之前，前面已经存储了多少个元素：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917164303544.png" alt="image-20220917164303544"></p><p>如果一维数组的下标从零开始，那么下三角中 a ij 的下标就是 i(i−1)&#x2F;2+j−1。而上三角的元素因为全是常数 c 或者为 0，最后一个空间（下标为 n(n+1)&#x2F;2）存储常数 c 即可，如果是 0，则不需要存储。</p><p>因此下三角矩阵按行序存储时，a ij 的下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917164625796.png" alt="image-20220917164625796"></p><p><strong>上三角矩阵如果按行序存储，怎么找到 a ij 的存储位置呢？</strong></p><p>先看看存储 a ij 之前，前面已经存储了多少个元素（梯形公式）：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917164934887.png" alt="image-20220917164934887"></p><p>如果一维数组的下标从 0 开始，那么上三角中 aij 的下标就是(i−1)(2n−i+2)&#x2F;2+j−i。而下三角的元素全是常数 c 或者为 0，最后一个空间（下标为 n(n+1)&#x2F;2）存储常数 c 即可。</p><p>因此上三角矩阵按行序存储时，a ij 的下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917165936889.png" alt="image-20220917165936889"></p><h3 id="对角矩阵："><a href="#对角矩阵：" class="headerlink" title="对角矩阵："></a>对角矩阵：</h3><p>对角矩阵又称为带状矩阵，是指在 n×n 的矩阵中非零元素集中在主对角线及其两侧，共 L（奇数）条对角线的带状区域内，称为 L 对角矩阵：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917170215104.png" alt="image-20220917170215104"></p><ol><li><p><strong>L 对角矩阵非零元素个数</strong></p><p>首先将每一行以对角线为中心进行补零，让每一行都达到带宽 L 个元素。一共补了多少个零呢？第一行补 d 个 0，第二行补 d−1 个 0 左上角补零个数为 d (d+1)&#x2F;2。同理，右下角补零个数也为 d(d+1)&#x2F;2，总的补零个数为 d(d+1)。那么每行按 L 个元素计算，再减去补零元素个数即可，即带状区域元素个数为 L×n−d(d+1)。因为 d&#x3D;(L−1)&#x2F;2，即 L&#x3D;2d+1，所以带状区域元素个数也可以表达为(2d+1)×n−d(d+1)。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917171101974.png" alt="image-20220917171101974"></p></li><li><p><strong>按行序存储</strong></p><p>补零后每行都有 L 个元素，需要 L×n 个空间。为了节省空间，第一行前面和最后一行后面的 d 个 0 可以不存储，“<strong>掐头去尾</strong>”，需要 L×n−2d 个空间。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917172219604.png" alt="image-20220917172219604"></p><p><strong>怎么找到 a ij 的存储位置呢？</strong></p><p>首先找到 aii 的存储位置，因为 aii 是对角线上的元素，以对角线为中心，左右两侧都是d 个元素。a ii 之前有 i−1 行，每行 L 个元素，a ii 所在行左侧有 d 个元素，因此 a ii 之前有(i−1)×L+d 个元素。</p><p>因为第一行前面的 d 个 0“<strong>掐头去尾</strong>”没有存储，所以 a ii 之前有(i−1)×L 个元素。aii 的存储位置为：(i−1)×L。而 aij 和 aii 相差 j−i 个元素，也就是说，aij的存储位置为：(i−1)×L+j−i：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917175712065.png" alt="image-20220917175712065"></p><p>如果 a ij 在 a ii 的左侧（i&gt;j）呢？它们之间相差 i−j 个元素。只需要计算出 a ii 的存储位置，减去它们之间的差值就可以了。<br>即 aij 的存储位置为(i−1)×L−(i−j)&#x3D;(i−1)×L+j−i。</p><p><strong>公式总结：</strong></p><p>按行序，用一维数组（下标从 0 开始）存储 L 对角矩阵，a ij 的存储位置为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180013907.png" alt="image-20220917180013907"></p><p>例如3对角矩阵中 a ij 的存储位置为 k&#x3D;3(i−1)+j−i&#x3D;2i+j−3，如果一维数组的下标从 1 开始，公式后面再加 1 即可。</p></li><li><p><strong>按对角线存储</strong></p><p>对角矩阵还有一种按对角线的顺序存储方式：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180434868.png" alt="image-20220917180434868"></p><p>即对角线作为 0 行，左侧分别为 1, 2, …, d行，右侧分别为−1, −2, …, −d 行。相当于行转换为 i′&#x3D;i−j，列值 j 不变，把 n×n 的 L 对角矩阵转换为 L×n 的矩阵：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180505020.png" alt="image-20220917180505020"></p><p>将其他位置补零：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180540927.png" alt="image-20220917180540927"></p><p>用一维数组 s[]（下标从 0 开始）按行序存储，仍然采用“掐头去尾”，第一行前面和最后一行后面的 d 个 0 不存储：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917180602358.png" alt="image-20220917180602358"></p><p><strong>怎么找到 a ij 的存储位置呢？</strong></p><p>a i′j 之前有 i′+d行，每行有 n 个元素，a i′j 所在行左侧有 j−1 个元素，因此 ai′j 之前有(i′+d)×n+j−1 个元素。</p><p>因为第一行前面的 d 个 0“掐头去尾”没有存储，所以 a i′j 之前有(i′+d)×n+j−1−d 个元素。a i′j的存储位置为：(i′+d)×n+j−1−d。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917181451463.png" alt="image-20220917181451463"></p><p>如果用一维数组（下标从 0 开始）按行序存储，a i′j 的下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917181526649.png" alt="image-20220917181526649"></p><p>又因为 i′&#x3D;i−j，因此对角矩阵中的 a ij 下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917181539937.png" alt="image-20220917181539937"></p><p><strong>公式总结：</strong></p><p>按对角线存储，对角矩阵中的 a ij 下标为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917181629298.png" alt="image-20220917181629298"></p></li></ol><h3 id="稀疏矩阵："><a href="#稀疏矩阵：" class="headerlink" title="稀疏矩阵："></a>稀疏矩阵：</h3><p>稀疏矩阵是指非零元素个数较少，且分布没有规律可言，那么少到什么程度才算稀疏呢？一般认为非零元素小于 5%时，属于稀疏矩阵。</p><p>当然也没那么绝对，只要非零元素个数远远小于矩阵元素个数，就可以认为是稀疏矩阵。</p><blockquote><p><strong>为了节省空间，只需要记录每个非零元素的行、列和数值即可，这就是三元组存储法</strong></p></blockquote><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220917183620395.png" alt="image-20220917183620395"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表是线性表的推广，也称为列表。</p><blockquote><p>它是 n(n≥0)个表元素组成的有限序列，记作 **LS&#x3D; (a0 , a1, a2 , …, a n−1 )**。LS 是表名，a i 是表元素，它可以是表（称为子表），也可以是数据元素(称为原子)。</p><p>n 为表的长度，n&#x3D;0 的广义表为空表。</p></blockquote><p>广义表最常见的操作就是求表头和表尾。</p><ul><li><p>表头 GetHead(L)：</p><p>非空广义表的第一个元素，可以是一个单元素，也可以是一个子表。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220918093948840.png" alt="image-20220918093948840"></p></li><li><p>表尾 GetTail(L)：</p><p>删除表头元素后余下的元素所构成的表。表尾一定是一个表。</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220918094015252.png" alt="image-20220918094015252"></p></li></ul><h2 id="数组与广义表学习技巧"><a href="#数组与广义表学习技巧" class="headerlink" title="数组与广义表学习技巧"></a>数组与广义表学习技巧</h2><p><strong>存储地址计算秘籍：</strong>a ij 的存储地址等于第一个元素的存储地址，加上前面的元素个数乘以每个元素占用的字节数。计算公式为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220918105951420.png" alt="image-20220918105951420"></p><p>LOC(第一个元素)表示第一个元素的存储地址，即基地址，LOC(a ij)表示 aij 的存储地址。</p><p><strong>存储下标计算秘籍：</strong>如果用一维数组 s[]存储（下标从 0 开始），则 aij 的存储下标 k 等于a ij 前面的元素个数。计算公式为：</p><p><img src="/2022/09/16/shu-ju-jie-gou-ru-men-shu-zu-yu-guang-yi-biao/image-20220918110119654.png" alt="image-20220918110119654"></p><p>如果一维数组的下标从 1 开始，公式后面再加 1 就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-字符串</title>
      <link href="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/"/>
      <url>/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>串：</strong>又称字符串，是由零个或多个字符组成的有限序列。</p><p><strong>串长：</strong>串中字符的个数，例如 S 的串长为 6。</p><p><strong>空串：</strong>零个字符的串，串长为 0。</p><p><strong>子串：</strong>串中任意个连续的字符组成的子序列，称为该串的子串，原串称为子串的主串。</p><blockquote><p>注意：空格也算一个字符。</p></blockquote><p><strong>空格串：</strong>全部由空格组成的串为空格串。</p><blockquote><p>注意：空格串不是空串。</p></blockquote><h3 id="顺序存储："><a href="#顺序存储：" class="headerlink" title="顺序存储："></a>顺序存储：</h3><ol><li><p>以’\0’表示字符串结束：</p><p>在 C、C++、Java 语言中，通常用’\0’表示字符串结束，’\0’不算在字符串长度内。</p></li><li><p>在 0 空间存储字符串的长度：</p><p>下标为 0 的空间不使用，因此可以预先分配 Maxsize+1 的空间，在下标为 0 的空间中存储字符串长度。</p></li><li><p>结构体变量存储字符串的长度：</p><p>串的运算如合并、插入、替换等操作，容易超过最大长度，出现溢出。为了解决这个问题，可以采用动态分配空间的方法，其结构体定义如下。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>  <span class="token comment">//指向字符串指针</span><span class="token keyword">int</span> length<span class="token punctuation">;</span>  <span class="token comment">//字符串的长度</span><span class="token punctuation">&#125;</span>SString<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="链式存储："><a href="#链式存储：" class="headerlink" title="链式存储："></a>链式存储：</h3><p>单链表存储字符串时，虽然插入和删除非常容易，但是这样做也有一个问题：一个节点只存储一个字符，如果需要存储的字符特别多，会浪费很多空间。</p><p>因此也可以考虑<strong>一个节点存储多个字符</strong>的形式，例如一个节点存储 3 个字符，最后一个节点不够 3 个时用#代替。</p><p>但是这样做也有一个大问题：如在第 2 个字符之前插入一个元素，就需要将 b 和 c 后移，那么这种后移还要跨到第二个节点，如同“蝴蝶效应”，一直波及最后一个节点，麻烦就大了！</p><p><strong>因此字符串很少使用链式存储结构，还是使用顺序存储结构更灵活一些。</strong></p><h2 id="模式匹配BF算法"><a href="#模式匹配BF算法" class="headerlink" title="模式匹配BF算法"></a>模式匹配BF算法</h2><p><strong>模式匹配：</strong>子串的定位运算称为串的模式匹配或串匹配。</p><p>假设有两个串 S、T，设 S 为主串，也称正文串；T 为子串，也称模式。</p><blockquote><p><strong>在主串 S 中查找与模式 T 相匹配的子串，如果查找成功，返回匹配的子串第一个字符在主串中的位置。</strong></p></blockquote><p>最笨的办法就是穷举所有 S 的所有子串，判断是否与 T 匹配，该算法称为 <strong>BF（Brute Force）</strong>算法。</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>从 S 第 1 个字符开始，与 T 第 1 个字符比较，如果相等，继续比较下一个字符，否则转向下一步；</li><li>从 S 第 2 个字符开始，与 T 第 1 个字符比较，如果相等，继续比较下一个字符，否则转向下一步，以此类推；</li><li>如果 T 比较完毕，则返回 T 在 S 中第一个字符出现的位置；</li><li>如果 S 比较完毕，则返回 0，说明 T 在 S 中未出现。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> SString<span class="token punctuation">[</span>Maxsize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//0号单元存放串的长度</span><span class="token keyword">bool</span> <span class="token function">StrAssign</span><span class="token punctuation">(</span>SString <span class="token operator">&amp;</span>T<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>chars<span class="token punctuation">)</span><span class="token comment">//生成一个其值等于chars的串T</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token operator">></span>Maxsize<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>chars<span class="token operator">+</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout<span class="token operator">&lt;&lt;</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Index_BF</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token comment">//BF算法</span><span class="token punctuation">&#123;</span> <span class="token comment">// 求T在主串S中第pos个字符之后第一次出现的位置</span><span class="token comment">//其中，T非空，1≤pos≤s[0],s[0]存放S串的长度</span><span class="token keyword">int</span> i<span class="token operator">=</span>pos<span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        sum<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 如果相等，则继续比较后面的字符</span><span class="token punctuation">&#123;</span>i<span class="token operator">++</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>i<span class="token operator">=</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//i退回到上一轮开始比较的下一个字符</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//j退回到第1个字符</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"一共比较了"</span><span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span><span class="token string">"次"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 匹配成功</span><span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析："><a href="#算法复杂度分析：" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p>设 S、T 串的长度分别为 n、m，则 BF 算法的时间复杂度分为以下两种情况：</p><ol><li><p>最好情况</p><p>在最好情况下，每一次匹配都在第一次比较时发现不等。</p><p>假设第 i 次匹配成功，则前 i−1 次匹配都进行了 1 次比较，一共 i−1 次，第 i 次匹配成功时进行了 m 次比较，则总的比较次数为 <strong>i−1+m</strong></p><p><strong>即模式串正好在主串的最后端。</strong></p><p>假 设 每 一 次 匹 配 成 功 的 概 率 均 等 ， 概 率p i &#x3D;1&#x2F;(n−m+1)，则在最好情况下，匹配成功的平均比较次数为：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914180721501.png" alt="image-20220914180721501"></p><p>最好情况下的平均时间复杂度为 O(n+m)。</p></li><li><p>最差情况</p><p>在最坏情况下，每一次匹配都比较到 T 的最后一个字符发现不等，回退重新开始，这样每次匹配都需要比较 m 次</p><p>假设第 i 次匹配成功，则前 i−1 次匹配都进行了 m 次比较，第 i 次匹配成功时也进行 m次比较，则总的比较次数为 <strong>i×m</strong></p><p>在匹配成功的情况下，最多需要 n−m+1 次匹配，<strong>即模式串正好在主串的最后端</strong></p><p>假设每一次匹配成功的概率均等，概率 p i&#x3D;1&#x2F;(n−m+1)，则在最坏情况下，匹配成功的平均比较次数为：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914180846050.png" alt="image-20220914180846050"></p><p>最坏情况下的平均时间复杂度为 O(n×m)。</p></li></ol><h2 id="模式匹配KMP算法"><a href="#模式匹配KMP算法" class="headerlink" title="模式匹配KMP算法"></a>模式匹配KMP算法</h2><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><p>按照 BF 算法，如果匹配的字符串不等，则 i 回退到 i−j+2，j 回退到 1，即 i&#x3D;2，j&#x3D;1：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914215010257.png" alt="image-20220914215010257"></p><p>其实 i 不用回退，让 j 回退到第 3 个位置，接着比较即可：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914215026957.png" alt="image-20220914215026957"></p><p>那怎么知道 T 中开头的两个字符和 i 指向的字符前面的两个字符一模一样？难道还要比较？</p><p>我们发现 i 指向的字符前面的两个字符和 T 中 j 指向的字符前面两个字符一模一样，<strong>因为它们一直相等， i++、j++才会走到当前的位置</strong>：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914215201151.png" alt="image-20220914215201151"></p><p>也就是说，我们不必判断开头的两个字母和 i 指向的字符前面的两个字符是否一样，只需要在 T 本身比较就可以了。</p><p>假设 T 中当前 j 指向的字符前面的所有字符为 T′，<strong>只需要比较T′的前缀和 T′的后缀即可</strong>：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220914215308905.png" alt="image-20220914215308905"></p><blockquote><p>注意：前缀和后缀不可以取字符串本身。如果串的长度为 n，前缀和后缀长度最多达到 <strong>n−1</strong></p></blockquote><p>因此，当 i、j 指向的字符不等时，只需要求出 T′的相等前缀后缀的最大长度 l，<strong>i 不变，j 回退到 l+1的位置继续比较即可</strong>。</p><p><strong>这样找所有的前缀和后缀比较，是不是也是暴力穷举？那怎么办呢？</strong>可以用动态规划递推</p><blockquote><p>有了 next[]数组，就很容易进行模式匹配了，当 S[i]≠T[j]时，i 不动，j 回退到 next[j]的位置继续比较即可。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//计算next函数值</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>            next<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">++</span>k<span class="token punctuation">;</span><span class="token keyword">else</span>k<span class="token operator">=</span>next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"-----next[]-------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Index_KMP</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//KMP算法</span><span class="token punctuation">&#123;</span> <span class="token comment">// 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><span class="token comment">//其中，T非空，1≤pos≤StrLength(S)</span><span class="token keyword">int</span> i<span class="token operator">=</span>pos<span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        sum<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 继续比较后面的字符</span><span class="token punctuation">&#123;</span>i<span class="token operator">++</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span>j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 模式串向右移动</span>    <span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"一共比较了"</span><span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span><span class="token string">"次"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 匹配成功</span><span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-1"><a href="#算法复杂度分析：-1" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p>设 S、T 串的长度分别为 n、m。KMP 算法的特点是：i 不回退，当 S[i]≠T[j]时，j 回退到 next[j]，重新开始比较。</p><p><strong>最坏情况下扫描整个 S 串，其时间复杂度为 O(n)。</strong></p><p><strong>计算 next[]数组需要扫描整个 T 串，其时间复杂度为 O(m)，因此总的时间复杂度为 O(n+m)。</strong></p><p>需要注意的是，尽管 BF 算法最坏情况下时间复杂度为 O(n×m)，KMP 算法的时间复杂度为 O(n+m)。但是在实际运用中，BF 算法的时间复杂度一般为 O(n+m)，因此仍然有很多地方用 BF 算法进行模式匹配。</p><blockquote><p><strong>只有在主串和子串有很多部分匹配的情况下，KMP 才显得更优越。</strong></p></blockquote><h2 id="改进的KMP算法"><a href="#改进的KMP算法" class="headerlink" title="改进的KMP算法"></a>改进的KMP算法</h2><h3 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h3><p>在 KMP 算法中，next[]求解非常方便、迅速，但是也有一个问题：当 s i≠t j 时，j 回退到 next[j]（k&#x3D;next[j]），然后 s i 与 t k 比较。这样的确没错，但是如果 t k&#x3D;t j，这次比较就没必要了，因为刚才就是因为 s i≠t j 才回退的，那么肯定 s i≠t k，完全没必要再比了：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220915111812301.png" alt="image-20220915111812301"></p><p>再向前回退，找下一个位置 next[k]，继续比较就可以了。当 si≠tj 时，本来应该 j 回退到next[j]（k&#x3D;next[j]），si 与 t k 比较。</p><p><strong>但是如果 t k&#x3D;t j，则不需要比较，继续回退到下一个位置 next[k]，减少了一次无效比较。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_next2</span><span class="token punctuation">(</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//计算next函数值改进算法</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span>k<span class="token operator">=</span>next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"-----next[]-------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-2"><a href="#算法复杂度分析：-2" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p>设 S、T 的长度分别为 n、m。改进的 KMP 算法只是在求解 next[]从常数上的改进，并没有降阶，因此其时间复杂度仍为 O(n+m)。</p><h2 id="字符串的应用–病毒检测"><a href="#字符串的应用–病毒检测" class="headerlink" title="字符串的应用–病毒检测"></a>字符串的应用–病毒检测</h2><p><strong>题目：</strong>疫情暴发，专家发现了一种新型环状病毒，这种病毒的 DNA 序列是环状的，而人类的 DNA 序列是线性的。专家把人类和病毒的 DNA 表示为字母组成的字符串序列，如果在某个患者的 DNA 中发现这种环状病毒，说明该患者已被感染病毒，否则没有感染。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>该问题属于字符串的模式匹配问题，可以使用前面讲的 BF 或 KMP 算法求解。这里需要对环状病毒进行处理，然后调用模式匹配算法即可。</p><p>处理环状病毒：</p><ol><li><p>环形处理</p><p>使用循环存储的方式，类似循环队列或循环链表的处理方式。假设病毒的 DNA 长度为m，依次从环状存储空间中每一个下标开始，取 m 个字符作为病毒序列：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220915165432322.png" alt="image-20220915165432322"></p></li><li><p>线性处理</p><p>将病毒序列扩大两倍，依次从每个下标开始，取 m 个字符，作为病毒序列。</p><p>例如，病毒序列：aabb，如图 4-45 所示。将该病毒序列扩大两倍。从每个下标（1、2、3、4）开始取 4 个字符，分别为 aabb、abba、bbaa、baab，这 4 个序列都是病毒序列的变种：</p><p><img src="/2022/09/14/shu-ju-jie-gou-ru-men-zi-fu-chuan/image-20220915165525020.png" alt="image-20220915165525020"></p></li></ol><h3 id="步骤：-3"><a href="#步骤：-3" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>首先对环状病毒进行处理（环形处理或线性处理）。</li><li>依次把每一个环状病毒变种作为子串，把患者 DNA 序列作为主串，进行模式匹配。一旦匹配成功，立即结束，返回已感染病毒。</li><li>重复运行第 2 步。</li><li>如果检测所有病毒变种都未匹配成功，返回未感染病毒。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Virus_detection</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span> SString T<span class="token punctuation">)</span><span class="token comment">//病毒检测</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    SString temp<span class="token punctuation">;</span><span class="token comment">//temp记录病毒变种</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//将T串扩大一倍，T[0]为病毒长度</span>        T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//依次检测T[0]个病毒变种</span>    <span class="token punctuation">&#123;</span>        temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">////病毒变种长度为T[0]</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//取出一个病毒变种</span>            temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>T<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Index_KMP</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>temp<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//检测到病毒</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度分析：-3"><a href="#算法复杂度分析：-3" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h3><p>假设病毒 DNA 序列长度为 m，则一共有 m 个变种，需要进行 m 次模式匹配，每次模式匹配如果使用 KMP 算法，其时间复杂度为 O(n+m)，则总的时间复杂度为 O(m×(n+m))。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-栈和队列</title>
      <link href="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/"/>
      <url>/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote><p><strong>后进先出（Last In First Out，LIFO）</strong>的线性序列，称为“栈”。栈也是一种线性表，只不过它是操作受限的线性表，只能在一端进出操作。</p><p>进出的一端称为栈顶（top），另一端称为栈底（base）。栈可以用顺序存储，也可以用链式存储，分别称为顺序栈和链栈。</p></blockquote><h3 id="顺序栈："><a href="#顺序栈：" class="headerlink" title="顺序栈："></a>顺序栈：</h3><p>顺序栈需要两个指针，base 指向栈底，top 指向栈顶。栈定义好了之后，还要先定义一个最大的分配空间，顺序结构都是如此，需要预先分配<br>空间。</p><blockquote><p>注意：栈只能在一端操作，后进先出，是人为规定的，也就是说<strong>不允许在中间查找、取值、插入、删除等操作</strong>。</p></blockquote><p>顺序栈本身是顺序存储的，有人就想：我偏要从中间取一个元素，不行吗？那肯定可以，但是这样做，就不是栈了。</p><h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><ol><li>初始化一个空栈，动态分配 Maxsize 大小的空间，用 S.top 和 S.base 指向该空间的基地址</li><li>注意判断空间分配是否成功</li></ol><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220910165857429.png" alt="image-20220910165857429"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//预先分配空间，这个数值根据实际需要预估确定；</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SqStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> <span class="token operator">*</span>base<span class="token punctuation">;</span> <span class="token comment">//栈底指针</span><span class="token keyword">int</span> <span class="token operator">*</span>top<span class="token punctuation">;</span> <span class="token comment">//栈顶指针</span><span class="token punctuation">&#125;</span>SqStack<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span> <span class="token comment">//构造一个空栈S</span><span class="token punctuation">&#123;</span>S<span class="token punctuation">.</span>base<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//为顺序栈分配一个最大容量为Maxsize的空间</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>    <span class="token comment">//空间分配失败</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>S<span class="token punctuation">.</span>top<span class="token operator">=</span>S<span class="token punctuation">.</span>base<span class="token punctuation">;</span>  <span class="token comment">//top初始为base，空栈</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入栈："><a href="#入栈：" class="headerlink" title="入栈："></a>入栈：</h4><p>入栈前要判断是否栈满，如果栈已满，则入栈失败；否则将元素放入栈顶，栈顶指针向上移动一个位置（top++）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token comment">// 插入元素e为新的栈顶元素</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span>S<span class="token punctuation">.</span>base<span class="token operator">==</span>Maxsize<span class="token punctuation">)</span> <span class="token comment">//栈满</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//元素e压入栈顶，然后栈顶指针加1，等价于*S.top=e; S.top++;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出栈："><a href="#出栈：" class="headerlink" title="出栈："></a>出栈：</h4><p>出栈前要判断是否栈空，如果栈是空的，则出栈失败；否则将栈顶元素暂存给一个变量，栈顶指针向下移动一个位置（top−−）。</p><ol><li><p>栈顶元素所在的位置实际上是 S.top −1，因此把该元素取出来，暂存在变量 e 中，然后 S.top 指针向下移动一个位置。</p></li><li><p>因此<strong>可以先移动一个位置</strong>，即− −S.top，然后再取元素。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220910170541077.png" alt="image-20220910170541077"></p></li></ol><blockquote><p>因为顺序存储删除一个元素时，并没有销毁该空间，所以 4 其实还在那个位置，只不过下次再有元素进栈时，就把它<strong>覆盖</strong>了。</p><p>相当于该元素已出栈，因为栈的内容是 S.base 到 S.top−1。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除S的栈顶元素，暂存在变量e中</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>base<span class="token operator">==</span>S<span class="token punctuation">.</span>top<span class="token punctuation">)</span> <span class="token comment">//栈空</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>e<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>S<span class="token punctuation">.</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//栈顶指针减1，将栈顶元素赋给e</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取栈顶元素："><a href="#取栈顶元素：" class="headerlink" title="取栈顶元素："></a>取栈顶元素：</h4><p>取栈顶元素和出栈不同。取栈顶元素只是把栈顶元素复制一份，栈顶指针未移动，栈内元素个数未变。</p><p>而出栈是指栈顶指针向下移动一个位置，栈内不再包含这个元素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">GetTop</span><span class="token punctuation">(</span>SqStack S<span class="token punctuation">)</span> <span class="token comment">//返回S的栈顶元素，栈顶指针不变</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">!=</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>  <span class="token comment">//栈非空</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回栈顶元素的值，栈顶指针不变</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链栈："><a href="#链栈：" class="headerlink" title="链栈："></a>链栈：</h3><p>链栈每个节点的地址是不连续的，只需要一个栈顶指针即可。</p><p>链栈的每个节点都包含两个域：数据域和指针域。是不是和单链表一模一样？可以把链栈看作一个不带头节点的单链表，但只能在头部进行插入、删除、取值等操作，不可以在中间和尾部操作。</p><h4 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h4><p>初始化一个空的链栈是不需要头节点的，因此只需要让栈顶指针为空即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Snode</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//数据域</span><span class="token keyword">struct</span> <span class="token class-name">Snode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span>Snode<span class="token punctuation">,</span><span class="token operator">*</span>LinkStack<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token comment">//构造一个空栈S</span><span class="token punctuation">&#123;</span>S<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入栈：-1"><a href="#入栈：-1" class="headerlink" title="入栈："></a>入栈：</h4><p>入栈是将新元素节点压入栈顶。因为链栈中第一个节点为栈顶，因此将新元素节点插到第一个节点的前面，然后修改栈顶指针指向新节点即可。</p><ol><li><p>生成新节点。入栈前要创建一个新节点，将元素 e 存入该节点的数据域。</p></li><li><p>将新元素节点插到第一个节点的前面，然后修改栈顶指针指向新节点。</p><ul><li>p-&gt;next&#x3D;S：将 S 的地址赋值给 p 的指针域，即新节点 p 的 next 指针指向 S。</li><li>S&#x3D;p：修改新的栈顶指针为 p。</li></ul><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220910182149962.png" alt="image-20220910182149962"></p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Push</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token comment">//在栈顶插入元素e</span><span class="token punctuation">&#123;</span>LinkStack p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token keyword">new</span> Snode<span class="token punctuation">;</span> <span class="token comment">//生成新结点</span>p<span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//将e放在新结点数据域</span>p<span class="token operator">-></span>next<span class="token operator">=</span>S<span class="token punctuation">;</span> <span class="token comment">//将新结点的指针域指向S，即将S的地址赋值给新结点的指针域</span>S<span class="token operator">=</span>p<span class="token punctuation">;</span>    <span class="token comment">//修改栈顶指针为p</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出栈：-1"><a href="#出栈：-1" class="headerlink" title="出栈："></a>出栈：</h4><p>出栈就是把栈顶元素删除，让栈顶指针指向下一个节点，然后释放该节点空间。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220910183055312.png" alt="image-20220910183055312"></p><ul><li>p&#x3D;S：将 S 的地址赋值给 p，即 p 指向栈顶元素节点。</li><li>S&#x3D;S-&gt;next：将 S 的后继节点的地址赋值给 S，即 S 指向它的后继节点。</li><li>delete p：最后释放 p 指向的节点空间，即 delete p。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Pop</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除S的栈顶元素，用e保存其值</span><span class="token punctuation">&#123;</span>LinkStack p<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//栈空</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>e<span class="token operator">=</span>S<span class="token operator">-></span>data<span class="token punctuation">;</span>  <span class="token comment">//将栈顶元素赋给e</span>p<span class="token operator">=</span>S<span class="token punctuation">;</span>  <span class="token comment">//用p保存栈顶元素地址，以备释放</span>S<span class="token operator">=</span>S<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">//修改栈顶指针，指向下一个结点</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span>  <span class="token comment">//释放原栈顶元素的空间</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取栈顶元素：-1"><a href="#取栈顶元素：-1" class="headerlink" title="取栈顶元素："></a>取栈顶元素：</h4><p>取栈顶元素和出栈不同，取栈顶元素只是把栈顶元素复制一份，栈顶指针并没有改变。而出栈是指删除栈顶元素，栈顶指针指向了下一个元素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">GetTop</span><span class="token punctuation">(</span>LinkStack S<span class="token punctuation">)</span> <span class="token comment">//返回S的栈顶元素，不修改栈顶指针</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//栈非空</span><span class="token keyword">return</span> S<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//返回栈顶元素的值，栈顶指针不变</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>顺序栈和链栈的所有基本操作都只需要常数时间，所以在时间效率上难分伯仲。</p><p>在空间效率方面，顺序栈需要预先分配固定长度的空间，有可能造成空间浪费或溢出；链栈每次只分配一个节点，除非没有内存，否则不会出现溢出，但是每个节点需要一个指针域，结构性开销增加。</p><p>因此，如果<strong>元素个数变化较大，可以采用链栈</strong>；反之，可以采用顺序栈。在实际应用中，顺序栈比链栈应用更广泛。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p>这种<strong>先进先出（First In First Out，FIFO）</strong>的线性序列，称为“队列”。队列也是一种线性表，只不过它是操作受限的线性表，只能在两端操作：一端进，一端出。</p><p>进的一端称为队尾（rear），出的一端称为队头（front）。</p></blockquote><h3 id="顺序队列："><a href="#顺序队列：" class="headerlink" title="顺序队列："></a>顺序队列：</h3><p>队列的顺序存储采用一段连续的空间存储数据元素，并用两个整型变量记录队头和队尾元素的下标。顺序队列定义好了之后，还要先定义一个最大的分配空间，顺序结构都是如此，需要预先分配空间。</p><blockquote><p>注意：队列只能在一端进、一端出，<strong>不允许在中间查找、取值、插入、删除等操作</strong>，先进先出是人为规定的，如果破坏此规则，就不是队列了。</p></blockquote><h4 id="入队和出队操作："><a href="#入队和出队操作：" class="headerlink" title="入队和出队操作："></a>入队和出队操作：</h4><ol><li><p>开始时为空队，Q.front &#x3D; Q.rear:</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172051098.png" alt="image-20220911172051098"></p></li><li><p>元素进队，放入队尾 Q.rear 的位置，然后 Q.rear 后移一位：</p></li></ol><p>   <img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172109380.png" alt="image-20220911172109380"></p><ol start="3"><li><p>元素出队，队头 Q.front 后移一位：</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172134406.png" alt="image-20220911172134406"></p></li><li><p>若此时队尾 Q.rear 已经超过了数组的最大下标，无法再进队，但是前面有空间却出现了队满的情况，这种情况称为“假溢出”：</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172240405.png" alt="image-20220911172240405"></p></li><li><p>为了解决“假溢出”，此时已经超过了数组的最大下标，即 Q.rear+1&#x3D;Maxsize（最大空间数 6），那么如果前面有空闲，Q.rear 可以转向前面下标为 0 的位置：</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911172256567.png" alt="image-20220911172256567"></p></li><li><p>当队列空间存满时，出现一个问题Q.front&#x3D;Q.rear，这和队空的条件一模一样，无法区分到底是队空，还是队满。有两种解决方法：</p><ul><li>一种办法是设置一个标志，标记队空和队满。</li><li>另一种办法是浪费一个空间，当队尾 Q.rear 的下一个位置 Q.front 时，就认为是队满。</li></ul></li></ol><p>上述到达尾部又向前存储的队列称为循环队列，<strong>为了避免“假溢出”，顺序队列通常采用循环队列</strong>。</p><h3 id="循环队列："><a href="#循环队列：" class="headerlink" title="循环队列："></a>循环队列：</h3><h4 id="队空："><a href="#队空：" class="headerlink" title="队空："></a>队空：</h4><p>无论队头和队尾在什么位置，只要 Q.rear 和 Q.front 指向同一个位置，就认为是队空。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911173711877.png" alt="image-20220911173711877"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="队满："><a href="#队满：" class="headerlink" title="队满："></a>队满：</h4><p>在此采用浪费一个空间的方法，当队尾 Q.rear 的下一个位置 Q.front 时，就认为是队满。</p><h5 id="临界状态："><a href="#临界状态：" class="headerlink" title="临界状态："></a>临界状态：</h5><p>但是 Q.rear 向后移动一个位置（Q.rear+1）后，很有可能超出了数组的最大下标，这时它的下一个位置应该为 0:</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911174340821.png" alt="image-20220911174340821"></p><p>队列的最大空间为 Maxsize，当 Q.rear&#x3D;Maxsize−1 时，Q.rear+1&#x3D;Maxsize。而根据循环队列的规则，Q.rear 的下一个位置为 0 才对，怎么才能变成 0 呢？</p><p>可以考虑<strong>取余运算</strong>，即(Q.rear+1)%Maxsize&#x3D;0。而此时 Q.front&#x3D;0，即(Q.rear+1)%Maxsize&#x3D;Q.front，此时为队满的临界状态。</p><h5 id="一般状态："><a href="#一般状态：" class="headerlink" title="一般状态："></a>一般状态：</h5><p>假如最大空间数 Maxsize&#x3D;100，当 Q.rear&#x3D;1 时，Q.rear+1&#x3D;2。取余后，(Q.rear+1)%Maxsize&#x3D;2，而此时 Q.front&#x3D;2，即(Q.rear+1)%Maxsize&#x3D;Q.front。</p><p>队满的一般状态也可以采用此公式判断队满。因为一个不大于 Maxsize 的数与 Maxsize 取余运算，结果仍然是该数本身，所以一般状态下，取余运算没有任何影响。</p><p><strong>只有在临界状态（Q.rear+1&#x3D;Maxsize）下，取余运算(Q.rear+1)%Maxsize 才会变为 0。</strong></p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911175419957.png" alt="image-20220911175419957"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h4><p>首先分配一个大小为 Maxsize 的空间，然后令 Q.front&#x3D;Q.rear&#x3D;0，即队头和队尾为 0，队列为空。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> <span class="token class-name">SqQueue</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> <span class="token operator">*</span>base<span class="token punctuation">;</span> <span class="token comment">//基地址</span><span class="token keyword">int</span> front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span> <span class="token comment">//头指针,尾指针</span><span class="token punctuation">&#125;</span>SqQueue<span class="token punctuation">;</span><span class="token comment">//循环队列的初始化</span><span class="token keyword">bool</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token comment">//注意使用引用参数，否则出了函数，其改变无效</span><span class="token punctuation">&#123;</span>Q<span class="token punctuation">.</span>base<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//分配空间</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//头指针和尾指针置为零，队列为空</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入队："><a href="#入队：" class="headerlink" title="入队："></a>入队：</h4><p>入队时，首先将元素 x 放入 Q.rear 所指空间，然后 Q.rear 后移一位。</p><p>当 Q.rear 后移一位时，为了处理临界状态（Q.rear+1&#x3D;Maxsize），需要加 1 后取余运算。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//循环队列的入队</span><span class="token keyword">bool</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token comment">//将元素e放入Q的队尾</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token operator">==</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> <span class="token comment">//尾指针后移一位等于头指针，表明队满</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//新元素插入队尾</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span> <span class="token comment">//队尾指针加1</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出队："><a href="#出队：" class="headerlink" title="出队："></a>出队：</h4><p>先用变量保存队头元素，然后队头 Q.front 后移一位。</p><p>当 Q.front 后移一位时，为了处理临界状态（Q.front+1&#x3D;Maxsize），需要加 1后取余运算。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//循环队列的出队</span><span class="token keyword">bool</span> <span class="token function">DeQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除Q的队头元素，用e返回其值</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">==</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//队空</span>e<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//保存队头元素</span>Q<span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span> <span class="token comment">//队头指针加1</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取队头元素："><a href="#取队头元素：" class="headerlink" title="取队头元素："></a>取队头元素：</h4><p>取队头元素时，只是把队头元素数据复制一份即可，并未改变队头位置，因此队列中的内容没有改变。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//取循环队列的队头元素</span><span class="token keyword">int</span> <span class="token function">GetHead</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span><span class="token comment">//返回Q的队头元素，不修改队头指针</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">!=</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span> <span class="token comment">//队列非空</span><span class="token keyword">return</span> Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="队列元素个数计算："><a href="#队列元素个数计算：" class="headerlink" title="队列元素个数计算："></a>队列元素个数计算：</h4><p>循环队列中的内容实际上为 Q.front～Q.rear−1 这一区间的数据元素，<strong>但是不可以直接用两个下标相减得到。因为队列是循环的</strong>，所以存在两种情况。</p><ul><li><p>Q.rear≥Q.front:</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911183047358.png" alt="image-20220911183047358"></p></li><li><p>Q.rear&lt;Q.front:</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911183539299.png" alt="image-20220911183539299"></p></li></ul><p>此时，Q.rear&#x3D;4，Q.front&#x3D;Maxsize−2，Q.rear-Q.front&#x3D;6−Maxsize。但是我们可以看到循环队列中的元素实际上为 6 个，那怎么办呢？当两者之差为负数时，可以将差值加上 Maxsize计算元素个数，即 Q.rear−Q.front+Maxsize&#x3D;6−Maxsize+Maxsize&#x3D;6，元素个数为 6。</p><blockquote><p>因此，在计算元素个数时，可以分两种情况判断。<br>1）<strong>Q.rear≥Q.front：元素个数为 Q.rear−Q.front。</strong><br>2）<strong>Q.rear&lt;Q.front：元素个数为 Q.rear−Q.front+Maxsize。</strong></p></blockquote><p>也可以采用取余的方法把两种情况巧妙地统一为一个语句:</p><blockquote><p><strong>队列中元素个数为：(Q.rear-Q.front+Maxsize)%Maxsize</strong></p><p>%Maxsize 是为了防止 Q.rear-Q.front 为正数的情况，</p><p>+Maxsize 是为了防止 Q.rear-Q.front为负数的情况</p></blockquote><h4 id="求队列的长度："><a href="#求队列的长度：" class="headerlink" title="求队列的长度："></a>求队列的长度：</h4><p>通过前面的分析，我们已经知道循环队列中元素个数为：(Q.rear−Q.front+Maxsize)%Maxsize，循环队列中元素个数即为循环队列的长度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//循环队列的长度</span><span class="token keyword">int</span> <span class="token function">QueueLength</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链队列："><a href="#链队列：" class="headerlink" title="链队列："></a>链队列：</h3><p>链队列类似一个单链表，需要两个指针 front 和 rear 分别指向队头和队尾。从队头出队，从队尾入队，为了出队时删除元素方便，可以增加一个头节点。</p><blockquote><p><strong>注意：链队列需要头节点</strong></p></blockquote><h4 id="初始化：-3"><a href="#初始化：-3" class="headerlink" title="初始化："></a>初始化：</h4><p>链队列的初始化，即创建一个头节点，头指针和尾指针指向头节点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> <span class="token class-name">Qnode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">Qnode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Qnode<span class="token punctuation">,</span><span class="token operator">*</span>Qptr<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  Qnode <span class="token operator">*</span>front<span class="token punctuation">;</span>  Qnode <span class="token operator">*</span>rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>LinkQueue<span class="token punctuation">;</span><span class="token comment">//链队的初始化</span><span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token comment">//注意使用引用参数，否则出了函数，其改变无效</span><span class="token punctuation">&#123;</span>Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token keyword">new</span> Qnode<span class="token punctuation">;</span> <span class="token comment">//创建头结点，头指针和尾指针指向头结点</span>Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入队：-1"><a href="#入队：-1" class="headerlink" title="入队："></a>入队：</h4><ol><li><p>先创建一个新节点，将元素 e 存入该节点的数值域。</p></li><li><p>然后将新节点插入队尾，尾指针后移。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911221232441.png" alt="image-20220911221232441"></p><ul><li>Q.rear-&gt;next&#x3D;s：把 s 节点的地址赋值给队列尾节点的 next 域，即尾节点的 next 指针指向 s。</li><li>Q.rear&#x3D;s：把 s 节点的地址赋值给尾指针，即尾指针指向 s，尾指针永远指向队尾。</li></ul></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//链队列的入队</span><span class="token keyword">void</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token comment">//将元素e放入队尾</span><span class="token punctuation">&#123;</span>Qptr s<span class="token punctuation">;</span>s<span class="token operator">=</span><span class="token keyword">new</span> Qnode<span class="token punctuation">;</span>s<span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>s<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment">//新元素插入队尾</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>s<span class="token punctuation">;</span>     <span class="token comment">//队尾指针后移</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="出队：-1"><a href="#出队：-1" class="headerlink" title="出队："></a>出队：</h4><p>出队相当于删除第一个数据元素，即将第一个数据元素节点跳过去。</p><ol><li><p>首先用 p 指针指向第一个数据节点，然后跳过该节点，即 Q.front-&gt;next&#x3D;p-&gt;next。</p></li><li><p><strong>若队列中只有一个元素，删除后需要修改队尾指针。</strong></p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220911222148596.png" alt="image-20220911222148596"></p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//链队列的出队</span><span class="token keyword">bool</span> <span class="token function">DeQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除Q的队头元素，用e返回其值</span><span class="token punctuation">&#123;</span>Qptr p<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">==</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token comment">//队空</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>p<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token punctuation">;</span>e<span class="token operator">=</span>p<span class="token operator">-></span>data<span class="token punctuation">;</span>     <span class="token comment">//保存队头元素</span>Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">==</span>p<span class="token punctuation">)</span> <span class="token comment">//若队列中只有一个元素，删除后需要修改队尾指针</span>        Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取队头元素：-1"><a href="#取队头元素：-1" class="headerlink" title="取队头元素："></a>取队头元素：</h4><p>队头实际上是 Q.front-&gt;next 指向的节点，即第一个数据节点，队头元素就是将该节点的数据域存储的元素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//取循环队列的队头元素</span><span class="token keyword">int</span> <span class="token function">GetHead</span><span class="token punctuation">(</span>LinkQueue Q<span class="token punctuation">)</span><span class="token comment">//返回Q的队头元素，不修改队头指针</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">!=</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span> <span class="token comment">//队列非空</span><span class="token keyword">return</span> Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈和队列的应用："><a href="#栈和队列的应用：" class="headerlink" title="栈和队列的应用："></a>栈和队列的应用：</h2><h3 id="数制的转换："><a href="#数制的转换：" class="headerlink" title="数制的转换："></a>数制的转换：</h3><p><strong>题目：</strong>将一个十进制数 n 转换为二进制数。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>十进制数转换为二进制，可以采用辗转相除、取余数的方法得到。例如十进制数 11 转二进制。先求余数 11%2&#x3D;1，求商 11&#x2F;2&#x3D;5，然后用商 5 再求余数，求商，直到商为 0，结束。</p><p>先求出的余数是二进制数的低位，后求出的余数是二进制数的高位，将得到的余数逆序输出就是所要的二进制数，即 11 的二进制数为 1011。如何将余数逆序输出呢？</p><p><strong>逆序输出正好符合栈的先入后出性质，因此可以借助栈来实现。</strong></p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>初始化一个栈 S。</li><li>如果 n!&#x3D;0，将 n%2 入栈 S，更新 n&#x3D;n&#x2F;2。</li><li>重复运行第 2 步，直到 n&#x3D;0 为止。</li><li>如果栈不空，弹出栈顶元素 e，输出 e，直到栈空。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> Elemtype<span class="token punctuation">;</span><span class="token comment">//先类型定义为int </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"sqstack.h"</span><span class="token comment">//引入自定义头文件,源码目录下名为sqstack.h的文件  </span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">binaryconversion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    SqStack S<span class="token punctuation">;</span><span class="token comment">//定义一个栈S</span>    <span class="token keyword">int</span> e<span class="token punctuation">;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Empty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果栈不空</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出栈</span>        cout<span class="token operator">&lt;&lt;</span>e<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token punctuation">;</span><span class="token comment">//输出栈顶元素</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析："><a href="#算法复杂度分析：" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>每次取余后除以 2，n 除以 2 多少次变为 1，那么第一个 while 语句就执行多少次。假设执行 x 次，则 n&#x2F;2x&#x3D;1，x&#x3D;log2n。因此，时间复杂度为 O(log2n)，使用的栈空间大小也是 log2n，空间复杂度也为 O(log 2n)。</p><h3 id="回文判定："><a href="#回文判定：" class="headerlink" title="回文判定："></a>回文判定：</h3><p><strong>题目：</strong>回文是指正读反读均相同的字符序列，如“abba”和“abcscba”均是回文，也就是说字符串沿中心线对称。试写一个算法判定给定的字符串是否为回文。</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p><strong>回文是中心对称的，可以将字符串前一半入栈，然后，栈中元素和字符串后一半进行比较。</strong>即将第一个出栈元素和后一半串中第一个字符比较，若相等，则再将出栈一个元素与后一个字符比较……直到栈空为止，则字符序列是回文。</p><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>初始化一个栈S。</li><li>求字符串长度，将前面一半的字符依次入栈 S。</li><li>如果栈不空，弹出栈顶元素 e，与字符串后一半元素比较。<strong>若 n 为奇数，则跳过中心点，比较中心点后面的元素。</strong>如果元素相等，则继续比较直到栈空，返回 true；如果元素不等，返回 false。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> Elemtype<span class="token punctuation">;</span><span class="token comment">//先类型定义为char </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"sqstack.h"</span><span class="token comment">//引入自定义头文件,源码目录下名为sqstack.h的文件   </span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">palindrome</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token comment">//判断字符串是否为回文</span><span class="token punctuation">&#123;</span>    SqStack S<span class="token punctuation">;</span><span class="token comment">//定义一个栈S</span>    <span class="token keyword">int</span> len<span class="token punctuation">,</span>i<span class="token punctuation">;</span>    <span class="token keyword">char</span> e<span class="token punctuation">;</span>    len<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回字符串长度</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化栈</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//将字符串前一半依次入栈</span>        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//字符串长度为奇数，跳过中心点</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Empty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果栈不空</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出栈</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token operator">!=</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//比较元素是否相等</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-1"><a href="#算法复杂度分析：-1" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>如果字符串长度为 n，将前一半入栈，后一半依次和出栈元素比较，相当于扫描了整个字符串，因此时间复杂度为 O(n)，使用的栈空间大小是 n&#x2F;2，空间复杂度也为 O(n)。</p><h3 id="双端队列："><a href="#双端队列：" class="headerlink" title="双端队列："></a>双端队列：</h3><p><strong>题目：</strong>设计一个数据结构，使其具有栈和队列两种特性。</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>栈是后进先出，队列是先进先出，如何具有这两种特性呢？<br>栈是在一端进出，队列是在一端进、另一端出，能否设计两端都可以进出呢？</p><blockquote><p>允许两端都可以进行入队和出队的队列，就是双端队列</p></blockquote><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912114829664.png" alt="image-20220912114829664"></p><p>循环队列表示的双端队列，可以用环形形象地表达出来。双端队列和普通循环队列的区别如图所示。</p><p>双端队列包括前端和后端，可以从前端进入、前端出队、后端进队、后端出队。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912115334112.png" alt="image-20220912115334112"></p><h4 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h4><ol><li><p>入队</p><ul><li><p>前端进队时，先令 Q.front 前移一位，再将元素放入 Q.front 的位置，a、b、c 依次从前端进队。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912121125792.png" alt="image-20220912121125792"></p></li><li><p>后端进队时，先将元素放入 Q.rear 的位置，再令 Q.rear 后移一位，d 从后端进队。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912121141406.png" alt="image-20220912121141406"></p></li></ul></li><li><p>出队</p><ul><li><p>从后端出队，先令 Q.rear 前移一位，再将 Q.rear 位置元素取出。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912121220588.png" alt="image-20220912121220588"></p></li><li><p>从前端出队，先将 Q.front 位置元素取出，再令 Q.front 后移一位。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912121233284.png" alt="image-20220912121233284"></p></li></ul></li></ol><blockquote><p><strong>后端进、前端出</strong>或者<strong>前端进、后端出</strong>体现了先进先出的特点，符合<strong>队列</strong>的特性。</p><p><strong>后端进、后端出</strong>或者<strong>前端进、前端出</strong>体现了后进先出的特点，符合<strong>栈</strong>的特性。</p></blockquote><h5 id="初始化：-4"><a href="#初始化：-4" class="headerlink" title="初始化："></a>初始化：</h5><p>初始化时，头指针和尾指针置为零，双端队列为空。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> <span class="token class-name">SqQueue</span><span class="token punctuation">&#123;</span>  ElemType base<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//一维数组存储，也可以设置指针动态分配空间</span>  <span class="token keyword">int</span> front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span> <span class="token comment">//头指针,尾指针</span><span class="token punctuation">&#125;</span>DuQueue<span class="token punctuation">;</span><span class="token comment">//初始化</span><span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token comment">//注意使用引用参数，否则出了函数，其改变无效</span><span class="token punctuation">&#123;</span>Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//头指针和尾指针置为零，队列为空</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="判队满："><a href="#判队满：" class="headerlink" title="判队满："></a>判队满：</h5><p>当队尾后移一位等于队头，表明队满。队尾后移一位即 Q.rear+1，加 1 后有可能等于Maxsize，此时下一个位置为 0，因此为处理临界状态，需要与 Maxsize 取余运算。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//判队满</span><span class="token keyword">bool</span> <span class="token function">isFull</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token operator">==</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> <span class="token comment">//尾指针后移一位等于头指针，表明队满</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>       <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="尾进："><a href="#尾进：" class="headerlink" title="尾进："></a>尾进：</h5><p>尾部进队，即后端进队时，先将元素放入 Q.rear 位置，然后 Q.rear 后移一位，后移时为处理边界情况，需要加 1 后模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token comment">//尾进</span><span class="token keyword">bool</span> <span class="token function">push_back</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//先放入</span>    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token comment">//向后移动一位</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="尾出："><a href="#尾出：" class="headerlink" title="尾出："></a>尾出：</h5><p>尾部出队，即后端出队时，先将 Q.rear 前移一位，然后取出元素。前移一位即 Q.rear−1，当 Q.rear 为 0 时，Q.rear−1 为负值，因此加上 Maxsize，正好是 Maxsize−1 的位置。那么，Q.rear−1 为正值时，加上 Maxsize 就超过了下标范围，需要模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//尾出</span><span class="token keyword">bool</span> <span class="token function">pop_back</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token comment">//向前移动一位</span>    x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取数据</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="头进："><a href="#头进：" class="headerlink" title="头进："></a>头进：</h5><p>头部进队，即前端进队时，先将 Q.front 前移一位，然后将元素先放入 Q.front 位置。队头前移一位即 Q.front−1，前移时为处理边界情况，需要加 Maxsize 再模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token comment">//头进</span><span class="token keyword">bool</span> <span class="token function">push_front</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token comment">//先向前移动一位</span>    Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//后放入</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="头出："><a href="#头出：" class="headerlink" title="头出："></a>头出：</h5><p>头部进队，即前端出队时，先取出元素，然后 Q.front 后移一位，即 Q.front+1，后移时为处理边界情况，需要模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//头出</span><span class="token keyword">bool</span> <span class="token function">pop_front</span><span class="token punctuation">(</span>DuQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取数据</span>    Q<span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token comment">//向后移动一位</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="取队头："><a href="#取队头：" class="headerlink" title="取队头："></a>取队头：</h5><p>取队头是指将 Q.front 位置的元素取出来，Q.front 未改变。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//取队头</span><span class="token keyword">bool</span> <span class="token function">get_front</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取队头数据;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="取队尾："><a href="#取队尾：" class="headerlink" title="取队尾："></a>取队尾：</h5><p><strong>因为 Q.rear 指针永远指向空</strong>，因此取队尾时，取 Q.rear 前面的那个位置，要想得到前面位置，为处理边界情况，需要加 Maxsize 再模 Maxsize取余。</p><blockquote><p><strong>注意：取队尾时，尾指针不移动。</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//取队尾</span><span class="token keyword">bool</span> <span class="token function">get_back</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="求长度："><a href="#求长度：" class="headerlink" title="求长度："></a>求长度：</h5><p>和普通循环队列求长度的方法一样，都是求从队头到队尾之间的元素个数。因为循环队列减法有可能有负值，因此需要加 Maxsize 再模 Maxsize 取余。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//求长度</span><span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span>Maxsize<span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h5><p>双端队列的遍历，即从头到尾输出整个队列中的元素，在输出过程中，队头和队尾并不移动，因此<strong>借助一个暂时变量即可</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//从头到尾输出整个队列元素（遍历）</span><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>DuQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout<span class="token operator">&lt;&lt;</span><span class="token string">"DuQueue is empty"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> temp<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span><span class="token comment">//设置一个暂存变量，头指针未移动</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       cout<span class="token operator">&lt;&lt;</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token punctuation">;</span>       temp<span class="token operator">=</span><span class="token punctuation">(</span>temp<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Maxsize<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"traverse is over!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>技巧：后移时，加 1 模 Maxsize；前移时，减 1 加 Maxsize 再模 Maxsize。</strong></p></blockquote><ol><li><p>输出受限的双端队列</p><p>允许在一端进队和出队，另一端只允许进队，这样的双端队列称为输出受限的双端队列。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164028211.png" alt="image-20220912164028211"></p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164110581.png" alt="image-20220912164110581"></p></li><li><p>输入受限的双端队列</p><p>允许在一端进队和出队，另一端只允许出队，这样的双端队列称为输入受限的双端队列。</p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164121646.png" alt="image-20220912164121646"></p><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164134580.png" alt="image-20220912164134580"></p></li></ol><h2 id="栈和队列学习技巧："><a href="#栈和队列学习技巧：" class="headerlink" title="栈和队列学习技巧："></a>栈和队列学习技巧：</h2><h3 id="栈和队列的比较："><a href="#栈和队列的比较：" class="headerlink" title="栈和队列的比较："></a>栈和队列的比较：</h3><p><img src="/2022/09/10/shu-ju-jie-gou-ru-men-zhan-he-dui-lie/image-20220912164341735.png" alt="image-20220912164341735"></p><h3 id="栈解题技巧："><a href="#栈解题技巧：" class="headerlink" title="栈解题技巧："></a>栈解题技巧：</h3><ol><li>栈顶指针所指位置<ul><li>在顺序栈中，栈顶指针指向的是栈顶元素的上一个位置，即空位置，取栈顶元素时要取*(S.top−1)才可以</li><li>入栈时，先把元素放入栈顶位置，然后栈顶指针后移，即*S.top++&#x3D;e。</li><li>出栈时，栈顶指针前移，用变量暂存栈顶元素，即 e&#x3D;−−S.top。</li></ul></li><li>出栈只是栈顶指针移动，空间元素仍然存在，但下次入栈时会覆盖</li><li>本文以动态分配为例，静态分配的情况处理方式不同<ul><li>静态分配是使用一个固定长度的数组存储数据，然后用一个 int 型的变量 top 指向栈顶，top 实际上是数组的下标。当栈空时，S.top&#x3D;0。</li><li>入栈时，先把元素放入栈顶位置，然后栈顶指针后移，即 S.data[S.top++]&#x3D;e。</li><li>出栈时，栈顶指针前移，用变量暂存栈顶元素，即 e&#x3D;S.data[−−S.top]。</li></ul></li><li>栈和队列的灵活运用：<ul><li>栈具有后进先出的特性，可以利用此特性解决如<strong>逆序输出</strong>、<strong>括号匹配</strong>等问题。由于栈只能在一端操作，插入、删除都是在栈顶进行，不需要移动元素，因此大多使用顺序栈。</li><li>队列具有先进先出的特性，可以利用此特性解决一系列<strong>排队</strong>、<strong>先到先得</strong>等问题。在确定队列长度范围的情况下，大多使用循环队列。如果队列长度变化较大，则使用链队。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue动画与过渡</title>
      <link href="/2022/09/09/vue-dong-hua-yu-guo-du/"/>
      <url>/2022/09/09/vue-dong-hua-yu-guo-du/</url>
      
        <content type="html"><![CDATA[<h2 id="使用CSS-keyframes实现动画"><a href="#使用CSS-keyframes实现动画" class="headerlink" title="使用CSS keyframes实现动画"></a>使用CSS keyframes实现动画</h2><blockquote><p>animation: [name] [duration] [timing-function] [delay] [iteration-count] [direction] [fill-mode]</p></blockquote><ul><li><p>name：用于给@keyframes指定动画名称</p></li><li><p>duration：用于标记一个动画完成周期所需时间，非必填，默认0s</p></li><li><p>timing-function：用于描述一个动画数值变化方式，非必填，默认ease</p><ul><li><p>linear:表示值变化均匀，匀速播放动画。</p></li><li><p>ease:默认参数。表示值变化以低速率开始，逐渐加快，直到结束前速率降低。</p></li><li><p>ease-in:表示值变化以低速率开始，平均速率过渡，结尾戛然而止。</p></li><li><p>ease-out:表示值变化以平均速率开始，以低速率缓慢结尾。</p></li><li><p>ease-in-out:表示值变化以低速率开始和结尾。</p></li><li><p>steps(int,start|end):表示将值区间按一定数量隔开，每段时间间隔中值保持不变。第一个参数为整型，第二个参数为字符串。</p><ul><li><p>int:间隔数量，数量越小效果越明显。</p></li><li><p>start|end:字符串参数，start为从值区间头部开始计算，end为从值区间尾部开始计算。</p></li><li><p>举例：值区间[0,99]，参数steps(4,start|end)，start或end。</p><p>将0<del>99分为四段，分别为0</del>24，25<del>49，50</del>74，75~99。</p><p>首先值以匀速从0开始向99变化。当为start时，值一旦在0~24开始变化，开始于此段的头部值0，则立刻输出该段结尾值24，等待时间推动值变化进入下一段。</p><p>当为end时，值一旦在0~24开始变化，由于未触发此段的尾部值24，故一直保持输出该段的头部值0，等待时间推动值变化进入下一段。</p></li></ul></li><li><p>cubic-bezier(p1x,p1y,p2x,p2y):表示值变化v-t图遵循贝塞尔曲线图形。</p><ul><li>在二维直角坐标系中，首先有P0(p0x,p0y)，此时p0x&#x3D;0，p0y&#x3D;0，即原点，此点固定不变。其次有P3(p3x,p3y)，此时p3x&#x3D;1,p3y&#x3D;1，此点固定不变。</li><li>最后有两自由点P1(p1x,p1y)、P2(p2x,p2y)，由P0P1组成一条贝塞尔辅助线，由P2P3组成另一条贝塞尔辅助线，在这两条辅助线的作用下生成一条贝塞尔曲线，此曲线即值变化速度曲线v-t图，其中负值代表方向。</li></ul></li></ul></li><li><p>delay：用于标记一个动画完成周期所需时间，非必填，默认0s</p></li><li><p>iteration-count：用于描述一个动画循环次数，非必填，默认0s，不设置则不使用循环播放效果</p><ul><li>整型：表示播放次数。</li><li>infinite:字符串，表示无限循环播放。</li></ul></li><li><p>direction：用于设置是否循环往复播放动画，非必填，默认normal</p><ul><li>normal:默认参数。动画正常播放，不进行循环往复操作。</li><li>reverse:动画反向播放。</li><li>alternate:动画在奇数次正向播放，在偶数次反向播放。</li><li>alternate-reverse:动画在偶数次正向播放，在奇数次反向播放。</li><li>initial:动画重新设置为默认值。</li><li>inherit:动画设置为父元素属性。</li></ul></li><li><p>fill-mode：用于在动画不播放时（处于延时或完成的状态）设置动画的位置，非必填，<strong>样式可以分为在animation外部的初始样式，以及在keyframes中定义的动画样式。</strong></p><ul><li>none:默认参数。在动画不播放时不对动画产生任何作用。</li><li>forwards:在动画结束时应用动画样式效果，在动画延时中应用初始样式效果。</li><li>backwards:在动画结束时应用初始样式效果，在动画延时中应用动画样式效果。</li><li>both:在动画结束时应用动画样式效果，在动画延时中应用动画样式效果。</li><li>initial:动画重新设置为默认值。</li><li>inherit:动画设置为父元素属性。</li></ul></li></ul><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>duration<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> duration <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>    45deg<span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 60%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>300deg<span class="token punctuation">,</span> 90%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0.5em 1.4em<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>    <span class="token comment">/* animation: rotate 10s linear infinite; */</span>  <span class="token property">animation</span><span class="token punctuation">:</span> rotate <span class="token function">v-bind</span><span class="token punctuation">(</span>duration + <span class="token string">"s"</span><span class="token punctuation">)</span> linear infinite<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@keyframes</span> rotate</span> <span class="token punctuation">&#123;</span>  <span class="token selector">0%</span> <span class="token punctuation">&#123;</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>0deg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token selector">100%</span> <span class="token punctuation">&#123;</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>360deg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用CSS-Transition实现动画"><a href="#使用CSS-Transition实现动画" class="headerlink" title="使用CSS Transition实现动画"></a>使用CSS Transition实现动画</h2><blockquote><p>Transition强调过渡，即一个元素从一个状态进入另一个状态的过程；而keyframes强调动画的运动轨迹，可设置中间状态改变动画轨迹。</p></blockquote><h3 id="transform参数："><a href="#transform参数：" class="headerlink" title="transform参数："></a>transform参数：</h3><ol><li><p>translate ( n px )：</p><p><strong>一个值：</strong>transform:translate(100px)，表示水平方向移动的位移，等同于translateX(100px)</p><p>translateX(x):沿 X 轴位移</p><p>translateY(y):沿 Y 轴位移</p><p>translateZ(z):沿 Z 轴位移</p><p><strong>两个值：</strong> transform:translate(100px, 200px)，第一个表示水平方向移动的位移，第二个表示垂直方向移动的位移</p><p>translate(x,y) :沿 X Y 轴位移</p><p><strong>三个值：</strong>translate3d(10px,20px,10px)，表示3D三个方向移动的位移，顺序为X,Y,Z</p></li><li><p>rotate ( n deg )：</p><p><strong>以角度(deg)为单位，正数是顺时针旋转，负数是逆时针旋转</strong> </p><p>rotate():2D旋转</p><p>rotateX():沿着X轴3D旋转</p><p>rotateY():沿着Y轴3D旋转</p><p>rotateZ():沿着Z轴3D旋转.要在其父级配合transform-style: preserve-3d;使用</p><p>rotate3D(x,y,z,n deg): 3D旋转，接受四个参数，x,y,z介于0-1之间，n是旋转的度数。元素围绕着xyz在空间中确定的唯一坐标点和原点之间的连线旋转指定的角度。</p></li><li><p>scale ( n )：</p><p><strong>一个值：</strong>transform: scale(1) ，表示水平跟垂直方向同时放大1倍</p><p><strong>两个值：</strong>transform: scale(1,2)，第一个参数表示水平方向的缩放比例，第二个参数表示垂直方向的缩放比例，等同于scaleX (1)和 scaleY(2)</p><p><strong>三个值：</strong>scale3d(0.5,0.3,0.4)，表示3D三个方向缩放的比例，顺序为X,Y,Z轴</p><p>数值为负时为缩小</p></li><li><p>skew ( n deg )：</p><p><strong>一个值：</strong>transform:skew(10deg)，表示水平方向的倾斜角度，等同于skewX(10deg)</p><p>skewX:表示水平方向的倾斜角度</p><p>skewY：表示垂直方向的倾斜角度</p><p><strong>两个值：</strong>transform:skew(10deg,20deg)，第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度</p></li><li><p>transform-origin：</p></li></ol><blockquote><p><strong>值得注意的是:在进行以上的变形操作时，默认都是以元素的中心为基点.</strong></p></blockquote><p><strong>有两个参数：第一个表示距离元素左上角水平方向的距离，第二个表示距离元素左上角垂直方向的距离。</strong></p><p><strong>第一个参数可以设置为left、center、right，第二个参数可以设置为top、center、bottom。</strong></p><h3 id="transition参数："><a href="#transition参数：" class="headerlink" title="transition参数："></a>transition参数：</h3><ol><li>transition-property：定过渡或动态模拟的css属性，也就是指定究竟是哪个属性要执行动画效果。<ul><li>none：没有属性会获得过渡效果。</li><li>all：所有属性都将获得过渡效果。</li><li>property：定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。</li></ul></li><li>transition-duration：指定完成过渡所需的时间，单位是秒或毫秒。参数同keyframes。</li><li>transition-timing-function：指定过渡函数。参数同keyframes。</li><li>transition-delay：开始执行动画的延迟时间，单位是秒或毫秒。参数同keyframes。</li></ol><p>示例：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>    45deg<span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 60%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>300deg<span class="token punctuation">,</span> 90%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0.5em 1.4em<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>  <span class="token property">transition</span><span class="token punctuation">:</span> all 0.5s ease-in-out<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.box:hover</span> <span class="token punctuation">&#123;</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1.25<span class="token punctuation">)</span> <span class="token function">skewY</span><span class="token punctuation">(</span>-20deg<span class="token punctuation">)</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>20deg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目开发与部署</title>
      <link href="/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/"/>
      <url>/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>安装Vue.js devtools浏览器拓展：</p><p><img src="/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/image-20220909155504413.png" alt="image-20220909155504413"></p><p>调试页面如下：</p><p><img src="/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/image-20220909155640255.png" alt="image-20220909155640255"></p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>在使用Vue开发项目时，无论使用哪种脚手架，都属于在<strong>开发环境</strong>中开发。在开发环境下，Vue为了方便开发者调试，对代码与组件并没有进行优化，性能不会太好。</p><p>在项目开发完成后，我们需要将项目构建成<strong>生产版本</strong>，在生产版本中，Vue会进一步优化性能，缩减代码体积。</p><p>使用Vite进行打包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> run build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打包后会生产dist文件夹，结构如下图：</p><p><img src="/2022/09/09/vue-xiang-mu-kai-fa-yu-bu-shu/image-20220909160316461.png" alt="image-20220909160316461"></p><p>打包后进行本地测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> run serve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue背后机制</title>
      <link href="/2022/09/09/vue-bei-hou-ji-zhi/"/>
      <url>/2022/09/09/vue-bei-hou-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="响应性基础：Proxy"><a href="#响应性基础：Proxy" class="headerlink" title="响应性基础：Proxy"></a>响应性基础：Proxy</h2><blockquote><p>Proxy是ES6中新添加的特性，用于给一个对象创建代理，用来拦截对象的操作。这样可以添加额外的业务逻辑或对原对象进行保护。</p></blockquote><p>拦截方法参考：</p><p><img src="/2022/09/09/vue-bei-hou-ji-zhi/image-20220909103853546.png" alt="image-20220909103853546"></p><p><img src="/2022/09/09/vue-bei-hou-ji-zhi/image-20220909103911409.png" alt="image-20220909103911409"></p><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> objProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">访问了 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>target<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 中的 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">，值为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// return target[key];</span>    <span class="token comment">// return 10;</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用Reflect.get()直接返回原对象的属性值</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">修改了 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>target<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 中的 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">，值为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>value<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// target[key] = value;</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果不调用Reflect.set()则原对象的值不会发生变化，可用来验证修改是否合法，如果合法返回Reflect.get()，否则提示错误</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// console.log(objProxy.a);</span>objProxy<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">// 访问 proxy</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>objProxy<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 访问原始对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现一个响应性示例（简化版）："><a href="#实现一个响应性示例（简化版）：" class="headerlink" title="实现一个响应性示例（简化版）："></a>实现一个响应性示例（简化版）：</h3><blockquote><p>目标：在修改对象的属性后，自动更新原对象的属性。</p></blockquote><p>基础原理：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> reactiveObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reactiveObj<span class="token punctuation">.</span>a <span class="token operator">+</span> reactiveObj<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>封装一部分后：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> currentObserver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  currentObserver <span class="token operator">=</span> fn<span class="token punctuation">;</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  currentObserver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// observe</span><span class="token keyword">let</span> reactiveObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentObserver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> targetObserver <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>targetObserver<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        targetObserver<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentObserver<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        targetObserver<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>currentObserver<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> observersForkey <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    observersForkey<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>observers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reactiveObj<span class="token punctuation">.</span>a <span class="token operator">+</span> reactiveObj<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">observe</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后完整封装：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> currentObserver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  currentObserver <span class="token operator">=</span> fn<span class="token punctuation">;</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  currentObserver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  observers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">registerObserver</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">execute</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">registerObserver</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentObserver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> targetObserver <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>targetObserver<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      targetObserver<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentObserver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      targetObserver<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>currentObserver<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> observersForkey <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  observersForkey<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> reactiveObj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reactiveObj<span class="token punctuation">.</span>a <span class="token operator">+</span> reactiveObj<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reactiveObj<span class="token punctuation">.</span>a <span class="token operator">-</span> reactiveObj<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 类似于调用 computed()</span><span class="token function">observe</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">observe</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  reactiveObj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Virtual-DOM：Vue-渲染机制的核心"><a href="#Virtual-DOM：Vue-渲染机制的核心" class="headerlink" title="Virtual DOM：Vue 渲染机制的核心"></a>Virtual DOM：Vue 渲染机制的核心</h2><p>因为使用Vue编写的程序，经常因为响应性的变化而重新渲染视图，如果直接操作真实的DOM，会是比较耗时的操作。这是因为需要找到某个节点，并将其换为新的节点，这样会触发浏览器的重新布局和重绘流程，对性能会有影响。</p><p>VirtualDOM的结构：</p><p><img src="/2022/09/09/vue-bei-hou-ji-zhi/image-20220909111405303.png" alt="image-20220909111405303"></p><p>Vue有渲染工具，会将虚拟的DOM转换为真实的DOM，在节点变化后，会根据算法调整节点顺序或更换节点。这种比对算法Vue中称为Patch，其他框架有称为diff或reconciliation。</p><blockquote><p>对于静态的DOM元素，Vue会保存这些节点，后续使用时会直接使用之前的节点；</p><p>对于响应性的节点，Vue会对包含这些节点的父节点维护一个记录，包含响应性数据的节点在更新时直接更新记录中的节点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-线性表</title>
      <link href="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/"/>
      <url>/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><ul><li><p>静态分配</p><p>顺序表最简单的方法是使用一个定长数组data[]存储数据，最大空间为 Maxsize，用 length记录实际的元素个数，即顺序表的长度。</p></li><li><p>动态分配</p><p>在程序运行过程中，根据需要动态分配一段连续的空间（大小为 Maxsize），用 elem 记录该空间的基地址（首地址），用 length 记录实际的元素个数，即顺序表的长度。</p><p>采用动态存储方法，在运算过程中，如果发生溢出，可以另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储空间的目的。</p></li></ul><h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><p>分配Maxsize空间，<strong>注意判断分配失败的情况</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//最大空间</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> <span class="token operator">*</span>elem<span class="token punctuation">;</span><span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">// 顺序表的长度</span><span class="token punctuation">&#125;</span>SqList<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">InitList</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token comment">//构造一个空的顺序表L</span><span class="token punctuation">&#123;</span>   <span class="token comment">//L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</span><span class="token comment">//不加&amp;内部改变，跳出函数后无效</span>    L<span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//为顺序表分配Maxsize个空间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment">//存储分配失败</span>    L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//空表长度为0</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h4><ol><li>注意判断顺序表是否已满。</li><li>将数据 x 存入顺序表的第 i 个位置，即 L.elem[i]&#x3D;x，然后 i++。</li><li>注意顺序表长度增加1。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">CreateList</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token comment">//创建一个顺序表L</span><span class="token punctuation">&#123;</span>   <span class="token comment">//L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</span><span class="token comment">//不加&amp;内部改变，跳出函数后无效</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    cin<span class="token operator">>></span>a<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span>Maxsize<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"顺序表已满！"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>    cin<span class="token operator">>></span>a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取值："><a href="#取值：" class="headerlink" title="取值："></a>取值：</h4><p>顺序表中的<strong>任何一个元素都可以立即被找到</strong>，称为随机存取方式。</p><p>由于下标是从 0 开始的，因此第 i 个元素，其下标为 i−1，即对应元素为 L.elem[i−1]</p><blockquote><p>注意：位序是指第几个元素，<strong>位序和下标差1</strong>。</p></blockquote><p>注意判断i值的合理性。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906155828274.png" alt="image-20220906155828274"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">GetElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token comment">//判断i值是否合理，若不合理，返回false</span>e<span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//第i-1的单元存储着第i个数据</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h4><p>在顺序表中查找一个元素 e，可以从第一个元素开始顺序查找，<strong>依次比较每一个元素值</strong>。如果相等，则返回元素位置（位序，即第几个元素）；如果查找整个顺序表都没找到，则返回−1。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">LocateELem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token punctuation">)</span>  <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//第几个元素，例如第5个元素，下标其实为4</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="算法复杂度分析："><a href="#算法复杂度分析：" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h5><ul><li><p>最好情况：如果元素正好在第一个位置，比较一次查找成功，时间复杂度为 O(1)。</p></li><li><p>最坏情况：如果元素正好在最后一个位置，比较 n 次查找成功，时间复杂度为 O(n)。</p></li><li><p>平均情况：如果查找的元素在第一个位置需要比较 1 次，第二个位置需要比较 2次……最后一个位置需要比较 n 次。如果该元素在第 i 个位置，则需要比较 i 次，把每种情况比较次数乘以其查找概率 pi 并求和，即为平均时间复杂度。如果查找概率均等，即每个关键字的查找概率均为 1&#x2F;n，则平均时间复杂度为：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906160600617.png" alt="image-20220906160600617"></p><p>因此，假设每个关键字查找的概率均等，顺序表查找算法的平均时间复杂度为 **O(n)**。</p></li></ul><h4 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h4><p>在顺序表中第 i 个位置之前插入一个元素 e，需要从最后一个元素开始，<strong>后移一位</strong>，直到把第 i 个元素也后移一位，然后把 e 放入第 i 个位置。</p><ol><li>注意判断位置i是否合法（<strong>1≤i≤L.length+1</strong>）。</li><li>注意判断顺序表的存储空间是否已满。</li><li>将第 L.length 至第 i 个元素<strong>依次向后移动一个位置</strong>，空出第 i 个位置并放入新元素。</li><li>注意表长加一。</li><li><strong>时刻注意位序和下标的关系！</strong></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//i值不合法</span><span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span>Maxsize<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//存储空间已满</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>       L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//从最后一个元素开始后移，直到第i个元素后移</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span>              <span class="token comment">//将新元素e放入第i个位置</span>L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">//表长增1</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="算法复杂度分析：-1"><a href="#算法复杂度分析：-1" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h5><p>可以在第 1 个位置之前插入，也可以在第 2 个位置之前……第 n 个位置之前，第 n+1 个位置之前插入，一共有 n+1 种情况，每种情况移动元素的个数是 n−i+1。把每种情况移动次数乘以其插入概率 p i 并求和，即为平均时间复杂度。如果插入概率均等，即每个位置的插入概率均为 1&#x2F;(n+1)，则平均时间复杂度为：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906161747867.png" alt="image-20220906161747867"></p><p>因此，假设每个位置插入的概率均等，顺序表插入算法平均时间复杂度为 **O(n)**。</p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><p>在顺序表中删除第 i 个元素，需要把该元素暂存到变量 e 中，然后从 i+1 个元素<strong>开始前移.</strong>…..直到把第 n 个元素也前移一位，即可完成删除操作。</p><ol><li>注意判断位置i是否合法（<strong>1≤i≤L.length+1</strong>）。</li><li>将欲删除的元素保存在 e 中。</li><li>将第 i+1 至第 n 个元素<strong>依次向前移动一个位置</strong>。</li><li>注意表长减1。</li><li><strong>时刻注意位序和下标的关系！</strong></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListDelete_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//i值不合法</span>   e<span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//将欲删除的元素保留在e中</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//被删除元素之后的元素前移</span>   L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//表长减1</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="算法复杂度分析：-2"><a href="#算法复杂度分析：-2" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h5><p>顺序表元素删除一共有 n 种情况，每种情况移动元素的个数是 n−i。把每种情况移动次数乘以其删除概率 p i 并求和，即为平均时间复杂度。假设删除每个元素的概率均等，即每个元素的删除概率均为 1&#x2F;n，则平均时间复杂度为：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906162308243.png" alt="image-20220906162308243"></p><p>因此，假设每个元素删除的概率均等，顺序表删除算法平均时间复杂度为 **O(n)**。</p><h3 id="顺序表的优点和缺点："><a href="#顺序表的优点和缺点：" class="headerlink" title="顺序表的优点和缺点："></a>顺序表的优点和缺点：</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>操作简单，存储密度高，<strong>可以随机存取</strong>，只需要 O(1)的时间就可以取出第 i 个元素。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>需要预先分配最大空间，最大空间数估计过大或过小会造成空间浪费或溢出。<strong>插入和删除操作需要移动大量元素</strong>。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>可以给每个元素附加一个指针域，指向下一个元素的存储位置，如图所示：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906165619151.png" alt="image-20220906165619151"></p><p>每个节点包含两个域：<strong>数据域</strong>和<strong>指针域</strong>。<strong>数据域存储数据元素，指针域存储下一个节点的地址</strong>，因此指针指向的类型也是节点类型。每个指针都指向下一个<br>节点，都是朝一个方向的，这样的链表称为单向链表或单链表。</p><p>只要给这个单链表设置一个头指针，这个链表中的每个节点就都可以找到了。有时为了操作方便，还会给链表增加一个不存放数据的头节点（也可以存放表长等信<br>息）。</p><h4 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h4><ol><li>创建头节点，<strong>令其指针域为空</strong>。</li><li>注意判断生成节点失败的情况。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//结点的数据域</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//结点的指针域</span><span class="token punctuation">&#125;</span>LNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span> <span class="token comment">//LinkList为指向结构体LNode的指针类型</span><span class="token keyword">bool</span> <span class="token function">InitList_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//构造一个空的单链表L</span><span class="token punctuation">&#123;</span>    L<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span>     <span class="token comment">//生成新结点作为头结点，用头指针L指向头结点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//生成结点失败</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">//头结点的指针域置空</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建：-1"><a href="#创建：-1" class="headerlink" title="创建："></a>创建：</h4><h5 id="头插法："><a href="#头插法：" class="headerlink" title="头插法："></a>头插法：</h5><blockquote><p>头插法是指每次把新节点插到头节点之后，<strong>其创建的单链表和数据输入顺序正好相反</strong>，因此也称为逆序建表。</p></blockquote><ol><li><p>初始化链表后，创建新节点，把元素1放入新节点数据域：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906170511493.png" alt="image-20220906170511493"></p></li><li><p>头插操作，插入 头节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906170546723.png" alt="image-20220906170546723"></p></li><li><p>同理插入元素2，插入头节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906170601300.png" alt="image-20220906170601300"></p><blockquote><p>赋值语句的两端：<strong>等号的右侧是节点的地址</strong>，<strong>等号的左侧是节点的指针域</strong>。</p></blockquote><ol><li>s-&gt;next&#x3D;L-&gt;next：L-&gt;next 存储的是下一个节点地址“9630”，将该地址赋值给 s-&gt;next指针域，即 s 节点的 next 指针指向 1 节点。</li><li>L-&gt;next&#x3D;s：将 s 节点的地址“2046”赋值给 L-&gt;next 指针域，即 L 节点的 next 指针指向 s 节点。</li></ol><p><strong>为什么要先修改后面那个指针呢？</strong></p><p>因为一旦修改了 L 节点的指针域指向 s，那么原来 L 节点后面的节点就找不到了，因此修改指针是有顺序的。</p><blockquote><p>修改指针的顺序原则：<strong>先修改没有指针标记的那一端</strong></p></blockquote><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906171402128.png" alt="image-20220906171402128"></p><p>如果要插入节点的两端都有标记，例如，再定义一个指针 q 指向 L 节点后面的节点，那么先修改哪个指针都无所谓了：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906171436712.png" alt="image-20220906171436712"></p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CreateList_H</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//前插法创建单链表</span><span class="token punctuation">&#123;</span><span class="token comment">//输入n个元素的值，建立到头结点的单链表L</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>LinkList s<span class="token punctuation">;</span> <span class="token comment">//定义一个指针变量</span>L<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//先建立一个带头结点的空链表</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入元素个数n："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入n个元素："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"前插法创建单链表..."</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>s<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span> <span class="token comment">//生成新结点s</span>cin<span class="token operator">>></span>s<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//输入元素值赋给新结点的数据域</span>s<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span>L<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//将新结点s插入到头结点之后</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="尾插法："><a href="#尾插法：" class="headerlink" title="尾插法："></a>尾插法：</h5><blockquote><p>尾插法每次把新节点链接到链表的尾部，<strong>其创建的单链表和数据输入顺序一致</strong>。</p></blockquote><ol><li><p>初始化链表后，创建新节点，把元素1放入新节点数据域并插入到尾结点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906201103508.png" alt="image-20220906201103508"></p><ol><li>s-&gt;next&#x3D;NULL：s 节点的指针域置空。</li><li>r-&gt;next&#x3D;s：将 s 节点的地址赋值给 r 节点的指针域，即将新节点 s 插入尾节点 r 之后。</li><li>r&#x3D;s：将 s 节点的地址赋值给 r，即 r 指向新的尾节点 s。</li></ol></li><li><p>输入数据元素 2，创建新节点，把元素 2 放入新节点数据域，插入到尾节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906201742129.png" alt="image-20220906201742129"></p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CreateList_R</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//尾插法创建单链表</span><span class="token punctuation">&#123;</span><span class="token comment">//输入n个元素的值，建立带表头结点的单链表L</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>LinkList s<span class="token punctuation">,</span> r<span class="token punctuation">;</span>L<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//先建立一个带头结点的空链表</span>r<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//尾指针r指向头结点</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入元素个数n："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入n个元素："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"尾插法创建单链表..."</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>s<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span><span class="token comment">//生成新结点</span>cin<span class="token operator">>></span>s<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//输入元素值赋给新结点的数据域</span>s<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>r<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment">//将新结点s插入尾结点*r之后</span>r<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment">//r指向新的尾结点s</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取值：-1"><a href="#取值：-1" class="headerlink" title="取值："></a>取值：</h4><p>单链表的取值不像顺序表那样可以随机访问任何一个元素，单链表只有头指针，各个节点的物理地址是不连续的。</p><blockquote><p>要想找到第 i 个节点，就必须<strong>从第一个节点开始按顺序向后找</strong>，一直找到第 i 个节点。</p></blockquote><blockquote><p>注意：<strong>链表的头指针不可随意改动！</strong>一个链表是由头指针来标识的，一旦头指针改动或丢失，这个链表就不完整或找不到了。如果需要用指针移动，可定义一个指针变量进行移动。</p></blockquote><ol><li><p>先定义一个 p 指针，指向第一个元素节点，用 j 作为计数器，j&#x3D;1。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906203132220.png" alt="image-20220906203132220"></p></li><li><p>如果 p 不为空且 j&lt;i，则 p 指向 p 的下一个节点，然后 j 加 1，即：p&#x3D;p-&gt;next; j++。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906203150910.png" alt="image-20220906203150910"></p></li><li><p>直到 p 为空或者 j&#x3D;i 停止。p 为空，说明没有数到 i，链表就结束了，即不存在第 i个节点；j&#x3D;i，说明找到了第 i 个节点。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906203203024.png" alt="image-20220906203203024"></p></li><li><p>如果i值不合法，也需要进行判断。</p></li><li><p><strong>注意每一步的条件因素</strong>。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">GetElem_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token comment">//单链表的取值</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中查找第i个元素</span><span class="token comment">//用e记录L中第i个数据元素的值</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>LinkList p<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//p指向第一个结点，</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//j为计数器</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">)</span> <span class="token comment">//顺链域向后扫描，直到p指向第i个元素或p为空</span>    <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向下一个结点</span>j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//计数器j相应加1</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//i值不合法i＞n或i&lt;=0</span>e<span class="token operator">=</span>p<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//取第i个结点的数据域</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找：-1"><a href="#查找：-1" class="headerlink" title="查找："></a>查找：</h4><p>在一个单链表中查找是否存在元素 e，可以定义一个 p 指针，指向第一个元素节点，比较 p 指向节点的数据域是否等于 e。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">LocateElem_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token comment">//按值查找</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中查找值为e的元素</span>LinkList p<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>p<span class="token operator">-></span>data<span class="token operator">!=</span>e<span class="token punctuation">)</span><span class="token comment">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向下一个结点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//查找失败p为NULL</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入：-1"><a href="#插入：-1" class="headerlink" title="插入："></a>插入：</h4><p>如果要在第 i 个节点之前插入一个元素，则必须先找到第 i−1 个节点。</p><blockquote><p>单链表只有一个指针域，是向后操作的，不可以向前操作。<strong>如果直接找到第 i 个节点，就无法向前操作，把新节点插入第 i 个节点之前</strong>。</p></blockquote><p>实际上，在第 i 个节点之前插入一个元素相当于在第 i−1 个节点之后插入一个元素，因此先找到第 i−1 个节点，然后将新节点插在其后面即可。</p><ol><li><p>定义一个 p 指针，指向头节点，用 j 作为计数器，<strong>j&#x3D;0</strong>。</p></li><li><p>如果 p 不为空且 j&lt;i−1，则 p 指向 p 的下一个节点，然后 j 加 1，即：p&#x3D;p-&gt;next; j++。</p></li><li><p>直到 p 为空或 j &gt;&#x3D;i−1 停止。</p></li><li><p>p 为空，说明没有数到 i−1，链表就结束了，即 i＞n+1，i 值不合法；j &gt;i−1 说明 i＜1，此时 i 值不合法，返回 false。如果 j&#x3D;i−1，说明找到了第 i−1 个节点。</p></li><li><p>将新节点插到第 i−1 个节点之后。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906204151314.png" alt="image-20220906204151314"></p><ol><li>s-&gt;next&#x3D;p-&gt;next：将 p 节点后面的节点地址赋值给 s 节点的指针域，即 s 节点的 next 指针指向 p 后面的节点。</li><li>p-&gt;next&#x3D;s：将 s 节点的地址赋值给 p 节点的指针域，即 p 节点的 next 指针指向 s 节点。</li></ol><p>前面讲的前插法建链表，就是每次将新节点插到头节点之后，现在是将新节点插到第 i−1 个节点之后。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListInsert_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token comment">//单链表的插入</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中第i个位置插入值为e的新结点</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>LinkList p<span class="token punctuation">,</span>s<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//查找第i-1个结点，p指向该结点</span>    <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">></span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//i＞n+1或者i＜1</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>s<span class="token operator">=</span><span class="token keyword">new</span> LNode<span class="token punctuation">;</span>     <span class="token comment">//生成新结点</span>s<span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>       <span class="token comment">//将新结点的数据域置为e</span>s<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//将新结点的指针域指向结点ai</span>p<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>       <span class="token comment">//将结点p的指针域指向结点s</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除：-1"><a href="#删除：-1" class="headerlink" title="删除："></a>删除：</h4><p>删除一个节点，实际上是把这个节点跳过去。根据单向链表向后操作的特性，要想跳过第 i 个节点，就<strong>必须先找到第 i−1 个节点</strong>，否则是无法跳过去的。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220906204522573.png" alt="image-20220906204522573"></p><ul><li>注意保存被删节点。</li><li>注意释放空间。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListDelete_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">//单链表的删除</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中，删除第i个位置</span>LinkList p<span class="token punctuation">,</span> q<span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//查找第i?1个结点，p指向该结点</span><span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>j<span class="token operator">></span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//当i>n或i&lt;1时，删除位置不合理</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>q<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">//临时保存被删结点的地址以备释放空间</span>p<span class="token operator">-></span>next<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//改变删除结点前驱结点的指针域</span><span class="token keyword">delete</span> q<span class="token punctuation">;</span>        <span class="token comment">//释放被删除结点的空间</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双向链表："><a href="#双向链表：" class="headerlink" title="双向链表："></a>双向链表：</h3><p>单链表只能向后操作，不可以向前操作。为了向前、向后操作方便，可以给每个元素附加两个指针域，一个存储前一个元素的地址，另一个存储下一个元素的地址。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909215632955.png" alt="image-20220909215632955"></p><h4 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h4><ol><li>创建头节点，不存储数据。</li><li>令头节点前后两个指针域均为空。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DuLNode</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//结点的数据域</span><span class="token keyword">struct</span> <span class="token class-name">DuLNode</span> <span class="token operator">*</span>prior<span class="token punctuation">,</span><span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//结点的指针域</span><span class="token punctuation">&#125;</span>DuLNode<span class="token punctuation">,</span><span class="token operator">*</span>DuLinkList<span class="token punctuation">;</span> <span class="token comment">//LinkList为指向结构体LNode的指针类型</span><span class="token keyword">bool</span> <span class="token function">InitDuList_L</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//构造一个空的双向链表L</span><span class="token punctuation">&#123;</span>    L<span class="token operator">=</span><span class="token keyword">new</span> DuLNode<span class="token punctuation">;</span>     <span class="token comment">//生成新结点作为头结点，用头指针L指向头结点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token comment">//生成结点失败</span>L<span class="token operator">-></span>prior<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">//头结点的两个指针域置空</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建：-2"><a href="#创建：-2" class="headerlink" title="创建："></a>创建：</h4><h5 id="头插法：-1"><a href="#头插法：-1" class="headerlink" title="头插法："></a>头插法：</h5><ol><li><p>将新节点插入到头节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909220959282.png" alt="image-20220909220959282"></p></li><li><p>创建新节点并继续插入到头节点的后面：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909221129893.png" alt="image-20220909221129893"></p><ol><li><p>s-&gt;next&#x3D;L-&gt;next：将 L 节点后面的节点（后继）地址赋值给 s 节点的指针域，即 s 节点的 next 指针指向 L 的后继节点。</p></li><li><p>L-&gt;next-&gt;prior&#x3D;s：将 s 节点的地址赋值给 L 的后继节点的 prior 指针域，即 L 的后继节点的 prior 指针指向 s 节点。<br><strong>注意这一步要先判断L-next是否为null。</strong></p></li><li><p>s-&gt;prior&#x3D;L：将 L 节点的地址赋值给 s 节点的 prior 指针域，即 s 节点的 prior 指针指向 L 节点。</p></li><li><p>L-&gt;next&#x3D;s：将 s 节点的地址赋值给 L 节点的指针域，即 L 节点的 next 指针指向 s 节点。</p><blockquote><p><strong>实际上，只需要将④语句放在最后修改即可，①②③语句顺序无要求。</strong></p></blockquote></li></ol></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CreateDuList_H</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//前插法创建双向链表</span><span class="token punctuation">&#123;</span><span class="token comment">//输入n个元素的值，建立到头结点的单链表L</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>DuLinkList s<span class="token punctuation">;</span> <span class="token comment">//定义一个指针变量</span>L<span class="token operator">=</span><span class="token keyword">new</span> DuLNode<span class="token punctuation">;</span>L<span class="token operator">-></span>prior<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//先建立一个带头结点的空链表</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入元素个数n："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"请依次输入n个元素："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"前插法创建单链表..."</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>s<span class="token operator">=</span><span class="token keyword">new</span> DuLNode<span class="token punctuation">;</span> <span class="token comment">//生成新结点s</span>cin<span class="token operator">>></span>s<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//输入元素值赋给新结点的数据域</span><span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>next<span class="token punctuation">)</span>            L<span class="token operator">-></span>next<span class="token operator">-></span>prior<span class="token operator">=</span>s<span class="token punctuation">;</span>        s<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span>        s<span class="token operator">-></span>prior<span class="token operator">=</span>L<span class="token punctuation">;</span>        L<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//将新结点s插入到头结点之后</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="尾插法：-1"><a href="#尾插法：-1" class="headerlink" title="尾插法："></a>尾插法：</h5><p>尾插法建双向链表和尾插法建单链表类似，需要有一个尾指针，不再赘述。</p><h4 id="取值：-2"><a href="#取值：-2" class="headerlink" title="取值："></a>取值：</h4><p>双向链表的取值、查找和单链表的一样，此处不再赘述。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">GetElem_L</span><span class="token punctuation">(</span>DuLinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token comment">//双向链表的取值</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的双向链表L中查找第i个元素</span><span class="token comment">//用e记录L中第i个数据元素的值</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>DuLinkList p<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//p指向第一个结点，</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//j为计数器</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">)</span> <span class="token comment">//顺链域向后扫描，直到p指向第i个元素或p为空</span>    <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向下一个结点</span>j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//计数器j相应加1</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//i值不合法i＞n或i&lt;=0</span>e<span class="token operator">=</span>p<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment">//取第i个结点的数据域</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找：-2"><a href="#查找：-2" class="headerlink" title="查找："></a>查找：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">LocateElem_L</span><span class="token punctuation">(</span>DuLinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token comment">//按值查找</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的双向链表L中查找值为e的元素</span>DuLinkList p<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>p<span class="token operator">-></span>data<span class="token operator">!=</span>e<span class="token punctuation">)</span><span class="token comment">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向下一个结点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//查找失败p为NULL</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入：-2"><a href="#插入：-2" class="headerlink" title="插入："></a>插入：</h4><p>双向链表因为有两个指针，可以向前后两个方向操作，<strong>直接找到第 i 个节点，就可以把新节点插入第 i 个节点之前。</strong></p><blockquote><p>注意：这里假设第 i 个节点是存在的，如果第 i 个节点不存在，而第 i−1 个节点存在，还是需要找到第 i−1 个节点，将新节点插入第 i−1 个节点之后，</p></blockquote><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909223237857.png" alt="image-20220909223237857"></p><ol><li>p-&gt;prior-&gt;next&#x3D;s：s 节点的地址赋值给 p 的前驱节点的 next 指针域，即 p 的前驱的next 指针指向 s。</li><li>s-&gt;prior&#x3D;p-&gt;prior：p 的前驱的地址赋值给 s 节点的 prior 指针域，即 s 节点的 prior 指针指向 p 的前驱。</li><li>s-&gt;next&#x3D;p：p 节点的地址赋值给 s 节点的 next 指针域，即 s 节点的 next 指针指向 p 节点。</li><li>p-&gt;prior&#x3D;s：s 节点的地址赋值给 p 节点的 prior 指针域，即 p 节点的 prior 指针指向 s 节点。</li></ol><p>因为 p 的前驱无标记，<strong>一旦修改了 p 节点的 prior 指针，p 的前驱就找不到了</strong>，因此，最后修改这个指针。只需要将④语句放在最后修改即可，①②③语句顺序无要求。</p><blockquote><p><strong>原则：先修改没有指针标记的那一端。</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListInsert_L</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token comment">//双向链表的插入</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的单链表L中第i个位置之前插入值为e的新结点</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>DuLinkList p<span class="token punctuation">,</span> s<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span> <span class="token comment">//查找第i个结点，p指向该结点</span>    <span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token comment">//i＞n+1或者i＜1</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>s<span class="token operator">=</span><span class="token keyword">new</span> DuLNode<span class="token punctuation">;</span>     <span class="token comment">//生成新结点</span>s<span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>       <span class="token comment">//将新结点的数据域置为e</span>p<span class="token operator">-></span>prior<span class="token operator">-></span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>s<span class="token operator">-></span>prior<span class="token operator">=</span>p<span class="token operator">-></span>prior<span class="token punctuation">;</span>s<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>p<span class="token operator">-></span>prior<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除：-2"><a href="#删除：-2" class="headerlink" title="删除："></a>删除：</h4><p>双向链表只要直接找到第 i 个节点，然后修改指针即可：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220909224117840.png" alt="image-20220909224117840"></p><ol><li><p>p-&gt;prior-&gt;next&#x3D;p-&gt;next：将 p 的后继节点的地址赋值给 p 的前驱节点的 next 指针域。即 p 的前驱节点的 next 指针指向 p 的后继节点。</p></li><li><p>p-&gt;next-&gt;prior &#x3D;p-&gt;prior：将 p 的前驱节点的地址赋值给 p 的后继节点的 prior 指针域，即 p 的后继节点的 prior 指针指向 p 的前驱节点。此项修改的前提是 p 的后继节点存在，如果不存在，则不需要此项修改。</p><blockquote><p>删除节点修改指针没有顺序，先修改哪个都可以。</p></blockquote></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ListDelete_L</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">//双向链表的删除</span><span class="token punctuation">&#123;</span><span class="token comment">//在带头结点的双向链表L中，删除第i个位置</span>DuLinkList p<span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>p<span class="token operator">=</span>L<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//查找第i个结点，p指向该结点</span><span class="token punctuation">&#123;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span><span class="token punctuation">(</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//当i>n或i&lt;1时，删除位置不合理</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token comment">//如果p的直接后继结点存在</span>        p<span class="token operator">-></span>next<span class="token operator">-></span>prior<span class="token operator">=</span>p<span class="token operator">-></span>prior<span class="token punctuation">;</span>p<span class="token operator">-></span>prior<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span>        <span class="token comment">//释放被删除结点的空间</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环链表："><a href="#循环链表：" class="headerlink" title="循环链表："></a>循环链表：</h3><p>如果从当前节点开始，无法访问该节点前面的节点，而最后一个节点的指针指向头节点，形成一个环，就可以从任何一个节点出发，访问所有的节点，这就是循环链表。</p><blockquote><p>循环链表和普通链表的区别就是最后一个节点的后继指向了头节点，还要让头节点的前驱指向最后一个节点。</p></blockquote><h3 id="链表的优点和缺点："><a href="#链表的优点和缺点：" class="headerlink" title="链表的优点和缺点："></a>链表的优点和缺点：</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>链表是动态存储，不需要预先分配最大空间；<strong>插入删除不需要移动元素</strong>。</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>每次动态分配一个节点，每个节点的地址是不连续的，需要有指针域记录下一个节点的地址，指针域需要占用一个 int 的空间，因此<strong>存储密度低</strong>（数据所占空间&#x2F;节点所占总空间）。</p><p><strong>存取元素必须从头到尾按顺序查找，属于顺序存取。</strong></p><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="合并有序顺序表："><a href="#合并有序顺序表：" class="headerlink" title="合并有序顺序表："></a>合并有序顺序表：</h3><p><strong>题目：</strong>将两个有序（非递减）顺序表 La 和 Lb 合并为一个新的有序（非递减）顺序表。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol><li>首先创建一个顺序表 Lc，其长度为 La 和 Lb 的长度之和。</li><li>然后从 La 和 Lb 中分别取数，比较其大小，将较小者放入 Lc 中，一直进行下去，直到其中一个顺序表 La 或 Lb 中的数取完为止。</li><li>把未取完的数再依次取出放入 Lc 中即可。</li></ol><h4 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h4><ol><li><p>设置 3 个工作指针：i、j、k（其实是整型数）。其中，i 和 j 分别指向 La 和 Lb 中当前待比较的元素，k 指向 Lc 中待放置元素的位置</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220910095920854.png" alt="image-20220910095920854"></p></li><li><p>比较 La.elem[i]和 Lb.elem[j]，将较小的赋值给 Lc.elem[k]，同时相应指针向后移动。如此反复，直到顺序表 La 或 Lb 中的数取完为止。</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220910100100150.png" alt="image-20220910100100150"></p></li><li><p>把 La 或 Lb中未取完的数依次取出，放入 Lc 中即可</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"sqlist.h"</span><span class="token comment">//引入自定义头文件,源码目录下名为sqlist.h的文件 </span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">MergeSqlist</span><span class="token punctuation">(</span>SqList La<span class="token punctuation">,</span>SqList Lb<span class="token punctuation">,</span>SqList <span class="token operator">&amp;</span>Lc<span class="token punctuation">)</span><span class="token comment">//顺序有序表的合并</span><span class="token punctuation">&#123;</span><span class="token comment">//已知顺序有序表La和Lb的元素按值非递减排列</span><span class="token comment">//La和Lb合并得到新的顺序有序表Lc，Lc的元素也按值非递减排列</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>i<span class="token operator">=</span>j<span class="token operator">=</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Lc<span class="token punctuation">.</span>length<span class="token operator">=</span>La<span class="token punctuation">.</span>length<span class="token operator">+</span>Lb<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">//新表长度为待合并两表的长度之和</span>Lc<span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>Lc<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//为合并后的新表分配一段空间</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>La<span class="token punctuation">.</span>length<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>Lb<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//两个表都非空</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>La<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>Lb<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//依次取出两表中值较小放入到Lc表中</span>Lc<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>La<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">else</span>Lc<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>Lb<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>La<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//La有剩余，依次将La的剩余元素插入Lc表的最后</span>Lc<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>La<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>Lb<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//Lb有剩余，依次将Lb的剩余元素插入Lc表的最后</span>Lc<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>Lb<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-3"><a href="#算法复杂度分析：-3" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>合并操作需要将 La 和 Lb 中的每一个元素取出放入 Lc 中，如果 La 和 Lb 的长度分别为 m、n，那么合并操作时间复杂度为 O(m+n) 空间复杂度也为 O(m+n)</p><h3 id="合并有序链表："><a href="#合并有序链表：" class="headerlink" title="合并有序链表："></a>合并有序链表：</h3><p><strong>题目：</strong>将两个有序（非递减）单链表 La 和 Lb 合并为一个新的有序（非递减）单链表。</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>链表合并不需要再创建空间，只需要“穿针引线”，把两个单链表中的节点按非递减的顺序串联起来即可。</p><blockquote><p>注意：单链表的头指针不可以移动，一旦头指针丢失，就找不到该单链表了，因此需要辅助指针。</p></blockquote><h4 id="解题：-1"><a href="#解题：-1" class="headerlink" title="解题："></a>解题：</h4><ol><li><p>设置 3 个辅助指针 p、q、r，p 和 q 分别指向 La 和 Lb 链表的当前比较位置，新链表头指针 Lc 指向 La，当作合并后的头节点。r 指向 Lc 的当前最后一个节点，利用 r 指针“穿针引线”：</p><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-xian-xing-biao/image-20220910102955699.png" alt="image-20220910102955699"></p></li><li><p>穿针引线。比较元素大小，将较小元素用 r 指针串起来。</p></li><li><p>第 1 次比较，p-&gt;data&#x3D;4 &gt; q-&gt;data&#x3D;2，用 r 指针将 q 节点串起来。串联剩余部分，直到其中一个指针为空。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">r<span class="token operator">-></span>next<span class="token operator">=</span>q<span class="token punctuation">;</span> <span class="token comment">//把 q 节点的地址赋值给 r 的 next 指针域，即 r 的 next 指针指向 q</span>r<span class="token operator">=</span>q<span class="token punctuation">;</span> <span class="token comment">//r 指针指向 Lc 的当前尾节点</span>q<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//q 指针向后移动，等待处理下一个节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>若 p 指针不为空，用 r 指针将 p 串连起来，即 r-&gt;next&#x3D;p;。注意这里只是把这个指针连上即可，剩余的节点不需要再处理。释放 Lb 节点空间，即 delete Lb。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mergelinklist</span><span class="token punctuation">(</span>LinkList La<span class="token punctuation">,</span>LinkList Lb<span class="token punctuation">,</span>LinkList <span class="token operator">&amp;</span>Lc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">,</span>r<span class="token punctuation">;</span>    p<span class="token operator">=</span>La<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向La的第一个元素</span>    q<span class="token operator">=</span>Lb<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//q指向Lb的第一个元素</span>    Lc<span class="token operator">=</span>La<span class="token punctuation">;</span>      <span class="token comment">//Lc指向La的头结点</span>    r<span class="token operator">=</span>Lc<span class="token punctuation">;</span>       <span class="token comment">//r指向Lc的尾部</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>q<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token operator">&lt;=</span>q<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token comment">//把p指向的结点串起来</span>        <span class="token punctuation">&#123;</span>            r<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>            r<span class="token operator">=</span>p<span class="token punctuation">;</span>            p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>             <span class="token comment">//把q指向的结点串起来</span>        <span class="token punctuation">&#123;</span>            r<span class="token operator">-></span>next<span class="token operator">=</span>q<span class="token punctuation">;</span>            r<span class="token operator">=</span>q<span class="token punctuation">;</span>            q<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">?</span>p<span class="token operator">:</span>q<span class="token punctuation">;</span><span class="token comment">//相当于if(p) r->next=p; else r->next=q;</span>    <span class="token keyword">delete</span> Lb<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-4"><a href="#算法复杂度分析：-4" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>链表合并不需要再创建空间，只需要穿针引线，把两个单链表中的节点按非递减的顺序串联起来即可。因此在最坏的情况下，需要串联每一个节点，如果 La 和 Lb 的长度分别为 m、n 时间复杂度为 O(m+n) 空间复杂度为 O(1)</p><h3 id="就地逆置单链表："><a href="#就地逆置单链表：" class="headerlink" title="就地逆置单链表："></a>就地逆置单链表：</h3><p><strong>题目：</strong>将带有头节点的单链表就地逆置。即元素的顺序逆转，而辅助空间复杂度为 O(1)。</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>头插法创建单链表得到的序列正好是逆序，那么我们就利用<strong>头插法建表</strong>的思路，实现就地逆置。</p><blockquote><p>注意：在修改指针之前，一定要用一个辅助指针记录断点，否则后面这一部分就会遗失，再也找不到了。</p></blockquote><h4 id="解题：-2"><a href="#解题：-2" class="headerlink" title="解题："></a>解题：</h4><ol><li><p>首先用 p 指针指向第一个元素节点，然后将头节点的 next 域置空。</p></li><li><p>将 p 节点用头插法插入链表 L 中，插入之前用 q 指针记录断点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">q<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// q 指向 p 的下一个节点，记录断点</span>p<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//将 L 的下一个节点地址赋值给 p 的 next 域</span>L<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//将 p 节点地址赋值给 L 的 next 域</span>p<span class="token operator">=</span>q<span class="token punctuation">;</span> <span class="token comment">//p 指向 q</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>p 指针为空，算法停止，单链表就地逆置完毕。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reverselinklist</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p指向L的第一个元素</span>    L<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//头结点的next域置空：</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//q指向p的下一个结点，记录断点；</span>        p<span class="token operator">-></span>next<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//头插法，将L的下一个结点地址赋值给p的next域</span>        L<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//将p结点地址赋值给L的next域</span>        p<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token comment">//指针后移，p指向q；</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-5"><a href="#算法复杂度分析：-5" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n) 没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)</p><h3 id="查找链表的中间节点："><a href="#查找链表的中间节点：" class="headerlink" title="查找链表的中间节点："></a>查找链表的中间节点：</h3><p><strong>题目：</strong>带有头节点的单链表 L，设计一个尽可能高效的算法求 L 中的中间节点。</p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>此类题型可以使用快慢指针来解决。一个快指针，一个慢指针，快指针走两步，慢指针走一步。当快指针指向结尾的时候，慢指针刚好指向中间节点。</p><h4 id="解题：-3"><a href="#解题：-3" class="headerlink" title="解题："></a>解题：</h4><p>放置两个小青蛙，一个跳得远，一次走两块石头；一个跳得近，一次走一块石头。当快青蛙走到终点时，慢青蛙正好走到中间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LinkList <span class="token function">findmiddle</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    p<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//p为快指针，初始时指向L</span>    q<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//q为慢指针，初始时指向L</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">-></span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//p为快指针一次走两步；</span>        q<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//q为慢指针一次走一步</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token comment">//返回中间结点指针</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-6"><a href="#算法复杂度分析：-6" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n) 没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)</p><h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>如何在单链表中查找倒数第 k 个节点？</p><p>仍然可以使用快慢指针，慢指针不要动，快指针先走 <strong>k−1</strong> 步，然后<strong>两个指针一起以同样的速度走</strong>。当快指针走到终点时，慢指针正好停留在倒数第 k 个节点，为什么呢？<br><strong>因为它们之间的距离始终保持 k−1。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LinkList <span class="token function">findk</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    p<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p为快指针，初始时指向第一个数据结点</span>    q<span class="token operator">=</span>L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//q为慢指针，初始时指向第一个数据结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>k<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//k减到0时，慢指针开始走</span>            q<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//q为慢指针</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//p为快指针，先走 k - 1步；</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token comment">//返回中间结点指针</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-7"><a href="#算法复杂度分析：-7" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n) 没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)</p><p>用快慢指针还可以解决很多问题，例如判断链表是否有环，判断两个链表是否相交等。</p><h3 id="删除链表中的重复元素："><a href="#删除链表中的重复元素：" class="headerlink" title="删除链表中的重复元素："></a>删除链表中的重复元素：</h3><p><strong>题目：</strong>用单链表保存 m 个整数，节点的结构为(data,next)，且|data|≤n(n 为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的节点。</p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>本题数据大小有范围限制，因此可以设置一个辅助数组记录该数据是否已出现，如果已出现，则删除；如果未出现，则标记。一趟扫描即可完成。</p><h4 id="解题：-4"><a href="#解题：-4" class="headerlink" title="解题："></a>解题：</h4><ol><li>设置一个辅助数组 flag[]，因为 n 为正整数，不包括 0，所以 0 空间不用。需要分配 n+1 个辅助空间，初始化时都为 0，表示这些数还未出现过，</li><li>设置 p 指针指向头节点，检查第一个数据元素是否已出现过。令 x&#x3D;abs(p-&gt;next-&gt;data)，如果已出现过（flag[x]&#x3D;1），则删除该节点；如果该节点数据元素未出现过，则标记 flag[x]&#x3D;1，p 指针向后移动，直到处理完毕。</li><li>abs(p-&gt;next-&gt;data)&#x3D;5，读取 flag[5]&#x3D;0，说明该节点数据元素未出现过，标记 flag[5]&#x3D;1，p 指针向后移动。</li><li>p-&gt;next 为空，算法停止。对于链表中 data 的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的节点。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Deleterep</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token comment">//删除重复元素</span><span class="token punctuation">&#123;</span>    LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>flag<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//定义flag数组，分配n+1个空间</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//初始化</span>        flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    p<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//指向头结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        x<span class="token operator">=</span><span class="token function">abs</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//未出现过</span>        <span class="token punctuation">&#123;</span>            flag<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//标记出现</span>            p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>           <span class="token comment">//指针后移</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            q<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>            p<span class="token operator">-></span>next<span class="token operator">=</span>q<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//删除重复元素</span>            <span class="token keyword">delete</span> q<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>flag<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法复杂度分析：-8"><a href="#算法复杂度分析：-8" class="headerlink" title="算法复杂度分析："></a>算法复杂度分析：</h4><p>根据题意，单链表中保存 m 个绝对值小于等于 n 的整数，因此链表元素个数为 m，算法从头到尾扫描了一遍链表，时间复杂度为 O(m) 采用了辅助数组 flag[]，因为 n 为正整数，不包括 0，所以 0 空间不用，需要分配 n+1 个辅助空间，因此空间时间复杂度为 O(n)</p><h2 id="线性表学习技巧"><a href="#线性表学习技巧" class="headerlink" title="线性表学习技巧"></a>线性表学习技巧</h2><h3 id="顺序表和链表的比较："><a href="#顺序表和链表的比较：" class="headerlink" title="顺序表和链表的比较："></a>顺序表和链表的比较：</h3><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220910113841323.png" alt="image-20220910113841323"></p><h3 id="顺序表解题技巧："><a href="#顺序表解题技巧：" class="headerlink" title="顺序表解题技巧："></a>顺序表解题技巧：</h3><ul><li><strong>位序和下标差 1，第 i 个元素的下标为 i−1。</strong></li><li><strong>交换元素、有序合并需要借助辅助空间。</strong></li><li><strong>交换元素、有序合并需要借助辅助空间。</strong></li></ul><h3 id="链表解题技巧："><a href="#链表解题技巧：" class="headerlink" title="链表解题技巧："></a>链表解题技巧：</h3><ul><li>赋值语句两端的含义：<strong>等号的右侧是节点的地址，等号的左侧是节点的指针域</strong></li><li>修改指针的顺序：<strong>先修改没有指针标记的那一端</strong></li><li>建立链表的两种方法：<strong>头插法、尾插法。头插法是逆序建表，尾插法是正序建表</strong></li><li>链表逆置、归并不需要额外空间，<strong>属于就地操作</strong>。</li><li><strong>快慢指针法</strong>：快慢指针可以解决很多问题，如链表中间节点、倒数第 k 个节点、判断链表是否有环、环的起点、公共部分的起点等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门-基础知识</title>
      <link href="/2022/09/06/shu-ju-jie-gou-ru-men-ji-chu-zhi-shi/"/>
      <url>/2022/09/06/shu-ju-jie-gou-ru-men-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构基础知识"><a href="#数据结构基础知识" class="headerlink" title="数据结构基础知识"></a>数据结构基础知识</h2><ol><li><p>数据</p><blockquote><p>数据是指所有能输入到计算机中的描述客观事物的符号，包括文本、声音、图像、符号等。</p></blockquote></li><li><p>数据元素</p><blockquote><p>数据元素是数据的基本单位，也称节点或记录：</p></blockquote><p><img src="/2022/09/06/shu-ju-jie-gou-ru-men-ji-chu-zhi-shi/image-20220906145439200.png" alt="image-20220906145439200"></p></li><li><p>数据项</p><blockquote><p>数据项表示有独立含义的数据最小单位，也称域。若干个数据项构成一个数据元素，数据项是不可分割的最小单位，如上图所示的“86”。</p></blockquote></li><li><p>数据对象</p><blockquote><p>数据对象是指相同特性的数据元素的集合，是数据的一个子集。</p></blockquote></li><li><p>数据结构</p><blockquote><p>数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。</p><p>数据结构是带“结构”的数据元素的集合，“结构”是指数据元素之间存在的关系。</p></blockquote></li><li><p>逻辑结构与存储结构</p><blockquote><p>逻辑结构是数据元素之间的关系，存储结构是数据元素及其关系在计算机中的存储方式。</p></blockquote><ul><li><p>逻辑结构：</p><p>数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题中抽象出来的数学模型。</p><ul><li><p><strong>集合</strong></p><p>数据元素间除“同属于一个集合”外，无其他关系。集合中的元素是离散、无序的。</p></li><li><p><strong>线性结构</strong></p><p>一个对一个，如线性表、栈、队列、数组、广义表。</p><p>有<strong>唯一的开始和唯一的结束</strong>，除了第一个元素外，每个元素都有唯一的直接前驱（前面那个）；除了最后一个元素外，每个元素都有唯一的直接后继（后面那个）。</p></li><li><p><strong>树形结构</strong></p><p>一个对多个，如树。</p><p>树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支，树枝和树枝之间是不相交的。</p></li><li><p><strong>图形结构</strong></p><p>多个对多个，如图、网。</p><p>图形结构就像我们经常见到的地图，任何一个节点都可能和其他节点有关系，就像一张错综复杂的网。</p></li></ul></li><li><p>存储结构：</p><p>数据元素及其关系在计算机中的存储方式。</p><ul><li><p><strong>顺序存储</strong></p><p>顺序存储是指逻辑上相邻的元素在计算机内的存储位置也是相邻的。</p><p>顺序存储采用一段连续的存储空间，将逻辑上相邻的元素存储在连续的空间内，中间不允许有空。顺序存储可以快速定位第几个元素的地址，但是插入和删除时需要移动大量元素。</p></li><li><p><strong>链式存储</strong></p><p>链式存储是指逻辑上相邻的元素在计算机内的存储位置不一定是相邻的。</p><p>每个节点除了数据域，还有一个指针域，记录下一个元素的存储地址。</p></li><li><p><strong>散列存储</strong></p><p>散列存储，又称哈希（Hash）存储，由节点的关键码值决定节点的存储地址。用散列函数确定数据元素的存储位置与关键码之间的对应关系。</p><p>散列存储可以通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。如果有冲突，则有多种处理冲突的方法。</p></li><li><p><strong>索引存储</strong></p><p>索引存储是指除建立存储节点信息外，还建立附加的索引表来标识节点的地址。索引表由若干索引项组成。如果每个节点在索引表中都有一个索引项，则该索引表称为稠密索引。若一组节点在索引表中只对应于一个索引项，则该索引表称为稀疏索引。</p></li></ul></li></ul></li><li><p>抽象数据类型</p><blockquote><p>抽象数据类型（Abstract Data Type，ADT）是将数据对象、数据对象之间的关系和数据对象的基本操作封装在一起的一种表达方式，它和工程中的应用是一致的。</p></blockquote><p>在工程项目中，开始编程之前，首先列出程序需要完成的功能任务，先不用管具体怎么实现，实现细节在项目后期完成，一开始只是抽象出有哪些基本操作。</p><ul><li><p><strong>为什么要使用抽象数据类型？</strong></p><p>抽象数据类型的主要作用是数据封装和信息隐藏，让实现与使用相分离。数据及其相关操作的结合称为数据封装。对象可以对其他对象隐藏某些操作细节，从而使这些操作不会受到其他对象的影响，这就是信息隐藏。抽象数据类型独立于运算的具体实现，使用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，实现了<strong>信息隐藏</strong>。</p></li><li><p><strong>为什么很多书中没有使用抽象数据类型？</strong></p><p>因为很多人觉得数据结构难以理解，学习起来非常吃力，因此仅仅将数据结构的基本操作作为重点，把每一个基本操作讲解清楚，使读者学会和掌握数据结构的基本操作，便完成了数据结构书的基本任务。在实际工程中，需要根据实际情况融会贯通，灵活运用，这是后续话题。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组合API</title>
      <link href="/2022/09/02/vue-zu-he-api/"/>
      <url>/2022/09/02/vue-zu-he-api/</url>
      
        <content type="html"><![CDATA[<h1 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h1><blockquote><ul><li>组件逻辑复用</li><li>逐步应用</li><li>与<code>Options API</code>共存</li></ul></blockquote><h2 id="为什么要使用Composition-API？"><a href="#为什么要使用Composition-API？" class="headerlink" title="为什么要使用Composition API？"></a>为什么要使用Composition API？</h2><p>在使用<code>Options API</code>时，我们必须反复在不同的配置项中跳跃进行代码阅读。</p><p>而使用<code>Composition API</code>后，我们可以将组件的所有代码写在一个<code>setup()</code>函数中，在其中我们可以自由地调整代码位置，让同一功能的代码放在一起。同时我们也可以抽离其中的函数放置在单独的文件中，让组件直接使用抽离出的函数，让组件代码更加简洁。</p><h2 id="Composition-API的入口——setup-函数："><a href="#Composition-API的入口——setup-函数：" class="headerlink" title="Composition API的入口——setup()函数："></a>Composition API的入口——<code>setup()</code>函数：</h2><blockquote><p>注意：<code>setup()</code>函数只是提供了响应式组件的<strong>替代</strong>方式，例如<code>data()</code>，<code>computed()</code>，<code>methods()</code>等。像静态的components，props，emits等组件配置项，还是使用原来的方式，不过之后还是会有替代的方式。</p></blockquote><p>示例：</p><p>组件MessageList.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主文件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageList</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageList <span class="token keyword">from</span> <span class="token string">"./components/MessageList.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MessageList<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何在setup-函数中定义响应式数据？"><a href="#如何在setup-函数中定义响应式数据？" class="headerlink" title="如何在setup()函数中定义响应式数据？"></a>如何在<code>setup()</code>函数中定义响应式数据？</h3><p>Vue提供了一组用于在<code>setup()</code>函数中定义响应式数据的函数，这些响应性数据也可称为<strong>状态</strong>。</p><blockquote><p>也就是说，随着用户使用，应用的响应式数据会根据事件的发生而发生变化，从而引起组件的刷新，也就是状态的改变。</p></blockquote><h4 id="ref-函数："><a href="#ref-函数：" class="headerlink" title="ref()函数："></a><code>ref()</code>函数：</h4><p><code>ref()</code>函数接收一个参数，可以是任意类型，它会把他们包装成响应式数据，作用就是<strong>替代了<code>data()</code>配置项</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>ref<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数字</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"字符串"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//字符串</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：如果传给<code>ref()</code>函数的是一个对象，那么对象的所有属性包括嵌套的属性都会转换为响应式的属性。</p></blockquote><p><strong>在<code>setup()</code>函数中，必须通过其value属性来访问其包装的响应式数据，但和原始数值不是全相等的，原理以后再说。而在模板中不需要使用value属性来访问。</strong></p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>messages = []<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>ref<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 使用ref()让其他依赖响应式数据的代码进行更新</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>messages<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="reactive-函数："><a href="#reactive-函数：" class="headerlink" title="reactive()函数："></a><code>reactive()</code>函数：</h4><blockquote><p><code>reactive()</code>函数与<code>ref()</code>函数类似，但它只接收一个<strong>对象类型</strong>的函数作为参数。这里的对象类型是广义的，包括数组。</p><p><code>reactive()</code>函数在<code>setup()</code>函数中可以直接访问，不需要使用value属性。</p><p>使用<code>ref()</code>函数时，其内部也会调用<code>reactive()</code>函数，把对象的所有属性转换为响应式数据，之后将转换后的值赋值给value属性。</p></blockquote><p>如何选择<code>ref()</code>函数和<code>reactive()</code>函数呢？</p><p>通常情况下直接使用ref()函数，因为它能直接定义基本数据，而且使用ref()函数定义的数据比较分散，所以更容易抽离成可复用的；</p><p><code>reactive()</code>函数则适用于一次性定义多个响应式数据的情况，将它们放置在一个对象中，之后通过该对象修改和访问其中的属性，适合存放组件的配置属性或表单数据。</p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; options.title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>      用户：&#123;&#123; options.user.name &#125;&#125;，活跃：&#123;&#123;        options.user.active ? "是" : "否"      &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>messages = []<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>删除全部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.title = <span class="token punctuation">'</span>这是标题<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.user.name = <span class="token punctuation">'</span>李四<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改用户<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// const messages = reactive([</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// const options = ref(&#123;</span>    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span>      <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> options <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="computed-函数："><a href="#computed-函数：" class="headerlink" title="computed()函数："></a><code>computed()</code>函数：</h4><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- v-model 可以直接绑定 ref，与 data 配置项等效 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>搜索消息<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchTerm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in searchedMessages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> computed <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> searchTerm <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> searchedMessages <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>searchTerm<span class="token punctuation">.</span>value <span class="token operator">===</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token keyword">return</span> messages<span class="token punctuation">.</span>value<span class="token punctuation">;</span>      <span class="token keyword">return</span> messages<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> msg<span class="token punctuation">.</span>content<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>searchTerm<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>searchedMessages<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> searchTerm<span class="token punctuation">,</span> searchedMessages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="watch-函数："><a href="#watch-函数：" class="headerlink" title="watch()函数："></a><code>watch()</code>函数：</h4><h5 id="监听响应式数据的变化："><a href="#监听响应式数据的变化：" class="headerlink" title="监听响应式数据的变化："></a>监听响应式数据的变化：</h5><ol><li><p>直接监听响应式数据：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">watch</span><span class="token punctuation">(</span>searchTerm<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>messages<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"搜索词："</span><span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>监听解剖后的响应式数据：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 直接监听 searchTerm 不可以</span>    <span class="token function">watch</span><span class="token punctuation">(</span>searchTerm<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"搜索词："</span><span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 需要使用一个函数</span>    <span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> searchTerm<span class="token punctuation">.</span>value<span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"搜索词："</span><span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h5 id="监听对象中基本类型的响应式属性："><a href="#监听对象中基本类型的响应式属性：" class="headerlink" title="监听对象中基本类型的响应式属性："></a>监听对象中基本类型的响应式属性：</h5><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; options.title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>      用户：&#123;&#123; options.user.name &#125;&#125;，活跃：&#123;&#123;        options.user.active ? "是" : "否"      &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.title = <span class="token punctuation">'</span>这是标题<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.user.name = <span class="token punctuation">'</span>李四<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改用户<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> reactive<span class="token punctuation">,</span> computed<span class="token punctuation">,</span> watch <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token comment">// const options = reactive(&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span>      <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 监听浅层 Object 属性</span>    <span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">,</span>      <span class="token comment">// () => options.title, // reactive</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 监听深层 Object 属性</span>    <span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">,</span>      <span class="token comment">// () => options.user.name, // reactive</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> options <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="监听对象类型的响应式属性："><a href="#监听对象类型的响应式属性：" class="headerlink" title="监听对象类型的响应式属性："></a>监听对象类型的响应式属性：</h5><blockquote><p>注意：直接监听value属性，<code>watch()</code>函数不会监听到变化。因为在监听整个对象的时候，<code>watch()</code>比较的是<strong>对象的引用</strong>，每次修改对象的属性都不会创建新的对象，而是在原对象中进行修改，所以<code>watch()</code>函数监听不到。<strong>数组同理</strong>。</p></blockquote><ol><li><p>配置<code>deep: true</code>：</p><blockquote><p>缺点：不能访问修改前的值</p></blockquote><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// with deep true，可以比对对象的属性</span>    <span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">,</span> newVal <span class="token operator">===</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相同的引用</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用扩展运算符<code>...</code>：</p><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token comment">// const options = reactive(&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span>      <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">watch</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span>options<span class="token punctuation">.</span>value <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">,</span> newVal <span class="token operator">===</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相同的引用</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> options <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只使用扩展运算符，并不会监听到子对象的值，如<code>user.name</code>。即使设置了<code>deep: true</code>，监听到的对象也是相同的引用。</p><blockquote><p>因为<code>...</code>语法创建的对象是<strong>浅拷贝</strong>，只会复制顶层的属性，子对象会原封不动的把引用传给新的对象。</p></blockquote><p>可使用JSON相关的方法进行深拷贝：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对象转为字符串再转为对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h5 id="同时监听多个响应性数据："><a href="#同时监听多个响应性数据：" class="headerlink" title="同时监听多个响应性数据："></a>同时监听多个响应性数据：</h5><p><code>watch()</code>函数支持使用数组进行监听：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 同时监听多个响应性数据</span>   <span class="token function">watch</span><span class="token punctuation">(</span>     <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">(</span><span class="token parameter">newVals<span class="token punctuation">,</span> oldVals</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVals<span class="token punctuation">,</span> oldVals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 其中的数据也是数组形式</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="watchEffect-函数："><a href="#watchEffect-函数：" class="headerlink" title="watchEffect()函数："></a><code>watchEffect()</code>函数：</h4><p><code>watchEffect()</code>和 <code>watch()</code>的作用基本一样，用于监听响应式数据的变化，并根据变化做一些业务逻辑，例如请求远程服务数据。</p><p>区别：</p><ol><li><code>watchEffect()</code>函数不用明确指定标签中的响应式数据，而是会根据回调函数中的代码<strong>自动</strong>判断。如果代码中用到了响应式数据，无论多少个，<strong>只要其中的一个发生了变化，<code>watchEffect()</code>函数就会重新执行一次。</strong></li><li><code>watchEffect()</code>函数无论数据是否发生了变化，<strong>都会先执行一次回调函数</strong>。</li><li><code>watchEffect()</code><strong>不能访问修改前的值，回调函数中的响应式的值都是修改后的</strong>。</li></ol><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; options.title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>      用户：&#123;&#123; options.user.name &#125;&#125;，活跃：&#123;&#123;        options.user.active ? "是" : "否"      &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg.content &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.title = <span class="token punctuation">'</span>这是标题<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>options.user.name = <span class="token punctuation">'</span>李四<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改用户<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watchEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token comment">// const options = reactive(&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span>      <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> options <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="watch-amp-watchEffect-清理收尾工作："><a href="#watch-amp-watchEffect-清理收尾工作：" class="headerlink" title="watch()&amp;watchEffect() 清理收尾工作："></a><code>watch()</code>&amp;<code>watchEffect()</code> 清理收尾工作：</h4><h5 id="watchEffect-函数：-1"><a href="#watchEffect-函数：-1" class="headerlink" title="watchEffect()函数："></a><code>watchEffect()</code>函数：</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">onInvalidate</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"做一些清理操作..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="watch-函数：-1"><a href="#watch-函数：-1" class="headerlink" title="watch()函数："></a><code>watch()</code>函数：</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">watch</span><span class="token punctuation">(</span>     <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> options<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title<span class="token punctuation">,</span>     <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">,</span> onInvalidate</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"做一些清理操作..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：<code>onInvalidate()</code>函数会在<strong>下次</strong>监听代码执行前执行</p></blockquote><h3 id="传递和访问Props属性："><a href="#传递和访问Props属性：" class="headerlink" title="传递和访问Props属性："></a>传递和访问Props属性：</h3><p>如果需要在<code>setup()</code>函数中访问Props属性，需要在<code>setup()</code>函数中设置<strong>参数</strong>：</p><p>示例：</p><p>子组件MessageList.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> toRefs <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件MessageListItem.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageListItem</span>        <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span>        <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.content<span class="token punctuation">"</span></span>      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageListItem</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> MessageListItem <span class="token keyword">from</span> <span class="token string">"./MessageListItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MessageListItem <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="转换非响应性props为响应性："><a href="#转换非响应性props为响应性：" class="headerlink" title="转换非响应性props为响应性："></a>转换非响应性props为响应性：</h3><p><code>setup()</code>函数中的props属性整体是响应性的，相当于使用<code>reactive()</code>或使用<code>ref()</code>创建的对象的value属性，故可以使用<code>watch()</code>或<code>watchEffect()</code>监听props中的属性变化。</p><p>但如果父组件传递给子组件的数据是非响应性的，如果使用解构语法拆解出来，那么是不会被监听到变化的，同样地类似computed()响应式属性也不会生效。</p><blockquote><p>须调用Vue中的<code>toRefs()</code>函数，之后再解构。</p></blockquote><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> toRefs <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> msg <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// const  msg = toRefs(props, 'msg');</span>    <span class="token function">watch</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newMsg</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ref-x2F-reactive创建的数据在Props中的响应性："><a href="#ref-x2F-reactive创建的数据在Props中的响应性：" class="headerlink" title="ref&#x2F;reactive创建的数据在Props中的响应性："></a>ref&#x2F;reactive创建的数据在Props中的响应性：</h3><blockquote><p>注意：如果父组件传递的数据类型为JavaScript基本类型，例如字符串、数字、布尔类型等，他们在通过属性传递后就会<strong>失去响应性</strong>，在子组件中需要使用<code>toRefs()</code>函数进行转换。</p></blockquote><blockquote><p>换言之，只有<strong>对象</strong>和<strong>数组</strong>类型的数据在传递的时候会保留其响应性。</p><p>使用<code>ref()</code>函数创建的数据在传递时，<strong>只会传递其value属性</strong>，在子组件中即为Proxy类型。</p></blockquote><h3 id="在setup-函数中定义methods："><a href="#在setup-函数中定义methods：" class="headerlink" title="在setup()函数中定义methods："></a>在<code>setup()</code>函数中定义methods：</h3><p>直接定义function：</p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>removeMessage(id)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>删除<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> toRefs <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 无参数</span>    <span class="token comment">// function removeMessage() &#123;</span>    <span class="token comment">//   console.log("删除消息");</span>    <span class="token comment">// &#125;</span>    <span class="token comment">// // 有参数</span>    <span class="token keyword">function</span> <span class="token function">removeMessage</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"删除消息"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> removeMessage <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Emit自定义事件："><a href="#Emit自定义事件：" class="headerlink" title="Emit自定义事件："></a>Emit自定义事件：</h3><blockquote><p>因为无法从<code>setup()</code>函数中访问<code>this</code>属性，<code>setup()</code>接收第二个参数context，其中一个属性就是emit函数。</p></blockquote><blockquote><p>context参数本身不是响应性的，所以可以<strong>直接使用解构赋值</strong>。</p></blockquote><p>示例：</p><p>子组件MessageListItem.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- &lt;button @click="removeMessage(id)">删除&lt;/button> --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>this.$emit(<span class="token punctuation">'</span>remove<span class="token punctuation">'</span>, id)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>删除<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> toRefs <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"remove"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// setup(props, &#123; emit &#125;) &#123;</span>    <span class="token comment">// 有参数</span>    <span class="token comment">// function removeMessage(id) &#123;</span>    <span class="token comment">//   emit("remove", id);</span>    <span class="token comment">// &#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// return &#123; emit &#125;;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件MessageList.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageListItem</span>        <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span>        <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.content<span class="token punctuation">"</span></span>        <span class="token attr-name">@remove</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>removeMessage<span class="token punctuation">"</span></span>      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageListItem</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> MessageListItem <span class="token keyword">from</span> <span class="token string">"./MessageListItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MessageListItem <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">removeMessage</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// console.log(id);</span>      messages<span class="token punctuation">.</span>value <span class="token operator">=</span> messages<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=></span> msg<span class="token punctuation">.</span>id <span class="token operator">!==</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> removeMessage <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="生命周期钩子："><a href="#生命周期钩子：" class="headerlink" title="生命周期钩子："></a>生命周期钩子：</h3><p>与<code>Options API</code>不同，<code>Composition API</code>中的生命周期钩子需要加上<strong>on</strong>前缀，后面对应的生命周期首字母大写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2022/09/02/vue-zu-he-api/image-20220904171819752.png" alt="image-20220904171819752"></p><p><img src="/2022/09/02/vue-zu-he-api/image-20220904172051743.png" alt="image-20220904172051743"></p><blockquote><p>没有beforeCreate和created对应生命周期钩子的原因是<code>setup()</code>函数本身就是在这两个生命周期期间执行的，所以在这两个生命周期的自定义业务逻辑，直接在<code>setup()</code>函数中编写即可。</p></blockquote><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>loading...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageListItem</span>        <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span>        <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.content<span class="token punctuation">"</span></span>      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageListItem</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> onMounted <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> MessageListItem <span class="token keyword">from</span> <span class="token string">"./MessageListItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MessageListItem <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> loading <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      loading<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        messages<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">[</span>          <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">;</span>        loading<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages<span class="token punctuation">,</span> loading <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Provide和Inject："><a href="#Provide和Inject：" class="headerlink" title="Provide和Inject："></a>Provide和Inject：</h3><ol><li><p>普通数据：</p><pre class="line-numbers language-none"><code class="language-none">provide(&#39;propName&#39;, value);inject(&#39;propName&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>响应式数据：</p><p>如果使用provide提供的数据本身是响应性的，那么inject接收的数据就是响应性的；</p><p>如果不是，则可以调用<code>ref()</code>，<code>reactive()</code>，<code>toRef()</code>，<code>toRefs()</code>转换为响应性数据：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- &lt;MovieItem :title="movie.title" :description="movie.description" /> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieItem</span> <span class="token attr-name">:description</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>movie.description<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieItem <span class="token keyword">from</span> <span class="token string">"./MovieItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> provide<span class="token punctuation">,</span> toRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MovieItem<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> movie <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"电影"</span><span class="token punctuation">,</span>      <span class="token literal-property property">description</span><span class="token operator">:</span> <span class="token string">"这是一段电影的描述"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">provide</span><span class="token punctuation">(</span><span class="token string">"movie"</span><span class="token punctuation">,</span> movie<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// provide("title", toRef(movie.value, "title"));</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      movie<span class="token punctuation">.</span>value<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"电影-修改"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> movie <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="获取Template-Ref："><a href="#获取Template-Ref：" class="headerlink" title="获取Template Ref："></a>获取Template Ref：</h3><p>即相当于在<code>Options API</code>中获取DOM和Vue组件实例：</p><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inputText<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inputControl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> onMounted<span class="token punctuation">,</span> ref <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> inputText <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> inputControl <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      inputControl<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> inputText<span class="token punctuation">,</span> inputControl <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取非props属性："><a href="#获取非props属性：" class="headerlink" title="获取非props属性："></a>获取非props属性：</h3><p>使用<code>attrs</code>可以获取在props中未明确定义的属性：</p><p>示例：</p><p>子组件MessageList.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageListItem</span>        <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in messages<span class="token punctuation">"</span></span>        <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.id<span class="token punctuation">"</span></span>        <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg.content<span class="token punctuation">"</span></span>      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageListItem</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> isRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> MessageListItem <span class="token keyword">from</span> <span class="token string">"./MessageListItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MessageListItem <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> attrs <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒1"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒2"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"这是一条消息提醒4"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">[</span><span class="token string">"data-title"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拆解出来，不再具有响应性</span>    <span class="token comment">// const &#123; test &#125; = attrs;</span>    <span class="token comment">// watchEffect(() => &#123;</span>    <span class="token comment">//   console.log(test, " in MessageList.vue");</span>    <span class="token comment">// &#125;);</span>    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>test<span class="token punctuation">,</span> <span class="token string">" in MessageList.vue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// console.log(attrs);</span>    <span class="token comment">// console.log(attrs.class);</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> messages <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageList</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>messageList<span class="token punctuation">"</span></span> <span class="token attr-name">:test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span> <span class="token attr-name">data-title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>消息列表<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageList <span class="token keyword">from</span> <span class="token string">"./components/MessageList.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MessageList<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      test<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">"changed"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> test <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用script-setup进一步简化组件代码："><a href="#使用script-setup进一步简化组件代码：" class="headerlink" title="使用script setup进一步简化组件代码："></a>使用script setup进一步简化组件代码：</h2><p>使用配置：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script setup<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li><p>script setup中定义的函数及变量等，可以直接在模板中使用，<strong>无需手动return</strong>。</p></li><li><p>script setup可以使用import导入库或其他组件，并在模板中直接使用，无需配置。</p></li><li><p>script setup中如果需要使用props，则可以调用<code>defineProps( [ &quot;propsName&quot;] )</code>函数。</p></li><li><p>script setup中如果需要使用emits，则可以调用<code>defineEmits( [ &quot;emitsName&quot;] )</code>函数。</p></li><li><p>script setup中如果需要使用slots和attrs：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useSlots<span class="token punctuation">,</span> useAttrs<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">const</span> slots <span class="token operator">=</span> <span class="token function">useSlots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> attrs <span class="token operator">=</span> <span class="token function">useAttrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门-贪心算法</title>
      <link href="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/"/>
      <url>/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法本质"><a href="#贪心算法本质" class="headerlink" title="贪心算法本质"></a>贪心算法本质</h2><blockquote><p>一个贪心算法总是做出当前最好的选择，也就是说，它期望通过<strong>局部最优选择</strong>从而得到全局最优的解决方案。</p></blockquote><p>贪心算法在解决问题的策略上“<strong>目光短浅</strong>”，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心算法并不是从整体最优考虑，它所做出的选择只是在<strong>某种意义上的局部最优</strong>。贪心算法能得到许多问题的<strong>整体最优解或整体最优解的近似解</strong>。</p><p>所谓贪心选择性质是指原问题的整体最优解可以通过一系列局部最优的选择得到。是运用贪心策略解决的问题在程序的运行过程中<strong>无回溯</strong>过程。根据贪心策略，一步一步地得到局部最优解。最终根据贪心策略，一步一步地得到局部最优解。</p><blockquote><p>冒泡排序就使用了贪心算法，它的贪心策略就是每一次从剩下的序列中选一个最大的数，把这些选出来的数放在一起，就得到了从大到小的排序结果。</p></blockquote><h2 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h2><p>该问题要求装载的物品的数量尽可能多，而船的容量是固定的，那么优先把重量小的物品放进去，在容量固定的情况下，装的物品最多。</p><p>采用<strong>重量最轻者先装</strong>的贪心选择策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。</p><h3 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h3><ol><li>当载重量为定值c时，每件古董越小时，可装载的古董数量就越大。只要依次选择最小重量古董，直到不能再装为止。</li><li>把n个古董的重量从小到大排序，然后根据贪心策略尽可能多地选出古董，直到不能继续装为止，此时达到最优。</li></ol><p>每个古董的重量如下表所示，海盗船的载重量c为30，那么在不打碎古董又不超过载重的情况下，要装入最多的古董。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901162702223.png" alt="image-20220901162702223"></p><ol><li><p>因为贪心策略是每次选择重量最小的古董装入海盗船，因此可以按照古董重量非递减排序，排序后如下表所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901162839158.png" alt="image-20220901162839158"></p></li><li><p>按照贪心策略，每次选择重量最小的古董放入（tmp 代表古董的重量，ans 代表已装裁的古董个数）。</p><p>i&#x3D;0，选择排序后的第 1 个，装入重量 tmp&#x3D;2，不超过载重量 30，ans &#x3D;1。<br>i&#x3D;1，选择排序后的第 2 个，装入重量 tmp&#x3D;2+3&#x3D;5，不超过载重量 30，ans &#x3D;2。<br>i&#x3D;2，选择排序后的第 3 个，装入重量 tmp&#x3D;5+4&#x3D;9，不超过载重量 30，ans &#x3D;3。<br>i&#x3D;3，选择排序后的第 4 个，装入重量 tmp&#x3D;9+5&#x3D;14，不超过载重量 30，ans &#x3D;4。<br>i&#x3D;4，选择排序后的第 5 个，装入重量 tmp&#x3D;14+7&#x3D;21，不超过载重量 30，ans &#x3D;5。<br>i&#x3D;5，选择排序后的第 6 个，装入重量 tmp&#x3D;21+10&#x3D;31，超过载重量 30，算法结束。<br>即放入古董的个数为 ans&#x3D;5 个。</p></li></ol><h3 id="运行代码："><a href="#运行代码：" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1000005</span><span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">double</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//古董的重量数组</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> c<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> m<span class="token punctuation">;</span>    cin<span class="token operator">>></span>m<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>c<span class="token operator">>></span>n<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//输入每个物品重量</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 可以利用 C++中的排序函数 sort（见附录 B），对古董的重量进行从小到大（非递减）排序。要使用此函数需引入头文件：</span>        <span class="token comment">// #include &lt;algorithm></span>        <span class="token comment">// 语法描述为：</span>        <span class="token comment">// sort(begin, end)//参数 begin 和 end 表示一个范围，分别为待排序数组的首地址和尾地址</span>        <span class="token comment">// sort 函数默认为升序</span>        <span class="token comment">// 在本例中只需要调用 sort 函数对古董的重量进行从小到大排序：</span>        <span class="token function">sort</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>w<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//按古董重量升序排序</span>        <span class="token keyword">double</span> tmp<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// tmp为已装载到船上的古董重量，ans为已装载的古董个数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            tmp<span class="token operator">+=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">&lt;=</span>c<span class="token punctuation">)</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*请输入载重量 c 及古董个数 n：30 8                        //载重量 c 及古董的个数 n请输入每个古董的重量，用空格分开：4 10 7 11 3 5 14 2         //每个古董的重量，用空格隔开*/</span><span class="token comment">//输出</span><span class="token comment">//能装入的古董最大数量为 Ans=5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析："><a href="#算法解析：" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li>算法复杂度分析：<ul><li>时间复杂度：首先需要按古董重量排序，调用 sort 函数，其平均时间复杂度为 O(nlogn)，输入和贪心策略求解的两个 for 语句时间复杂度均为 O(n)，因此时间复杂度为 <strong>O(n + nlog(n))</strong></li><li>空间复杂度：程序中变量 tmp、ans 等占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为 <strong>O(1)</strong></li></ul></li><li>优化拓展：<ul><li>为什么在没有装满的情况下，仍然是最优解？因为此算法要求装入最多数量，和价值无关，所以从重量小的开始装才能装入最多的数量。</li><li>如果想知道装入哪些古董，应当如何实现？</li></ul></li></ol><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>假设山洞中有 n 种宝物，每种宝物有一定重量 w 和相应的价值 v，毛驴运载能力有限，只能运走 m 重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？</p><p>答案是选择<strong>性价比</strong>（<strong>价值&#x2F;重量</strong>）最高的宝物，如果可以达到运载重量m，那么一定能得到价值最大，即每次从剩下的宝物中选择性价比最高的宝物。</p><h3 id="算法设计：-1"><a href="#算法设计：-1" class="headerlink" title="算法设计："></a>算法设计：</h3><ol><li>将 n 种宝物的重量和价值存储在结构体 three（包含重量、价值、性价比 3 个成员）中，同时求出每种宝物的性价比也存储在对应的结构体 three 中，将其按照性价比从高到低排序。采用 sum 来存储毛驴能够运走的最大价值，初始化为 0。</li><li>根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于 m（毛驴运载能力），如果小于 m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m 减去放入宝物的重量；如果不小于 m，**则取该宝物的一部分 m * p[i]**，m&#x3D;0，程序结束。m 减少到 0，则 sum 得到最大值。</li></ol><p>有一批宝物的价值，价值和重量如表所示，毛驴的运载能力m&#x3D;30。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901172836572.png" alt="image-20220901172836572"></p><ol><li><p>按照性价比降序排序，排序后如下表所示：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901173212678.png" alt="image-20220901173212678"></p></li><li><p>每次选择性价比高的宝物放入：</p><p>第 1 次选择宝物 2，剩余容量 30−2&#x3D;28，目前装入最大价值为 8。<br>第 2 次选择宝物 10，剩余容量 28−5&#x3D;23，目前装入最大价值为 8+15&#x3D;23。<br>第 3 次选择宝物 6，剩余容量 23−8&#x3D;15，目前装入最大价值为 23+20&#x3D;43。<br>第 4 次选择宝物 3，剩余容量 15−9&#x3D;6，目前装入最大价值为 43+18&#x3D;61。</p><p>第 5 次选择宝物 5，剩余容量 6−5&#x3D;1，目前装入最大价值为 61+8&#x3D;69。<br>第 6 次选择宝物 8，发现上次处理完时剩余容量为 1，而 8 号宝物重量为 4，无法全部放入，那么可以采用部分装入的形式，装入 1 个重量单位，因为 8 号宝物的单位重量价值为1.5，因此放入价值 1×1.5&#x3D;1.5，你也可以认为装入了 8 号宝物的 1&#x2F;4，目前装入最大价值为69+1.5&#x3D;70.5，剩余容量为 0。</p></li><li><p>构造最优解：</p><p>把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了 8 号财宝的 1&#x2F;4），能够装入宝物的最大价值为 70.5。</p></li></ol><h3 id="运行代码：-1"><a href="#运行代码：-1" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-2</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> M<span class="token operator">=</span><span class="token number">1000005</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">three</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> w<span class="token punctuation">;</span><span class="token comment">//每个宝物的重量</span>    <span class="token keyword">double</span> v<span class="token punctuation">;</span><span class="token comment">//每个宝物的价值</span>    <span class="token keyword">double</span> p<span class="token punctuation">;</span><span class="token comment">//性价比</span><span class="token punctuation">&#125;</span>s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//如果不使用自定义比较函数，那么sort函数排序时不知道按哪一项的值排序，因此采用自定义比较函数的办法实现宝物性价比的降序排序。</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>three a<span class="token punctuation">,</span>three b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>p<span class="token operator">></span>b<span class="token punctuation">.</span>p<span class="token punctuation">;</span><span class="token comment">//根据宝物的单位价值从大到小排序</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token comment">//n 表示有n个宝物</span>    <span class="token keyword">double</span> m <span class="token punctuation">;</span><span class="token comment">//m 表示毛驴的承载能力</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入宝物数量n及毛驴的承载能力m ："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token operator">>></span>m<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入每个宝物的重量和价值，用空格分开： "</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token operator">>></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token operator">/</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token comment">//每个宝物单位价值</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>s<span class="token operator">+</span>n<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 前两个参数分别为待排序数组的首地址和尾地址，最后一个参数compare表示比较的类型</span>    <span class="token keyword">double</span> sum<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">;</span><span class="token comment">// sum 表示贪心记录运走宝物的价值之和</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//按照排好的顺序贪心</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> m<span class="token operator">></span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token punctuation">)</span><span class="token comment">//如果宝物的重量小于毛驴剩下的承载能力</span>        <span class="token punctuation">&#123;</span>            m<span class="token operator">-=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            sum<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token comment">//如果宝物的重量大于毛驴剩下的承载能力</span>        <span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>m<span class="token operator">*</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span><span class="token comment">//部分装入，m为剩余的装载能力，即还能装多少货物，s[i].p为单位重量价值，二者相乘为总价值。</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"装入宝物的最大价值Maximum value="</span><span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//输出装入宝物的最大价值</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//輸入</span><span class="token comment">/* 6 19 //宝物数量，驴子的承载重量2 8 //第 1 个宝物的重量和价值6 1 //第 2 个宝物的重量和价值7 94 310 23 4*/</span><span class="token comment">//输出</span><span class="token comment">//Maxinum value=24.6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析：-1"><a href="#算法解析：-1" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li><p>算法复杂度分析：</p><ul><li>时间复杂度：该算法的时间主要耗费在将宝物按照性价比排序上，采用的是快速排序，算法时间复杂度为 <strong>O(nlogn)</strong></li><li>空间复杂度：空间主要耗费在存储宝物的性价比，空间复杂度为 <strong>O(n)</strong></li></ul><p>贪心策略是在每次取剩下物品里面性价比最高的物品，这样可以使得在相同重量条件下比选其他物品所得的价值更大，因此采用贪心策略能得到最优解。</p></li><li><p>优化拓展：</p><ul><li><p>如果宝物不能分割，贪心算法是否能得到最优解？</p><p>不一定。有可能出现剩余容量，没有装满的情况。这种情况下可能存在刚好达到运载能力的选择方案，因此在宝物不可分割、没法装满的情况下，贪心算法并不能得到最优解，仅仅是最优解的近似解。</p></li></ul></li></ol><h2 id="会议安排问题"><a href="#会议安排问题" class="headerlink" title="会议安排问题"></a>会议安排问题</h2><p>会议安排的目的是能在<strong>有限的时间内召开更多的会议</strong>（任何两个会议不能同时进行）。在会议安排中，每个会议 i 都有起始时间 bi 和结束时间 e i，且 bi&lt;ei，即一个会议进行的时间为半开区间[bi，ei）。如果[b i，ei）与[bj，ej）均在“有限的时间内”，且不相交，则称会议 i 与会议 j 相容的。也就是说，当 bi≥ej 或 bj≥ei 时，会议 i与会议 j 相容。会议安排问题要求在<strong>所给的会议集合中选出最大的相容活动子集</strong>，即尽可能在有限的时间内召开更多的会议。</p><p>尝试贪心策略：如果选择最早开始时间的会议，则如果会议持续时间很长，例如 8 点开始，却要持续 12 个小时，这样一天就只能安排一个会议；如果选择持续时间最短，则可能开始时间很晚，例如 19 点开始，20 点结束，这样也只能安排一个会议，所以我们最好选择那些开始时间要早，而且持续时间短的会议，即最早开始时间+持续时间最短，就是最早结束时间。</p><blockquote><p>每次从剩下的会议中选择<strong>具有最早结束时间且与已安排的会议相容</strong>的会议安排。</p></blockquote><h3 id="算法设计：-2"><a href="#算法设计：-2" class="headerlink" title="算法设计："></a>算法设计：</h3><ol><li>初始化：将 n 个会议的开始时间、结束时间存放在结构体数组中（想一想，为什么不用两个一维数组分别存储？），如果需要知道选中了哪些会议，还需要在结构体中增加会议编号，然后按结束时间从小到大排序（非递减），结束时间相等时，按开始时间从大到小排序（非递增）；</li><li>根据贪心策略就是选择第一个具有最早结束时间的会议，用 last 记录刚选中会议的结束时间；</li><li>选择第一个会议之后，依次从剩下未安排的会议中选择，如果会议 i <strong>开始时间大于等于最后一个选中的会议的结束时间</strong> last，那么会议 i 与已选中的会议相容，可以安排，更新 last 为刚选中会议的结束时间；否则，舍弃会议 i，检查下一个会议是否可以安排。</li></ol><p>原始的会议时间表：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215008673.png" alt="image-20220901215008673"></p><p>排序后的会议时间表：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215037996.png" alt="image-20220901215037996"></p><p>贪心选择过程：</p><ul><li><p>首先选择排序后的第一个会议即最早结束的会议（编号为 2），用 last 记录最后一个被选中会议的结束时间，last&#x3D;4。</p></li><li><p>检查余下的会议，找到第一个开始时间大于等于 last（last&#x3D;4）的会议，子问题转化为从该会议开始，余下的所有会议。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215159196.png" alt="image-20220901215159196"></p><p>从子问题中，选择第一个会议即最早结束的会议（编号为 3），更新 last 为刚选中会议的结束时间 last&#x3D;7。</p></li><li><p>检查余下的会议，找到第一个开始时间大于等于 last（last&#x3D;7）的会议，子问题转化为从该会议开始，余下的所有会议。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215514120.png" alt="image-20220901215514120"></p><p>从子问题中，选择第一个会议即最早结束的会议（编号为 7），更新 last 为刚选中会议的结束时间 last&#x3D;11。</p></li><li><p>检查余下的会议，找到第一个开始时间大于等于 last（last&#x3D;11）的会议，子问题转化为从该会议开始，余下的所有会议。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215546493.png" alt="image-20220901215546493"></p><p>从子问题中，选择第一个会议即最早结束的会议（编号为 10），更新 last 为刚选中会议的结束时间 last&#x3D;14；所有会议检查完毕，算法结束。</p></li><li><p>从贪心选择的结果，可以看出，被选中的会议编号为{2，3，7，10}，可以安排的会议数量最多为 4。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901215640659.png" alt="image-20220901215640659"></p></li></ul><h3 id="运行代码：-2"><a href="#运行代码：-2" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-3</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Meet</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> beg<span class="token punctuation">;</span>   <span class="token comment">//会议的开始时间</span>    <span class="token keyword">int</span> end<span class="token punctuation">;</span>   <span class="token comment">//会议的结束时间</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>   <span class="token comment">//记录会议的编号</span><span class="token punctuation">&#125;</span>meet<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//会议的最大个数为1000</span><span class="token keyword">class</span> <span class="token class-name">setMeet</span><span class="token punctuation">&#123;</span>  <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>ans<span class="token punctuation">;</span> <span class="token comment">// n:会议总数 ans: 最大的安排会议总数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//读入数据</span><span class="token keyword">void</span> setMeet<span class="token double-colon punctuation">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">,</span>e<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入会议总数："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入会议的开始时间和结束时间，以空格分开:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>s<span class="token operator">>></span>e<span class="token punctuation">;</span>        meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>beg<span class="token operator">=</span>s<span class="token punctuation">;</span>        meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token operator">=</span>e<span class="token punctuation">;</span>        meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>Meet x<span class="token punctuation">,</span>Meet y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>end <span class="token operator">==</span> y<span class="token punctuation">.</span>end<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>beg <span class="token operator">></span> y<span class="token punctuation">.</span>beg<span class="token punctuation">;</span><span class="token comment">//结束时间相等时，按开始时间从大到小排序</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>end <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>end<span class="token punctuation">;</span><span class="token comment">//按结束时间从小到大排序</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> setMeet<span class="token double-colon punctuation">::</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>meet<span class="token punctuation">,</span>meet<span class="token operator">+</span>n<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//对会议按结束时间排序</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"排完序的会议时间如下:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"会议编号："</span><span class="token operator">&lt;&lt;</span><span class="token string">"  开始时间 "</span><span class="token operator">&lt;&lt;</span><span class="token string">" 结束时间"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      cout<span class="token operator">&lt;&lt;</span> <span class="token string">"   "</span> <span class="token operator">&lt;&lt;</span> meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">&lt;&lt;</span><span class="token string">"\t\t"</span><span class="token operator">&lt;&lt;</span>meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>beg <span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span> meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"-------------------------------------------------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"选择的会议的过程:"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"  选择第"</span><span class="token operator">&lt;&lt;</span> meet<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">&lt;&lt;</span><span class="token string">"个会议"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//选中了第一个会议</span>    ans<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> last <span class="token operator">=</span> meet<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">;</span>  <span class="token comment">//记录刚刚被选中会议的结束时间</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>beg<span class="token operator">>=</span>last<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//如果会议i开始时间大于等于最后一个选中的会议的结束时间</span>           ans<span class="token operator">++</span><span class="token punctuation">;</span>           last <span class="token operator">=</span> meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">;</span>           cout <span class="token operator">&lt;&lt;</span><span class="token string">"  选择第"</span><span class="token operator">&lt;&lt;</span>meet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">&lt;&lt;</span><span class="token string">"个会议"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"最多可以安排"</span> <span class="token operator">&lt;&lt;</span>ans <span class="token operator">&lt;&lt;</span> <span class="token string">"个会议"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  setMeet sm<span class="token punctuation">;</span>  sm<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读入数据</span>  sm<span class="token punctuation">.</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//贪心算法求解</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*输入会议总数：10输入会议的开始时间和结束时间，以空格分开：3 61 45 72 55 93 88 116 108 1212 14*/</span><span class="token comment">//输出</span><span class="token comment">/*排完序的会议时间如下：会议编号 开始时间 结束时间2 1 44 2 51 3 63 5 76 3 85 5 98 6 107 8 119 8 1210 12 14选择的会议的过程：选择第 2 个会议选择第 3 个会议选择第 7 个会议选择第 10 个会议最多可以安排 4 个会议*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析：-2"><a href="#算法解析：-2" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li>算法复杂度分析：<ul><li>时间复杂度：在该算法中，问题的规模就是会议总个数 n。显然，执行次数随问题规模的增大而变化。首先在成员函数 setMeet::init()中，输入 n 个结构体数据。输入作为基本语句，显然，共执行 n 次。而后在调用成员函数 setMeet::solve()中进行排序，易知 sort 排序函数的平均时间复杂度为 O(nlogn)。随后进行选择会议，贡献最大的为 if(meet[i].beg&gt;&#x3D;last)语句，时间复杂度为 O(n)，总时间复杂度为 O(n +nlogn)&#x3D; <strong>O(nlogn)</strong></li><li>空间复杂度：在该算法中，meet[]结构体数组为输入数据，不计算在空间复杂度内。辅助空间有 i、n、ans 等变量，则该程序空间复杂度为常数阶，即 <strong>O(1)</strong></li></ul></li><li>优化拓展：<ul><li>有没有更好的办法，比如有更小的算法时间复杂度？</li></ul></li></ol><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>给定有向带权图 G &#x3D;（V，Ｅ），其中每条边的权是非负实数。此外，给定 V 中的一个顶点，称为源点。现在要计算从源到所有其他各顶点的最短路径长度，这里路径长度指路上各边的权之和。</p><h3 id="算法设计：-3"><a href="#算法设计：-3" class="headerlink" title="算法设计："></a>算法设计：</h3><blockquote><p>Dijkstra 算法是解决单源最短路径问题的贪心算法，它<strong>先求出长度最短的一条路径</strong>，再参照该最短路径<strong>求出长度次短的一条路径</strong>，直到求出从源点到其他各个顶点的最短路径。</p></blockquote><p>Dijkstra 算法的基本思想是首先假定源点为 u，顶点集合 V 被划分为两部分：集合 S和 V−S。初始时 S 中仅含有源点 u，其中 S 中的顶点到源点的最短路径已经确定。集合V−S 中所包含的顶点到源点的最短路径的长度待定，称从源点出发只经过 S 中的点到达V−S 中的点的路径为特殊路径，并用数组 dist[]记录当前每个顶点所对应的最短特殊路径长度。将其连接的 V−S 中的顶点加入到集合 S 中，同时更新数组 dist[]。一旦 S 包含了所有顶点，dist[]就是从源到所有其他顶点之间的最短路径长度。</p><ol><li>数据结构。设置地图的带权邻接矩阵为 map[][]，即如果从源点 u 到顶点 i 有边，就令 map[u][i]等于&lt;u，i&gt;的权值，否则 map[u][i]&#x3D;∞（无穷大）；采用一维数组 dist[i]<br>来记录从源点到 i 顶点的最短路径长度；采用一维数组 p[i]来记录最短路径上 i 顶点的前驱。</li><li>初始化。令集合 S&#x3D;{u}，对于集合 V−S 中的所有顶点 x，初始化 dist[i]&#x3D;map[u][i]，如果源点 u 到顶点 i 有边相连，初始化 p[i]&#x3D;u，否则 p[i]&#x3D; −1。</li><li>找最小。在集合 V−S 中依照贪心策略来寻找使得 dist[j]具有最小值的顶点 t，即dist[t]&#x3D;min（dist[j]|j 属于 V−S 集合），则顶点 t 就是集合 V−S 中距离源点 u 最近的顶点。</li><li>加入 S 战队。将顶点 t 加入集合 S 中，同时更新 V−S。</li><li>判结束。如果集合 V−S 为空，算法结束，否则转（6）。</li><li>借东风。在（3）中已经找到了源点到 t 的最短路径，那么对集合 V−S 中所有与顶点 t 相邻的顶点 j，都可以借助 t 走捷径。如果 dis[j]&gt;dist[t]+map[t][j]，则 dist[j]&#x3D;dist[t]+map[t][j]，记录顶点 j 的前驱为 t，有 p[j]&#x3D; t，转（3）。</li></ol><p>由此，可求得从源点 u 到图 G 的其余各个顶点的最短路径及长度，也可通过数组 p[]逆向找到最短路径上经过的城市。</p><p>算法步骤如下。</p><p>初始景点地图：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901224759504.png" alt="image-20220901224759504"></p><p>设置地图的带权邻接矩阵为 map[][]，即如果从顶点 i 到顶点 j 有边，则 map[i][j]等于&lt;i,j&gt;的权值，否则 map[i][j]&#x3D;∞（无穷大）:</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901224817141.png" alt="image-20220901224817141"></p><p>令集合 S&#x3D;{1}，V−S&#x3D;{2，3，4，5}，对于集合 V−S 中的所有顶点 x，初始化最短距离数组 dist[i]&#x3D;map[1][i]，dist[u]&#x3D;0，如图 2-12 所示。如果源点 1 到顶点 i 有边相连，初始化前驱数组 p[i]&#x3D;1，否则 p[i]&#x3D; −1，如图 2-13 所示：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225045842.png" alt="image-20220901225045842"></p><p>在集合 V−S&#x3D;{2，3，4，5}中，依照贪心策略来寻找 V−S 集合中 dist[]最小的顶点 t，如图 2-14 所示。<br>找到最小值为 2，对应的结点 t&#x3D;2。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225130199.png" alt="image-20220901225130199"></p><p>将顶点 t&#x3D;2 加入集合 S 中 S&#x3D;{1，2}，同时更新 V−S&#x3D;{3，4，5}，如图 2-15 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225251138.png" alt="image-20220901225251138"></p><p>刚刚找到了源点到 t&#x3D;2 的最短路径，那么对集合 V−S 中所有 t 的邻接点 j，都可以借助 t 走捷径。我们从图或邻接矩阵都可以看出，2 号结点的邻接点是 3 和 4 号结点，如图 2-16 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225400247.png" alt="image-20220901225400247"></p><p>先看 3 号结点能否借助 2 号走捷径：dist[2]+map[2][3]&#x3D;2+2&#x3D;4，而当前 dist[3]&#x3D;5&gt;4，因此可以走捷径即 2—3，更新 dist[3]&#x3D;4，记录顶点 3 的前驱为 2，即 p[3]&#x3D; 2。<br>再看 4 号结点能否借助 2 号走捷径：如果 dist[2]+map[2][4]&#x3D;2+6&#x3D;8，而当前 dist[4]&#x3D;∞&gt;8，因此可以走捷径即 2—4，更新 dist[4]&#x3D;8，记录顶点 4 的前驱为 2，即 p[4]&#x3D; 2。<br>更新后如图 2-17 和图 2-18 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225409864.png" alt="image-20220901225409864"></p><p>在集合 V−S&#x3D;{3，4，5}中，依照贪心策略来寻找 dist[]具有最小值的顶点 t，依照贪心策略来寻找 V−S 集合中 dist[]最小的顶点 t，如图 2-19 所示。<br>找到最小值为 4，对应的结点 t&#x3D;3。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225450417.png" alt="image-20220901225450417"></p><p>将顶点 t&#x3D;3 加入集合 S 中 S&#x3D;{1，2，3}，同时更新 V−S&#x3D;{4，5}，如图 2-20 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225518417.png" alt="image-20220901225518417"></p><p>刚刚找到了源点到 t &#x3D;3 的最短路径，那么对集合 V−S 中所有 t 的邻接点 j，都可以借助t 走捷径。我们从图或邻接矩阵可以看出，3 号结点的邻接点是 4 和 5 号结点。<br>先看 4 号结点能否借助 3 号走捷径：dist[3]+map[3][4]&#x3D;4+7&#x3D;11，而当前 dist[4]&#x3D;8&lt;11，比当前路径还长，因此不更新。<br>再看 5 号结点能否借助 3 号走捷径：dist[3]+map[3][5]&#x3D;4+1&#x3D;5，而当前 dist[5]&#x3D;∞&gt;5，因此可以走捷径即 3—5，更新 dist[5]&#x3D;5，记录顶点 5 的前驱为 3，即 p[5]&#x3D;3。<br>更新后如图 2-21 和图 2-22 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225552693.png" alt="image-20220901225552693"></p><p>在集合 V−S&#x3D;{4，5}中，依照贪心策略来寻找 V−S 集合中 dist[]最小的顶点 t，如图 2-23 所示。<br>找到最小值为 5，对应的结点 t&#x3D;5。</p><p>将顶点 t&#x3D;5 加入集合 S 中 S&#x3D;{1，2，3，5}，同时更新 V−S&#x3D;{4}，如图 2-24 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220901225914054.png" alt="image-20220901225914054"></p><p>刚刚找到了源点到 t &#x3D;5 的最短路径，那么对集合 V−S 中所有 t 的邻接点 j，都可以借助 t 走捷径。我们从图或邻接矩阵可以看出，5 号结点没有邻接点，因此不更新。</p><p>在集合 V−S&#x3D;{4}中，依照贪心策略来寻找 dist[]最小的顶点 t，只有一个顶点，所以很容易找到。<br>找到最小值为 8，对应的结点 t&#x3D;4。</p><p>V−S&#x3D;{ }为空时，算法停止。<br>由此，可求得从源点 u 到图 G 的其余各个顶点的最短路径及长度，也可通过前驱数组p[]逆向找到最短路径上经过的城市。</p><p>例如，p[5]&#x3D;3，即 5 的前驱是 3；p[3]&#x3D;2，即 3 的前驱是 2；p[2]&#x3D;1，即 2 的前驱是 1；p[1]&#x3D; −1，1 没有前驱，那么从源点 1 到 5 的最短路径为 1—2—3—5。</p><h3 id="运行代码：-3"><a href="#运行代码：-3" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;windows.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 城市的个数可修改</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF<span class="token operator">=</span><span class="token number">1e7</span><span class="token punctuation">;</span> <span class="token comment">// 无穷大10000000</span><span class="token keyword">int</span> map<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">;</span><span class="token comment">//n城市的个数，m为城市间路线的条数</span><span class="token keyword">bool</span> flag<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//如果s[i]等于true，说明顶点i已经加入到集合S;否则顶点i属于集合V-S</span><span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>     dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//初始化源点u到其他各个顶点的最短路径长度</span>     flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>INF<span class="token punctuation">)</span>       p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//源点u到该顶点的路径长度为无穷大，说明顶点i与源点u不相邻</span>     <span class="token keyword">else</span>       p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>u<span class="token punctuation">;</span> <span class="token comment">//说明顶点i与源点u相邻，设置顶点i的前驱p[i]=u</span>     <span class="token punctuation">&#125;</span>    dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    flag<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment">//初始时，集合S中只有一个元素：源点u</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> INF<span class="token punctuation">,</span>t <span class="token operator">=</span> u<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//在集合V-S中寻找距离源点u最近的顶点t</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>temp<span class="token punctuation">)</span>           <span class="token punctuation">&#123;</span>            t<span class="token operator">=</span>j<span class="token punctuation">;</span>            temp<span class="token operator">=</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span>u<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment">//找不到t，跳出循环</span>        flag<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//否则，将t加入集合</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//更新与t相邻接的顶点到源点u的距离</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span> map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>INF<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>               dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">;</span>               p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>t <span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">findpath</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> x<span class="token punctuation">;</span>  stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>s<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"源点为："</span><span class="token operator">&lt;&lt;</span>u<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    x<span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>      x<span class="token operator">=</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"源点到其它各顶点最短路径为："</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"--"</span><span class="token punctuation">;</span>      s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">";最短距离为："</span><span class="token operator">&lt;&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">,</span>st<span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"color 0d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市的个数："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin <span class="token operator">>></span> n<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市之间的路线的个数:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cin <span class="token operator">>></span>m<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市之间的路线以及距离："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token punctuation">&#123;</span>             map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span><span class="token comment">//初始化邻接矩阵为无穷大</span>          <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin <span class="token operator">>></span> u <span class="token operator">>></span> v <span class="token operator">>></span> w<span class="token punctuation">;</span>            map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵储存，保留最小的距离</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"请输入小明所在的位置:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">;</span>        cin <span class="token operator">>></span> st<span class="token punctuation">;</span>        <span class="token function">Dijkstra</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"小明所在的位置:"</span><span class="token operator">&lt;&lt;</span>st<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>             cout <span class="token operator">&lt;&lt;</span><span class="token string">"小明:"</span><span class="token operator">&lt;&lt;</span>st<span class="token operator">&lt;&lt;</span><span class="token string">" - "</span><span class="token operator">&lt;&lt;</span><span class="token string">"要去的位置:"</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> INF<span class="token punctuation">)</span>               cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sorry,无路可达"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>             <span class="token keyword">else</span>               cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 最短距离为:"</span><span class="token operator">&lt;&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>         <span class="token function">findpath</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*请输入城市的个数：5请输入城市之间的路线的个数：11请输入城市之间的路线以及距离：1 5 125 1 81 2 162 1 295 2 322 4 134 2 271 3 153 1 213 4 74 3 19请输入小明所在的位置：5*/</span><span class="token comment">//输出</span><span class="token comment">/*小明所在的位置：5小明:5 - 要去的位置:1 最短距离为：8小明:5 - 要去的位置:2 最短距离为：24小明:5 - 要去的位置:3 最短距离为：23小明:5 - 要去的位置:4 最短距离为：30小明:5 - 要去的位置:5 最短距离为：0*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为我们在程序中使用 p[]数组记录了最短路径上每一个结点的前驱，因此除了显示最短距离外，还可以显示最短路径上经过了哪些城市，可以增加一段程序逆向找到该最短路径上的城市序列。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">findpath</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>s<span class="token punctuation">;</span><span class="token comment">//利用 C++自带的函数创建一个栈 s，需要程序头部引入#include&lt;stack></span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"源点为："</span><span class="token operator">&lt;&lt;</span>u<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        x<span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将前驱依次压入栈中</span>    x<span class="token operator">=</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"源点到其他各顶点最短路径为："</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"--"</span><span class="token punctuation">;</span><span class="token comment">//依次取栈顶元素</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出栈</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">";最短距离为："</span><span class="token operator">&lt;&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要在主函数末尾调用该函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">findpath</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//主函数中 st 为源点</span><span class="token comment">//输出结果如下</span><span class="token comment">/*源点为：5源点到其他各顶点最短路径为：5--1；最短距离为：8源点到其他各顶点最短路径为：5--1--2；最短距离为：24源点到其他各顶点最短路径为：5--1--3；最短距离为：23源点到其他各顶点最短路径为：5--1--3--4；最短距离为：30源点到其他各顶点最短路径为：5；最短距离为：0*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析：-3"><a href="#算法解析：-3" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li><p>算法复杂度分析：</p><ul><li>时间复杂度：在 Dijkstra 算法描述中，一共有 4 个 for 语句，第①个 for 语句的执行次数为 n，第②个 for 语句里面嵌套了两个 for 语句③、④，它们的执行次数均为 n，对算法的运行时间贡献最大，当外层循环标号为 1 时，③、④语句在内层循环的控制下均执行 n 次，外层循环②从 1～n。因此，该语句的执行次数为 n*n&#x3D; n²，算法的时间复杂度为 <strong>O(n²)</strong></li><li>空间复杂度：由以上算法可以得出，实现该算法所需要的辅助空间包含为数组 flag、变量 i、j、t 和 temp 所分配的空间，因此，空间复杂度为 <strong>O(n)</strong></li></ul></li><li><p>优化拓展：</p><ul><li><p>在 for 语句③中，即在集合 V−S 中寻找距离源点 u 最近的顶点 t，其时间复杂度为 O(n)，如果我们使用优先队列，则可以把时间复杂度降为 **O(log n)**那么如何使用优先队列呢？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-4-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;windows.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 城市的个数可修改</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">1e7</span><span class="token punctuation">;</span> <span class="token comment">// 无穷大</span><span class="token keyword">int</span> map<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">;</span><span class="token keyword">int</span> flag<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span>  <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span>step<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> sp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        u<span class="token operator">=</span>a<span class="token punctuation">;</span>step<span class="token operator">=</span>sp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span>  Node<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 重载 &lt;</span>        <span class="token keyword">return</span> step<span class="token operator">></span>a<span class="token punctuation">.</span>step<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> st<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    priority_queue <span class="token operator">&lt;</span>Node<span class="token operator">></span> Q<span class="token punctuation">;</span>  <span class="token comment">// 优先队列优化</span>    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Node</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化flag数组为0</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>      dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span> <span class="token comment">// 初始化所有距离为，无穷大</span>    dist<span class="token punctuation">[</span>st<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        Node it<span class="token operator">=</span>Q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//优先队列队头元素为最小值</span>        Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> t<span class="token operator">=</span>it<span class="token punctuation">.</span>u<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//说明已经找到了最短距离，该结点是队列里面的重复元素</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        flag<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>INF<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 判断与当前点有关系的点，并且自己不能到自己</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>   <span class="token comment">// 求距离当前点的每个点的最短距离,进行松弛操作</span>                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Node</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 把更新后的最短距离压入优先队列，注意：里面的元素有重复</span>                 <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">,</span>st<span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"color 0d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置背景及字体颜色</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市的个数："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span> n<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市之间的路线的个数:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span>m<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//初始化图的邻接矩阵</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token punctuation">&#123;</span>              map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span><span class="token comment">//初始化邻接矩阵为无穷大</span>          <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入城市之间u,v的路线以及距离w："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>u<span class="token operator">>></span>v<span class="token operator">>></span>w<span class="token punctuation">;</span>            map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵储存，保留最小的距离</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入小明所在的位置:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">;</span>        cin<span class="token operator">>></span>st<span class="token punctuation">;</span>        <span class="token function">Dijkstra</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"小明所在的位置:"</span><span class="token operator">&lt;&lt;</span>st<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>             cout <span class="token operator">&lt;&lt;</span><span class="token string">"小明:"</span><span class="token operator">&lt;&lt;</span>st<span class="token operator">&lt;&lt;</span><span class="token string">"--->"</span><span class="token operator">&lt;&lt;</span><span class="token string">"要去的位置:"</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>INF<span class="token punctuation">)</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sorry,无路可达"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>             <span class="token keyword">else</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 最短距离为:"</span><span class="token operator">&lt;&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>通常的编码方法有固定长度编码和不等长度编码两种。这是一个设计最优编码方案的问题，目的是使总码长度最短。这个问题利用字符的<strong>使用频率</strong>来编码，是不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。如果采用等长的编码方案，假设所有字符的编码都等长，则表示 n 个不同的字符需要[log n]位。例如，3 个不同的字符 a、b、c，至少需要 2 位二进制数表示，a 为 00，b 为 01，c 为 10。如果每个字符的使用频率相等，固定长度编码是空间效率最高的方法。</p><ol><li><p>编码尽可能短</p><p>我们可以让使用频率高的字符编码较短，使用频率低的编码较长，这种方法可以提高压缩率，节省空间，也能提高运算和通信速度。即<strong>频率越高，编码越短</strong>。</p></li><li><p>不能有二义性</p><p>例如，ABCD 四个字符如果编码如下。<br>A：0。B：1。C：01。D：10。<br>那么现在有一列数 0110，该怎样翻译呢？是翻译为 ABBA，ABD，CBA，还是 CD？那么如何消除二义性呢？解决的办法是：任何一个字符的编码不能是另一个字符编码的前缀，即<strong>前缀码特性</strong>。</p></li></ol><h3 id="算法设计：-4"><a href="#算法设计：-4" class="headerlink" title="算法设计："></a>算法设计：</h3><p>哈夫曼算法采取的<strong>贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树</strong>，构造一棵新树，新树根节点的权值为其左右孩子结点权值之和，将新树插入到树的集合中，求解步骤如下。</p><ol><li>确定合适的数据结构。编写程序前需要考虑的情况有：<ul><li>哈夫曼树中没有度为 1 的结点，则一棵有 n 个叶子结点的哈夫曼树共有 2n−1 个结点（n−1 次的“合并”，每次产生一个新结点），</li><li>构成哈夫曼树后，为求编码，需从叶子结点出发走一条从叶子到根的路径。</li><li>译码需要从根出发走一条从根到叶子的路径，那么我们需要知道每个结点的权值、双亲、左孩子、右孩子和结点的信息。</li></ul></li><li>初始化。构造 n 棵结点为 n 个字符的单结点树集合 T&#x3D;{t1，t2，t3，…，t n}，每棵树只有一个带权的根结点，权值为该字符的使用频率。</li><li>如果 T 中只剩下一棵树，则哈夫曼树构造成功，跳到步骤（6）。否则，从集合 T中取出没有双亲且权值最小的两棵树 t i 和 t j，将它们合并成一棵新树 zk，新树的左孩子为 t i，右孩子为 t j，zk 的权值为 t i 和 t j 的权值之和。</li><li>从集合 T 中删去 t i，t j，加入 zk。</li><li>重复以上（3）～（4）步。</li><li>约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码。算法结束。</li></ol><p>下图是一些字符和它们的使用频率：</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100212471.png" alt="image-20220902100212471"></p><p>我们可以把每一个字符作为叶子，它们对应的频率作为其权值，为了比较大小方便，可以对其同时扩大 100 倍，得到 a～f 分别对应 5、32、18、7、25、13。</p><ol><li><p>初始化。构造 n 棵结点为 n 个字符的单结点树集合 T&#x3D;{a，b，c，d，e，f}，如图 2-33 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100356328.png" alt="image-20220902100356328"></p></li><li><p>从集合 T 中取出没有双亲的且权值最小的两棵树a 和 d，将它们合并成一棵新树 t1，新树的左孩子为 a，右孩子为 d，新树的权值为 a 和 d 的权值之和为 12。新树的树根 t1 加入集合 T，a 和 d 从集合T中删除，如图 2-34 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100406071.png" alt="image-20220902100406071"></p></li><li><p>从集合 T 中取出没有双亲的且权值最小的两棵树 t1 和 f，将它们合并成一棵新树 t2，新树的左孩子为 t1，右孩子为 f，新树的权值为 t1 和 f 的权值之和为 25。新树的树根 t2 加入集合 T，将 t1 和 f 从集合 T 中删除，如图 2-35 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100415960.png" alt="image-20220902100415960"></p></li><li><p>从集合 T 中取出没有双亲且权值最小的两棵树 c 和 e，将它们合并成一棵新树 t3，新树的左孩子为 c，右孩子为 e，新树的权值为 c 和 e 的权值之和为 43。新树的树根 t3 加入集合 T，将 c 和 e 从集合 T 中删除，如图 2-36 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100425130.png" alt="image-20220902100425130"></p></li><li><p>从集合 T 中取出没有双亲且权值最小的两棵树 t2和 b，将它们合并成一棵新树 t4，新树的左孩子为 t2，右孩子为 b，新树的权值为 t2 和 b 的权值之和为 57。新树的树根t4 加入集合 T，将 t2 和 b 从集合 T 中删除，如图 2-37 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100437842.png" alt="image-20220902100437842"></p></li><li><p>从集合 T 中取出没有双亲且权值最小的两棵树 t3和 t4，将它们合并成一棵新树 t5，新树的左孩子为 t4，右孩子为 t3，新树的权值为 t3 和 t4的权值之和为 100。新树的树根 t5 加入集合 T，将 t3 和 t4 从集合 T 中删除，如图 2-38所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100446844.png" alt="image-20220902100446844"></p></li><li><p>T 中只剩下一棵树，哈夫曼树构造成功。</p></li><li><p>约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码，如图 2-39 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902100458042.png" alt="image-20220902100458042"></p></li></ol><h3 id="运行代码：-4"><a href="#运行代码：-4" class="headerlink" title="运行代码："></a>运行代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXBIT</span>    <span class="token expression"><span class="token number">100</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXVALUE</span>  <span class="token expression"><span class="token number">10000</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLEAF</span>   <span class="token expression"><span class="token number">30</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXNODE</span>   <span class="token expression">MAXLEAF<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> weight<span class="token punctuation">;</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>    <span class="token keyword">int</span> lchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> rchild<span class="token punctuation">;</span>    <span class="token keyword">char</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HNodeType<span class="token punctuation">;</span>        <span class="token comment">/* 结点结构体 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> bit<span class="token punctuation">[</span>MAXBIT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HCodeType<span class="token punctuation">;</span>        <span class="token comment">/* 编码结构体 */</span>HNodeType HuffNode<span class="token punctuation">[</span>MAXNODE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 定义一个结点结构体数组 */</span>HCodeType HuffCode<span class="token punctuation">[</span>MAXLEAF<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* 定义一个编码结构体数组*/</span><span class="token comment">/* 构造哈夫曼树 */</span><span class="token keyword">void</span> <span class="token function">HuffmanTree</span> <span class="token punctuation">(</span>HNodeType HuffNode<span class="token punctuation">[</span>MAXNODE<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* i、j： 循环变量，m1、m2：构造哈夫曼树不同过程中两个最小权值结点的权值，       x1、x2：构造哈夫曼树不同过程中两个最小权值结点在数组中的序号。*/</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> x2<span class="token punctuation">;</span>    <span class="token keyword">double</span> m1<span class="token punctuation">,</span>m2<span class="token punctuation">;</span>    <span class="token comment">/* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//权值</span>        HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 输入 n 个叶子结点的权值 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Please input value and weight of leaf node "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin<span class="token operator">>></span>HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token operator">>></span>HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 构造 Huffman 树 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span><span class="token comment">//执行n-1次合并</span>         m1<span class="token operator">=</span>m2<span class="token operator">=</span>MAXVALUE<span class="token punctuation">;</span>         <span class="token comment">/* m1、m2中存放两个无父结点且结点权值最小的两个结点 */</span>        x1<span class="token operator">=</span>x2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/* 找出所有结点中权值最小、无父结点的两个结点，并合并之为一棵二叉树 */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">+</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;</span>m1<span class="token operator">&amp;&amp;</span>HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                m2 <span class="token operator">=</span> m1<span class="token punctuation">;</span>                x2 <span class="token operator">=</span> x1<span class="token punctuation">;</span>                m1 <span class="token operator">=</span> HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>                x1 <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> m2 <span class="token operator">&amp;&amp;</span> HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                m2<span class="token operator">=</span>HuffNode<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>                x2<span class="token operator">=</span>j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 设置找到的两个子结点 x1、x2 的父结点信息 */</span>        HuffNode<span class="token punctuation">[</span>x1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent  <span class="token operator">=</span> n<span class="token operator">+</span>i<span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent  <span class="token operator">=</span> n<span class="token operator">+</span>i<span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>n<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> m1<span class="token operator">+</span>m2<span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>n<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild <span class="token operator">=</span> x1<span class="token punctuation">;</span>        HuffNode<span class="token punctuation">[</span>n<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild <span class="token operator">=</span> x2<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"x1.weight and x2.weight in round "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>HuffNode<span class="token punctuation">[</span>x1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>HuffNode<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">/* 用于测试 */</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 哈夫曼树编码 */</span><span class="token keyword">void</span> <span class="token function">HuffmanCode</span><span class="token punctuation">(</span>HCodeType HuffCode<span class="token punctuation">[</span>MAXLEAF<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    HCodeType cd<span class="token punctuation">;</span>       <span class="token comment">/* 定义一个临时变量来存放求解编码时的信息 */</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cd<span class="token punctuation">.</span>start<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        c<span class="token operator">=</span>i<span class="token punctuation">;</span>        p<span class="token operator">=</span>HuffNode<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>HuffNode<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">==</span>c<span class="token punctuation">)</span>                cd<span class="token punctuation">.</span>bit<span class="token punctuation">[</span>cd<span class="token punctuation">.</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                cd<span class="token punctuation">.</span>bit<span class="token punctuation">[</span>cd<span class="token punctuation">.</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            cd<span class="token punctuation">.</span>start<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment">/*前移一位 */</span>            c<span class="token operator">=</span>p<span class="token punctuation">;</span>            p<span class="token operator">=</span>HuffNode<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>    <span class="token comment">/* 设置下一循环条件 */</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span>cd<span class="token punctuation">.</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>           HuffCode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>bit<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>cd<span class="token punctuation">.</span>bit<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        HuffCode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start<span class="token operator">=</span>cd<span class="token punctuation">.</span>start<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>n<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Please input n:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    <span class="token function">HuffmanTree</span><span class="token punctuation">(</span>HuffNode<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//构造哈夫曼树</span>    <span class="token function">HuffmanCode</span><span class="token punctuation">(</span>HuffCode<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 哈夫曼树编码</span>    <span class="token comment">//输出已保存好的所有存在编码的哈夫曼编码</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>HuffNode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token operator">&lt;&lt;</span><span class="token string">": Huffman code is: "</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>HuffCode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            cout<span class="token operator">&lt;&lt;</span>HuffCode<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>bit<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*Please input n：6Please input value and weight of leaf node 1a 0.05Please input value and weight of leaf node 2b 0.32Please input value and weight of leaf node 3c 0.18Please input value and weight of leaf node 4d 0.07Please input value and weight of leaf node 5e 0.25Please input value and weight of leaf node 6f 0.13*/</span><span class="token comment">//输出</span><span class="token comment">/*x1.weight and x2.weight in round 1 0.05 0.07x1.weight and x2.weight in round 2 0.12 0.13x1.weight and x2.weight in round 3 0.18 0.25x1.weight and x2.weight in round 4 0.25 0.32x1.weight and x2.weight in round 5 0.43 0.57a: Huffman code is: 1000b: Huffman code is: 11c: Huffman code is: 00d: Huffman code is: 1001e: Huffman code is: 01f: Huffman code is: 101*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法解析：-4"><a href="#算法解析：-4" class="headerlink" title="算法解析："></a>算法解析：</h3><ol><li><p>算法复杂度分析：</p><ul><li><p>时间复杂度：由程序可以看出，在函数 HuffmanTree()中，if (HuffNode[j].weight&lt;m1&amp;&amp;HuffNode[j].parent&#x3D;&#x3D;−1)为基本语句，外层 i 与 j 组成双层循环：</p><p>i&#x3D;0 时，该语句执行 n 次；<br>i&#x3D;1 时，该语句执行 n+1 次；<br>i&#x3D;2 时，该语句执行 n+2 次；<br>……<br>i&#x3D;n−2 时，该语句执行 n+n−2 次；<br>则基本语句共执行 n+（n+1）+（n+2）+…+（n+（n−2））&#x3D;（n−1）*（3n−2）&#x2F;2 次（等<br>差数列）；在函数 HuffmanCode()中，编码和输出编码时间复杂度都接近 n2；则该算法时间复<br>杂度为 <strong>O(n2)</strong></p></li><li><p>空间复杂度：所需存储空间为结点结构体数组与编码结构体数组，哈夫曼树数组HuffNode[]中的结点为 n 个，每个结点包含 bit[MAXBIT]和 start 两个域，则该算法空间复杂度为 <strong>O(n*MAXBIT)</strong></p></li></ul></li><li><p>优化拓展：</p><ol><li>函数 HuffmanTree()中找两个权值最小结点时使用优先队列，时间复杂度为 logn，执行 n−1 次，总时间复杂度为 <strong>O( n logn)</strong></li><li>函数 HuffmanCode()中，哈夫曼编码数组 HuffNode[]中可以定义一个动态分配空间的线性表来存储编码，每个线性表的长度为实际的编码长度，这样可以大大节省空间。</li></ol></li></ol><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h3><p>某学校下设 10 个学院，3 个研究所，1 个大型图书馆，4 个实验室。其中，1～10 号节点代表 10 个学院，11～13 号节点代表 3 个研究所，14 号节点代表图书馆，15～18 号节点代表 4 个实验室。该问题用无向连通图 G &#x3D;（V，E）来表示通信网络，V 表示顶点集，E 表示边集。把各个单位抽象为图中的顶点，顶点与顶点之间的边表示单位之间的通信网络，边的权值表示布线的费用。如果两个节点之间没有连线，代表这两个单位之间不能布线，费用为无穷大。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902104007203.png" alt="image-20220902104007203"></p><p>那么我们如何设计网络电缆布线，将各个单位连通起来，并且费用最少呢？</p><p>对于 n 个顶点的连通图，只需 n−1 条边就可以使这个图连通，n−1 条边要想保证图连通，就必须不含回路，所以我们只需要找出 n−1 条<strong>权值最小且无回路的边</strong>即可。</p><h4 id="算法设计：-5"><a href="#算法设计：-5" class="headerlink" title="算法设计："></a>算法设计：</h4><p>如果在一个图中深度搜索或广度搜索有没有回路，是一件繁重的工作。有一个很好的办法—<strong>避圈法</strong>。</p><p>在生成树的过程中，我们把已经在生成树中的结点看作一个集合，把剩下的结点看作另一个集合，从连接两个集合的边中选择一条权值最小的边即可。</p><p>首先任选一个结点，例如 1 号结点，把它放在集合 U 中，U&#x3D;{1}，那么剩下的结点即V−U&#x3D;{2，3，4，5，6，7}，V 是图的所有顶点集合。如图 2-60 所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902104202251.png" alt="image-20220902104202251"></p><p>现在只需在连接两个集合（V 和 V−U）的边中看哪一条边权值最小，把权值最小的边关联的结点加入到集合 U。从图 2-60 可以看出，连接两个集合的 3 条边中，结点 1 到结点 2的边权值最小，选中此条边，把 2 号结点加入 U 集合 U&#x3D;{1，2}，V−U&#x3D;{3，4，5，6，7}。</p><p>再从连接两个集合（V 和 V−U）的边中选择一条权值最小的边。从图 2-61 可以看出，连接两个集合的 4 条边中，结点 2 到结点 7 的边权值最小，选中此条边，把 7 号结点加入 U集合 U&#x3D;{1，2，7}，V−U&#x3D;{3，4，5，6}。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902104251672.png" alt="image-20220902104251672"></p><p>如此下去，直到 U&#x3D;V 结束，选中的边和所有的结点组成的图就是最小生成树。这就是Prim算法。</p><ul><li><p>确定合适的数据结构。设置带权邻接矩阵 C 存储图 G，如果图 G 中存在边（u，x），令 C[u][x]等于边（u，x）上的权值，否则，C[u][x]&#x3D;∞ ；bool 数组 s[]，如果 s[i]&#x3D;true，说明顶点 i 已加入集合 U。可以通过设置两个数组来找到集合中最短的边，closest[j]表示 V−U 中的顶点 j 到集合 U 中的最邻近点，lowcost[j]表示 V−U中的顶点 j 到集合 U 中的最邻近点的边值，即边（j,closest[j]）的权值。</p><p>例如，在图 2-62 中，7 号结点到 U 集合中的最邻近点是 2，closest[7]&#x3D;2，如图 2-63 所示。7 号结点到最邻近点 2 的边值为 1，即边（2，7）的权值，记为 lowcost[7]&#x3D;1，如图 2-64所示。</p><p><img src="/2022/09/01/suan-fa-ru-men-tan-xin-suan-fa/image-20220902104743734.png" alt="image-20220902104743734"></p><p>只需要在 V−U 集合中找 lowcost[]值最小的顶点即可。</p></li><li><p>初始化。令集合 U&#x3D;{u0 }，u0∈V，并初始化数组 closest[]、lowcost[]和 s[]。</p></li><li><p>在 V−U 集合中找 lowcost 值最小的顶点 t，即 lowcost[t]&#x3D;min{lowcost[j]|j∈V−U}，满足该公式的顶点 t 就是集合 V−U 中连接集合 U 的最邻近点。</p></li><li><p>将顶点 t 加入集合 U。</p></li><li><p>如果集合 V−U，算法结束，否则，转步骤 6。</p></li><li><p>对集合 V−U 中的所有顶点 j，更新其 lowcost[]和 closest[]。更新公式：if（C[t][j]&lt;lowcost [j] ) { lowcost [j]&#x3D; C [t] [j]; closest [j] &#x3D; t; }，转步骤 3。</p></li></ul><h4 id="运行代码：-5"><a href="#运行代码：-5" class="headerlink" title="运行代码："></a>运行代码：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-6</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3fffffff</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">bool</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> closest<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> u0<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//顶点个数n、开始顶点u0、带权邻接矩阵C[n][n]</span>    <span class="token comment">//如果s[i]=true,说明顶点i已加入最小生成树</span>    <span class="token comment">//的顶点集合U；否则顶点i属于集合V-U</span>    <span class="token comment">//将最后的相关的最小权值传递到数组lowcost</span>    s<span class="token punctuation">[</span>u0<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//初始时，集合中U只有一个元素，即顶点u0</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>u0<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">[</span>u0<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            closest<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>u0<span class="token punctuation">;</span>            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//在集合中V-u中寻找距离集合U最近的顶点t</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp<span class="token operator">=</span>INF<span class="token punctuation">;</span>        <span class="token keyword">int</span> t<span class="token operator">=</span>u0<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                t<span class="token operator">=</span>j<span class="token punctuation">;</span>                temp<span class="token operator">=</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span>u0<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>       <span class="token comment">//找不到t，跳出循环</span>        s<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>     <span class="token comment">//否则，讲t加入集合U</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//更新lowcost和closest</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                closest<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>        <span class="token keyword">int</span> u0<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数n和边数m:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token operator">>></span>m<span class="token punctuation">;</span>        <span class="token keyword">int</span> sumcost<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数u,v和边值w:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>u<span class="token operator">>></span>v<span class="token operator">>></span>w<span class="token punctuation">;</span>            c<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>w<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入任一结点u0:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span> u0 <span class="token punctuation">;</span>        <span class="token comment">//计算最后的lowcos的总和，即为最后要求的最小的费用之和</span>        <span class="token function">Prim</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> u0<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"数组lowcost的内容为"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>           sumcost <span class="token operator">+=</span> lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小的花费是："</span><span class="token operator">&lt;&lt;</span>sumcost<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*输入结点数 n 和边数 m：7 12输入结点数 u，v 和边值 w：1 2 231 6 281 7 362 3 202 7 13 4 153 7 44 5 34 7 95 6 175 7 166 7 25输入任一结点 u0：1*/</span><span class="token comment">//输出</span><span class="token comment">/*数组 lowcost 的内容为：0 23 4 9 3 17 1最小的花费是：57*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法解析：-5"><a href="#算法解析：-5" class="headerlink" title="算法解析："></a>算法解析：</h4><ol><li><p>算法复杂度分析：</p><ul><li>时间复杂度：在 Prim（int n，int u0，int c[N][N]）算法中，一共有 4 个 for 语句，第①个 for 语句的执行次数为 n，第②个 for 语句里面嵌套了两个 for 语句③、④，它们的执行次数均为 n，对算法的运行时间贡献最大。当外层循环标号为 1 时，③、④语句在内层循环的控制下均执行 n 次，外层循环②从 1～n。因此，该语句的执行次数为 n*n&#x3D;n²，算法的时间复杂度为 <strong>O(n²)</strong></li><li>空间复杂度：算法所需要的辅助空间包含 i、j、lowcost 和 closest，则算法的空间复杂度是 <strong>O(n)</strong></li></ul></li><li><p>优化拓展：</p><ol><li>for 语句③找 lowcost 最小值时使用优先队列，每次出队一个最小值，时间复杂度为logn，执行 n 次，总时间复杂度为 <strong>O( n logn)</strong></li><li>for 语句④更新 lowcost 和 closest 数据时，如果图采用邻接表存储，每次只检查t的邻接边，不用从 1～n 检查，检查更新的次数为 E（边数），每次更新数据入队，入队的时间复杂度为 logn，这样更新的时间复杂度为 <strong>O( Elogn)</strong></li></ol></li></ol><h3 id="Kurskal算法："><a href="#Kurskal算法：" class="headerlink" title="Kurskal算法："></a>Kurskal算法：</h3><h4 id="算法设计：-6"><a href="#算法设计：-6" class="headerlink" title="算法设计："></a>算法设计：</h4><p>构造最小生成树还有一种算法，Kurskal 算法：设 G&#x3D;（V，E）是无向连通带权图，V&#x3D;{1，2，…，n}；设最小生成树 T&#x3D;（V，TE），该树的初始状态为只有 n 个顶点而无边的非连通图T&#x3D;（V，{}），Kruskal 算法将这 n 个顶点看成是 n 个孤立的连通分支。它首先将所有的边按权值从小到大排序，然后只要 T 中选中的边数不到 n−1，就做如下的贪心选择：在边集 E 中选取权值最小的边（i，j），如果将边（i，j）加入集合 TE 中不产生回路（圈），则将边（i，j）加入边集 TE 中，即用边（i，j）将这两个连通分支合并连接成一个连通分支；否则继续选择下一条最短边。把边（i，j）从集合 E 中删去。继续上面的贪心选择，直到 T 中所有顶点都在同一个连通分支上为止。此时，选取到的 n−1 条边恰好构成 G 的一棵最小生成树 T。</p><p>怎样判断加入某条边后图 T 会不会出现回路呢？</p><p>Kruskal 算法用了一个非常聪明的方法，就是运用<strong>集合避圈</strong>：<strong>如果所选择加入的边的起点和终点都在 T 的集合中，那么就可以断定一定会形成回路（圈）。</strong></p><h4 id="运行代码：-6"><a href="#运行代码：-6" class="headerlink" title="运行代码："></a>运行代码：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-7</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> nodeset<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">;</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">comp</span><span class="token punctuation">(</span>Edge x<span class="token punctuation">,</span> Edge y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        nodeset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> nodeset<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> q <span class="token operator">=</span> nodeset<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span>q<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//检查所有结点，把集合号是 q 的改为 p</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nodeset<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>q<span class="token punctuation">)</span>        nodeset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//a 的集合号赋值给 b 集合号</span><span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Merge</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token punctuation">,</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数n和边数m:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>        <span class="token function">Init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数u,v和边值w:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            cin<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> e<span class="token operator">+</span>m<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小的花费是："</span> <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法解析：-6"><a href="#算法解析：-6" class="headerlink" title="算法解析："></a>算法解析：</h4><ol><li><p>算法复杂度分析：</p><ul><li>时间复杂度：算法中，需要对边进行排序，若使用快速排序，执行次数为 e<em>loge，算法的时间复杂度为 O(e</em>loge)。而合并集合需要 n−1 次合并，每次为 O(n)，合并集合的时间复杂度为 <strong>O(n^2)</strong></li><li>空间复杂度：算法所需要的辅助空间包含集合号数组 nodeset[n]，则算法的空间复杂度是 <strong>O(n)</strong></li></ul></li><li><p>优化拓展：</p><ol><li><p>该算法合并集合的时间复杂度为 O(n2 )，我们可以用并查集的思想优化，使合并集合的时间复杂度降为 *<em>O(e</em>logn)**，优化后的程序如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//program 2-7-1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> father<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">;</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">comp</span><span class="token punctuation">(</span>Edge x<span class="token punctuation">,</span> Edge y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>        father<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span>q<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">></span> q<span class="token punctuation">)</span>        father<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token comment">//小的赋值给大的集合号</span>    <span class="token keyword">else</span>        father<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Merge</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token punctuation">,</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数n和边数m:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>        <span class="token function">Init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"输入结点数u,v和边值w:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            cin<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token operator">>></span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> e<span class="token operator">+</span>m<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小的花费是："</span> <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输入</span><span class="token comment">/*输入结点数 n 和边数 m：7 12输入结点数 u，v 和边值 w：1 2 231 6 281 7 362 3 202 7 13 4 153 7 44 5 34 7 95 6 175 7 166 7 25*/</span><span class="token comment">//输出</span><span class="token comment">//最小的花费:57</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ol><p><strong>本文摘录于《趣学算法》一书，欲学习其他算法请购买正版书籍！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门-算法复杂性</title>
      <link href="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/"/>
      <url>/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="算法复杂性"><a href="#算法复杂性" class="headerlink" title="算法复杂性"></a>算法复杂性</h2><blockquote><p>算法是指对特定问题求解步骤的一种描述。</p></blockquote><p>算法具有以下特性：</p><ul><li><strong>有穷性</strong>：算法是由若干条指令组成的有穷序列，总是在执行若干次后结束，不可能永不停止。</li><li><strong>确定性</strong>：每条语句有确定的含义，无歧义。</li><li><strong>可行性</strong>：算法在当前环境条件下可以通过有限次运算实现。</li><li><strong>输入输出</strong>：有零个或多个输入，一个或多个输出。</li></ul><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><blockquote><p>算法运行需要的时间，一般将<strong>算法的执行次数</strong>作为时间复杂度的度量标准。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//算法 1-3</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//运行1次</span>total<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//运行1次</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//运行n次</span><span class="token punctuation">&#123;</span>  sum<span class="token operator">=</span>sum<span class="token operator">+</span>i<span class="token punctuation">;</span><span class="token comment">//运行n次</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//运行n*(n+1)次</span>total<span class="token operator">=</span>total<span class="token operator">+</span>i<span class="token punctuation">;</span><span class="token comment">//运行n*n次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把算法的所有语句的运行次数加起来：1+1+<em>n</em>+1+<em>n</em>+<em>n</em>×(<em>n</em>+1)+<em>n</em>×<em>n</em>，可以用一个函数T(n)表达：<br>$$<br>T(n)&#x3D;2n^2+3n+3<br>$$<br>当n足够大时,我们可以看到算法运行时间主要取决于第一项，后面的甚至可以忽略不计。<br>用极限表示为：<br>$$<br>\lim_{n\rightarrow\infty}\frac{T(n)}{f(n)}&#x3D;C≠0，C为不等于0的常数<br>$$<br>如果用<strong>时间复杂度的渐近上界</strong>表示，如图1-1所示。</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830204543034.png" alt="image-20220830204543034"></p><p>从图1-1中可以看出，当n≥n0时，T(m)≤Cf(n)，当n足够大时，T(n)和f(n)近似相等。因此，我们用O(f(n))来表示时间复杂度渐近上界，通常用这种表示法衡量算法时间复杂度。算法1-3的时间复杂度渐近上界为O(f(n))&#x3D;O(n^2)，用极限表示为：<br>$$<br>\lim_{n\rightarrow\infty}\frac{T(n)}{f(n)}&#x3D;\frac{2n^2+3n+3}{n^2}&#x3D;2≠0<br>$$<br>还有<strong>渐近下界</strong>符号Ω(T(n)≥Cf(n))，如图1-2所示。</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830205123640.png" alt="image-20220830205123640"></p><p>从图1-2可以看出，当n≥n0时，T(n)≥Cf(n)，当n足够大时，T(n)和f(n)近似相等，因此，我们用Ω(f(n))来表示时间复杂度渐近下界。<br><strong>渐近精确界</strong>符号Θ(C1f(n)≤T(n)≤C2f(n))，如图1-3所示。</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830210210688.png" alt="image-20220830210210688"></p><p>从图1-3中可以看出，当n≥n0时，C1f(n)≤T(n)≤C2f(n)，当n足够大时，T(n)和f(n)近似相等。这种两边逼近的方式，更加精确近似，因此，用<br>Θ(f(n))来表示时间复杂度渐近精确界。<br>我们通常使用<strong>时间复杂度渐近上界</strong>O(f(n))来表示时间复杂度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//算法1-4</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//运行1次</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span><span class="token comment">//可假设运行x次</span><span class="token punctuation">&#123;</span>i<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//可假设运行x次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察算法1-4，无法立即确定while及i&#x3D;i*2运行了多少次。这时可假设运行了x次，每次运算后i值为2，2^2，2^3，…，2^x，当i&#x3D;n时结束，即2^x&#x3D;n时结束，则x&#x3D;log2(n)，那么算法1-4的运算次数为1+2log2(n)，时间复杂度渐近上界为O(f(n))&#x3D;O(log2(n))。</p><blockquote><p>注意：不是每个算法都能直接计算运行次数</p></blockquote><p>有些算法，如排序、查找、插入等算法，可以分为<strong>最好</strong>、<strong>最坏</strong>和<strong>平均</strong>情况分别求算法渐近复杂度，但我们考查一个算法通常考查最坏的情况，而不是考查最好的情况，<strong>最坏情况对衡量算法的好坏具有实际的意义</strong>。</p><h3 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h3><blockquote><p>算法占用的空间大小。一般将算法的<strong>辅助空间</strong>作为衡量空间复杂度的标准。</p></blockquote><p>空间复杂度的本意是指算法在运行过程中占用了多少存储空间。算法占用的存储空间包括：</p><ol><li>输入&#x2F;输出数据</li><li>算法本身</li><li>额外需要的辅助空间</li></ol><p>输入输出数据占用的空间是必需的，算法本身占用的空间可以通过精简算法来缩减，但这个压缩的量是很小的，可以忽略不计。而在运行时使用的辅助变量所占用的空间，即辅助空间是衡量空间复杂度的关键因素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//算法1-6</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token comment">//x与y交换</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp<span class="token punctuation">;</span>temp<span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token comment">//temp为辅助空间</span>x<span class="token operator">=</span>y<span class="token punctuation">;</span>y<span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法使用了一个辅助空间temp，空间复杂度为O(1)。</p><blockquote><p>注意：递归算法中，每一次递推需要一个栈空间来保存调用记录，因此，空间复杂度需要计算递归栈的辅助空间。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//算法1-7</span><span class="token function">fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n&lt;0 data error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">fac</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="斐波那契数列："><a href="#斐波那契数列：" class="headerlink" title="斐波那契数列："></a>斐波那契数列：</h2><p>根据斐波那契数列的定义，直接设计一个递归算法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Fib1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">Fib1</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">Fib1</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，n&gt;2时要分别调用Fib1(n-1)、Fib1(n-2)和执行一次加法运算，即：</p><p>n&gt;2时，T(n) &#x3D; T(n-1) + T(n-2) + 1;</p><p>递归表达式和时间复杂度T(n)之间的关系如下：</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830214752191.png" alt="image-20220830214752191"></p><p>由此可得：T(n)≥F(n)。</p><p><img src="/2022/08/30/suan-fa-ru-men-suan-fa-fu-za-xing/image-20220830214934155.png" alt="image-20220830214934155"></p><p>由于T(n)≥F(n)，这是一个指数阶的算法！复杂度属于爆炸增量函数，这在算法设计时应当避开的，那么我们可以改进它呢？</p><p>既然斐波那契数列中的每一项是前两项之和，如果记录前两项的值，只需要一次加法运算就可以得到当前项，时间复杂度会不会更低一些？我们用数组试试看：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Fib2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，算法的时间复杂度为O(n)。时间复杂度却从<strong>指数阶降到了多项式阶</strong>，这是算法效率的一个巨大突破！</p><p>其实我们只需要得到第n个斐波那契数，中间结果只是为了下一次使用，根本不需要记录。因此我们采用<strong>迭代法</strong>进行算法设计：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Fib3</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>s1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>s2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>s2<span class="token operator">=</span>s1<span class="token operator">+</span>s2<span class="token punctuation">;</span><span class="token comment">//辗转相加法</span>s1<span class="token operator">=</span>s2<span class="token operator">-</span>s1<span class="token punctuation">;</span><span class="token comment">//记录前一项</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> s2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进一步讨论：我们能不能继续降阶，使算法时间复杂度更低呢？</p><p><strong>本文摘录于《趣学算法》一书，欲学习其他算法请购买正版书籍！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UESTC研究生选课</title>
      <link href="/2022/08/25/uestc-yan-jiu-sheng-xuan-ke/"/>
      <url>/2022/08/25/uestc-yan-jiu-sheng-xuan-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="选课"><a href="#选课" class="headerlink" title="选课"></a>选课</h2><h3 id="学位课-目前已选17分"><a href="#学位课-目前已选17分" class="headerlink" title="学位课 目前已选17分"></a>学位课 目前已选17分</h3><p>算法设计与分析（2班）–陈佳 2学分秋</p><p>随机过程与排队论（小班研讨）–顾小丰 2学分秋</p><p>工程伦理与学术道德（9班）–谢小东 1学分春与秋</p><p>新时代中国特色社会主义理论与实践（沙河二班）–曹银忠 2学分秋</p><p>图论及应用（15班）–王也洲 3学分春</p><p>网络计算模式（1班）–丁熠 2学分春</p><p>高级计算机结构（不要选吴晓华的）或选其他学位课</p><p>硕士研究生学位英语–庞慧 3学分春与秋</p><h3 id="非学位课-目前已选10分"><a href="#非学位课-目前已选10分" class="headerlink" title="非学位课 目前已选10分"></a>非学位课 目前已选10分</h3><p>Unix&#x2F;Linux操作系统内核结构（2班）–刘玓 2学分秋</p><p>网络安全理论与技术（2班）–李树全 2学分秋</p><p>网络编程–任立勇 2学分秋</p><p>高级数字图像处理–甘涛 2学分秋</p><p>研究生论文写作指导课程（2班）–李晓瑜 1学分春</p><p>自然辩证法概论（沙河4班）–不要选郭芙蕊 1学分春</p><h3 id="教学实践环节-目前已选6分"><a href="#教学实践环节-目前已选6分" class="headerlink" title="教学实践环节 目前已选6分"></a>教学实践环节 目前已选6分</h3><p>逆向工程–何兴高 2学分春</p><p>基地实践 4学分春与秋</p><h3 id="必修环节-目前已选5-5分"><a href="#必修环节-目前已选5-5分" class="headerlink" title="必修环节 目前已选5.5分"></a>必修环节 目前已选5.5分</h3><p>学术资源的使用与分析3班–曹学艳 1学分秋</p><p>教学实践或创新创业与社会实践 1学分春与秋</p><p>论文开题报告 1学分春与秋</p><p>论文中期报告 1学分春与秋</p><p>学术活动 1学分春与秋</p><p>上学期的课：</p><p><img src="/2022/08/25/uestc-yan-jiu-sheng-xuan-ke/image-20220825220711481.png" alt="image-20220825220711481"></p><p>下学期的课：</p><p><img src="/2022/08/25/uestc-yan-jiu-sheng-xuan-ke/image-20220825220804082.png" alt="image-20220825220804082"></p><h3 id="上学期已选学分："><a href="#上学期已选学分：" class="headerlink" title="上学期已选学分："></a>上学期已选学分：</h3><p>学位课：5分</p><p>非学位课：8分</p><p>必修环节：1分</p><p>实践教学环节：0分</p><h3 id="下学期应选学分："><a href="#下学期应选学分：" class="headerlink" title="下学期应选学分："></a>下学期应选学分：</h3><p>学位课：6分（学位英语3学分，新中特2学分）</p><ul><li>网络计算模式 2学分</li><li>图论及应用 3学分</li><li>软件架构模型与设计 2学分</li></ul><p>非学位课：1分</p><ul><li>研究生论文写作指导课程 1学分</li></ul><p>必修环节：4分</p><ul><li>教学实践或创新创业与社会实践 1学分</li><li>学术活动 1学分</li><li>论文开题报告 1学分</li><li>论文中期报告 1学分</li></ul><p>实践教学环节：6分</p><ul><li>基地实践 4学分</li><li>逆向工程 2学分</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硕士生涯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Vite快速建立一个Vue项目</title>
      <link href="/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/"/>
      <url>/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h3 id="使用Vite创建Vue项目："><a href="#使用Vite创建Vue项目：" class="headerlink" title="使用Vite创建Vue项目："></a>使用Vite创建Vue项目：</h3><ol><li><p>在全局安装好node.js环境的前提下，切换到你想要创建项目的目录下，终端输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> init vite@latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Vite在安装项目时不会主动安装依赖，所以需要手动安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动项目：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="Vite3-0更新内容："><a href="#Vite3-0更新内容：" class="headerlink" title="Vite3.0更新内容："></a>Vite3.0更新内容：</h3><p>2022年7月，Vite3.0版本正式发布，有以下更新内容：</p><ol><li><p><strong>CLI的更新</strong>：</p><p>在执行 vite 命令启动项目时，终端的界面和之前会有所不同，而更重要的是，为了避免 Vite 开发服务的端口和别的应用冲突，默认的端口号从之前的 3000 变成了 <strong>5173</strong>。</p></li><li><p><strong>开箱即用的 WebSocket 连接策略</strong>：</p><p>Vite 2 中有存在一个痛点，即在存在代理的情况下(比如 Web IDE)需要我们手动配置 WebSocket 使 HMR 生效。目前 Vite 内置了一套更加完善的 WebSocket 连接策略，自动满足更多场景的 HMR 需求。</p></li><li><p><strong>服务冷启动性能提升</strong>：</p><p>Vite 3.0 在服务冷启动方面做了非常多的工作，来最大程度提升项目启动的速度。</p><p>首先我们来盘点一下 Vite 2.x 阶段服务冷启动的一些问题。</p><p>从 Vite 2.0 到 2.9 版本之前，Vite 会在服务启动之前进行依赖预构建，也就是使用 Esbuild 将项目中使用到的依赖扫描出来(Scan)，然后分别进行一次打包(Optimize)。</p><p><img src="/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/c3cfb6a684fa99a5c3041509de0efe32d14316.png"></p><p>这样会造成两个问题：</p><blockquote><ul><li>依赖预构建会阻塞 Dev Server 启动，但其实不阻塞的情况下，Dev Server 也可以正常启动。</li><li>当某些 Vite 插件手动注入了 import 语句，比如调用babel-plugin-import 添加import Button from ‘antd&#x2F;lib&#x2F;button’，就会导致 Vite 的二次预构建，因为antd&#x2F;lib&#x2F;button 的引入代码由 Vite 插件注入，属于 Dev Server 运行时发现的依赖，冷启动阶段无法扫描到。</li></ul></blockquote><p>所谓的二次预构建包含两个步骤，一是需要将所有的依赖全量预构建，二是由于依赖更新，页面需要进行 reload，加载最新的依赖代码。这样会导致 Dev Server 性能明显下降，尤其是在新增依赖较多的场景下，很容易出现浏览器卡住的情况。因此二次预构建也是需要极力避免的。当时 vite-plugin-optimize-persist就是为了解决二次预构建带来的问题，通过持久化的方式记录 Dev Server 运行时扫描到的依赖，从而让首次预构建便可以感知到，避免二次预构建的发生。</p><p>到了 2.9 版本，Vite 将预构建的逻辑做了一次整体的重构，最后的效果是下面这样的：</p><ul><li><p>Dev Server 启动后预构建(Optimize 阶段)在后台执行，也就是预构建不再阻塞 Dev Server 的启动，只需要等待 Scan 阶段完成，不过通常这个阶段的开销非常小。</p><p><img src="/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/321e2ec83707448c7ff3914fd6007c66cec4bc.png"></p></li><li><p>如果某些依赖是 Dev Server 运行时才发现的，那么 Vite 会尽可能地复用已有预构建产物，尽量不进行 page reload。</p></li></ul><p>那问题就完全解决了吗？其实并不是，在某些场景下，Vite 仍然不可避免地需要二次预构建。如下面的这个例子：</p><p><img src="/2022/08/19/shi-yong-vite-kuai-su-jian-li-yi-ge-vue-xiang-mu/b8775ee25f447b0377145799ba9b0d9b29fbdd.png"></p><p>A 和 B 都是项目的第三方依赖，它们也同时依赖 C。那么当 Vite 预构建 A 的时候，将会 A 和 C 一起进行打包。但 Vite 在运行时发现了依赖 B，而 A 和 B 需要共享 C 的代码，这样 C 的代码可能就会被抽离成一个公共的 chunk，因此之前 A 的预构建产物可能就发生变化了，那么此时 Vite 必须要强制刷新页面，让浏览器使用最新的预构建产物。这仍然是一个二次预构建(所有依赖再次打包 + page reload)的过程。</p><p>总体而言，2.9 版本解决了预构建阻塞服务启动的问题，但并没有完全解决二次预构建的问题。</p><p>但在 Vite 3.0，二次预构建的问题也得到了根本的解决。那 Vite 3.0 是如何做到的呢？</p><p>核心的解决思路在于<strong>延迟处理</strong>，<strong>即把预构建的行为延迟到页面加载的最后阶段进行</strong>，此时 Vite 已经编译完了所有的源文件，可以准确地记录下所有需要预构建的依赖(包括 Vite 插件添加的一些依赖)，然后统一进行预构建，将预构建的产物响应给给浏览器即可。</p><p>因此，与 Vite 2.0 相比，Vite 3.0 在冷启动阶段所做的优化主要有两个方面：</p><blockquote><ul><li>预构建不再阻塞 Dev Server 的启动，真正做到服务秒启动的效果。</li><li>从根本上防止二次预构建的发生。</li></ul></blockquote></li><li><p><strong>import.meta.glob 语法更新</strong>：</p><ol><li><p>Vite 3.0 中重写对 import.meta.glob 的实现进行了重写，支持了更加灵活的 glob 语法，增加了如下的一些特性：</p><ul><li>多种模式匹配：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token string">"./another/*.js"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>否定模式(!)：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token string">"!**/bar.js"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>命名导入，可以更好地做到 Tree Shaking：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token keyword">import</span><span class="token operator">:</span> <span class="token string">"setup"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>自定义 query 参数：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">custom</span><span class="token operator">:</span> <span class="token string">"data"</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指定 eager 模式，替换掉原来import.meta.globEager：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"./dir/*.js"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">eager</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p><strong>SSR 产物默认使用 ESM 格式</strong>：</p><p>在当下的社区生态中，众多 SSR 框架已经在使用 ESM 格式作为默认的产物格式。Vite 3.0 也积极拥抱社区，支持 SSR 构建默认打包出 ESM 格式的产物。</p></li><li><p><strong>Relative Base 支持</strong>：</p><p>Vite 3.0 正式支持 Relative Base(即配置base: ‘’)，主要用于构建时无法确定 base 地址的场景。</p></li><li><p><strong>更细粒度的 base 配置</strong>：</p><p>在某些场景下，我们需要将不同的资源部署到不同的 CDN 上，比如将图片部署到单独的 CDN，和 JS&#x2F;CSS 的部署服务区分开来。但 2.x 的版本仅支持统一的部署域名，即base 配置。在 3.0 中，你可以通过 renderBuiltUrl 进行更细粒度的配置：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token literal-property property">experimental</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">renderBuiltUrl</span><span class="token operator">:</span> <span class="token punctuation">(</span>filename<span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">hostType</span><span class="token operator">:</span> <span class="token string">'js'</span> <span class="token operator">|</span> <span class="token string">'css'</span> <span class="token operator">|</span> <span class="token string">'html'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>hostType <span class="token operator">===</span> <span class="token string">'js'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">runtime</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">window.__toCdnUrl(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'https://cdn.domain.com/assets/'</span> <span class="token operator">+</span> filename      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//目前该配置项还不稳定 ，可能会在之后的 minor 版本修改。具体文档见 https://vitejs.dev/guide/build.html#advanced-base-options</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Esbuild 预构建用于生产环境</strong>：</p><p>这应该是 Vite 架构上非常大的一个改动: 将原来仅仅用于开发阶段的依赖预构建功能应用在生产环境。在 Vite 2.x 中，开发阶段使用 Esbuild 来打包依赖，而在生产环境使用 Rollup 进行打包，用 @rollupjs&#x2F;plugin-commonjs 来处理 cjs 的依赖，这样做会导致依赖处理的不一致问题，造成一些生产构建中的 bug。</p><p>但 Vite 3.0 中支持通过配置将 Esbulid 预构建同时用于开发环境和生产环境，仅添加optimizeDeps.disabled: false 的配置即可。不过这个改动确实比较大，Vite 团队不打算将此作为 v3 的正式更新内容，而是一个实验性质的功能，不会默认开启。</p><p>顺便提一句，Rollup 将在接下来的几个月发布 v3 的大版本，要知道，Rollup 2.0 发布至今已经过去 2 年多的时间了，无论是 Rollup 还是 Vite 来讲，这都是一次非常重大的变更。由于 Vite 的架构非常依赖 Rollup，在 Rollup 发布 v3 之后，Vite 也将跟随着发布 Vite 的第 4 个 major 版本。所以，Vite 4.0 的到来也不远啦：）</p></li><li><p><strong>仓库内部的变化</strong>：</p><p>除了本身功能上的演进，Vite 的仓库本身也产生了不少的变化，从中我们也能了解到社区的一些动向:</p><ul><li>不再支持 Nodejs 12，需要 Node.js 14.18+ 的版本。</li><li>单元测试和 E2E 测试从 Jest 完全迁移到 Vitest，一方面 Vitest 更快、体验更好，另一方面也能在 Vite 这样大型的仓库完善 Vitest 的生态，进一步提升 Vitest 稳定性。</li><li>VitePress 文档部分也参与 CI 流程。</li><li>包管理器 pnpm 迁移至 v7。</li><li>不管是Vite 本身的包还是 E2E 中测试的项目，都在 package.json 中声明type: “module”，即 Pure ESM 包，对外提供 ESM 格式的产物，将社区 Pure ESM 的趋势又推动了一步。</li><li>官方所有的 Vite 插件都采用unbuild(新一代库构建工具) 进行构建，pluin-vue-jsx 和plugin-legacy 均迁移到了 TS 上。</li><li>包体积优化。3.0 进一步优化 Vite 本身的产物和 node_modules 体积，将terser 和node-forge 的依赖移除，让用户进行按需安装(node-forge 的功能是实现 https 证书生成，可用@vitejs&#x2F;plugin-basic-ssl 插件替代)，效果如下：</li></ul><table><thead><tr><th></th><th>Publish Size</th><th>Install Size</th></tr></thead><tbody><tr><td>Vite 2.9.14</td><td>4.38MB</td><td>19.1MB</td></tr><tr><td>Vite 3.0.0</td><td>3.05MB</td><td>17.8MB</td></tr><tr><td>Reduction</td><td>-30%</td><td>-7%</td></tr></tbody></table><p>不得不说在自身包体积的优化方面， Vite 对于还是做的很细致的，这也是很多库开发者忽视的一点，有时候加个插件就得安装动辄上百 MB 的依赖，导致项目的 node_modules 最后变得非常臃肿，此时不妨学习一下 Vite 是怎么优化自身体积的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Vue中的组件知识</title>
      <link href="/2022/08/19/guan-yu-vue-zhong-de-zu-jian-zhi-shi/"/>
      <url>/2022/08/19/guan-yu-vue-zhong-de-zu-jian-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="创建组件的注意事项："><a href="#创建组件的注意事项：" class="headerlink" title="创建组件的注意事项："></a>创建组件的注意事项：</h3><blockquote><p>在HTML模板中使用组件时，首字母大写的形式只能在template配置项中的HTML代码中使用，或者在单文件组件的HTML中使用。</p><p>如果在像index.html这种纯html文件中使用组件时，必须使用<strong>小写单词+短横线</strong>的形式。</p><p>定义名字的时候尽量使用两个或以上的单词，避免和原生的HTML标签名冲突。</p><p>组件数据的流向设计：<strong>属性向下，事件向上</strong>，即父组件只能向子组件传递数据，子组件不能修改父组件的属性，父组件也不能访问子组件中的属性，子组件可通过事件触发父组件中的事件。</p></blockquote><h3 id="props："><a href="#props：" class="headerlink" title="props："></a>props：</h3><blockquote><p>组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。父组件的数据需要通过 prop 才能下发到子组件中。也就是<code>props</code>是<strong>子组件访问父组件数据的唯一接口</strong>。</p><ul><li>单向数据流</li><li>父组件属性变化，子组件自动刷新</li><li>子组件不能直接修改父组件属性</li></ul></blockquote><p>你可以基于对象的语法使用以下选项：</p><ul><li><code>type</code>: 可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的<a href="vue/guide/components-props.html#Prop-%E7%B1%BB%E5%9E%8B">更多信息在此</a>。</li><li><code>default</code>: <code>any</code><br>为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。</li><li><code>required</code>: <code>Boolean</code><br>定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。</li><li><code>validator</code>: <code>Function</code><br>自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在<a href="vue/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81">这里</a>查阅更多 prop 验证的相关信息。</li></ul><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"sender"</span><span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"time"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>     <span class="token literal-property property">isStudent</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>         <span class="token literal-property property">type</span><span class="token operator">:</span>Boolean<span class="token punctuation">,</span>         <span class="token keyword">default</span><span class="token operator">:</span><span class="token boolean">true</span> <span class="token comment">// 可声明默认值</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 不同类型的数据，注意默认值的返回类型</span><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">type</span><span class="token operator">:</span> Object<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">"abc"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">followers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">type</span><span class="token operator">:</span> Array<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 即使是空数组，也需要从函数中返回</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">handleClick</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">type</span><span class="token operator">:</span> Function<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"点击事件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>   <span class="token literal-property property">time</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>     <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>     <span class="token comment">// 可以在props中校验数据</span>     <span class="token function">validator</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> value <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token literal-property property">sender</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>     <span class="token literal-property property">type</span><span class="token operator">:</span> String<span class="token punctuation">,</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>     <span class="token literal-property property">type</span><span class="token operator">:</span> String<span class="token punctuation">,</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父组件中，首先需要引入组件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageItem <span class="token keyword">from</span> <span class="token string">"./components/MessageItem.vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    MessageItem  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>向子组件传值：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> <span class="token comment">&lt;!-- 使用v-bind才可以传送数据本身的属性值 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageItem</span>  <span class="token attr-name">:user</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>&#123;haha:222&#125;</span> <span class="token attr-name">:time</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>2022</span> <span class="token attr-name">sender</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>q<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageItem</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="emit："><a href="#emit：" class="headerlink" title="emit："></a>emit：</h3><blockquote><p>子组件可以使用 $emit <strong>触发父组件的自定义事件</strong>。</p><p>Vue虽然也支持通过props向父组件传递数据，但如此做子组件就会<strong>依赖</strong>父组件，即如果父组件没有传递参数，且子组件的事件处理函数也没有默认值，那么子组件调用事件处理函数就会报出异常；而使用emit事件传递则没有这个问题，如果父组件不处理子组件的事件也没有任何问题，因为子组件不依赖父组件的事件监听。</p></blockquote><ul><li><p>参数</p><ul><li><code>&#123;string&#125; eventName</code></li><li><code>[...args]</code></li></ul><p>触发当前实例上的事件。附加参数都会传给监听器回调。</p></li><li><p>示例</p><p>在子组件中，定义emits数组以及触发事件，可添加多个参数：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"deletePosts"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>deletePosts<span class="token punctuation">'</span>, 5)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可自定义方法，例如：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPosts(5)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token function">selectPosts</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"deletePosts"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// selectPosts事件触发后，自动触发deletePosts事件</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父组件中，首先需要引入组件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageItem <span class="token keyword">from</span> <span class="token string">"./components/MessageItem.vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    MessageItem  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件触发方法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MessageItem</span>  <span class="token attr-name">@deletePosts</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>handleDeletePosts<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MessageItem</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MessageItem <span class="token keyword">from</span> <span class="token string">"./components/MessageItem.vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    MessageItem  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token function">handleDeletePosts</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="provide和inject："><a href="#provide和inject：" class="headerlink" title="provide和inject："></a>provide和inject：</h3><blockquote><p>在实际开发中，可能需要传递数据到更深层次的组件，例如子组件的子组件，即使中间的组件没有用到这个属性也要层层传递。</p></blockquote><p>Vue中提供了<code>provide</code>配置项来向<strong>所有下层组件</strong>传递数据，而用到数据的组件可以使用<code>inject</code>配置项来获取数据：</p><ul><li><strong>类型</strong>：<ul><li><strong>provide</strong>：<code>Object | () =&gt; Object</code></li><li><strong>inject</strong>：<code>Array&lt;string&gt; | &#123; [key: string]: string | Symbol | Object &#125;</code></li></ul></li></ul><p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</p><p><code>provide</code> 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 <code>Symbol</code> 和 <code>Reflect.ownKeys</code> 的环境下可工作。</p><p><code>inject</code> 选项应该是：</p><ul><li>一个字符串数组，或</li><li>一个对象，对象的 key 是本地的绑定名，value 是：<ul><li>在可用的注入内容中搜索用的 key (字符串或 Symbol)，或</li><li>一个对象，该对象的：<ul><li><code>from</code> 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)</li><li><code>default</code> 属性是降级情况下使用的 value</li></ul></li></ul></li></ul><blockquote><p>注意：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote><ul><li><p>示例：</p><p>MovieCard.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieItem</span>      <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>movie.title<span class="token punctuation">"</span></span>      <span class="token attr-name">:description</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>movie.description<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieItem <span class="token keyword">from</span> <span class="token string">"./MovieItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MovieItem<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">movie</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"电影"</span><span class="token punctuation">,</span>        <span class="token literal-property property">description</span><span class="token operator">:</span> <span class="token string">"这是一段电影的描述"</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.card</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MovieItem.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieTitle</span> <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    &#123;&#123; description &#125;&#125;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieTitle <span class="token keyword">from</span> <span class="token string">"./MovieTitle.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MovieTitle <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"title"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.description</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 10%<span class="token punctuation">,</span> 88%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MovieTitle.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"title"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">h2</span> <span class="token punctuation">&#123;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出组件的层级关系，中间组件尽管没有使用到title属性，但仍需要将其加入到props配置项中，向下传递到MovieTitle.vue文件中。若使用<code>provide</code>和<code>inject</code>配置项，则简洁很多：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- &lt;MovieItem :title="movie.title" :description="movie.description" /> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieItem</span> <span class="token attr-name">:description</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>movie.description<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieItem <span class="token keyword">from</span> <span class="token string">"./MovieItem.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    MovieItem<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">movie</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"电影"</span><span class="token punctuation">,</span>        <span class="token literal-property property">description</span><span class="token operator">:</span> <span class="token string">"这是一段电影的描述"</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">provide</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"测试电影"</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.card</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- &lt;MovieTitle :title="title" /> --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MovieTitle</span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    &#123;&#123; description &#125;&#125;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> MovieTitle <span class="token keyword">from</span> <span class="token string">"./MovieTitle.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> MovieTitle <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// props: ["title", "description"],</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"description"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.description</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 10%<span class="token punctuation">,</span> 88%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>&#123;&#123; title &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// props: ["title"],</span>  <span class="token literal-property property">inject</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"title"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">h2</span> <span class="token punctuation">&#123;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但如此做<code>provide</code>中的title属性没有与data中的title属性相对应，若修改为以下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">provide</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>movie<span class="token punctuation">.</span>title<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则会报错：</p><p><img src="/2022/08/19/guan-yu-vue-zhong-de-zu-jian-zhi-shi/image-20220819210345147.png" alt="image-20220819210345147"></p><p>原因是如果需要<code>provide</code>提供data中的属性，则需要将<code>provide</code>写为一个函数，类似data中的形式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>movie<span class="token punctuation">.</span>title<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="如何修改子组件中的样式："><a href="#如何修改子组件中的样式：" class="headerlink" title="如何修改子组件中的样式："></a>如何修改子组件中的样式：</h3><p>对于子组件中的根元素，可通过普通CSS样式书写格式进行修改，若想为子组件中除根元素以外的元素，则需要使用<code>deep</code>选择器：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.text :deep(a)</span> <span class="token punctuation">&#123;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>0deg<span class="token punctuation">,</span> 80%<span class="token punctuation">,</span> 70%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ref："><a href="#ref：" class="headerlink" title="ref："></a>ref：</h3><p>Vue提供了一种机制，可以获取到组件的实例并访问其中的属性，即为<code>ref</code>。使用<code>ref</code>可以访问到原生的HTML的DOM实例，也可以获取Vue组件的实例，但会破坏数据的流向，所以万不得已的时候最好不要使用。</p><p>在子组件中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inputText<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inputControl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">inputText</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inputControl<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inputControl<span class="token punctuation">.</span><span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">input</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 8px 14px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 30%<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父组件中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AutoFocus</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>autofocus<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> AutoFocus <span class="token keyword">from</span> <span class="token string">"./components/AutoFocus.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    AutoFocus<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>autofocus<span class="token punctuation">.</span>inputText<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>autofocus<span class="token punctuation">.</span><span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> <span class="token string">"PingFang SC"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Yahei"</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">body</span> <span class="token punctuation">&#123;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #0f141c<span class="token punctuation">;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">radial-gradient</span><span class="token punctuation">(</span>    #212943 0.6000000000000001px<span class="token punctuation">,</span>    #0f141c 0.6000000000000001px  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-size</span><span class="token punctuation">:</span> 12px 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#app</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="让组件支持v-model指令："><a href="#让组件支持v-model指令：" class="headerlink" title="让组件支持v-model指令："></a>让组件支持v-model指令：</h3><p>示例：</p><p>子组件SearchInput.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>搜索：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">input</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 8px 14px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 30%<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SearchInput</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchTerm<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>&#123;&#123;searchTerm&#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> SearchInput <span class="token keyword">from</span> <span class="token string">"./components/SearchInput.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    SearchInput<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">SearchTerm</span><span class="token operator">:</span> <span class="token string">""</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> <span class="token string">"PingFang SC"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Yahei"</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">body</span> <span class="token punctuation">&#123;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #0f141c<span class="token punctuation">;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">radial-gradient</span><span class="token punctuation">(</span>    #212943 0.6000000000000001px<span class="token punctuation">,</span>    #0f141c 0.6000000000000001px  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-size</span><span class="token punctuation">:</span> 12px 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#app</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">p</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时v-model并不能生效，需要在子组件中添加属性：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span>    <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>搜索：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span>    <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>      <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>      <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>modelValue<span class="token punctuation">"</span></span>      <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>update:modelValue<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"modelValue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"update:modelValue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">input</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 8px 14px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 30%<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若需要多个v-model，添加更多属性，并加以区分：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span>    <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>搜索：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span>    <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>      <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>      <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchTerm<span class="token punctuation">"</span></span>      <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>update:searchTerm<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>类别：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span>      <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span>      <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>update:category<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>    <span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>default<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>默认<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fontend<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>前端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>backend<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>后端<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fullstack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>全栈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"searchTerm"</span><span class="token punctuation">,</span> <span class="token string">"category"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"update:searchTerm"</span><span class="token punctuation">,</span> <span class="token string">"update:category"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">label</span> <span class="token punctuation">&#123;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">input</span> <span class="token punctuation">&#123;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 8px 14px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 30%<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">select</span> <span class="token punctuation">&#123;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 6px<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!-- v-model 后面的参数必须和子组件接收的属性名相同，例如 searchTerm --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SearchInput</span>        <span class="token attr-name"><span class="token namespace">v-model:</span>searchTerm</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchTerm<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">v-model:</span>category</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span>      <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>splitLine<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>搜索词：&#123;&#123; searchTerm &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>类别：&#123;&#123; category &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> SearchInput <span class="token keyword">from</span> <span class="token string">"./components/SearchInput.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    SearchInput<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 名字无需和 SearchInput 中的属性名相同</span>      <span class="token comment">// 例如这里可以叫 searchQuery，</span>      <span class="token literal-property property">searchTerm</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>      <span class="token literal-property property">category</span><span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> <span class="token string">"PingFang SC"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Yahei"</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">body</span> <span class="token punctuation">&#123;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #0f141c<span class="token punctuation">;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">radial-gradient</span><span class="token punctuation">(</span>    #212943 0.6000000000000001px<span class="token punctuation">,</span>    #0f141c 0.6000000000000001px  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-size</span><span class="token punctuation">:</span> 12px 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#app</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.splitLine</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 1px<span class="token punctuation">;</span>  <span class="token property">border-bottom</span><span class="token punctuation">:</span> 1px dashed <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">p</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>50deg<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 80%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用动态组件渲染不同的HTML标签："><a href="#使用动态组件渲染不同的HTML标签：" class="headerlink" title="使用动态组件渲染不同的HTML标签："></a>使用动态组件渲染不同的HTML标签：</h3><blockquote><p>使用<code>:is</code>+HTML标签（可能需要用到计算属性）</p></blockquote><p>父组件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!-- 动态 HTML 元素  --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>三级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>四级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>五级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextHeading</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>六级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TextHeading</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> TextHeading <span class="token keyword">from</span> <span class="token string">"./components/TextHeading.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    TextHeading<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>子组件TextHeading.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>heading<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Component</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"level"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">heading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">h</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>level<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">h1</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 3em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h2</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 2.4em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h3</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 1.8em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h4</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 1.4em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h5</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 1.2em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">h6</span> <span class="token punctuation">&#123;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 1em<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用动态组件渲染不同的Vue组件："><a href="#使用动态组件渲染不同的Vue组件：" class="headerlink" title="使用动态组件渲染不同的Vue组件："></a>使用动态组件渲染不同的Vue组件：</h3><blockquote><p>使用<code>:is</code>+组件名称</p></blockquote><p>例如此功能实现两个表单组件的切换：</p><p>登录表单文件ProfileForm.vue：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">@submit.prevent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>昵称：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>生日：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>date<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>地址：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">::-webkit-calendar-picker-indicator</span> <span class="token punctuation">&#123;</span>  <span class="token property">filter</span><span class="token punctuation">:</span> <span class="token function">invert</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注册表单文件RegisterForm.vue：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">@submit.prevent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>手机号：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span>      <span class="token punctuation">></span></span>验证码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sendSMSCodeBtn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        发送验证码      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span>    <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.sendSMSCodeBtn</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 24px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父组件App.vue文件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>buttons<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span>          <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm === <span class="token punctuation">'</span>RegisterForm<span class="token punctuation">'</span><span class="token punctuation">"</span></span>          <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm = <span class="token punctuation">'</span>ProfileForm<span class="token punctuation">'</span><span class="token punctuation">"</span></span>        <span class="token punctuation">></span></span>          下一步        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm === <span class="token punctuation">'</span>ProfileForm<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm = <span class="token punctuation">'</span>RegisterForm<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            上一步          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>完成<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> RegisterForm <span class="token keyword">from</span> <span class="token string">"./components/RegisterForm.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> ProfileForm <span class="token keyword">from</span> <span class="token string">"./components/ProfileForm.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    RegisterForm<span class="token punctuation">,</span>    ProfileForm<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">currentForm</span><span class="token operator">:</span> <span class="token string">"RegisterForm"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，如果仅使用这种方法切换表单，会导致表单数据缺失，原因是因为使用动态组件每次切换组件时，都会创建新的组件实例。</p></blockquote><p>改进：</p><blockquote><p>在<code>Component</code>标签外绑定<code>KeepAlive</code>标签</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 动态组件默认每次渲染都会重新创建，数据会丢失，使用 &lt;KeepAlive>&lt;/KeepAlive> 组件可以缓存组件，避免数据丢失 --></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>KeepAlive</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentForm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>KeepAlive</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组件传送"><a href="#组件传送" class="headerlink" title="组件传送"></a>组件传送</h3><h4 id="在其他DOM元素挂载组件："><a href="#在其他DOM元素挂载组件：" class="headerlink" title="在其他DOM元素挂载组件："></a>在其他DOM元素挂载组件：</h4><blockquote><p>某些组件可能在逻辑上不属于任何父组件，例如页面边缘的提示框，它们会根据<code>body</code>元素进行绝对定位。如果我们将它们放在某个父组件中，那么它们的位置就会限制于父组件容器内。</p></blockquote><blockquote><p>Vue提供了<code>teleport</code>属性，可以让子组件挂载在其他页面元素上。</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Teleport</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>body<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>show<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alertBox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>closeIcon<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>show = false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>X<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span>消息提示框组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Teleport</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多次传送组件："><a href="#多次传送组件：" class="headerlink" title="多次传送组件："></a>多次传送组件：</h4><p>如果一个组件多次传送到相同的页面下，那么传送的顺序会追加到页面中，例如要弹出多个消息提示框：</p><p>在index.html文件中添加：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>icon<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/favicon.ico<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Vite App<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!-- 添加messages --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>messages<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/src/main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父组件App.vue文件中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msgs.push(`这是一段消息$&#123;msgs.length + 1&#125;`)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        添加消息      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AlertBox</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg in msgs<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; msg &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AlertBox</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> AlertBox <span class="token keyword">from</span> <span class="token string">"./components/AlertBox.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    AlertBox<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">msgs</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> <span class="token string">"PingFang SC"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Yahei"</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">body</span> <span class="token punctuation">&#123;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #0f141c<span class="token punctuation">;</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">radial-gradient</span><span class="token punctuation">(</span>    #212943 0.6000000000000001px<span class="token punctuation">,</span>    #0f141c 0.6000000000000001px  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-size</span><span class="token punctuation">:</span> 12px 12px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#app</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">button</span> <span class="token punctuation">&#123;</span>  <span class="token property">border</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>    90deg<span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>240deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">hsl</span><span class="token punctuation">(</span>280deg<span class="token punctuation">,</span> 50%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 12px 18px<span class="token punctuation">;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.container</span> <span class="token punctuation">&#123;</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token comment">/* border: 1px solid hsl(280deg, 100%, 50%); */</span><span class="token punctuation">&#125;</span><span class="token comment">/*注意此处布局*/</span><span class="token selector">#messages</span> <span class="token punctuation">&#123;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column-reverse<span class="token punctuation">;</span>  <span class="token property">gap</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>   <span class="token comment">&lt;!-- 此处改为#messages --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Teleport</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#messages<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>show<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alertBox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>closeIcon<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>show = false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>X<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span>消息提示框组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Teleport</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//可添加计时器，3s后关闭提示框</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.alertBox</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 350px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 80px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid <span class="token function">hsl</span><span class="token punctuation">(</span>280<span class="token punctuation">,</span> 100%<span class="token punctuation">,</span> 50%<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 24px<span class="token punctuation">;</span>  <span class="token comment">/* position: absolute;  right: 12px;  bottom: 12px; */</span>  <span class="token comment">/*改为相对定位，因为关闭按钮在其中*/</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.content</span> <span class="token punctuation">&#123;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.closeIcon</span> <span class="token punctuation">&#123;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>  <span class="token property">font-weight</span><span class="token punctuation">:</span> 900<span class="token punctuation">;</span>  <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Mixins："><a href="#Mixins：" class="headerlink" title="Mixins："></a>Mixins：</h3><h4 id="组件配置的复用："><a href="#组件配置的复用：" class="headerlink" title="组件配置的复用："></a>组件配置的复用：</h4><blockquote><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。（现在不推荐使用此种方法进行组件复用）</p></blockquote><p>例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义一个混入对象</span><span class="token keyword">var</span> myMixin <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">hello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello from mixin!'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义一个使用混入对象的组件</span><span class="token keyword">var</span> Component <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span>myMixin<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">var</span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// => "hello from mixin!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="共同属性的覆盖与合并："><a href="#共同属性的覆盖与合并：" class="headerlink" title="共同属性的覆盖与合并："></a>共同属性的覆盖与合并：</h4><ul><li><code>data</code>函数：Mixins中的<code>data</code>属性会与组件中的data属性进行<strong>合并</strong>，<strong>如果有同名的属性，组件自身的属性会覆盖Mixins中的属性</strong>。</li><li><code>computed</code>，<code>methods</code>，<code>components</code>，<code>props</code>等这些值为数组或对象，同data函数中的合并覆盖规则。</li><li>如果是<strong>生命周期钩子</strong>，Mixins和组件中的<strong>都会执行</strong>，<strong>Mixins中的先执行</strong>，<strong>组件中的后执行</strong>。</li></ul><h4 id="全局注册："><a href="#全局注册：" class="headerlink" title="全局注册："></a>全局注册：</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createApp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">"./App.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> PaginationMixin <span class="token keyword">from</span> <span class="token string">"./mixins/PaginationMixin"</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span>PaginationMixin<span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">siteTitle</span><span class="token operator">:</span> <span class="token string">"我的 Vue 应用"</span><span class="token punctuation">,</span>  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">siteTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>siteTitle<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>        &#123;&#123; siteTitle &#125;&#125;      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PaginationComponent</span>        <span class="token attr-name">:totalPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>totalPage<span class="token punctuation">"</span></span>        <span class="token attr-name">:defaultCurrentPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentPage<span class="token punctuation">"</span></span>      <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PaginationComponent2</span>        <span class="token attr-name">:totalPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>totalPage<span class="token punctuation">"</span></span>        <span class="token attr-name">:defaultCurrentPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentPage<span class="token punctuation">"</span></span>      <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BaseButton</span> <span class="token attr-name">:defaultCurrentPage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentPage<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> BaseButton <span class="token keyword">from</span> <span class="token string">"./components/BaseButton.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> PaginationComponent <span class="token keyword">from</span> <span class="token string">"./components/PaginationComponent.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> PaginationComponent2 <span class="token keyword">from</span> <span class="token string">"./components/PaginationComponent2.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">siteTitle</span><span class="token operator">:</span> <span class="token string">"Mixin 全局注册"</span><span class="token punctuation">,</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    PaginationComponent<span class="token punctuation">,</span>    PaginationComponent2<span class="token punctuation">,</span>    BaseButton<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">totalPage</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>      <span class="token literal-property property">currentPage</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Mixins也存在局限性，例如命名易冲突，各代码之间的逻辑功能也不能复用。</p></blockquote><h3 id="异步组件加载："><a href="#异步组件加载：" class="headerlink" title="异步组件加载："></a>异步组件加载：</h3><p>对于大型项目，一次性加载所有组件会影响页面的首次打开速度。正确方法应该是根据用户的操作与导航，加载相应的组件。</p><blockquote><p><code>defineAsyncComponent</code>：接收一个回调函数作为参数，可用于异步加载组件。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> defineAsyncComponent <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> ProductPage <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"./components/ProductPage.vue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组件错误处理："><a href="#组件错误处理：" class="headerlink" title="组件错误处理："></a>组件错误处理：</h3><h4 id="全局错误处理："><a href="#全局错误处理：" class="headerlink" title="全局错误处理："></a>全局错误处理：</h4><p><code>errorHandler</code>：</p><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>默认值</strong>：<code>undefined</code></p></li><li><p><strong>用法</strong>：</p><pre class="line-numbers language-none"><code class="language-none">Vue.config.errorHandler &#x3D; function (err, vm, info) &#123;  &#x2F;&#x2F; handle error  &#x2F;&#x2F; &#96;info&#96; 是 Vue 特定的错误信息，比如错误所在的生命周期钩子  &#x2F;&#x2F; 只在 2.2.0+ 可用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p><blockquote><p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p></blockquote><blockquote><p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p></blockquote><blockquote><p>从 2.6.0 起，这个钩子也会捕获 <code>v-on</code> DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。</p></blockquote><blockquote><p>错误追踪服务 <a href="https://sentry.io/">Sentry</a> 和 <a href="https://docs.bugsnag.com/platforms/browsers/vue/">Bugsnag</a> 都通过此选项提供了官方支持。</p></blockquote></li></ul><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createApp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">"./App.vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">errorHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="错误边界："><a href="#错误边界：" class="headerlink" title="错误边界："></a>错误边界：</h4><blockquote><p>如果某个Vue组件提供了错误处理能力，那么它就被称为错误边界。Vue组件会以事件冒泡方式向父组件传递错误信息，只有当父组件处理了错误并手动停止了错误的传播，错误才不会继续向上传递，这样这个子组件所有的子组件发生的错误都会交给他进行处理。</p></blockquote><p>示例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>error<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>啊哦，我是错误的顶级组件了！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>      <span class="token comment">&lt;!-- &lt;AppList v-else :data="data" /> --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AppList</span> <span class="token attr-name">:data</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>data<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AppButton</span><span class="token punctuation">></span></span>测试按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AppButton</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> AppList <span class="token keyword">from</span> <span class="token string">"./components/AppList.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> AppButton <span class="token keyword">from</span> <span class="token string">"./components/AppButton.vue"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    AppList<span class="token punctuation">,</span>    AppButton<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token literal-property property">error</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">errorCaptured</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">// 停止错误向上传播</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费利用云资源训练模型教程</title>
      <link href="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/"/>
      <url>/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="谷歌在线训练模型的流程："><a href="#谷歌在线训练模型的流程：" class="headerlink" title="谷歌在线训练模型的流程："></a>谷歌在线训练模型的流程：</h3><blockquote><p>如果本地训练模型，会长时间占用自己显卡的显存，而且显卡的显存大小很大程度上影响训练的时间，谷歌提供免费的云端GPU，有足足16G的显存可以用来训练数据集。</p><p>由于是免费资源，所以训练的持续时间不能太长从而占用公共资源，如果是需要训练几天的大型数据，本教程不再适用。</p></blockquote><h4 id="1-注册Google-Drive云盘"><a href="#1-注册Google-Drive云盘" class="headerlink" title="1.注册Google Drive云盘"></a>1.注册Google Drive云盘</h4><blockquote><p>目的是为了之后将云盘中的文件挂载到Colaboratory上，防止文件丢失。</p><p>官网地址：<a href="https://drive.google.com/">https://drive.google.com</a></p></blockquote><p>新建一个文件夹，将训练所需的准备文件放置在此文件夹中。</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726103637723.png" alt="image-20220726103637723"></p><h4 id="2-从云盘连接到Colaboratory"><a href="#2-从云盘连接到Colaboratory" class="headerlink" title="2.从云盘连接到Colaboratory"></a>2.从云盘连接到Colaboratory</h4><p>点击右上角新建一个Google Colaboratory，如果没有该选项，则需要点击<strong>连接更多应用程式</strong>进行安装：</p><img src="image-20220726104004419.png" alt="image-20220726104004419" style="zoom:50%;" /><p>创建好后，进入下面的页面：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726104147163.png" alt="image-20220726104147163"></p><p>默认是使用CPU的资源，需要更改为使用GPU的资源。点击菜单栏中的<strong>修改</strong>按钮，再点击<strong>笔记本设置</strong>，更改为使用GPU资源：</p><img src="image-20220726104256034.png" alt="image-20220726104256034" style="zoom:50%;" /><p>点击右上角<strong>连接</strong>按钮，选择<strong>连接到托管代码执行程序</strong>，这样就连接上云盘了：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726104410455.png" alt="image-20220726104410455"></p><h4 id="3-准备工作："><a href="#3-准备工作：" class="headerlink" title="3.准备工作："></a>3.准备工作：</h4><p>查看当前GPU情况，16G的显存，已经算很好的配置了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span>nvidia-smi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220526204800113.png" alt="image-20220526204800113"></p><p>脚本定义挂载网盘并执行代码，需要点击链接输入验证码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">from</span> google<span class="token punctuation">.</span>colab <span class="token keyword">import</span> drivedrive<span class="token punctuation">.</span>mount<span class="token punctuation">(</span><span class="token string">'/content/drive'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726110413026.png" alt="image-20220726110413026"></p><p>进入到挂载的文件夹中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">%cd /content/drive <span class="token comment"># /content/drive</span>%cd My<span class="token punctuation">\</span> Drive/colab <span class="token comment"># /content/drive/My Drive/colab</span><span class="token operator">!</span>git clone https://github.com/ultralytics/yolov5.git <span class="token comment"># 克隆yolov5的代码到文件夹中</span>%cd yolov5/ <span class="token comment"># /content/drive/MyDrive/colab/yolov5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>回到Dirve云盘中，此时文件夹结构应该如下图，一个是yolov5官方的文件夹，一个是自己的数据集文件夹：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726110943526.png" alt="image-20220726110943526"></p><p>开始训练前，还需要修改下yolov5的文件。找到yolov5文件夹中的models文件夹，根据所需打开.yaml文件，这里以yolov5s.yaml为例：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726111130283.png" alt="image-20220726111130283"></p><p>修改其中的nc值，根据你自己数据集所需进行修改，修改完后点击右上角的<strong>Save to Drive</strong>按钮：</p><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220726111403630.png" alt="image-20220726111403630"></p><h4 id="4-开始训练："><a href="#4-开始训练：" class="headerlink" title="4.开始训练："></a>4.开始训练：</h4><p>进入yolov5文件夹：</p><pre class="line-numbers language-none"><code class="language-none">%cd yolov5&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 执行训练命令，注意自己的训练集位置输入是否正确：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span>python train.py --data <span class="token punctuation">..</span>/Lion/data.yaml --cfg models/yolov5s.yaml --weights <span class="token string">''</span> --batch-size <span class="token number">32</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/07/26/mian-fei-li-yong-yun-zi-yuan-xun-lian-mo-xing-jiao-cheng/image-20220526205304830.png" alt="image-20220526205304830"></p><p>训练结束后，将训练好的权重中最好的权重best.pt下载到本地，其余检测操作同本地检测图片操作相同。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像识别 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全速下载百度网盘的教程</title>
      <link href="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/"/>
      <url>/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载Microsoft-Edge浏览器"><a href="#1-下载Microsoft-Edge浏览器" class="headerlink" title="1.下载Microsoft  Edge浏览器"></a>1.下载Microsoft  Edge浏览器</h3><h3 id="2-添加油猴插件："><a href="#2-添加油猴插件：" class="headerlink" title="2.添加油猴插件："></a>2.添加油猴插件：</h3><p>点开浏览器右上角三个点，点击<strong>拓展</strong>选项，再点击<strong>管理扩展</strong>选项：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722112815950.png" alt="image-20220722112815950"></p><p>点击<strong>获取 Microsoft Edage 扩展</strong>，在商店中搜索<strong>Tampermonkey</strong>，下载绿色的：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722113257104.png" alt="image-20220722113257104"></p><h3 id="3-添加百度网盘直链下载助手："><a href="#3-添加百度网盘直链下载助手：" class="headerlink" title="3.添加百度网盘直链下载助手："></a>3.添加百度网盘直链下载助手：</h3><p>点开浏览器右上角的扩展选项，点击<strong>Tampermonkey</strong>，选择<strong>获取新脚本</strong>：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722113540704.png" alt="image-20220722113540704"></p><p>搜索用户脚本，<strong>百度网盘简易下载助手（直链下载复活版）</strong></p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722113712560.png" alt="image-20220722113712560"></p><p>最好是访问<a href="https://greasyfork.org/zh-CN/scripts/418182-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%AE%80%E6%98%93%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B-%E7%9B%B4%E9%93%BE%E4%B8%8B%E8%BD%BD%E5%A4%8D%E6%B4%BB%E7%89%88">百度网盘简易下载助手（直链下载复活版） (greasyfork.org)</a>，只要跳转到这个界面就算成功，注意版本是1.5.5，然后安装此脚本：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114026073.png" alt="image-20220722114026073"></p><h3 id="4-安装Aria2："><a href="#4-安装Aria2：" class="headerlink" title="4.安装Aria2："></a>4.安装Aria2：</h3><p>在上个页面往下拉，下载Aria2：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114202084.png" alt="image-20220722114202084"></p><h3 id="5-如何全速下载："><a href="#5-如何全速下载：" class="headerlink" title="5.如何全速下载："></a>5.如何全速下载：</h3><p>进入下载好的Aria2文件夹，双击打开<strong>aria2.exe</strong>文件，<strong>保持在后台运行</strong>；如果你需要查看下载页面，在打开aria2.exe后，再点击AriaNg启动器.exe文件，跳转到浏览器查看下载进度：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114825906.png" alt="image-20220722114825906"></p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722114908574.png" alt="image-20220722114908574"></p><p>点击要下载资源的百度网盘链接，<strong>将其保存到自己网盘后</strong>，<strong>在网页端进入自己的网盘</strong>：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220908085628498.png" alt="image-20220908085628498"></p><p>右上角会出现<strong>千千下载助手</strong>，选择你要下载的资源，点击简易下载助手：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20230621150809524.png" alt="image-20230621150809524"></p><p>点击<strong>点击获取直链地址</strong>，关注公众号获取验证码：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20230621150853628.png" alt="image-20230621150853628"></p><p>获取后，<strong>修改保存路径</strong>，点击<strong>发送至Aria2</strong>按钮：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20230621150903156.png" alt="image-20230621150903156"></p><p>回到Aria或者回到AriaNg启动器.exe打开的浏览器页面，就能看到下载进度：</p><p><img src="/2022/07/22/quan-su-xia-zai-bai-du-wang-pan-de-jiao-cheng/image-20220722120052380.png" alt="image-20220722120052380"></p><p>速度非常快，和你的网速一致，全速下载！</p><blockquote><p>注意：只能下载单个文件，<strong>无法直接下载文件夹</strong>！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学入门--光</title>
      <link href="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/"/>
      <url>/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/</url>
      
        <content type="html"><![CDATA[<h3 id="WebGL入门："><a href="#WebGL入门：" class="headerlink" title="WebGL入门："></a>WebGL入门：</h3><h3 id="1-画布："><a href="#1-画布：" class="headerlink" title="1.画布："></a>1.画布：</h3><h4 id="1-坐标系："><a href="#1-坐标系：" class="headerlink" title="1.坐标系："></a>1.坐标系：</h4><p>对于大多数计算机屏幕，坐标原点位于屏幕左上角，x轴向右侧延伸，y轴向左侧延伸：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143143556.png" alt="image-20220620143143556"></p><p>但对于3D图形程序员来说，更倾向使用另一种坐标系：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143216979.png" alt="image-20220620143216979"></p><h4 id="2-颜色模型："><a href="#2-颜色模型：" class="headerlink" title="2.颜色模型："></a>2.颜色模型：</h4><h5 id="1-减法色模型："><a href="#1-减法色模型：" class="headerlink" title="1.减法色模型："></a>1.减法色模型：</h5><p>从包含所有波长的光开始，减去一部分数量的颜色，从而创建任何其他颜色：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143348156.png" alt="image-20220620143348156"></p><p>但这种模型不完全正确，实际原色是青色、平红色和黄色。而且混合这三种模型会产生一种稍暗的颜色，但不是纯黑色，因此需要添加黑色作为第四种“原色”，黑色用K表示，因此我们得出CMYK模型，如下图：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143819653.png" alt="image-20220620143819653"></p><h5 id="2-加法色模型："><a href="#2-加法色模型：" class="headerlink" title="2.加法色模型："></a>2.加法色模型：</h5><p>屏幕与纸张相反，屏幕本身是黑色的，还会发出光，因此我们从没有光开始，然后添加我们想要的波长的光。大多数颜色可以通过在黑色表面添加不同“数量”的红色、绿色、蓝色来创建，这就是RGB颜色模型，是一种加法色模型，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620143826817.png" alt="image-20220620143826817"></p><h4 id="3-颜色深度："><a href="#3-颜色深度：" class="headerlink" title="3.颜色深度："></a>3.颜色深度：</h4><p>大多数图像都是使用8位二进制数来表示一种原色，这里称原色为颜色通道，每个通道使用8位二进制的话，一个像素由三个通道组成就是24位二进制数，共有2^24种不同颜色，这种格式成为R8G8B8格式，是常用格式，颜色深度认为是24位。</p><h4 id="4-颜色表示："><a href="#4-颜色表示：" class="headerlink" title="4.颜色表示："></a>4.颜色表示：</h4><p>使用三个字节来表示一种颜色，每个字节保存从0到255的8位颜色通道的值，我们将颜色表示为(R,G,B)。</p><h4 id="5-颜色的处理方式："><a href="#5-颜色的处理方式：" class="headerlink" title="5.颜色的处理方式："></a>5.颜色的处理方式：</h4><p>我们可以通过将每个颜色通道值乘一个常量来修改颜色的强度，可以通过将每个颜色通道值分别相加来将两个颜色相加。这些运算可能产生无效值，我们将<strong>任何超过255的值视为255，任何低于0的值视为0</strong>，我们把这称为将值范围限制[0,255]，类似生活中使用相机曝光不足或过度曝光的情况。</p><h4 id="6-场景："><a href="#6-场景：" class="headerlink" title="6.场景："></a>6.场景：</h4><p>场景需要坐标轴来讨论其中的为题，不能使用与画布相同的坐标系，因为画布为2D，场景是3D，如图是场景使用的坐标系：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620144636553.png" alt="image-20220620144636553"></p><p>场景的单位取决于我们的场景代表什么，不同场景单位不同。</p><h3 id="2-基础光线追踪知识："><a href="#2-基础光线追踪知识：" class="headerlink" title="2.基础光线追踪知识："></a>2.基础光线追踪知识：</h3><h4 id="1-渲染图片："><a href="#1-渲染图片：" class="headerlink" title="1.渲染图片："></a>1.渲染图片：</h4><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620152206227.png" alt="image-20220620152206227"></p><p>如何让计算机渲染这张图片？我们用一个固定的视角和一个窗口来观察风景，将图像分成很多“格子”，在每一个格子涂上相应的颜色，最终绘制的图像如图：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620152351610.png" alt="image-20220620152351610"></p><p>绘画过程可以是这样的：</p><ul><li>将眼睛和框架搭建好</li><li>扫描画布上每一个区域</li><li>对应画布和图像上的区域</li><li>识别图像上每一个区域所看到的的颜色</li><li>将每个区域的颜色画出来</li></ul><h4 id="2-基本假设："><a href="#2-基本假设：" class="headerlink" title="2.基本假设："></a>2.基本假设：</h4><p>首先我们需要一个固定的观察位置，也就是相机位置，用O表示，假设相机位置O&#x3D;(0,0,0)；假设有一个固定的相机方位，相机方位决定了相机指向哪里，我们假设相机指向z轴正方向，并且y轴正方向是向上的，x轴正方向是向右的，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620153152123.png" alt="image-20220620153152123"></p><p>再假设一个“窗口”，假设位于相机正前方，垂直于z轴，中心在z轴上，平行于x轴与y轴，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620153300698.png" alt="image-20220620153300698"></p><p>图中的矩形作为我们观察世界的窗口，我们称之为视口。本质上，我们将在画布上绘制我们通过视口看到的任何内容。注意视口大小和视口到相机距离决定了从相机可以观察的角度，称为<strong>视野</strong>。</p><h4 id="3-画布空间到视口空间："><a href="#3-画布空间到视口空间：" class="headerlink" title="3.画布空间到视口空间："></a>3.画布空间到视口空间：</h4><p>视口是以世界空间的单位衡量的，而画布是以像素衡量的，所以从画布到空间坐标<strong>只是比例的改变</strong>。</p><h4 id="4-追踪光线："><a href="#4-追踪光线：" class="headerlink" title="4.追踪光线："></a>4.追踪光线：</h4><blockquote><p>现实世界中，光线是经过反射后到我们的眼睛中，我们可以尝试模拟场景光源中光子离开光源的路径，但这非常耗时，而且光子数量惊人，并且只有一小部分光子在通过视口后会刚好到达。这种技术称为光子追踪或光子映射。</p></blockquote><p>相反我们考虑，反向光线：从相机发出射线，穿过视口中的某个点，并跟踪射线的路径，直到他“击中”场景中的某个物体，这个物体就是相机通过视口那个点看到的物体。因此我们只需将<strong>该物体的颜色</strong>作为“通过该点的光的颜色”，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620155153656.png" alt="image-20220620155153656"></p><h3 id="3-光："><a href="#3-光：" class="headerlink" title="3.光："></a>3.光：</h3><p>将介绍3种类型的光源，点光，方向光和环境光。</p><h4 id="1-简单假设："><a href="#1-简单假设：" class="headerlink" title="1.简单假设："></a>1.简单假设：</h4><p>用单个实数i来表征任何光，i源于光的强度，使用白光从而保证事情简单。其次将忽视空气，因为在现实生活中，光源离得越远，看起来就越暗，因为空气中漂浮的粒子会在光线穿过它们时吸收部分光。</p><h3 id="2-光源："><a href="#2-光源：" class="headerlink" title="2.光源："></a>2.光源：</h3><h5 id="1-点光："><a href="#1-点光：" class="headerlink" title="1.点光："></a>1.点光：</h5><p>从3D空间中的一个固定的点发射光，这个点被称为点光源的位置，点光源向每个方向均匀的发射光，这就是它被称为全向光的原因。因此，点光可以完全用位置和强度来描述。</p><p>定义向量L作为从场景中的点P到光源Q的方向，我们可以计算这个向量，称其为光向量，即Q-P。需要注意，Q是固定的，P可以是场景中的任何点，因此L对于场景中的每个点都是不同的，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620162555479.png" alt="image-20220620162555479"></p><h5 id="2-方向光："><a href="#2-方向光：" class="headerlink" title="2.方向光："></a>2.方向光：</h5><p>和点光一样，方向光也有强度，但没有位置，相反它有一个固定的方向。在方向光的情况下，L是给定的，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620163037954.png" alt="image-20220620163037954"></p><h5 id="3-环境光："><a href="#3-环境光：" class="headerlink" title="3.环境光："></a>3.环境光：</h5><p>不希望每个物体被直接照亮或者完全黑暗，为了突破这一限制，定义第三种光源，称之为环境光。它只以其强度为特征。我们将声明环境光为场景中的每个点贡献一些光，不管它在哪里。</p><p>一般来说，一个场景会有单个环境光（因为环境光只有一个强度值，任何数量的环境光都可以简单地组合成一个环境光）和任何数量的点光及方向光。</p><h5 id="4-单点光照："><a href="#4-单点光照：" class="headerlink" title="4.单点光照："></a>4.单点光照：</h5><p>为了计算单个点的光照，我们将计算每个光源奉献的光，并将它们加在一起，得到一个代表该点接收到的光的总量的数字。然后我们可以用这个总量乘物体表面在该点的颜色，从而获得该点的着色颜色，用以代表该点接收了多少光。</p><p>我们可以根据物体反射的方式直观地将物体分为两大类：“哑光“和”闪光“物体。</p><h5 id="5-漫反射："><a href="#5-漫反射：" class="headerlink" title="5.漫反射："></a>5.漫反射：</h5><p>当一束光线照射到一个哑光物体上时，光线会沿着每个方向均匀地散射回场景中，这个过程叫做漫反射，这是使哑光物体看起来无光泽的原因。另一方面，反射的光的数量取决于光线和物体表面之间的角度，这是因为光线所携带的能量必须根据角度分散在更小或更大的区域上，所以单位面积上反射到场景的能量分别更高或更低，如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620164823915.png" alt="image-20220620164823915"></p><h5 id="6-镜面反射："><a href="#6-镜面反射：" class="headerlink" title="6.镜面反射："></a>6.镜面反射：</h5><p>与哑光物体不同，感知这些闪亮物体表面的方式实际上取决于你的视角。不规则物体表面是这样反射的：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620165117294.png" alt="image-20220620165117294"></p><p>但如果表面是相对光滑的呢？如图所示：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620165209598.png" alt="image-20220620165209598"></p><p>注意在计算机图形学中，除非特殊说明，光源方向都是从场景中任意一点指向光源的方向，与物理中入射光的方向相反，是为了方便后续光照模型中的计算。</p><p>但并非每一个物体是完全光滑的，所以总有一部分光线会沿着接近R的方向被反射，越是接近R，该方向反射的光线越多，物体的光泽度决定反射光线衰减的程度：</p><p><img src="/2022/07/20/ji-suan-ji-tu-xing-xue-ru-men-guang/image-20220620165525865.png" alt="image-20220620165525865"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端必看的书籍【进阶】</title>
      <link href="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/"/>
      <url>/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-白银前端："><a href="#1-白银前端：" class="headerlink" title="1.白银前端："></a>1.白银前端：</h3><blockquote><p>可以熟练的进行平时的业务开发，但是对于JS高阶，源码，浏览器原理，数据结构与算法，设计模式，网络，前端工程之类的东西很迷茫，只知道大致概念。</p></blockquote><ul><li><p>《剖析Vue.js内部运行机制》，对于Vue内部的基础原理的理解，适合新手初次接触Vue。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/160fdc404b36a1a0_tplv-t2oaga2asx-zoom-1.webp" alt="img"></p></li><li><p>《深入浅出Vue.js》，从原生demo一步步转换成框架的样子，循序渐进。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s31471882.webp" alt="img"></p></li><li><p><a href="https://ustbhuangyi.github.io/vue-analysis/"> Vue.js 技术揭秘 (ustbhuangyi.github.io)</a>，源码解析，更进一步的对于源码的理解。</p></li><li><p><a href="https://github.com/HcySunYang/vue-design/tree/elegant">Vue全面解析</a>，非常详细，逐行分析源码。</p></li><li><p>《图解http》，比较入门，满足日常基本使用。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s27283822.webp" alt="img"></p></li><li><p>《图解TCP&#x2F;IP》，入门级别，同上一起使用。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s26676928.webp" alt="img"></p></li><li><p>《TCP&#x2F;IP详解 卷1》，非常详细和深入地讲解tcp和ip协议。</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s28845534.webp" alt="img"></p></li></ul><h3 id="2-黄金前端："><a href="#2-黄金前端：" class="headerlink" title="2.黄金前端："></a>2.黄金前端：</h3><blockquote><p>有需要对大型项目的架构的把控，项目管理，资源分配能力的需求，专注于整体的把握，不再拘泥于具体技术。</p></blockquote><ul><li><p>《JavaScript设计模式与开发实践》</p><p><img src="/2022/07/19/qian-duan-bi-kan-de-shu-ji-jin-jie/s28065006.webp" alt="img"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Node.js实现图像识别接口调用</title>
      <link href="/2022/07/16/ji-yu-node-js-shi-xian-tu-xiang-shi-bie-jie-kou-diao-yong/"/>
      <url>/2022/07/16/ji-yu-node-js-shi-xian-tu-xiang-shi-bie-jie-kou-diao-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="1-比较各类商业图像识别接口："><a href="#1-比较各类商业图像识别接口：" class="headerlink" title="1.比较各类商业图像识别接口："></a>1.比较各类商业图像识别接口：</h3><p>1.火山引擎：对于人体、人像的识别功能较多，对于动物几乎没有，分类较少只有两三个，而且识别精度较差，往往识别不出图像中的实体。</p><p>2.谷歌引擎：识别精度、细节相当高，但没有分类，识别元素过多，且在国外，调试和支付不太方便。</p><p>3.百度引擎：识别精度优秀，分类较多，有明确的动物识别分类，且能衍生出百科知识，返回的标签为中文标签。</p><p>4.阿里云引擎：识别分类没有动物分类，但是在阿里云市场有其他公司的接口，相当于外包。</p><h3 id="2-选用接口："><a href="#2-选用接口：" class="headerlink" title="2.选用接口："></a>2.选用接口：</h3><p>综合考虑使用百度动物识别，使用语言为node.js。但其官方示例没有node.js的语言示例，需要自己琢磨开发。</p><h4 id="1-调用百度获取token的接口："><a href="#1-调用百度获取token的接口：" class="headerlink" title="1.调用百度获取token的接口："></a>1.调用百度获取token的接口：</h4><p>一开始的想法是将这个过程作为中间件，但发现作为中间件使用后，原接口就不能再发起请求了，原因不得而知，只能将其封装在方法中：</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">async function getToken() &#123;  const param &#x3D; qs.stringify(&#123;    grant_type: &quot;client_credentials&quot;,    client_id: &quot;your client_id&quot;,    client_secret: &quot;your client_secret&quot;,  &#125;);  &#x2F;&#x2F;通过秘钥获取token相关属性  try &#123;    &#x2F;&#x2F;但这个方法需要考虑到异步问题    &#x2F;&#x2F; axios(&#123;    &#x2F;&#x2F;   method: &quot;get&quot;,    &#x2F;&#x2F;   baseURL: &quot;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;&quot;,    &#x2F;&#x2F;   &#x2F;&#x2F;两种url写法均可以请求到    &#x2F;&#x2F;   &#x2F;&#x2F; url: &#96;oauth&#x2F;2.0&#x2F;token?grant_type&#x3D;client_credentials&amp;client_id&#x3D;$&#123;client_id&#125;&amp;client_secret&#x3D;$&#123;client_secret&#125;&#96;,    &#x2F;&#x2F;   url: &quot;oauth&#x2F;2.0&#x2F;token?&quot; + param,    &#x2F;&#x2F; &#125;).then((res) &#x3D;&gt; &#123;    &#x2F;&#x2F;   &#x2F;&#x2F; var stream &#x3D; res.data.pipe(fs.createWriteStream(&quot;.&#x2F;baidu-token.json&quot;));    &#x2F;&#x2F;   &#x2F;&#x2F; stream.on(&quot;finish&quot;, () &#x3D;&gt; &#123;    &#x2F;&#x2F;   &#x2F;&#x2F;   console.log(&quot;传输完成！&quot;);    &#x2F;&#x2F;   &#x2F;&#x2F; &#125;);    &#x2F;&#x2F;   return axios.get(&quot;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token?&quot; + param);    &#x2F;&#x2F; &#125;);    return axios.get(&quot;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token?&quot; + param);  &#125; catch (error) &#123;    console.log(error);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之前考虑过将获取到的token存放在文件中，这样不太会占用内存，但使用fs.createWriteStream(“.&#x2F;baidu-token.json”)浏览器会报同源跨域错误，虽然没什么影响，但如果不想看见报错还是不要使用这种优雅的写法了。</p><h4 id="2-将图像转换为base64格式："><a href="#2-将图像转换为base64格式：" class="headerlink" title="2.将图像转换为base64格式："></a>2.将图像转换为base64格式：</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> image2base64 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"image-to-base64"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> imageBase64 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">image2base64</span><span class="token punctuation">(</span>      <span class="token comment">// "http://localhost:4000/" + req.file.filename</span>      imageUrl    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里的imageUrl直接使用的是阿里云存储OSS返回的url，比较方便</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-调用动物识别接口："><a href="#3-调用动物识别接口：" class="headerlink" title="3.调用动物识别接口："></a>3.调用动物识别接口：</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getAnimal</span><span class="token punctuation">(</span><span class="token parameter">imageUrl<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> token <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> imageBase64 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">image2base64</span><span class="token punctuation">(</span>      <span class="token comment">// "http://localhost:4000/" + req.file.filename</span>      imageUrl    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> bodyFormData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bodyFormData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"image"</span><span class="token punctuation">,</span> imageBase64<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">"post"</span><span class="token punctuation">,</span>      <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://aip.baidubce.com/rest/2.0/image-classify/v1/animal?access_token=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>token<span class="token punctuation">.</span>data<span class="token punctuation">.</span>access_token<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>      <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"content-type"</span><span class="token operator">:</span> <span class="token string">"application/x-www-form-urlencoded"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token literal-property property">data</span><span class="token operator">:</span> bodyFormData<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    response<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里一定要将imageBase64添加到bodyFormData，官方文档中没有说，是一个坑。</p><h3 id="3-识别结果："><a href="#3-识别结果：" class="headerlink" title="3.识别结果："></a>3.识别结果：</h3><p><img src="/2022/07/16/ji-yu-node-js-shi-xian-tu-xiang-shi-bie-jie-kou-diao-yong/image-20220716192722021.png" alt="image-20220716192722021"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 图像识别 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端必看的书籍【入门】</title>
      <link href="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/"/>
      <url>/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="1-黑铁前端："><a href="#1-黑铁前端：" class="headerlink" title="1.黑铁前端："></a>1.黑铁前端：</h3><blockquote><p>没有接触过前端，对于前端没有概念。</p></blockquote><p>推荐书籍：</p><ul><li><p>《Head First HTML与CSS（第2版）》，看完会对html和css有基本概念。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716182659269.png" alt="image-20220716182659269"></p></li><li><p>《JavaScript DOM编程艺术》，最好的JS入门书籍，其中还介绍了最符合标准的编程理念。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716182900459.png" alt="image-20220716182900459"></p></li><li><p>《JavaScript高级程序设计（第4版）》，带你入门基础的JavaScript语法，DOM环境和事件，本地存储和跨域等等，是一本非常全面的书籍。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716183058434.png" alt="image-20220716183058434"></p></li></ul><h3 id="2-青铜前端："><a href="#2-青铜前端：" class="headerlink" title="2.青铜前端："></a>2.青铜前端：</h3><blockquote><p>可以使用html，css，JavaScript编写简单的页面，但还不会使用库。</p></blockquote><ul><li><p>《JavaScript高级程序设计（第4版）》，没错，继续攻读一遍，会有新的收获。</p></li><li><p>Vue，这时候可以尝试接触库和框架了，直接看官方文档，养成看官方文档的好习惯。</p></li><li><p>《ES6标准入门 第3版 》，了解ES6用法基础。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716183639881.png" alt="image-20220716183639881"></p></li></ul><h3 id="3-白银前端："><a href="#3-白银前端：" class="headerlink" title="3.白银前端："></a>3.白银前端：</h3><blockquote><p>会使用库，例如可以用vue，jquery完成普通业务的开发，比如说一些活动落地页和后台管理页面</p></blockquote><ul><li><p>《JavaScript高级程序设计（第4版）》，没错，再看一遍会有新的成长。</p></li><li><p>《正则表达式必知必会(修订版)》，书很薄，但是正则表达式是前端开发者必须要会的一项技能。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716183927650.png" alt="image-20220716183927650"></p></li><li><p>《你不知道的JavaScript 上卷》，内容为作用域和闭包以及对象原型，很重要。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716184057259.png" alt="image-20220716184057259"></p></li><li><p>《你不知道的JavaScript 中卷》，内容为类型、语法、异步和性能。异步推荐看《ES6标准入门》，性能部分不推荐看</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716184230506.png" alt="image-20220716184230506"></p></li><li><p>《你不知道的JavaScript 下卷》，内容为JavaScript入门知识和未来发展趋势的展望，对前两本书的总结，ES6部分不推荐看。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716184550929.png" alt="image-20220716184550929"></p><ul><li><p>《深入理解ES6》，在了解ES6基础上的一本进阶书籍。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716184902235.png" alt="image-20220716184902235"></p></li></ul></li><li><p>《JavaScript 忍者秘籍》，很有深度的一本书，对于JS的核心部分剖析的很详细。</p><p><img src="/2022/07/16/qian-duan-bi-kan-de-shu-ji-ru-men/image-20220716185140322.png" alt="image-20220716185140322"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最简单的提升网站的性能的方法</title>
      <link href="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/"/>
      <url>/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CDN加速"><a href="#1-CDN加速" class="headerlink" title="1.CDN加速"></a>1.CDN加速</h3><ul><li><p>什么是CDN？</p><p>CDN英文全称content delivery network，翻译过来就是内容分发网络，是一种在地理位置上分散的服务器组，这些服务器组一起工作来加速互联网内容快速传播，这些内容包括HTML页面，css、javascript文件，图像、视频等媒体文件。</p><p>通俗来讲，就是CDN服务公司通过在全球各地建立很多服务器，然后当你加入他们的网络后 ，他们会缓存你的网站内容到各地服务器上，这样当访问你的网站时，他们就会从最近的缓存服务器上读取你的网站，而不需要直接访问你网站所在的服务器地址。</p></li><li><p>为什么强烈建议启用CDN？</p><p>研究表明，如果你的网站打开速度超过2s以上，那么你的客户很有可能离你而去，这一点对于商业化网站尤其重要，打开速度慢，那么将造成不可估量的损失。</p><p>以本博客为例，仓库放在Github上，国内加载速度很慢，因此需要CDN加速来优化网站打开速度。</p></li></ul><h4 id="Cloudflare-CDN"><a href="#Cloudflare-CDN" class="headerlink" title="Cloudflare CDN"></a>Cloudflare CDN</h4><p>Cloudflare是全球最大的一家主营CDN和网络安全的公司，而且配置也非常简单。</p><h5 id="第一步：在Cloudflare添加你的网站"><a href="#第一步：在Cloudflare添加你的网站" class="headerlink" title="第一步：在Cloudflare添加你的网站"></a>第一步：在Cloudflare添加你的网站</h5><p>点击左侧导航栏中的<strong>网站</strong>选项，再点击右上角的<strong>添加站点</strong>按钮，输入你的域名，Cloudflare会开始扫描查询你的网站DNS配置。</p><p><img src="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/image-20220715144412879.webp" alt="image-20220715144412879"></p><p>查询DNS完毕之后，会复制你的DNS记录到Cloudflare，然后点击继续按钮；接下来页面会要求你把原来的域名服务器更改为Cloudflare自己的，不改域名服务器，上面的DNS并不会生效。</p><p><img src="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/image-20220715144840060.webp" alt="image-20220715144840060"></p><p>以腾讯云为例，登录<strong>腾讯云域名注册管理控制台</strong>，进入“我的域名”页面，选择待修改的DNS域名，点击<strong>管理</strong>选项：</p><p><img src="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/image-20220715145234006.webp" alt="image-20220715145234006"></p><p>将DNS服务器修改为Cloudflare提供的两个：</p><p><img src="/2022/07/15/zui-jian-dan-de-ti-sheng-wang-zhan-de-xing-neng-de-fang-fa/image-20220715145503131.webp" alt="image-20220715145503131"></p><p>至此，你的域名就可以在Cloudflare上管理了，在24小时域名服务器更新完成后，用户也可以通过你自己的域名访问到网站了。</p><h5 id="第二步：优化性能"><a href="#第二步：优化性能" class="headerlink" title="第二步：优化性能"></a>第二步：优化性能</h5><p>在Cloudflare进入主页，点击配置好的网站，选择免费套餐，勾选以下设置：</p><ul><li><p>提高安全性</p></li><li><ul><li>自动 HTTPS 重写</li><li>始终使用 HTTPS</li></ul></li><li><p>优化性能</p></li><li><ul><li>Auto Minify， 勾选html、css、js，保存</li><li>Brotli，打开，保存</li></ul></li></ul><p>点击左侧导航栏中的<strong>速度</strong>按钮：</p><ul><li><p>优化</p></li><li><ul><li>Auto Minify 自动最小化 – JavaScript、CSS、HTML 全部勾选，其实这在入门设置的时候就已经勾选了，可以不需要改动</li><li>Brotli – 开启， 同上</li><li>Rocket Loader – 开启，可缩短包含 JavaScript 的页面的绘制时间。</li><li>Railgun – 加入你得主机商在你的主机商安装了此软件，比如<a href="https://link.zhihu.com/?target=https://www.qingsongb2c.com/goto/chemicloud-hosting/">Chemicloud</a>，可以开启，</li><li>AMP（Accelerated Mobile Pages即加速移动端网页的加载速度） 真实 URL – 可开启</li></ul></li><li><p>Browser Insights（现功能在其他地方设置，有操作指导教程，跟着走就行）</p></li><li><ul><li>配置 – Browser Insights开启</li></ul></li></ul><h3 id="2-图片格式与压缩技术："><a href="#2-图片格式与压缩技术：" class="headerlink" title="2.图片格式与压缩技术："></a>2.图片格式与压缩技术：</h3><ol><li><p>将你网站中的文件换为.webp格式，webp是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自图像编码格式VP8 。是由Google购买On2 Technologies后发展出来的格式，以BSD授权条款发布。webp可让网页图档有效进行压缩，同时又不影响图片格式兼容与实际清晰度，进而让整体网页下载速度加快。</p><p>推荐一个转换格式网站：<a href="https://cdkm.com/cn/jpg-to-webp">JPG转WEBP - 免费在线将JPG文件转换成WEBP (cdkm.com)</a></p></li><li><p>无损压缩各类格式图片的网站：<a href="https://tinypng.com/">TinyPNG – Compress WebP, PNG and JPEG images intelligently</a></p></li></ol><p>本文仅介绍了两种最简单的加速个人网站的技巧，还有许多优化技巧，例如压缩字体，URL优化，SEO优化等，以后会更新教程。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用yolo5进行数据训练</title>
      <link href="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/"/>
      <url>/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载数据集并进行本地训练的标准流程"><a href="#1-下载数据集并进行本地训练的标准流程" class="headerlink" title="1.下载数据集并进行本地训练的标准流程"></a>1.下载数据集并进行本地训练的标准流程</h3><ol><li><p>克隆github项目</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/theAIGuysCode/OIDv4_ToolKit pip <span class="token function">install</span> -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下载数据集</p><p>数据集网站为<a href="https://storage.googleapis.com/openimages/web/index.html">https://storage.googleapis.com/openimages/web/index.html</a></p><p>搜索对应的类别，这里以Lion为例，下载训练集200张：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python main.py downloader --classes Lion --type_csv train --limit <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>注意：若某个类别有两个单词组成，单词间使用下划线代替：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python main.py downloader --classes Bell_pepper --type_csv train --limit <span class="token number">400</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>注意：若想同时训练多个类别，可通过如下代码将多个类别移动至同一类别：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python main.py downloader --classes Aircraft Weapon --type_csv <span class="token builtin class-name">test</span> --limit <span class="token number">100</span> --multiclasses <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>数据预处理</p><p>下载后的数据存储在OID&#x2F;Dataset&#x2F;train&#x2F;，每个类别的文件包括对应的image和label，对应的label为txt文件，打开后为：</p><pre class="line-numbers language-none"><code class="language-none">Lion 48.0 268.23846499999996 972.8 561.4438100000001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>的label为txt文件，打开后为：</p><pre class="line-numbers language-none"><code class="language-none">Lion 48.0 268.23846499999996 972.8 561.4438100000001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但目前的label格式并不能直接拿来放在yolov5中训练，需要转换成yolov5接受的格式</p><ol><li><p>打开classes.txt，将里面的内容改为需要转换的类别：</p><p>在本例中，修改为：Lion</p></li><li><p>运行指令<code>python convert_annotations.py</code>,转换label格式。<br>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token keyword">import</span> argparse<span class="token keyword">import</span> fileinput<span class="token comment"># function that turns XMin, YMin, XMax, YMax coordinates to normalized yolo format</span><span class="token keyword">def</span> <span class="token function">convert</span><span class="token punctuation">(</span>filename_str<span class="token punctuation">,</span> coords<span class="token punctuation">)</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span>    image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>filename_str <span class="token operator">+</span> <span class="token string">".jpg"</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-=</span> coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    coords<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-=</span> coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    x_diff <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    y_diff <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>x_diff    coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>y_diff    coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    coords<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">"Label"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> coordsROOT_DIR <span class="token operator">=</span> os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># create dict to map class names to numbers for yolo</span>classes <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"classes.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myFile<span class="token punctuation">:</span>    <span class="token keyword">for</span> num<span class="token punctuation">,</span> line <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>myFile<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        line <span class="token operator">=</span> line<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>        classes<span class="token punctuation">[</span>line<span class="token punctuation">]</span> <span class="token operator">=</span> num    myFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># step into dataset directory</span>os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"OID"</span><span class="token punctuation">,</span> <span class="token string">"Dataset"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>DIRS <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># for all train, validation and test folders</span><span class="token keyword">for</span> DIR <span class="token keyword">in</span> DIRS<span class="token punctuation">:</span>    <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>DIR<span class="token punctuation">)</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span>DIR<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Currently in subdirectory:"</span><span class="token punctuation">,</span> DIR<span class="token punctuation">)</span>                CLASS_DIRS <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># for all class folders step into directory to change annotations</span>        <span class="token keyword">for</span> CLASS_DIR <span class="token keyword">in</span> CLASS_DIRS<span class="token punctuation">:</span>            <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>CLASS_DIR<span class="token punctuation">)</span><span class="token punctuation">:</span>                os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span>CLASS_DIR<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Converting annotations for class: "</span><span class="token punctuation">,</span> CLASS_DIR<span class="token punctuation">)</span>                                <span class="token comment"># Step into Label folder where annotations are generated</span>                os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">"Label"</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> filename <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    filename_str <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    <span class="token keyword">if</span> filename<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">".txt"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        annotations <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>                            <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>                                <span class="token keyword">for</span> class_type <span class="token keyword">in</span> classes<span class="token punctuation">:</span>                                    line <span class="token operator">=</span> line<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>class_type<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>classes<span class="token punctuation">.</span>get<span class="token punctuation">(</span>class_type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                labels <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>                                coords <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                coords <span class="token operator">=</span> convert<span class="token punctuation">(</span>filename_str<span class="token punctuation">,</span> coords<span class="token punctuation">)</span>                                labels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> labels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> labels<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> labels<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> coords<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>                                newline <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                line <span class="token operator">=</span> line<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>line<span class="token punctuation">,</span> newline<span class="token punctuation">)</span>                                annotations<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">)</span>                            f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                        os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span>                        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> outfile<span class="token punctuation">:</span>                            <span class="token keyword">for</span> line <span class="token keyword">in</span> annotations<span class="token punctuation">:</span>                                outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>                                outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>                            outfile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                        os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">"Label"</span><span class="token punctuation">)</span>                os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span>                os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span>        os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>移动标签位置</p><p>数据预处理后，txt和jpg文件是放在一个文件夹下的，仍然不是yolov5要求的文件格式，即label，image文件夹分开存放。首先删除Label文件夹中的文件，但不要删除Label文件夹；</p><p>运行代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> glob<span class="token keyword">import</span> shutil<span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Pathp <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">r"E:\opencv_learning\OIDv4_ToolKit-master\OID\Dataset\validation\Lion"</span><span class="token punctuation">)</span>  <span class="token comment">#  需要统计的文件夹路径，这里我们统计的是桌面上的test文件夹，可以随便改名</span>q <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">r"E:\opencv_learning\Lion\valid\Label"</span><span class="token punctuation">)</span> <span class="token comment">#  将提取出的所有txt放到test2文件夹下，如果没有需要先创建一个，可以随便改名</span>FileList <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"**/*.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 找出这个文件夹下的所有txt格式的文件，可以自行换成flac、mp4、mp3，全都可以！</span><span class="token keyword">for</span> <span class="token builtin">file</span> <span class="token keyword">in</span> FileList<span class="token punctuation">:</span>       <span class="token comment"># 这个的意思是，遍历所有找出的txt文件，并复制到另一个文件夹中</span>    shutil<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span>q<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时将Lion文件夹下的txt文件复制到Label文件夹下，将Label文件夹重命名为label，复制出来到与yolov5项目同一目录级别的文件夹下；接着同上处理img文件，复制出来放在与label文件夹同一级别的目录中，最终目录格式：</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525105312819.webp"></p><ul><li><p>注意：如果使用shutil的move()剪切方法会报错，具体原因据说是shutil的源码bug，目前仍然没有修复，所以只能用这种比较麻烦的方法构成所需目录。</p></li><li><p>注意，要在train同一目录下创建data.yaml文件，内容参考其他data.yaml文件。</p></li><li><p>注意：如果要得到正确的训练结果，还需要下载同类别的validation文件，张数约为训练集的百分之20，用以上方法整理到与train文件夹同一目录下，test文件同理，最终目录结构：</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525105701317.webp"></p></li></ul><p>lion_detect是我自己创建放几张网上找的图片用来测试的。</p></li><li><p>开始训练</p><p>打开yolov5 6.1项目，设置训练参数：</p></li></ol><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525105912373.webp"></p><p>​点击train.py文件运行，开始训练，训练完成后打开detect.py文件，设置参数：</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525110031198.webp"></p><p>​其中best.pt是训练后最好的权重，用以检测。</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525110313235.webp"></p><p>​我们对比一下官方自带的训练集的检测结果：</p><p><img src="/2022/07/13/shi-yong-yolo5-jin-xing-shu-ju-xun-lian/image-20220525110334725.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像识别 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebGL着色器入门</title>
      <link href="/2022/07/13/webgl-zhao-se-qi-ru-men/"/>
      <url>/2022/07/13/webgl-zhao-se-qi-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="1-着色器是什么？"><a href="#1-着色器是什么？" class="headerlink" title="1.着色器是什么？"></a>1.着色器是什么？</h3><p>WebGL需要两种着色器：<br><strong>顶点着色器(Vertex shader)</strong>:顶点着色器是用来描述顶点特性（如位置、颜色等)的程序。顶点(vertex)是指二维或三维空间中的一个点，比如二维或三维图形的端点或交点。</p><p><strong>片元着色器(Vertex shader)</strong>:进行逐片元处理过程如光照的程序。片元(fragment)是一个WebGL术语，你可以将其理解为像素（图像的单元）。</p><p>下图是浏览器显示图像的流程：</p><p><img src="/2022/07/13/webgl-zhao-se-qi-ru-men/image-20220713214157458.webp"></p><p>图的左侧是两个浏览器窗口。它们是同一个窗口，上面一个是执行JavaScript程序之前的窗口，下面一个是执行之后的。程序执行的流程大概是：首先运行JavaScript程序，调用了WbGL的相关方法，然后顶点着色器和片元着色器就会执行，在颜色缓冲区内进行绘制，这时就清空了绘图区；最后，颜色缓冲区中的内容会自动在浏览器的画布上显示出来。</p><h3 id="2-着色器代码示例："><a href="#2-着色器代码示例：" class="headerlink" title="2.着色器代码示例："></a>2.着色器代码示例：</h3><p>因为着色器程序代码必须预先处理成单个字符串的形式，所以我们用+号将多行字符串连成一个长字符串。每一行以\n结束，这是由于当着色器内部出错时，就能获取出错的行号，这对于检查源代码中的错误很有帮助。但是，\n并不是必须的，你自己编写着色器时，也可以不用它。</p><p><img src="/2022/07/13/webgl-zhao-se-qi-ru-men/image-20220713214259031.webp"></p><h3 id="3-初始化着色器："><a href="#3-初始化着色器：" class="headerlink" title="3.初始化着色器："></a>3.初始化着色器：</h3><p>大部分WebGL程序都遵循这样的流程：</p><p><img src="/2022/07/13/webgl-zhao-se-qi-ru-men/image-20220713214315749.webp"></p><p>目前最重要的是，你必须知道，<strong>WebGL程序包括运行在浏览器中的JavaScript和运行在WebGL系统的着色器程序这两个部分</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
